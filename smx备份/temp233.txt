public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/27/2016",
	time = "08:21:31"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new String:SI_Names[10][32] =
{
	"Unknown",
	"Smoker",
	"Boomer",
	"Hunter",
	"Spitter",
	"Jockey",
	"Charger",
	"Witch",
	"Tank",
	"Not SI"
};
new Handle:hCvarDmgThreshold;
public Plugin:myinfo =
{
	name = "1v1 EQ",
	description = "A plugin designed to support 1v1.",
	author = "Blade + Confogl Team, Tabun, Visor",
	version = "0.1",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	hCvarDmgThreshold = CreateConVar("sm_1v1_dmgthreshold", "24", "Amount of damage done (at once) before SI suicides.", 262144, true, 1.0, false, 0.0);
	HookEvent("player_hurt", Event_PlayerHurt, EventHookMode:1);
	return 0;
}

public Action:Event_PlayerHurt(Handle:event, String:name[], bool:dontBroadcast)
{
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	if (!IsClientAndInGame(attacker))
	{
		return Action:0;
	}
	new damage = GetEventInt(event, "dmg_health");
	new zombie_class = GetZombieClass(attacker);
	new var1;
	if (GetClientTeam(attacker) == 3 && zombie_class != 8 && damage >= GetConVarInt(hCvarDmgThreshold))
	{
		new remaining_health = GetClientHealth(attacker);
		CPrintToChatAll("[{olive}1v1{default}] {red}%N{default}({green}%s{default}) had {olive}%d{default} health remaining!", attacker, SI_Names[zombie_class], remaining_health);
		ForcePlayerSuicide(attacker);
		if (remaining_health == 1)
		{
			CPrintToChat(victim, "You don't have to be mad...");
		}
	}
	return Action:0;
}

GetZombieClass(client)
{
	return GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
}

bool:IsClientAndInGame(index)
{
	new var1;
	if (index > 0 && index < MaxClients)
	{
		return IsClientInGame(index);
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.5.0-dev+3690",
	date = "11/29/2012",
	time = "14:54:38"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "sdkhooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "1v1 SkeetStats",
	description = "Shows 1v1-relevant info at end of round.",
	author = "Tabun",
	version = "0.1f",
	url = "nope"
};
new Handle:hPounceDmgInt;
new Handle:hRUPActive;
new Handle:hCountTankDamage;
new Handle:hCountWitchDamage;
new Handle:hBrevityFlags;
new bool:bCountTankDamage;
new bool:bCountWitchDamage;
new iBrevityFlags;
new bool:bRUPActive;
new iPounceDmgInt;
new String:sClientName[66][64];
new iGotKills[66];
new iGotCommon[66];
new iDidDamage[66];
new iDidDamageAll[66];
new iDidDamageTank[66];
new iDidDamageWitch[66];
new iShotsFired[66];
new iPelletsFired[66];
new iShotsHit[66];
new iPelletsHit[66];
new iMeleesFired[66];
new iMeleesHit[66];
new iDeadStops[66];
new iHuntSkeets[66];
new iHuntSkeetsInj[66];
new iHuntHeadShots[66];
new bool:bIsHurt[66];
new bool:bIsPouncing[66];
new iDmgDuringPounce[66];
new iClientPlaying;
new bool:bLateLoad;
new iRoundNumber;
new bool:bInRound;
new bool:bPlayerLeftStartArea;
new Float:fPreviousShot[66];
new iPreviousShotType[66];
new bCurrentShotHit[66];
new iCurrentShotDmg[66];
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

bool:operator<(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) < 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

StrCat(String:buffer[], maxlength, String:source[])
{
	new len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	return Format(buffer[len], maxlength - len, "%s", source);
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

MoveType:GetEntityMoveType(entity)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_MoveType", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_MoveType");
		}
		gotconfig = true;
	}
	return GetEntProp(entity, PropType:1, datamap, 4, 0);
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	HookEvent("round_start", RoundStart_Event, EventHookMode:2);
	HookEvent("round_end", RoundEnd_Event, EventHookMode:2);
	HookEvent("player_left_start_area", PlayerLeftStartArea, EventHookMode:1);
	HookEvent("player_hurt", PlayerHurt_Event, EventHookMode:1);
	HookEvent("player_death", PlayerDeath_Event, EventHookMode:1);
	HookEvent("player_shoved", PlayerShoved_Event, EventHookMode:1);
	HookEvent("infected_hurt", InfectedHurt_Event, EventHookMode:1);
	HookEvent("infected_death", InfectedDeath_Event, EventHookMode:1);
	HookEvent("weapon_fire", WeaponFire_Event, EventHookMode:1);
	HookEvent("ability_use", AbilityUse_Event, EventHookMode:1);
	hCountTankDamage = CreateConVar("sm_skeetstat_counttank", "0", "Damage on tank counts towards totals if enabled.", 262144, true, 0.0, true, 1.0);
	hCountWitchDamage = CreateConVar("sm_skeetstat_countwitch", "0", "Damage on witch counts towards totals if enabled.", 262144, true, 0.0, true, 1.0);
	hBrevityFlags = CreateConVar("sm_skeetstat_brevity", "32", "Flags for setting brevity of the report (hide 1:SI, 2:CI, 4:Accuracy, 8:Skeets/Deadstops, 32: melee acc, 64: damage count).", 262144, true, 0.0, false, 0.0);
	bCountTankDamage = GetConVarBool(hCountTankDamage);
	bCountWitchDamage = GetConVarBool(hCountWitchDamage);
	iBrevityFlags = GetConVarInt(hBrevityFlags);
	HookConVarChange(hCountTankDamage, ConVarChange_CountTankDamage);
	HookConVarChange(hCountWitchDamage, ConVarChange_CountWitchDamage);
	HookConVarChange(hBrevityFlags, ConVarChange_BrevityFlags);
	hPounceDmgInt = FindConVar("z_pounce_damage_interrupt");
	iPounceDmgInt = GetConVarInt(hPounceDmgInt);
	HookConVarChange(hPounceDmgInt, ConVarChange_PounceDmgInt);
	hRUPActive = FindConVar("l4d_ready_enabled");
	if (hRUPActive)
	{
		bRUPActive = GetConVarBool(hRUPActive);
		HookConVarChange(hRUPActive, ConVarChange_RUPActive);
	}
	else
	{
		bRUPActive = false;
	}
	bPlayerLeftStartArea = false;
	RegConsoleCmd("sm_skeets", SkeetStat_Cmd, "Prints the current skeetstats.", 0);
	RegConsoleCmd("say", Say_Cmd, "", 0);
	RegConsoleCmd("say_team", Say_Cmd, "", 0);
	if (bLateLoad)
	{
		bPlayerLeftStartArea = true;
		iClientPlaying = GetCurrentSurvivor();
	}
	return 0;
}

public OnClientPutInServer(client)
{
	decl String:tmpBuffer[64];
	GetClientName(client, tmpBuffer, 64);
	if (strcmp(tmpBuffer, sClientName[client], true))
	{
		ClearClientSkeetStats(client);
		strcopy(sClientName[client], 64, tmpBuffer);
	}
	return 0;
}

public ConVarChange_CountTankDamage(Handle:cvar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10))
	{
		bCountTankDamage = true;
	}
	else
	{
		bCountTankDamage = false;
	}
	return 0;
}

public ConVarChange_CountWitchDamage(Handle:cvar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10))
	{
		bCountWitchDamage = true;
	}
	else
	{
		bCountWitchDamage = false;
	}
	return 0;
}

public ConVarChange_BrevityFlags(Handle:cvar, String:oldValue[], String:newValue[])
{
	iBrevityFlags = StringToInt(newValue, 10);
	return 0;
}

public ConVarChange_RUPActive(Handle:cvar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10))
	{
		bRUPActive = true;
	}
	else
	{
		bRUPActive = false;
	}
	return 0;
}

public ConVarChange_PounceDmgInt(Handle:cvar, String:oldValue[], String:newValue[])
{
	iPounceDmgInt = StringToInt(newValue, 10);
	return 0;
}

public Action:PlayerLeftStartArea(Handle:event, String:name[], bool:dontBroadcast)
{
	iClientPlaying = GetCurrentSurvivor();
	bPlayerLeftStartArea = true;
	return Action:0;
}

public OnMapStart()
{
	if (!bLateLoad)
	{
		bPlayerLeftStartArea = false;
	}
	bLateLoad = false;
	return 0;
}

public OnMapEnd()
{
	iRoundNumber = 0;
	bInRound = false;
	return 0;
}

public RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	iClientPlaying = GetCurrentSurvivor();
	bPlayerLeftStartArea = false;
	if (!bInRound)
	{
		bInRound = true;
		iRoundNumber += 1;
	}
	new i;
	new maxplayers = MaxClients;
	i = 1;
	while (i <= maxplayers)
	{
		ClearClientSkeetStats(i);
		i++;
	}
	return 0;
}

public RoundEnd_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (bInRound)
	{
		ResolveOpenShots();
		CreateTimer(3.0, delayedSkeetStatPrint, any:0, 0);
		bInRound = false;
	}
	return 0;
}

public Action:Say_Cmd(client, args)
{
	if (!client)
	{
		return Action:0;
	}
	decl String:sMessage[32];
	GetCmdArg(1, sMessage, 32);
	if (StrEqual(sMessage, "!skeets", true))
	{
		return Action:3;
	}
	return Action:0;
}

public Action:SkeetStat_Cmd(client, args)
{
	ResolveOpenShots();
	PrintSkeetStats(client);
	return Action:3;
}

public Action:delayedSkeetStatPrint(Handle:timer)
{
	PrintSkeetStats(0);
	return Action:0;
}

public PlayerHurt_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new zombieClass;
	new victimId = GetEventInt(event, "userid");
	new victim = GetClientOfUserId(victimId);
	new attackerId = GetEventInt(event, "attacker");
	new attacker = GetClientOfUserId(attackerId);
	if (iClientPlaying != attacker)
	{
		return 0;
	}
	if (GetClientTeam(victim) != 3)
	{
		return 0;
	}
	new damage = GetEventInt(event, "dmg_health");
	new damagetype = GetEventInt(event, "type");
	new hitgroup = GetEventInt(event, "hitgroup");
	if (damagetype & 536870912)
	{
		new var5 = iCurrentShotDmg[iClientPlaying];
		var5 = var5[damage];
		if (bIsPouncing[victim])
		{
			new var6 = iDmgDuringPounce[victim];
			var6 = var6[damage];
		}
		if (!bCurrentShotHit[iClientPlaying])
		{
			if (hitgroup == 1)
			{
				iHuntHeadShots[iClientPlaying]++;
			}
		}
		bCurrentShotHit[iClientPlaying] = 1;
	}
	else
	{
		if (damagetype & 2)
		{
			iShotsHit[iClientPlaying]++;
			if (hitgroup == 1)
			{
				iHuntHeadShots[iClientPlaying]++;
			}
			if (bIsPouncing[victim])
			{
				new var7 = iDmgDuringPounce[victim];
				var7 = var7[damage];
			}
		}
		new var1;
		if (damagetype & 4 || damagetype & 128)
		{
			new var2;
			if (iPreviousShotType[iClientPlaying] == 19 && GetEngineTime() - fPreviousShot[iClientPlaying] < 1048576000)
			{
				bCurrentShotHit[iClientPlaying] = 1;
			}
		}
	}
	zombieClass = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
	new var3;
	if (zombieClass >= 1 && zombieClass < 7)
	{
		new var8 = iDidDamage[attacker];
		var8 = var8[damage];
		new var9 = iDidDamageAll[attacker];
		var9 = var9[damage];
	}
	else
	{
		new var4;
		if (zombieClass == 8 && bCountTankDamage)
		{
			new var10 = iDidDamageAll[attacker];
			var10 = var10[damage];
			new var11 = iDidDamageTank[attacker];
			var11 = var11[damage];
		}
	}
	return 0;
}

public InfectedHurt_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new userId = GetEventInt(event, "attacker");
	new user = GetClientOfUserId(userId);
	if (iClientPlaying != user)
	{
		return 0;
	}
	if (!bPlayerLeftStartArea)
	{
		return 0;
	}
	new var1;
	if (bRUPActive && GetEntityMoveType(user))
	{
		return 0;
	}
	new damage = GetEventInt(event, "amount");
	new damageType = GetEventInt(event, "type");
	new victimEntId = GetEventInt(event, "entityid");
	if (damageType & 536870912)
	{
		bCurrentShotHit[iClientPlaying] = 1;
		if (IsCommonInfected(victimEntId))
		{
			switch (iPreviousShotType[iClientPlaying])
			{
				case 3:
				{
					damage = RoundFloat(float(damage) * 2.03);
				}
				case 4:
				{
					damage = RoundFloat(float(damage) * 2.29);
				}
				case 8:
				{
					damage = RoundFloat(float(damage) * 1.64);
				}
				case 11:
				{
					damage = RoundFloat(float(damage) * 1.84);
				}
				default:
				{
				}
			}
		}
		else
		{
			if (IsWitch(victimEntId))
			{
				new damageDone = damage;
				switch (iPreviousShotType[iClientPlaying])
				{
					case 3:
					{
						damage = 25;
					}
					case 4:
					{
						damage = 23;
					}
					case 8:
					{
						damage = 31;
					}
					case 11:
					{
						damage = 28;
					}
					default:
					{
					}
				}
				new var2;
				if (iCurrentShotDmg[iClientPlaying][damage] > 200 && damageDone > 100)
				{
					damage *= 2;
				}
			}
		}
		new var5 = iCurrentShotDmg[iClientPlaying];
		var5 = var5[damage];
	}
	else
	{
		if (damageType & 2)
		{
			iShotsHit[iClientPlaying]++;
		}
		new var3;
		if (damageType & 4 || damageType & 128)
		{
			new var4;
			if (iPreviousShotType[iClientPlaying] == 19 && GetEngineTime() - fPreviousShot[iClientPlaying] < 1048576000)
			{
				bCurrentShotHit[iClientPlaying] = 1;
			}
		}
	}
	if (IsWitch(victimEntId))
	{
		new damageDone = GetEventInt(event, "amount");
		if (bCountWitchDamage)
		{
			new var6 = iDidDamageAll[user];
			var6 = var6[damageDone];
			new var7 = iDidDamageWitch[user];
			var7 = var7[damageDone];
		}
	}
	return 0;
}

public PlayerDeath_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new zombieClass;
	new victimId = GetEventInt(event, "userid");
	new victim = GetClientOfUserId(victimId);
	new attackerId = GetEventInt(event, "attacker");
	new attacker = GetClientOfUserId(attackerId);
	if (iClientPlaying != attacker)
	{
		return 0;
	}
	if (!IsClientAndInGame(victim))
	{
		return 0;
	}
	if (GetClientTeam(victim) != 3)
	{
		return 0;
	}
	new damagetype = GetEventInt(event, "type");
	new var1;
	if (damagetype & 536870912 || damagetype & 2)
	{
		if (bIsPouncing[victim])
		{
			if (bIsHurt[victim])
			{
				iHuntSkeetsInj[iClientPlaying]++;
			}
			else
			{
				iHuntSkeets[iClientPlaying]++;
			}
			bIsPouncing[victim] = 0;
			iDmgDuringPounce[victim] = 0;
		}
	}
	zombieClass = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
	new var2;
	if (zombieClass >= 1 && zombieClass < 7)
	{
		iGotKills[attacker]++;
	}
	return 0;
}

public InfectedDeath_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new attackerId = GetEventInt(event, "attacker");
	new attacker = GetClientOfUserId(attackerId);
	new var1;
	if (attackerId && IsClientAndInGame(attacker))
	{
		if (GetClientTeam(attacker) == 2)
		{
			iGotCommon[attacker]++;
		}
	}
	return 0;
}

public PlayerShoved_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new userId = GetEventInt(event, "attacker");
	new user = GetClientOfUserId(userId);
	if (iClientPlaying != user)
	{
		return 0;
	}
	new victimId = GetEventInt(event, "userId");
	new victim = GetClientOfUserId(victimId);
	if (bIsPouncing[victim])
	{
		iDeadStops[user]++;
		bIsPouncing[victim] = 0;
		iDmgDuringPounce[victim] = 0;
	}
	return 0;
}

public AbilityUse_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new userId = GetEventInt(event, "userid");
	new user = GetClientOfUserId(userId);
	new String:abilityName[64];
	GetEventString(event, "ability", abilityName, 64);
	new var1;
	if (IsClientAndInGame(user) && strcmp(abilityName, "ability_lunge", false) && !bIsPouncing[user])
	{
		bIsPouncing[user] = 1;
		iDmgDuringPounce[user] = 0;
		bIsHurt[user] = GetClientHealth(user) < iPounceDmgInt;
		CreateTimer(0.1, groundTouchTimer, user, 1);
	}
	return 0;
}

public Action:groundTouchTimer(Handle:timer, any:client)
{
	new var2;
	if (IsClientAndInGame(client) && (isGrounded(client) || !IsPlayerAlive(client)))
	{
		bIsPouncing[client] = 0;
		KillTimer(timer, false);
	}
	return Action:0;
}

public bool:isGrounded(client)
{
	return GetEntProp(client, PropType:1, "m_fFlags", 4, 0) & 1 > 0;
}

public WeaponFire_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new userId = GetEventInt(event, "userid");
	new user = GetClientOfUserId(userId);
	if (iClientPlaying != user)
	{
		return 0;
	}
	if (!bPlayerLeftStartArea)
	{
		return 0;
	}
	new var1;
	if (bRUPActive && GetEntityMoveType(user))
	{
		return 0;
	}
	new weaponId = GetEventInt(event, "weaponid");
	new count = GetEventInt(event, "count");
	new weaponType = GetWeaponType(weaponId);
	if (weaponType == 1)
	{
		ResolveOpenShots();
		iShotsFired[iClientPlaying]++;
		new var2 = iPelletsFired[iClientPlaying];
		var2 = var2[count];
		fPreviousShot[iClientPlaying] = GetEngineTime();
		bCurrentShotHit[iClientPlaying] = 0;
		iCurrentShotDmg[iClientPlaying] = 0;
		iPreviousShotType[iClientPlaying] = weaponId;
		return 0;
	}
	if (weaponType == 2)
	{
		ResolveOpenShots();
		iMeleesFired[iClientPlaying]++;
		fPreviousShot[iClientPlaying] = GetEngineTime();
		bCurrentShotHit[iClientPlaying] = 0;
		iCurrentShotDmg[iClientPlaying] = 0;
		iPreviousShotType[iClientPlaying] = 19;
		return 0;
	}
	if (weaponType == 3)
	{
		iShotsFired[iClientPlaying]++;
		return 0;
	}
	return 0;
}

String:PrintSkeetStats(toClient)
{
	new String:printBuffer[512] = "";
	decl String:tmpBuffer[256];
	if (0 >= iClientPlaying)
	{
		return String:0;
	}
	if (!iBrevityFlags & 1)
	{
		if (!iBrevityFlags & 64)
		{
			if (!iBrevityFlags & 2)
			{
				Format(tmpBuffer, 256, "1v1Stat - Kills: (\x05%4d \x01damage,\x05 %3d \x01kills)  (\x05%3d \x01common)\n", iDidDamageAll[iClientPlaying], iGotKills[iClientPlaying], iGotCommon[iClientPlaying]);
			}
			else
			{
				Format(tmpBuffer, 256, "1v1Stat - Kills: (\x05%4d \x01damage,\x05 %3d \x01kills)\n", iDidDamageAll[iClientPlaying], iGotKills[iClientPlaying]);
			}
		}
		else
		{
			if (!iBrevityFlags & 2)
			{
				Format(tmpBuffer, 256, "1v1Stat - Kills: (\x05%4d \x01kills, \x05 %3d \x01common)\n", iGotKills[iClientPlaying], iGotCommon[iClientPlaying]);
			}
			Format(tmpBuffer, 256, "1v1Stat - Kills: (\x05%4d \x01kills)\n", iGotKills[iClientPlaying]);
		}
		StrCat(printBuffer, 512, tmpBuffer);
		if (!toClient)
		{
			PrintToServer("\x01%s", printBuffer);
			PrintToChatAll("\x01%s", printBuffer);
		}
		else
		{
			if (IsClientAndInGame(toClient))
			{
				PrintToChat(toClient, "\x01%s", printBuffer);
			}
		}
	}
	if (!iBrevityFlags & 8)
	{
		Format(tmpBuffer, 256, "1v1Stat - Skeet: (\x05%4d \x01normal,\x05 %3d \x01hurt)   (\x05%3d \x01deadstops)\n", iHuntSkeets[iClientPlaying], iHuntSkeetsInj[iClientPlaying], iDeadStops[iClientPlaying]);
		StrCat(printBuffer, 512, tmpBuffer);
		if (!toClient)
		{
			PrintToServer("\x01%s", printBuffer);
			PrintToChatAll("\x01%s", printBuffer);
		}
		else
		{
			if (IsClientAndInGame(toClient))
			{
				PrintToChat(toClient, "\x01%s", printBuffer);
			}
		}
	}
	if (!iBrevityFlags & 4)
	{
		new var2;
		if (iShotsFired[iClientPlaying] || (iMeleesFired[iClientPlaying] && !iBrevityFlags & 32))
		{
			if (iShotsFired[iClientPlaying])
			{
				Format(tmpBuffer, 256, "1v1Stat - Acc. : (all shots [\x04%3.0f%%\x01]", float(iShotsHit[iClientPlaying]) / float(iShotsFired[iClientPlaying]) * 100);
			}
			else
			{
				Format(tmpBuffer, 256, "1v1Stat - Acc. : (all shots [\x04%3.0f%%\x01]", 0);
			}
			if (iPelletsFired[iClientPlaying])
			{
				StrCat(printBuffer, 512, tmpBuffer);
				Format(tmpBuffer, 256, ", buckshot [\x04%3.0f%%\x01]", float(iPelletsHit[iClientPlaying]) / float(iPelletsFired[iClientPlaying]) * 100);
			}
			new var3;
			if (iMeleesFired[iClientPlaying] && !iBrevityFlags & 32)
			{
				StrCat(printBuffer, 512, tmpBuffer);
				Format(tmpBuffer, 256, ", melee [\x04%3.0f%%\x01]", float(iMeleesHit[iClientPlaying]) / float(iMeleesFired[iClientPlaying]) * 100);
			}
			StrCat(printBuffer, 512, tmpBuffer);
			Format(tmpBuffer, 256, ")\n");
		}
		else
		{
			Format(tmpBuffer, 256, "1v1Stat - Acc. : (no shots fired)\n");
		}
		StrCat(printBuffer, 512, tmpBuffer);
		if (!toClient)
		{
			PrintToServer("\x01%s", printBuffer);
			PrintToChatAll("\x01%s", printBuffer);
		}
		else
		{
			if (IsClientAndInGame(toClient))
			{
				PrintToChat(toClient, "\x01%s", printBuffer);
			}
		}
	}
	return String:0;
}

public ResolveOpenShots()
{
	if (0 >= iClientPlaying)
	{
		return 0;
	}
	if (iPreviousShotType[iClientPlaying])
	{
		if (bCurrentShotHit[iClientPlaying])
		{
			if (iPreviousShotType[iClientPlaying] == 19)
			{
				iMeleesHit[iClientPlaying]++;
			}
			iShotsHit[iClientPlaying]++;
			if (iCurrentShotDmg[iClientPlaying])
			{
				new iTotalPellets;
				new iPelletDamage;
				switch (iPreviousShotType[iClientPlaying])
				{
					case 3:
					{
						iTotalPellets = 10;
						iPelletDamage = 25;
					}
					case 4:
					{
						iTotalPellets = 11;
						iPelletDamage = 23;
					}
					case 8:
					{
						iTotalPellets = 8;
						iPelletDamage = 31;
					}
					case 11:
					{
						iTotalPellets = 9;
						iPelletDamage = 28;
					}
					default:
					{
					}
				}
				if (iTotalPellets)
				{
					new addPellets = RoundFloat(float(iCurrentShotDmg[iClientPlaying] / iPelletDamage));
					new var2 = iPelletsHit[iClientPlaying];
					new var1;
					if (addPellets <= iTotalPellets)
					{
						var1 = addPellets;
					}
					else
					{
						var1 = iTotalPellets;
					}
					var2 = var2[var1];
				}
			}
		}
		iPreviousShotType[iClientPlaying] = 0;
	}
	return 0;
}

GetWeaponType(weaponId)
{
	new var1;
	if (weaponId == 3 || weaponId == 8 || weaponId == 4 || weaponId == 11)
	{
		return 1;
	}
	if (weaponId == 19)
	{
		return 2;
	}
	new var2;
	if (weaponId == 1 || weaponId == 32 || weaponId == 2 || weaponId == 7 || weaponId == 33 || weaponId == 6 || weaponId == 10 || weaponId == 5 || weaponId == 9 || weaponId == 26 || weaponId == 34 || weaponId == 35 || weaponId == 36 || weaponId == 45)
	{
		return 3;
	}
	return 0;
}

GetCurrentSurvivor()
{
	new i;
	new maxplayers = MaxClients;
	i = 1;
	while (i <= maxplayers)
	{
		if (IsSurvivor(i))
		{
			return i;
		}
		i++;
	}
	return -1;
}

ClearClientSkeetStats(client)
{
	iGotKills[client] = 0;
	iGotCommon[client] = 0;
	iDidDamage[client] = 0;
	iDidDamageAll[client] = 0;
	iDidDamageWitch[client] = 0;
	iDidDamageTank[client] = 0;
	iShotsFired[client] = 0;
	iPelletsFired[client] = 0;
	iShotsHit[client] = 0;
	iPelletsHit[client] = 0;
	iMeleesFired[client] = 0;
	iMeleesHit[client] = 0;
	iDeadStops[client] = 0;
	iHuntSkeets[client] = 0;
	iHuntSkeetsInj[client] = 0;
	iHuntHeadShots[client] = 0;
	fPreviousShot[client] = 0;
	iPreviousShotType[client] = 0;
	bCurrentShotHit[client] = 0;
	iCurrentShotDmg[client] = 0;
	bIsPouncing[client] = 0;
	bIsHurt[client] = 0;
	iDmgDuringPounce[client] = 0;
	return 0;
}

bool:IsClientAndInGame(index)
{
	new var1;
	return index > 0 && index <= MaxClients && IsClientInGame(index);
}

bool:IsSurvivor(client)
{
	new var1;
	return IsClientAndInGame(client) && GetClientTeam(client) == 2;
}

bool:IsWitch(iEntity)
{
	new var1;
	if (iEntity > 0 && IsValidEntity(iEntity) && IsValidEdict(iEntity))
	{
		decl String:strClassName[64];
		GetEdictClassname(iEntity, strClassName, 64);
		return StrEqual(strClassName, "witch", true);
	}
	return false;
}

bool:IsCommonInfected(iEntity)
{
	new var1;
	if (iEntity > 0 && IsValidEntity(iEntity) && IsValidEdict(iEntity))
	{
		decl String:strClassName[64];
		GetEdictClassname(iEntity, strClassName, 64);
		return StrEqual(strClassName, "infected", true);
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:17"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "AI Tank Gank",
	description = "Kills tanks on pass to AI.",
	author = "Stabby",
	version = "0.2",
	url = ""
};
new Handle:hKillOnCrash;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	hKillOnCrash = CreateConVar("tankgank_killoncrash", "0", "If 0, tank will not be killed if the player that controlled it crashes.", 262144, true, 0.0, true, 1.0);
	HookEvent("player_bot_replace", OnTankGoneAi, EventHookMode:1);
	return 0;
}

public Action:OnTankGoneAi(Handle:event, String:name[], bool:dontBroadcast)
{
	new formerTank = GetClientOfUserId(GetEventInt(event, "player"));
	new newTank = GetClientOfUserId(GetEventInt(event, "bot"));
	new var1;
	if (GetClientTeam(newTank) == 3 && GetEntProp(newTank, PropType:0, "m_zombieClass", 4, 0) == 8)
	{
		new var2;
		if (formerTank && !GetConVarBool(hKillOnCrash))
		{
			CreateTimer(1.0, Timed_CheckAndKill, newTank, 0);
			return Action:0;
		}
		ForcePlayerSuicide(newTank);
	}
	return Action:0;
}

public Action:Timed_CheckAndKill(Handle:unused, any:newTank)
{
	if (IsFakeClient(newTank))
	{
		ForcePlayerSuicide(newTank);
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "12/10/2015",
	time = "12:51:14"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new bool:isPulled[66];
new bool:isPulling[66];
new bool:isJocked[66];
new bool:isJocking[66];
new bool:isCharged[66];
new bool:isCharging[66];
new bool:isPounced[66];
new bool:isPouncing[66];
new bool:seesWeapon[66];
new bool:isReloading[66];
new ItemType:ItemSpawn[66];
new ItemImportance[66];
public Plugin:myinfo =
{
	name = "Auto Communicator",
	description = "Allows players to communicate several game events with one command.",
	author = "Jacob",
	version = "0.1",
	url = "https://github.com/jacob404/Pro-Mod-4.0/releases/latest"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	BfWriteByte(hBuffer, author);
	BfWriteByte(hBuffer, 1);
	BfWriteString(hBuffer, szMessage);
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	HookEvent("weapon_reload", Event_Reload, EventHookMode:1);
	HookEvent("weapon_spawn_visible", Event_WeaponVisible, EventHookMode:1);
	HookEvent("charger_pummel_start", Event_SurvivorCharged, EventHookMode:1);
	HookEvent("charger_pummel_end", Event_ChargeEnd, EventHookMode:1);
	HookEvent("pounce_stopped", Event_PounceEnd, EventHookMode:1);
	HookEvent("lunge_pounce", Event_SurvivorPounced, EventHookMode:1);
	HookEvent("jockey_ride_end", Event_RideEnd, EventHookMode:1);
	HookEvent("jockey_ride", Event_SurvivorRode, EventHookMode:1);
	HookEvent("tongue_grab", Event_SurvivorPulled, EventHookMode:1);
	HookEvent("tongue_release", Event_PullEnd, EventHookMode:1);
	RegConsoleCmd("sm_autocom", Command_AutoCommunicate, "", 0);
	return 0;
}

public Action:Command_AutoCommunicate(client, args)
{
	PrioritizeMessage(client);
	return Action:0;
}

public PrioritizeMessage(client)
{
	if (GetClientTeam(client) == 2)
	{
		if (isPulled[client])
		{
			PrintToSurvivors("(Survivor) {blue}%N {default}:  I'm pulled!");
		}
		else
		{
			if (isJocked[client])
			{
				PrintToSurvivors("(Survivor) {blue}%N {default}:  I'm jocked!");
			}
			if (isCharged[client])
			{
				PrintToSurvivors("(Survivor) {blue}%N {default}:  I'm charged!");
			}
			if (isPounced[client])
			{
				PrintToSurvivors("(Survivor) {blue}%N {default}:  I'm pounced!");
			}
			if (seesWeapon[client])
			{
				TalkAboutPlayerItem(client);
			}
			if (isReloading[client])
			{
				PrintToSurvivors("(Survivor) {blue}%N {default}:  I'm reloading.", client);
			}
			CPrintToChat(client, "{green}[{lightgreen}ACB{green}] {default}Couldn't find anything to communicate. More will be added soon!");
		}
	}
	else
	{
		if (GetClientTeam(client) == 3)
		{
			if (isPulling[client])
			{
				PrintToInfected("(Infected) {red}%N {default}:  Cover me! I've got a pull!", client);
			}
			else
			{
				if (isJocking[client])
				{
					PrintToInfected("(Infected) {red}%N {default}:  Cover me! I jockeyed one!", client);
				}
				if (isCharging[client])
				{
					PrintToInfected("(Infected) {red}%N {default}:  Cover me! I landed my charge!", client);
				}
				if (isPouncing[client])
				{
					PrintToInfected("(Infected) {red}%N {default}:  Cover me! I pounced one!", client);
				}
				CPrintToChat(client, "{green}[{lightgreen}ACB{green}] {default}Couldn't find anything to communicate. More will be added soon!");
			}
		}
		CPrintToChat(client, "{green}[{lightgreen}ACB{green}] You can not use the auto communicator as a spectator.");
	}
	return 0;
}

public Event_SurvivorCharged(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	new charger = GetClientOfUserId(GetEventInt(event, "userid"));
	isCharging[charger] = 1;
	isCharged[victim] = 1;
	return 0;
}

public Event_ChargeEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	new charger = GetClientOfUserId(GetEventInt(event, "userid"));
	isCharging[charger] = 1;
	isCharged[victim] = 0;
	return 0;
}

public Event_SurvivorPounced(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	new hunter = GetClientOfUserId(GetEventInt(event, "userid"));
	isPouncing[hunter] = 1;
	isPounced[victim] = 1;
	return 0;
}


/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "Event_PounceEnd" (number 15)
public Event_SurvivorRode(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	new jockey = GetClientOfUserId(GetEventInt(event, "userid"));
	isJocking[jockey] = 1;
	isJocked[victim] = 1;
	return 0;
}

public Event_RideEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	new jockey = GetClientOfUserId(GetEventInt(event, "userid"));
	isJocking[jockey] = 0;
	isJocked[victim] = 0;
	return 0;
}

public Event_SurvivorPulled(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	new smoker = GetClientOfUserId(GetEventInt(event, "userid"));
	isPulling[smoker] = 1;
	isPulled[victim] = 1;
	return 0;
}

public Event_PullEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	new smoker = GetClientOfUserId(GetEventInt(event, "userid"));
	isPulling[smoker] = 0;
	isPulled[victim] = 0;
	return 0;
}

public Event_Reload(Handle:event, String:name[], bool:dontBroadcast)
{
	new player = GetClientOfUserId(GetEventInt(event, "userid"));
	if (!(GetEventBool(event, "manual")))
	{
		isReloading[player] = 1;
		CreateTimer(3.0, ReloadTimer, player, 0);
	}
	return 0;
}

public Action:ReloadTimer(Handle:timer, any:player)
{
	isReloading[player] = 0;
	return Action:0;
}

public Event_WeaponVisible(Handle:event, String:name[], bool:dontBroadcast)
{
	new player = GetClientOfUserId(GetEventInt(event, "userid"));
	seesWeapon[player] = 1;
	decl String:weapon[32];
	GetEventString(event, "weaponname", weapon, 32);
	if (StrEqual(weapon, "pain_pills", true))
	{
		ItemSpawn[player] = 1;
	}
	else
	{
		new var1;
		if (StrEqual(weapon, "ammo", true) && ItemImportance[player] <= 7)
		{
			ItemSpawn[player] = 2;
			ItemImportance[player] = 7;
		}
		new var2;
		if (StrEqual(weapon, "vomitjar", true) && ItemImportance[player] <= 6)
		{
			ItemSpawn[player] = 3;
			ItemImportance[player] = 6;
		}
		new var3;
		if (StrEqual(weapon, "smg_silenced", true) && ItemImportance[player] <= 5)
		{
			ItemSpawn[player] = 4;
			ItemImportance[player] = 5;
		}
		new var4;
		if (StrEqual(weapon, "shotgun_chrome", true) && ItemImportance[player] <= 4)
		{
			ItemSpawn[player] = 5;
			ItemImportance[player] = 4;
		}
		new var5;
		if (StrEqual(weapon, "smg", true) && ItemImportance[player] <= 3)
		{
			ItemSpawn[player] = 6;
			ItemImportance[player] = 3;
		}
		new var6;
		if (StrEqual(weapon, "pumpshotgun", true) && ItemImportance[player] <= 2)
		{
			ItemSpawn[player] = 7;
			ItemImportance[player] = 2;
		}
		if (StrEqual(weapon, "melee", true))
		{
			ItemSpawn[player] = 8;
			ItemImportance[player] = 1;
		}
	}
	CreateTimer(5.0, WeaponReset, player, 0);
	return 0;
}

TalkAboutPlayerItem(player)
{
	switch (ItemSpawn[player])
	{
		case 0:
		{
			PrintToChat(player, "ERROR: Undefined Entity");
		}
		case 1:
		{
			PrintItem(player, "Pills");
		}
		case 2:
		{
			PrintItem(player, "Ammo");
		}
		case 3:
		{
			PrintItem(player, "Bile Bomb");
		}
		case 4:
		{
			PrintItem(player, "Silenced Uzi");
		}
		case 5:
		{
			PrintItem(player, "Chrome Shotgun");
		}
		case 6:
		{
			PrintItem(player, "Uzi");
		}
		case 7:
		{
			PrintItem(player, "Pump Shotgun");
		}
		case 8:
		{
			PrintItem(player, "Melee Weapon");
		}
		default:
		{
		}
	}
	return 0;
}

PrintItem(player, String:itemName[])
{
	PrintToSurvivors("(Survivor) {blue}%N {default}:  %s over here.", player, itemName);
	return 0;
}

public Action:WeaponReset(Handle:timer, any:player)
{
	seesWeapon[player] = 0;
	ItemImportance[player] = 0;
	ItemSpawn[player] = 0;
	return Action:0;
}

PrintToSurvivors(String:Message[])
{
	decl String:sPrint[256];
	VFormat(sPrint, 256, Message, 2);
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && GetClientTeam(i) == 2)
		{
		}
	}
	return 0;
}

PrintToInfected(String:Message[])
{
	decl String:sPrint[256];
	VFormat(sPrint, 256, Message, 2);
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && GetClientTeam(i) == 3)
		{
		}
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "04/17/2017",
	time = "16:51:58"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 0,
};
public Plugin:myinfo =
{
	name = "L4D2 Auto-pause",
	description = "When a player disconnects due to crash, automatically pause the game. When they rejoin, give them a correct spawn timer.",
	author = "Darkid, Griffin",
	version = "1.9",
	url = "https://github.com/jbzdarkid/AutoPause"
};
new Handle:enabled;
new Handle:force;
new Handle:apdebug;
new Handle:crashedPlayers;
new Handle:infectedPlayers;
new bool:readyUpIsAvailable;
new bool:RoundEnd;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator-(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) - oper2;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

CTimer_Start(CountdownTimer:timer, Float:duration)
{
	CTimer_SetTimestamp(timer, GetGameTime() + duration);
	CTimer_SetDuration(timer, duration);
	return 0;
}

Float:CTimer_GetRemainingTime(CountdownTimer:timer)
{
	return CTimer_GetTimestamp(timer) - GetGameTime();
}

CTimer_SetDuration(CountdownTimer:timer, Float:duration)
{
	StoreToAddress(timer + 4, duration, NumberType:2);
	return 0;
}

Float:CTimer_GetTimestamp(CountdownTimer:timer)
{
	return LoadFromAddress(timer + 8, NumberType:2);
}

CTimer_SetTimestamp(CountdownTimer:timer, Float:timestamp)
{
	StoreToAddress(timer + 8, timestamp, NumberType:2);
	return 0;
}

CountdownTimer:L4D2Direct_GetSpawnTimer(client)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return CountdownTimer:0;
	}
	new Address:pEntity = GetEntityAddress(client);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CTerrorPlayer::SpawnTimer");
		if (offs == -1)
		{
			return CountdownTimer:0;
		}
		return offs + pEntity;
	}
	return CountdownTimer:0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public OnPluginStart()
{
	enabled = CreateConVar("autopause_enable", "1", "Whether or not to automatically pause when a player crashes.", 0, false, 0.0, false, 0.0);
	force = CreateConVar("autopause_force", "0", "Whether or not to force pause when a player crashes.", 0, false, 0.0, false, 0.0);
	apdebug = CreateConVar("autopause_apdebug", "0", "Whether or not to debug information.", 0, false, 0.0, false, 0.0);
	crashedPlayers = CreateTrie();
	infectedPlayers = CreateArray(64, 0);
	HookEvent("round_start", round_start, EventHookMode:1);
	HookEvent("round_end", round_end, EventHookMode:1);
	HookEvent("player_team", playerTeam, EventHookMode:1);
	HookEvent("player_disconnect", playerDisconnect, EventHookMode:0);
	return 0;
}

public OnAllPluginsLoaded()
{
	readyUpIsAvailable = LibraryExists("readyup");
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		readyUpIsAvailable = false;
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		readyUpIsAvailable = true;
	}
	return 0;
}

public round_start(Handle:event, String:name[], bool:dontBroadcast)
{
	ClearTrie(crashedPlayers);
	ClearArray(infectedPlayers);
	RoundEnd = false;
	return 0;
}

public round_end(Handle:event, String:name[], bool:dontBroadcast)
{
	RoundEnd = true;
	return 0;
}

public playerTeam(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return 0;
	}
	decl String:steamId[64];
	GetClientAuthString(client, steamId, 64, true);
	if (strcmp(steamId, "BOT", true))
	{
		new oldTeam = GetEventInt(event, "oldteam");
		new newTeam = GetEventInt(event, "team");
		new index = FindStringInArray(infectedPlayers, steamId);
		if (oldTeam == 3)
		{
			if (index != -1)
			{
				RemoveFromArray(infectedPlayers, index);
			}
			if (GetConVarBool(apdebug))
			{
				LogMessage("[AutoPause] Removed player %s from infected team.", steamId);
			}
		}
		if (newTeam == 3)
		{
			decl Float:spawnTime;
			if (GetTrieValue(crashedPlayers, steamId, spawnTime))
			{
				new CountdownTimer:spawnTimer = L4D2Direct_GetSpawnTimer(client);
				CTimer_Start(spawnTimer, spawnTime);
				RemoveFromTrie(crashedPlayers, steamId);
				LogMessage("[AutoPause] Player %s rejoined, set spawn timer to %f.", steamId, spawnTime);
			}
			else
			{
				if (index == -1)
				{
					PushArrayString(infectedPlayers, steamId);
					if (GetConVarBool(apdebug))
					{
						LogMessage("[AutoPause] Added player %s to infected team.", steamId);
					}
				}
			}
		}
		return 0;
	}
	return 0;
}

public playerDisconnect(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return 0;
	}
	decl String:steamId[64];
	GetClientAuthString(client, steamId, 64, true);
	if (strcmp(steamId, "BOT", true))
	{
		decl String:reason[128];
		GetEventString(event, "reason", reason, 128);
		decl String:playerName[128];
		GetEventString(event, "name", playerName, 128);
		decl String:timedOut[256];
		Format(timedOut, 256, "%s timed out", playerName);
		if (GetConVarBool(apdebug))
		{
			LogMessage("[AutoPause] Player %s (%s) left the game: %s", playerName, steamId, reason);
		}
		new var2;
		if (strcmp(reason, timedOut, true) && strcmp(reason, "No Steam logon", true))
		{
			new var3;
			if ((!readyUpIsAvailable || !IsInReady()) && (!RoundEnd && GetConVarBool(enabled)))
			{
				if (GetConVarBool(force))
				{
					ServerCommand("sm_forcepause");
				}
				else
				{
					FakeClientCommand(client, "sm_pause");
				}
				CPrintToChatAll("{blue}[{default}AutoPause{blue}] {olive}%s {default}crashed.", playerName);
			}
		}
		if (FindStringInArray(infectedPlayers, steamId) != -1)
		{
			decl Float:timeLeft;
			new CountdownTimer:spawnTimer = L4D2Direct_GetSpawnTimer(client);
			if (spawnTimer)
			{
				timeLeft = CTimer_GetRemainingTime(spawnTimer);
				LogMessage("[AutoPause] Player %s left the game with %f time until spawn.", steamId, timeLeft);
				SetTrieValue(crashedPlayers, steamId, timeLeft, true);
			}
		}
		return 0;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/22/2016",
	time = "10:06:15"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new Handle:hCvarCvarChange;
new Handle:hCvarNameChange;
new Handle:hCvarSpecNameChange;
new Handle:hCvarShowSpecsChat;
new bool:bCvarChange;
new bool:bNameChange;
new bool:bSpecNameChange;
new bool:bShowSpecsChat;
public Plugin:myinfo =
{
	name = "BeQuiet",
	description = "Please be Quiet!",
	author = "Sir",
	version = "1.33.7",
	url = "https://github.com/SirPlease/SirCoding"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	AddCommandListener(Say_Callback, "say");
	AddCommandListener(TeamSay_Callback, "say_team");
	HookEvent("server_cvar", Event_ServerDontNeedPrint, EventHookMode:0);
	HookEvent("player_changename", Event_NameDontNeedPrint, EventHookMode:0);
	hCvarCvarChange = CreateConVar("bq_cvar_change_suppress", "1", "Silence Server Cvars being changed, this makes for a clean chat with no disturbances.", 0, false, 0.0, false, 0.0);
	hCvarNameChange = CreateConVar("bq_name_change_suppress", "1", "Silence Player name Changes.", 0, false, 0.0, false, 0.0);
	hCvarSpecNameChange = CreateConVar("bq_name_change_spec_suppress", "1", "Silence Spectating Player name Changes.", 0, false, 0.0, false, 0.0);
	hCvarShowSpecsChat = CreateConVar("bq_show_player_team_chat_spec", "1", "Show Spectators what Players are saying in team chat.", 0, false, 0.0, false, 0.0);
	bCvarChange = GetConVarBool(hCvarCvarChange);
	bNameChange = GetConVarBool(hCvarNameChange);
	bSpecNameChange = GetConVarBool(hCvarSpecNameChange);
	bShowSpecsChat = GetConVarBool(hCvarShowSpecsChat);
	HookConVarChange(hCvarCvarChange, cvarChanged);
	HookConVarChange(hCvarNameChange, cvarChanged);
	HookConVarChange(hCvarSpecNameChange, cvarChanged);
	HookConVarChange(hCvarShowSpecsChat, cvarChanged);
	return 0;
}

public Action:Say_Callback(client, String:command[], argc)
{
	decl String:sayWord[32];
	GetCmdArg(1, sayWord, 32);
	new var1;
	if (sayWord[0] == '!' || sayWord[0] == '/')
	{
		return Action:3;
	}
	return Action:0;
}

public Action:TeamSay_Callback(client, String:command[], argc)
{
	decl String:sayWord[32];
	GetCmdArg(1, sayWord, 32);
	new var1;
	if (sayWord[0] == '!' || sayWord[0] == '/')
	{
		return Action:3;
	}
	new var2;
	if (bShowSpecsChat && GetClientTeam(client) != 1)
	{
		new String:sChat[256];
		GetCmdArgString(sChat, 256);
		StripQuotes(sChat);
		new i = 1;
		while (i <= 65)
		{
			new var3;
			if (IsValidClient(i) && GetClientTeam(i) == 1)
			{
				if (GetClientTeam(client) == 2)
				{
					CPrintToChat(i, "{default}(Survivor) {blue}%N {default}: %s", client, sChat);
				}
				CPrintToChat(i, "{default}(Infected) {red}%N {default}: %s", client, sChat);
			}
			i++;
		}
	}
	return Action:0;
}

public Action:Event_ServerDontNeedPrint(Handle:event, String:name[], bool:dontBroadcast)
{
	if (bCvarChange)
	{
		return Action:3;
	}
	return Action:0;
}

public Action:Event_NameDontNeedPrint(Handle:event, String:name[], bool:dontBroadcast)
{
	new client;
	new clientid = GetEventInt(event, "userid");
	client = GetClientOfUserId(clientid);
	if (IsValidClient(client))
	{
		if (GetClientTeam(client) == 1)
		{
			if (bSpecNameChange)
			{
				return Action:3;
			}
		}
		if (bNameChange)
		{
			return Action:3;
		}
	}
	return Action:0;
}

public cvarChanged(Handle:cvar, String:oldValue[], String:newValue[])
{
	bCvarChange = GetConVarBool(hCvarCvarChange);
	bNameChange = GetConVarBool(hCvarNameChange);
	bSpecNameChange = GetConVarBool(hCvarSpecNameChange);
	bShowSpecsChat = GetConVarBool(hCvarShowSpecsChat);
	return 0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client) || !IsClientInGame(client))
	{
		return false;
	}
	return true;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4140",
	date = "11/15/2013",
	time = "14:59:58"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new IsInCharge[66];
public Plugin:myinfo =
{
	name = "Blocks heatseeking chargers",
	description = "",
	author = "sheo",
	version = "1.2",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_bot_replace", BotReplacesPlayer, EventHookMode:1);
	HookEvent("charger_charge_start", Event_ChargeStart, EventHookMode:1);
	HookEvent("charger_charge_end", Event_ChargeEnd, EventHookMode:1);
	HookEvent("player_spawn", Event_OnPlayerSpawn, EventHookMode:1);
	HookEvent("player_death", Event_OnPlayerDeath, EventHookMode:1);
	CreateConVar("l4d2_block_heatseeking_chargers_version", "1.2", "Block heatseeking chargers fix version", 262400, false, 0.0, false, 0.0);
	return 0;
}

public Event_ChargeStart(Handle:event, String:name[], bool:dontBroadcast)
{
	IsInCharge[GetClientOfUserId(GetEventInt(event, "userid"))] = 1;
	return 0;
}

public Event_ChargeEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	IsInCharge[GetClientOfUserId(GetEventInt(event, "userid"))] = 0;
	return 0;
}

public Action:BotReplacesPlayer(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "player"));
	if (IsInCharge[client])
	{
		new bot = GetClientOfUserId(GetEventInt(event, "bot"));
		SetEntProp(bot, PropType:0, "m_fFlags", GetEntProp(bot, PropType:0, "m_fFlags", 4, 0) | 32, 4, 0);
		IsInCharge[client] = 0;
	}
	return Action:0;
}

public Event_OnPlayerSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	IsInCharge[GetClientOfUserId(GetEventInt(event, "userid"))] = 0;
	return 0;
}

public Event_OnPlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	IsInCharge[GetClientOfUserId(GetEventInt(event, "userid"))] = 0;
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "12/10/2015",
	time = "12:51:15"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Plugin:myinfo =
{
	name = "Block Trolls",
	description = "Prevents calling votes while others are loading",
	author = "ProdigySim, CanadaRox, darkid",
	version = "2.0.1.0",
	url = "https://github.com/jacob404/Pro-Mod-4.0/releases/latest"
};
new bool:g_bBlockCallvote;
new loadedPlayers;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	AddCommandListener(Vote_Listener, "callvote");
	AddCommandListener(Vote_Listener, "vote");
	HookEvent("player_team", OnPlayerJoin, EventHookMode:1);
	return 0;
}

public OnMapStart()
{
	g_bBlockCallvote = true;
	loadedPlayers = 0;
	CreateTimer(40.0, EnableCallvoteTimer, any:0, 0);
	return 0;
}

public OnPlayerJoin(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!(GetEventInt(event, "oldteam")))
	{
		loadedPlayers += 1;
		if (loadedPlayers == 6)
		{
			g_bBlockCallvote = false;
		}
	}
	return 0;
}

public Action:Vote_Listener(client, String:command[], argc)
{
	if (g_bBlockCallvote)
	{
		ReplyToCommand(client, "[SM] Voting is not enabled until 60s into the round");
		return Action:3;
	}
	new L4D2Team:team = GetClientTeam(client);
	new var2;
	if (client && IsClientInGame(client) && (team == L4D2Team:2 || team == L4D2Team:3))
	{
		return Action:0;
	}
	ReplyToCommand(client, "[SM] You must be ingame and not a spectator to vote");
	return Action:3;
}

public Action:CallvoteCallback(client, args)
{
	if (g_bBlockCallvote)
	{
		return Action:3;
	}
	return Action:0;
}

public Action:EnableCallvoteTimer(Handle:timer)
{
	g_bBlockCallvote = false;
	return Action:4;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "11/24/2014",
	time = "19:20:03"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new Handle:z_mob_spawn_max_size;
public Plugin:myinfo =
{
	name = "Boomer Horde Equalizer",
	description = "Fixes boomer hordes being different sizes based on wandering commons.",
	author = "Visor, Jacob",
	version = "1.1",
	url = "https://github.com/Attano"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	z_mob_spawn_max_size = FindConVar("z_mob_spawn_max_size");
	PatchWanderersCheck(true);
	return 0;
}

public OnPluginEnd()
{
	PatchWanderersCheck(false);
	return 0;
}

public Action:L4D_OnSpawnITMob(&amount)
{
	amount = GetConVarInt(z_mob_spawn_max_size);
	return Action:0;
}

PatchWanderersCheck(bool:enable)
{
	new Handle:hGamedata = LoadGameConfigFile("boomer_horde_equalizer");
	new Address:pAddress;
	if (!hGamedata)
	{
		SetFailState("Gamedata 'boomer_horde_equalizer.txt' missing or corrupt");
	}
	pAddress = GameConfGetAddress(hGamedata, "OnCharacterVomitedUpon_Sig");
	if (!pAddress)
	{
		SetFailState("Couldn't find the 'OnCharacterVomitedUpon_Sig' address");
	}
	new iOffset = GameConfGetOffset(hGamedata, "WanderersCondition");
	decl patchBytes[4];
	new originalBytes[4] = {57,243,125,19};
	new var1;
	if (enable)
	{
		var1 = originalBytes[0];
	}
	else
	{
		var1 = patchBytes[0];
	}
	if (var1 == LoadFromAddress(iOffset + pAddress, NumberType:0))
	{
		new i;
		while (i < 4)
		{
			if (!(0 > patchBytes[i]))
			{
				new var2;
				if (enable)
				{
					var2 = patchBytes[i];
				}
				else
				{
					var2 = originalBytes[i];
				}
				StoreToAddress(i + iOffset + pAddress, var2, NumberType:0);
				new var3;
				if (enable)
				{
					var3 = patchBytes[i];
				}
				else
				{
					var3 = originalBytes[i];
				}
				PrintToServer("Set %x@%i", var3, i);
				i++;
			}
		}
	}
	CloseHandle(hGamedata);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.3.5-dev",
	date = "04/13/2011",
	time = "18:39:03"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Versus Boss Spawn Persuasion",
	description = "Makes Versus Boss Spawns obey cvars",
	author = "ProdigySim",
	version = "1.1",
	url = "http://compl4d2.com/"
};
new Handle:hCvarEnabled;
new Handle:hCvarSkipStaticMaps;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	hCvarEnabled = CreateConVar("l4d_obey_boss_spawn_cvars", "0", "Enable forcing boss spawns to obey boss spawn cvars", 0, false, 0.0, false, 0.0);
	hCvarSkipStaticMaps = CreateConVar("l4d_obey_boss_spawn_except_static", "0", "Don't override boss spawning rules on Static Tank Spawn maps (c7m1, c13m2)", 0, false, 0.0, false, 0.0);
	return 0;
}

public Action:L4D_OnGetScriptValueInt(String:key[], &retVal)
{
	if (GetConVarBool(hCvarEnabled))
	{
		if (StrEqual(key, "DisallowThreatType", true))
		{
			retVal = 0;
			return Action:3;
		}
		if (StrEqual(key, "ProhibitBosses", true))
		{
			retVal = 0;
			return Action:3;
		}
	}
	return Action:0;
}

public Action:L4D_OnGetMissionVSBossSpawning(&Float:spawn_pos_min, &Float:spawn_pos_max, &Float:tank_chance, &Float:witch_chance)
{
	if (GetConVarBool(hCvarEnabled))
	{
		if (GetConVarBool(hCvarSkipStaticMaps))
		{
			decl String:mapbuf[32];
			GetCurrentMap(mapbuf, 32);
			new var1;
			if (StrEqual(mapbuf, "c7m1_docks", true) || StrEqual(mapbuf, "c13m2_southpinestream", true))
			{
				return Action:0;
			}
		}
		return Action:3;
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:26:05"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_builtinvotes =
{
	name = "BuiltinVotes",
	file = "builtinvotes.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_smsock =
{
	name = "Socket",
	file = "socket.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_bosspercent =
{
	name = "l4d_boss_percent",
	file = "l4d_boss_percent.smx",
	required = 1,
};
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 1,
};
new Handle:hVote;
new Float:fTankSpawns[5];
new Float:fWitchSpawns[5];
new bool:bStaticSpawnsActive;
public Plugin:myinfo =
{
	name = "L4D2 Boss Percents Standardizer",
	description = "Sets predefined boss spawn coordinates from a shared database. Intended for use in cups.",
	author = "Visor",
	version = "1.0.1",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator!=(Float:,_:)(Float:oper1, oper2)
{
	return FloatCompare(oper1, float(oper2)) != 0;
}

ExplodeString(String:text[], String:split[], String:buffers[][], maxStrings, maxStringLength, bool:copyRemainder)
{
	new reloc_idx;
	new idx;
	new total;
	new var1;
	if (maxStrings < 1 || !split[0])
	{
		return 0;
	}
	while ((idx = SplitString(text[reloc_idx], split, buffers[total], maxStringLength)) != -1)
	{
		reloc_idx = idx + reloc_idx;
		total++;
		if (maxStrings == total)
		{
			if (copyRemainder)
			{
				strcopy(buffers[total + -1], maxStringLength, text[reloc_idx - idx]);
			}
			return total;
		}
	}
	total++;
	strcopy(buffers[total], maxStringLength, text[reloc_idx]);
	return total;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

bool:IsNewBuiltinVoteAllowed()
{
	new var1;
	if (IsBuiltinVoteInProgress() || CheckBuiltinVoteDelay())
	{
		return false;
	}
	return true;
}

public __ext_builtinvotes_SetNTVOptional()
{
	MarkNativeAsOptional("CreateBuiltinVote");
	MarkNativeAsOptional("DisplayBuiltinVote");
	MarkNativeAsOptional("AddBuiltinVoteItem");
	MarkNativeAsOptional("InsertBuiltinVoteItem");
	MarkNativeAsOptional("RemoveBuiltinVoteItem");
	MarkNativeAsOptional("RemoveAllBuiltinVoteItems");
	MarkNativeAsOptional("GetBuiltinVoteItem");
	MarkNativeAsOptional("GetBuiltinVoteItemCount");
	MarkNativeAsOptional("SetBuiltinVoteArgument");
	MarkNativeAsOptional("GetBuiltinVoteArgument");
	MarkNativeAsOptional("IsBuiltinVoteInProgress");
	MarkNativeAsOptional("GetBuiltinVoteMaxItems");
	MarkNativeAsOptional("SetBuiltinVoteOptionFlags");
	MarkNativeAsOptional("GetBuiltinVoteOptionFlags");
	MarkNativeAsOptional("SetBuiltinVoteResultCallback");
	MarkNativeAsOptional("CheckBuiltinVoteDelay");
	MarkNativeAsOptional("IsClientInBuiltinVotePool");
	MarkNativeAsOptional("RedrawClientBuiltinVote");
	MarkNativeAsOptional("GetBuiltinVoteType");
	MarkNativeAsOptional("SetBuiltinVoteTeam");
	MarkNativeAsOptional("GetBuiltinVoteTeam");
	MarkNativeAsOptional("SetBuiltinVoteInitiator");
	MarkNativeAsOptional("GetBuiltinVoteInitiator");
	MarkNativeAsOptional("DisplayBuiltinVotePass");
	MarkNativeAsOptional("DisplayBuiltinVotePass2");
	MarkNativeAsOptional("DisplayBuiltinVoteFail");
	return 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetCDirector()
{
	static Address:TheDirector;
	if (!TheDirector)
	{
		TheDirector = GameConfGetAddress(L4D2Direct_GetGameConf(), "CDirector");
	}
	return TheDirector;
}

Address:L4D2Direct_GetCDirectorVersusMode()
{
	static Address:pVersusModeDirector;
	if (!pVersusModeDirector)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode");
		if (offs == -1)
		{
			return Address:0;
		}
		pVersusModeDirector = L4D2Direct_GetCDirector() + offs;
		pVersusModeDirector = LoadFromAddress(pVersusModeDirector, NumberType:2);
	}
	return pVersusModeDirector;
}

Address:L4D2Direct_GetVSTankFlowAddr()
{
	static Address:pTankFlowPercent;
	if (!pTankFlowPercent)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_fTankSpawnFlowPercent");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankFlowPercent = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pTankFlowPercent;
}

Address:L4D2Direct_GeVSTankToSpawnAddr()
{
	static Address:pTankSpawnThisRound;
	if (!pTankSpawnThisRound)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_bTankThisRound");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankSpawnThisRound = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pTankSpawnThisRound;
}

Address:L4D2Direct_GetVSWitchFlowAddr()
{
	static Address:pWitchFlowPercent;
	if (!pWitchFlowPercent)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_fWitchSpawnFlowPercent");
		if (offs == -1)
		{
			return Address:0;
		}
		pWitchFlowPercent = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pWitchFlowPercent;
}

Address:L4D2Direct_GetVSWitchToSpawnAddr()
{
	static Address:pWitchSpawnThisRound;
	if (!pWitchSpawnThisRound)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_bWitchThisRound");
		if (offs == -1)
		{
			return Address:0;
		}
		pWitchSpawnThisRound = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pWitchSpawnThisRound;
}

L4D2Direct_SetVSTankFlowPercent(roundNumber, Float:flow)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(roundNumber * 4 + L4D2Direct_GetVSTankFlowAddr(), flow, NumberType:2);
	return 0;
}

L4D2Direct_SetVSTankToSpawnThisRound(roundNumber, bool:spawn)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(L4D2Direct_GeVSTankToSpawnAddr() + roundNumber, spawn, NumberType:0);
	return 0;
}

L4D2Direct_SetVSWitchFlowPercent(roundNumber, Float:flow)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(roundNumber * 4 + L4D2Direct_GetVSWitchFlowAddr(), flow, NumberType:2);
	return 0;
}

L4D2Direct_SetVSWitchToSpawnThisRound(roundNumber, bool:spawn)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(L4D2Direct_GetVSWitchToSpawnAddr() + roundNumber, spawn, NumberType:0);
	return 0;
}

public __pl_bosspercent_SetNTVOptional()
{
	MarkNativeAsOptional("UpdateBossPercents");
	return 0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public OnPluginStart()
{
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	RegConsoleCmd("sm_cup", Vote, "", 0);
	return 0;
}

public Action:Vote(client, args)
{
	if (bStaticSpawnsActive)
	{
		PrintToChat(client, "\x01[\x04BossEQ\x01] Static spawns already applied! If it's a new game, reload the config by typing \x03!rmatch\x01");
		return Action:3;
	}
	new var1;
	if (IsSpectator(client) || L4D2_GetMapNumber() > 0 || !IsInReady() || InSecondHalfOfRound())
	{
		PrintToChat(client, "\x01[\x04BossEQ\x01] Vote can only be started by a player during ready-up @ first round, first map!");
		return Action:3;
	}
	if (StartVote(client, "Apply static boss spawns for this match?"))
	{
		FakeClientCommand(client, "Vote Yes");
	}
	return Action:3;
}

bool:StartVote(client, String:sVoteHeader[])
{
	if (IsNewBuiltinVoteAllowed())
	{
		new iNumPlayers;
		decl players[MaxClients];
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (!IsClientConnected(i) || !IsClientInGame(i))
			{
			}
			else
			{
				new var2;
				if (!(IsSpectator(i) || IsFakeClient(i)))
				{
					iNumPlayers++;
					players[iNumPlayers] = i;
				}
			}
			i++;
		}
		hVote = CreateBuiltinVote(BuiltinVoteActionHandler:17, BuiltinVoteType:3, BuiltinVoteAction:26);
		SetBuiltinVoteArgument(hVote, sVoteHeader);
		SetBuiltinVoteInitiator(hVote, client);
		SetBuiltinVoteResultCallback(hVote, BuiltinVoteHandler:19);
		DisplayBuiltinVote(hVote, players, iNumPlayers, 20);
		return true;
	}
	PrintToChat(client, "\x01[\x04BossEQ\x01] Vote cannot be started now.");
	return false;
}

public VoteActionHandler(Handle:vote, BuiltinVoteAction:action, param1, param2)
{
	switch (action)
	{
		case 2:
		{
			hVote = MissingTAG:0;
			CloseHandle(vote);
		}
		case 8:
		{
			DisplayBuiltinVoteFail(vote, param1);
		}
		default:
		{
		}
	}
	return 0;
}

public VoteResultHandler(Handle:vote, num_votes, num_clients, client_info[][2], num_items, item_info[][2])
{
	new i;
	while (i < num_items)
	{
		if (item_info[i][0] == 1)
		{
			if (num_clients / 2 < item_info[i][1])
			{
				DisplayBuiltinVotePass(vote, "Applying custom boss spawns...");
				PrintToChatAll("\x01[\x04BossEQ\x01] Vote passed! Applying custom boss spawns...");
				DownloadAndSaveStaticSpawns();
				return 0;
			}
		}
		i++;
	}
	DisplayBuiltinVoteFail(vote, BuiltinVoteFailReason:3);
	return 0;
}

public OnRoundStart()
{
	CreateTimer(5.5, RewriteBossFlows, any:0, 0);
	return 0;
}

public Action:RewriteBossFlows(Handle:timer)
{
	new var1;
	if (bStaticSpawnsActive && !InSecondHalfOfRound())
	{
		SetTankSpawn(fTankSpawns[L4D2_GetMapNumber()]);
		SetWitchSpawn(fWitchSpawns[L4D2_GetMapNumber()]);
		UpdateBossPercents();
	}
	return Action:0;
}

DownloadAndSaveStaticSpawns()
{
	decl String:sCurrentMap[64];
	new Handle:hMap = CreateDataPack();
	GetCurrentMap(sCurrentMap, 64);
	WritePackString(hMap, sCurrentMap);
	new Handle:socket = SocketCreate(SocketType:1, OnSocketError);
	SocketSetArg(socket, hMap);
	SocketConnect(socket, OnSocketConnected, OnSocketReceive, OnSocketDisconnected, "31.186.250.11", 80);
	return 0;
}

public OnSocketConnected(Handle:socket, any:map)
{
	decl String:sCurrentMap[64];
	ResetPack(map, false);
	ReadPackString(map, sCurrentMap, 64);
	decl String:sRequestStr[256];
	Format(sRequestStr, 256, "GET /%s?%s HTTP/1.0\r\nHost: %s\r\nConnection: close\r\n\r\n", "bosspercentdb.php", sCurrentMap, "31.186.250.11");
	SocketSend(socket, sRequestStr, -1);
	return 0;
}

public OnSocketReceive(Handle:socket, String:receiveData[], dataSize, any:map)
{
	new String:buffer[2][128] = {
		"\r\n\r\n",
		" %d (errno %d)"
	};
	ExplodeString(receiveData, "\r\n\r\n", buffer, 2, 128, false);
	if (buffer[1])
	{
		new String:sBossSpawns[2][64] = {
			"||",
			"nSecondHalfOfRound"
		};
		ExplodeString(buffer[1], "||", sBossSpawns, 2, 64, false);
		new String:sMapsBuffer[5][8] = {
			"|",
			"socket error %d (errno %d)",
			"rror %d (errno %d)",
			"(errno %d)",
			"d)"
		};
		ExplodeString(sBossSpawns[0][sBossSpawns], "|", sMapsBuffer, 5, 8, false);
		new i;
		while (i < 5)
		{
			fTankSpawns[i] = StringToFloat(sMapsBuffer[i]) / 100.0;
			i++;
		}
		ExplodeString(sBossSpawns[1], "|", sMapsBuffer, 5, 8, false);
		new i;
		while (i < 5)
		{
			fWitchSpawns[i] = StringToFloat(sMapsBuffer[i]) / 100.0;
			i++;
		}
		bStaticSpawnsActive = true;
		OnRoundStart();
		return 0;
	}
	PrintToChatAll("\x01[\x04BossEQ\x01] No predefined spawns could be found for this campaign.");
	return 0;
}

public OnSocketDisconnected(Handle:socket, any:map)
{
	CloseHandle(socket);
	return 0;
}

public OnSocketError(Handle:socket, errorType, errorNum, any:map)
{
	LogError("socket error %d (errno %d)", errorType, errorNum);
	CloseHandle(socket);
	return 0;
}

SetTankSpawn(Float:flow)
{
	new i;
	while (i <= 1)
	{
		if (flow != 0.0)
		{
			L4D2Direct_SetVSTankToSpawnThisRound(i, true);
			L4D2Direct_SetVSTankFlowPercent(i, flow);
		}
		else
		{
			L4D2Direct_SetVSTankToSpawnThisRound(i, false);
		}
		i++;
	}
	return 0;
}

SetWitchSpawn(Float:flow)
{
	new i;
	while (i <= 1)
	{
		if (flow != 0.0)
		{
			L4D2Direct_SetVSWitchToSpawnThisRound(i, true);
			L4D2Direct_SetVSWitchFlowPercent(i, flow);
		}
		else
		{
			L4D2Direct_SetVSWitchToSpawnThisRound(i, false);
		}
		i++;
	}
	return 0;
}

L4D2_GetMapNumber()
{
	return LoadFromAddress(L4D2Direct_GetCDirector() + 864, NumberType:0);
}

bool:IsSpectator(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 1;
}

InSecondHalfOfRound()
{
	return GameRules_GetProp("m_bInSecondHalfOfRound", 4, 0);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4140",
	date = "11/08/2013",
	time = "10:15:44"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new iBotUsedCount[2][66];
public Plugin:myinfo =
{
	name = "Simplified Bot Pop Stop",
	description = "Removes pills from bots if they try to use them and restores them when a human takes over.",
	author = "Stabby & CanadaRox",
	version = "1.3",
	url = "no url"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	HookEvent("weapon_fire", Event_WeaponFire, EventHookMode:1);
	HookEvent("bot_player_replace", Event_PlayerJoined, EventHookMode:1);
	HookEvent("round_start", Event_RoundStart, EventHookMode:2);
	return 0;
}

public Event_WeaponFire(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new weaponid = GetEventInt(event, "weaponid");
	if (IsFakeClient(client))
	{
		if (weaponid == 15)
		{
			new var1 = iBotUsedCount;
			var1[0][var1][client]++;
			RemovePlayerItem(client, GetPlayerWeaponSlot(client, 4));
		}
		if (weaponid == 23)
		{
			iBotUsedCount[1][client]++;
			RemovePlayerItem(client, GetPlayerWeaponSlot(client, 4));
		}
	}
	return 0;
}

public Event_PlayerJoined(Handle:event, String:name[], bool:dontBroadcast)
{
	new leavingBot = GetClientOfUserId(GetEventInt(event, "bot"));
	new var2 = iBotUsedCount;
	new var1;
	if (var2[0][var2][leavingBot] > 0 || iBotUsedCount[1][leavingBot] > 0)
	{
		RestoreItems(GetClientOfUserId(GetEventInt(event, "player")), leavingBot);
		new var3 = iBotUsedCount;
		var3[0][var3][leavingBot] = 0;
		iBotUsedCount[1][leavingBot] = 0;
	}
	return 0;
}

public Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	new i;
	while (i < 2)
	{
		new j;
		while (j < 66)
		{
			iBotUsedCount[i][j] = 0;
			j++;
		}
		i++;
	}
	return 0;
}

RestoreItems(client, leavingBot)
{
	decl entity;
	decl Float:clientOrigin[3];
	new currentWeapon = GetPlayerWeaponSlot(client, 4);
	new i;
	while (i < 2)
	{
		new j = iBotUsedCount[i][leavingBot];
		while (0 < j)
		{
			new var1;
			if (i)
			{
				var1[0] = 2008;
			}
			else
			{
				var1[0] = 1988;
			}
			entity = CreateEntityByName(var1, -1);
			GetClientAbsOrigin(client, clientOrigin);
			clientOrigin[2] += 10.0;
			TeleportEntity(entity, clientOrigin, NULL_VECTOR, NULL_VECTOR);
			DispatchSpawn(entity);
			if (currentWeapon == -1)
			{
				EquipPlayerWeapon(client, entity);
				currentWeapon = entity;
			}
			j--;
		}
		i++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2",
	date = "01/07/2015",
	time = "22:05:11"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new bool:g_bIsBridge;
new bool:g_bIsRealTank = 1;
new g_iTankCount;
public Plugin:myinfo =
{
	name = "Bridge Escape Fix",
	description = "Kills the unlimited tank spawns on parish finale.",
	author = "Jacob",
	version = "1.3",
	url = "github.com/jacob404/myplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	HookEvent("tank_spawn", Event_TankSpawn, EventHookMode:1);
	HookEvent("round_start", Event_RoundStart, EventHookMode:2);
	return 0;
}

public OnMapStart()
{
	decl String:mapname[64];
	GetCurrentMap(mapname, 64);
	if (StrEqual(mapname, "c5m5_bridge", true))
	{
		g_bIsBridge = true;
	}
	else
	{
		g_bIsBridge = false;
	}
	g_iTankCount = 0;
	return 0;
}

public Event_TankSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	new tank = GetClientOfUserId(GetEventInt(event, "userid"));
	if (g_bIsRealTank)
	{
		g_iTankCount += 1;
		g_bIsRealTank = false;
		CreateTimer(5.0, TankSpawnTimer, any:0, 0);
	}
	new var1;
	if (g_bIsBridge && g_iTankCount >= 3)
	{
		ForcePlayerSuicide(tank);
	}
	return 0;
}

public Action:TankSpawnTimer(Handle:timer)
{
	g_bIsRealTank = true;
	return Action:0;
}

public Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	g_iTankCount = 0;
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "09/03/2015",
	time = "21:46:37"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Caster Addons Manager",
	description = "Allows casters to join the server with their addons on",
	author = "Visor",
	version = "1.2",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_team", OnTeamChange, EventHookMode:1);
	return 0;
}

public Action:L4D2_OnClientDisableAddons(String:SteamID[])
{
	new var1;
	if (IsIDCaster(SteamID))
	{
		var1 = MissingTAG:3;
	}
	else
	{
		var1 = MissingTAG:0;
	}
	return var1;
}

public OnTeamChange(Handle:event, String:name[], bool:dontBroadcast)
{
	if (GetEventInt(event, "team") != 1)
	{
		new client = GetClientOfUserId(GetEventInt(event, "userid"));
		CreateTimer(1.0, CasterCheck, client, 2);
	}
	return 0;
}

public Action:CasterCheck(Handle:timer, any:client)
{
	new var1;
	if (client && IsClientInGame(client) && GetClientTeam(client) != 1 && IsClientCaster(client))
	{
		PrintToChat(client, "\x01<\x05Cast\x01> Unregister from casting first before playing.");
		PrintToChat(client, "\x01<\x05Cast\x01> Use \x04!notcasting");
		ChangeClientTeam(client, 1);
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.9.0.6276",
	date = "04/10/2019",
	time = "20:36:02"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Caster Assister",
	description = "Allows spectators to control their own specspeed and move vertically",
	author = "CanadaRox, Sir",
	version = "2.1",
	url = ""
};
new Float:currentMulti[66] =
{
	1065353216, ...
};
new Float:currentIncrement[66] =
{
	1036831949, ...
};
new Float:verticalIncrement[66] =
{
	1092616192, ...
};
public void:__ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.BytesLeft.get");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return void:0;
}

.2920.-40000005(Float:oper)
{
	return oper ^ -2147483648;
}

.2920.-40000005(Float:oper)
{
	return oper ^ -2147483648;
}

.2920.-40000005(Float:oper)
{
	return oper1 >= float(oper2);
}

.2920.-40000005(Float:oper)
{
	return oper1 >= float(oper2);
}

.2920.-40000005(Float:oper)
{
	return oper1 <= float(oper2);
}

.2920.-40000005(Float:oper)
{
	return oper1 <= float(oper2);
}

public .2920.-40000005(Float:oper)
{
	RegConsoleCmd("sm_set_specspeed_multi", .2920.-40000005, "", 0);
	RegConsoleCmd("sm_set_specspeed_increment", .2920.-40000005, "", 0);
	RegConsoleCmd("sm_increase_specspeed", .2920.-40000005, "", 0);
	RegConsoleCmd("sm_decrease_specspeed", .2920.-40000005, "", 0);
	RegConsoleCmd("sm_set_vertical_increment", .2920.-40000005, "", 0);
	HookEvent("player_team", .2920.-40000005, EventHookMode:1);
	return 0;
}

public .2920.-40000005(Float:oper)
{
	new team = GetEventInt(event, "team", 0);
	if (team == 1)
	{
		new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
		SetEntPropFloat(client, PropType:0, "m_flLaggedMovementValue", currentMulti[client], 0);
	}
	return 0;
}

public .2920.-40000005(Float:oper)
{
	if (GetClientTeam(client) != 1)
	{
		return 3;
	}
	if (args != 1)
	{
		ReplyToCommand(client, "Usage: sm_set_specspeed_multi # (default: 1.0)");
		return 3;
	}
	decl String:buffer[12];
	GetCmdArg(1, buffer, 10);
	new Float:newVal = StringToFloat(buffer);
	if (.2920.-40000005(newVal))
	{
		SetEntPropFloat(client, PropType:0, "m_flLaggedMovementValue", newVal, 0);
		currentMulti[client] = newVal;
	}
	return 3;
}

public .2920.-40000005(Float:oper)
{
	if (GetClientTeam(client) != 1)
	{
		return 3;
	}
	if (args != 1)
	{
		ReplyToCommand(client, "Usage: sm_set_specspeed_increment # (default: 0.1)");
		return 3;
	}
	decl String:buffer[12];
	GetCmdArg(1, buffer, 10);
	currentIncrement[client] = StringToFloat(buffer);
	return 3;
}

public .2920.-40000005(Float:oper)
{
	if (GetClientTeam(client) != 1)
	{
		return 3;
	}
	.2920.-40000005(client, currentIncrement[client]);
	return 3;
}

public .2920.-40000005(Float:oper)
{
	if (GetClientTeam(client) != 1)
	{
		return 3;
	}
	.2920.-40000005(client, .2920.-40000005(currentIncrement[client]));
	return 3;
}

.2920.-40000005(Float:oper)
{
	new Float:curVal = GetEntPropFloat(client, PropType:0, "m_flLaggedMovementValue", 0);
	if (.2920.-40000005(curVal + difference))
	{
		SetEntPropFloat(client, PropType:0, "m_flLaggedMovementValue", curVal + difference, 0);
		currentMulti[client] = curVal + difference;
	}
	return 0;
}

public .2920.-40000005(Float:oper)
{
	if (GetClientTeam(client) != 1)
	{
		return 3;
	}
	if (args != 1)
	{
		ReplyToCommand(client, "Usage: sm_set_vertical_increment # (default: 10.0)");
		return 3;
	}
	decl String:buffer[12];
	GetCmdArg(1, buffer, 10);
	verticalIncrement[client] = StringToFloat(buffer);
	return 3;
}

public .2920.-40000005(Float:oper)
{
	if (GetClientTeam(client) == 1)
	{
		if (buttons & 32)
		{
			.2920.-40000005(client, verticalIncrement[client]);
		}
		if (buttons & 8192)
		{
			.2920.-40000005(client, .2920.-40000005(verticalIncrement[client]));
		}
	}
	return 0;
}

public .2920.-40000005(Float:oper)
{
	new var1;
	return .2920.-40000005(speed, 0) && .2920.-40000005(speed, 2);
}

.2920.-40000005(Float:oper)
{
	decl Float:origin[3];
	GetClientAbsOrigin(client, origin);
	origin[2] += distance;
	TeleportEntity(client, origin, NULL_VECTOR, NULL_VECTOR);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "01/03/2017",
	time = "20:32:45"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCvarMotdTitle;
new Handle:hCvarMotdUrl;
public Plugin:myinfo =
{
	name = "Config Description",
	description = "Displays a descriptive MOTD on desire",
	author = "Visor",
	version = "0.2",
	url = "https://github.com/Attano/smplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

ShowMOTDPanel(client, String:title[], String:msg[], type)
{
	decl String:num[4];
	new Handle:Kv = CreateKeyValues("data", "", "");
	IntToString(type, num, 3);
	KvSetString(Kv, "title", title);
	KvSetString(Kv, "type", num);
	KvSetString(Kv, "msg", msg);
	ShowVGUIPanel(client, "info", Kv, true);
	CloseHandle(Kv);
	return 0;
}

public OnPluginStart()
{
	hCvarMotdTitle = CreateConVar("sm_cfgmotd_title", "ZoneMod", "Custom MOTD title", 262144, false, 0.0, false, 0.0);
	hCvarMotdUrl = CreateConVar("sm_cfgmotd_url", "https://github.com/SirPlease/ZoneMod/blob/master/README.md", "Custom MOTD url", 262144, false, 0.0, false, 0.0);
	RegConsoleCmd("sm_changelog", ShowMOTD, "Show a MOTD describing the current config", 262144);
	RegConsoleCmd("sm_cfg", ShowMOTD, "Show a MOTD describing the current config", 262144);
	return 0;
}

public Action:ShowMOTD(client, args)
{
	decl String:title[64];
	decl String:url[192];
	GetConVarString(hCvarMotdTitle, title, 64);
	GetConVarString(hCvarMotdUrl, url, 192);
	ShowMOTDPanel(client, title, url, 2);
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:24"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new Handle:hInflictorTrie;
new bool:bLateLoad;
new Handle:hDmgPunch;
new Handle:hDmgFirst;
new Handle:hDmgSmash;
new Handle:hDmgStumble;
new Handle:hDmgPound;
new Handle:hDmgCappedVictim;
new Handle:hDmgIncappedPound;
new bool:bChargerPunched[66];
new bool:bChargerCharging[66];
new survivorProps[4] =
{
	13284, 16008, 16128, 15976
};
public Plugin:myinfo =
{
	name = "Charger Damage",
	description = "Charger damage modifier",
	author = "Tabun, Jacob, Visor",
	version = "0.4",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator==(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) == 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 2);
	new index = CFormat(szCMessage, 250, -1);
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			if (index == -1)
			{
				PrintToChat(i, szCMessage);
			}
			CSayText2(i, index, szCMessage);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	BfWriteByte(hBuffer, author);
	BfWriteByte(hBuffer, 1);
	BfWriteString(hBuffer, szMessage);
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	if (bLateLoad)
	{
		new i = 1;
		while (MaxClients + 1 > i)
		{
			if (IsClientInGame(i))
			{
				SDKHook(i, SDKHookType:2, OnTakeDamage);
			}
			i++;
		}
	}
	hDmgPunch = CreateConVar("charger_dmg_punch", "8", "Damage per (normal) charger punch.", 262144, true, 0.0, false, 0.0);
	hDmgFirst = CreateConVar("charger_dmg_firstpunch", "8", "Damage for first charger punch (in its life). -1 to ignore punch count", 262144, true, -1.0, false, 0.0);
	hDmgSmash = CreateConVar("charger_dmg_impact", "10", "Damage for impact after a charge.", 262144, true, 0.0, false, 0.0);
	hDmgStumble = CreateConVar("charger_dmg_stumble", "2", "Damage for stumbled impact after a charge.", 262144, true, 0.0, false, 0.0);
	hDmgPound = CreateConVar("charger_dmg_pound", "15", "Damage for pounds after charge/collision completed.", 262144, true, 0.0, false, 0.0);
	hDmgCappedVictim = CreateConVar("charger_dmg_cappedvictim", "8", "Damage for capped Survivor victims.", 262144, true, 0.0, false, 0.0);
	hDmgIncappedPound = CreateConVar("charger_dmg_incapped", "15", "Damage for incapped victims.", 262144, true, 0.0, false, 0.0);
	HookEvent("round_start", RoundStart_Event, EventHookMode:2);
	HookEvent("player_spawn", PlayerSpawn_Event, EventHookMode:1);
	HookEvent("charger_charge_start", ChargeStart_Event, EventHookMode:1);
	HookEvent("charger_charge_end", ChargeEnd_Event, EventHookMode:1);
	hInflictorTrie = BuildInflictorTrie();
	return 0;
}

public OnClientPostAdminCheck(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnMapStart()
{
	setCleanSlate();
	return 0;
}

public Action:RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	setCleanSlate();
	return Action:0;
}

public Action:PlayerSpawn_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (!IsClientAndInGame(client))
	{
		return Action:0;
	}
	if (GetClientTeam(client) != 3)
	{
		return Action:0;
	}
	if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) != 6)
	{
		return Action:0;
	}
	bChargerPunched[client] = 0;
	bChargerCharging[client] = 0;
	return Action:0;
}

public ChargeStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new clientId = GetEventInt(event, "userid");
	new client = GetClientOfUserId(clientId);
	if (IsClientAndInGame(client))
	{
		bChargerCharging[client] = 1;
	}
	return 0;
}

public ChargeEnd_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new clientId = GetEventInt(event, "userid");
	new client = GetClientOfUserId(clientId);
	if (IsClientAndInGame(client))
	{
		bChargerCharging[client] = 0;
	}
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (!inflictor || !attacker || !victim || !IsValidEdict(victim) || !IsValidEdict(inflictor))
	{
		return Action:0;
	}
	decl String:classname[64];
	new var2;
	if (IsClientAndInGame(attacker) && IsClientAndInGame(victim))
	{
		if (inflictor == attacker)
		{
			GetClientWeapon(inflictor, classname, 64);
		}
		else
		{
			GetEdictClassname(inflictor, classname, 64);
		}
		new var3;
		if (GetClientTeam(attacker) == 3 && GetClientTeam(victim) == 2)
		{
			return Action:0;
		}
		if (GetEntProp(attacker, PropType:0, "m_zombieClass", 4, 0) != 6)
		{
			return Action:0;
		}
		new TankOrSIWeapon:inflictorID;
		if (!GetTrieValue(hInflictorTrie, classname, inflictorID))
		{
			return Action:0;
		}
		if (inflictorID != TankOrSIWeapon:1)
		{
			return Action:0;
		}
		if (1092616192 == damage)
		{
			new var4;
			if (0.0 == damageForce[0] && 0.0 == damageForce[1] && 0.0 == damageForce[2])
			{
				damage = GetConVarFloat(hDmgSmash);
				return Action:1;
			}
			new Float:dmgFirst = GetConVarFloat(hDmgFirst);
			new var5;
			if (!bChargerPunched[attacker] && dmgFirst > -1.0)
			{
				bChargerPunched[attacker] = 1;
				damage = dmgFirst;
				return Action:1;
			}
			new var6;
			if (IsUnderAttack(victim))
			{
				var6 = GetConVarFloat(hDmgCappedVictim);
			}
			else
			{
				var6 = GetConVarFloat(hDmgPunch);
			}
			damage = var6;
			return Action:1;
		}
		if (1073741824 == damage)
		{
			damage = GetConVarFloat(hDmgStumble);
			return Action:1;
		}
		new var8;
		if (1097859072 == damage && (0.0 == damageForce[0] && 0.0 == damageForce[1] && 0.0 == damageForce[2]))
		{
			new var9;
			if (IsIncapped(victim))
			{
				var9 = GetConVarFloat(hDmgIncappedPound);
			}
			else
			{
				var9 = GetConVarFloat(hDmgPound);
			}
			damage = var9;
			return Action:1;
		}
		CPrintToChatAll("{default}-{blue}Charger Damage{default}- {green}warning, charger doing a type of damage it shouldn't! infl.: [%s] type [%d] damage [%.0f] force [%.0f %.0f %.0f]", classname, damageType, damage, damageForce, damageForce[1], damageForce[2]);
		return Action:3;
	}
	return Action:0;
}

bool:IsClientAndInGame(index)
{
	new var1;
	return index > 0 && index <= MaxClients && IsClientInGame(index);
}

setCleanSlate()
{
	new i;
	new maxplayers = 65;
	i = 1;
	while (i <= maxplayers)
	{
		bChargerPunched[i] = 0;
		bChargerCharging[i] = 0;
		i++;
	}
	return 0;
}

Handle:BuildInflictorTrie()
{
	new Handle:trie = CreateTrie();
	SetTrieValue(trie, "weapon_tank_claw", any:0, true);
	SetTrieValue(trie, "tank_rock", any:0, true);
	SetTrieValue(trie, "weapon_charger_claw", any:1, true);
	return trie;
}

bool:IsUnderAttack(survivor)
{
	new i;
	while (i < 4)
	{
		if (IsClientAndInGame(GetEntDataEnt2(survivor, survivorProps[i])))
		{
			return true;
		}
		i++;
	}
	return false;
}

bool:IsIncapped(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:22"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new PATCH_REPLACEMENT[5] =
{
	49, 192, 15, 31, 0
};
new ORIGINAL_BYTES[5];
new Address:g_pPatchTarget;
new bool:g_bIsPatched;
new Handle:hAllMaps;
new Handle:hSaferoomFrustrationTickdownMaps;
public Plugin:myinfo =
{
	name = "Checkpoint Rage Control",
	description = "Enable tank to lose rage while survivors are in saferoom",
	author = "ProdigySim, Visor",
	version = "0.3",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public OnPluginStart()
{
	new Handle:hGamedata = LoadGameConfigFile("checkpoint-rage-control");
	if (!hGamedata)
	{
		SetFailState("Gamedata 'checkpoint-rage-control.txt' missing or corrupt");
	}
	g_pPatchTarget = FindPatchTarget(hGamedata);
	CloseHandle(hGamedata);
	hSaferoomFrustrationTickdownMaps = CreateTrie();
	hAllMaps = CreateConVar("crc_global", "0", "Remove saferoom frustration preservation mechanic on all maps by default", 0, false, 0.0, false, 0.0);
	RegServerCmd("saferoom_frustration_tickdown", SetSaferoomFrustrationTickdown, "", 0);
	return 0;
}

public Action:SetSaferoomFrustrationTickdown(args)
{
	decl String:mapname[64];
	GetCmdArg(1, mapname, 64);
	SetTrieValue(hSaferoomFrustrationTickdownMaps, mapname, any:1, true);
	return Action:0;
}

public OnPluginEnd()
{
	Unpatch();
	return 0;
}

public OnMapStart()
{
	if (GetConVarBool(hAllMaps))
	{
		Patch();
		return 0;
	}
	decl String:mapname[64];
	GetCurrentMap(mapname, 64);
	decl dummy;
	if (GetTrieValue(hSaferoomFrustrationTickdownMaps, mapname, dummy))
	{
		Patch();
	}
	else
	{
		Unpatch();
	}
	return 0;
}

public OnRoundLive()
{
	if (IsPatched())
	{
		PrintToChatAll("\x04Tank\x01 will still lose frustration while survivors are in saferoom on this map.");
	}
	return 0;
}

bool:IsPatched()
{
	return g_bIsPatched;
}

Patch()
{
	if (!IsPatched())
	{
		new i;
		while (i < 5)
		{
			StoreToAddress(i + g_pPatchTarget, PATCH_REPLACEMENT[i], NumberType:0);
			i++;
		}
		g_bIsPatched = true;
	}
	return 0;
}

Unpatch()
{
	if (IsPatched())
	{
		new i;
		while (i < 5)
		{
			StoreToAddress(i + g_pPatchTarget, ORIGINAL_BYTES[i], NumberType:0);
			i++;
		}
		g_bIsPatched = false;
	}
	return 0;
}

Address:FindPatchTarget(Handle:hGamedata)
{
	new Address:pTarget = GameConfGetAddress(hGamedata, "SaferoomCheck_Sig");
	if (!pTarget)
	{
		SetFailState("Couldn't find the 'SaferoomCheck_Sig' address");
	}
	new iOffset = GameConfGetOffset(hGamedata, "UpdateZombieFrustration_SaferoomCheck");
	pTarget = iOffset + pTarget;
	if (LoadFromAddress(pTarget, NumberType:0) != 232)
	{
		SetFailState("Saferoom Check Offset or signature seems incorrect");
	}
	ORIGINAL_BYTES[0] = 232;
	new i = 1;
	while (i < 5)
	{
		ORIGINAL_BYTES[i] = LoadFromAddress(i + pTarget, NumberType:0);
		i++;
	}
	return pTarget;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2",
	date = "12/09/2014",
	time = "23:59:39"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new bool:AllowJingle = 1;
new bool:JingleCooldown;
new bool:SurvivorSnow;
new bool:InfectedSnow;
public Plugin:myinfo =
{
	name = "Christmas Surprise",
	description = "Happy Holidays",
	author = "Jacob",
	version = "1.0",
	url = "https://github.com/jacob404/myplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	BfWriteByte(hBuffer, author);
	BfWriteByte(hBuffer, 1);
	BfWriteString(hBuffer, szMessage);
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	RegConsoleCmd("sm_jingle", PlayMusic_Cmd, "Starts a christmas jingle.", 0);
	RegConsoleCmd("sm_unjingle", StopMusic_Cmd, "Stops music clientside.", 0);
	RegConsoleCmd("sm_nosnow", KillSnow_Cmd, "Calls a vote to disable snow.", 0);
	HookEvent("round_start", Event_RoundStart, EventHookMode:2);
	return 0;
}

public OnMapStart()
{
	PrecacheSound("music/flu/jukebox/all_i_want_for_xmas.wav", false);
	CreateTimer(0.5, MakeSnow, any:0, 0);
	return 0;
}

public Action:MakeSnow(Handle:timer)
{
	new iSnow = -1;
	while ((iSnow = FindEntityByClassname(iSnow, "func_precipitation")) != -1)
	{
		AcceptEntityInput(iSnow, "Kill", -1, -1, 0);
	}
	iSnow = -1;
	iSnow = CreateEntityByName("func_precipitation", -1);
	if (iSnow != -1)
	{
		decl String:sMap[64];
		decl Float:vMins[3];
		decl Float:vMax[3];
		decl Float:vBuff[3];
		GetCurrentMap(sMap, 64);
		Format(sMap, 64, "maps/%s.bsp", sMap);
		PrecacheModel(sMap, true);
		DispatchKeyValue(iSnow, "model", sMap);
		DispatchKeyValue(iSnow, "preciptype", "3");
		GetEntPropVector(0, PropType:1, "m_WorldMaxs", vMax, 0);
		GetEntPropVector(0, PropType:1, "m_WorldMins", vMins, 0);
		SetEntPropVector(iSnow, PropType:0, "m_vecMins", vMins, 0);
		SetEntPropVector(iSnow, PropType:0, "m_vecMaxs", vMax, 0);
		vBuff[0] = vMins[0] + vMax[0];
		vBuff[1] = vMins[1] + vMax[1];
		vBuff[2] = vMins[2] + vMax[2];
		TeleportEntity(iSnow, vBuff, NULL_VECTOR, NULL_VECTOR);
		DispatchSpawn(iSnow);
		ActivateEntity(iSnow);
	}
	return Action:0;
}

public OnRoundIsLive()
{
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i))
		{
			StopSound(i, 0, "music/flu/jukebox/all_i_want_for_xmas.wav");
		}
		i++;
	}
	AllowJingle = false;
	return 0;
}

public Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	AllowJingle = true;
	CreateTimer(0.7, MakeSnow, any:0, 0);
	SurvivorSnow = false;
	InfectedSnow = false;
	return 0;
}

public Action:MusicTimer(Handle:timer)
{
	JingleCooldown = false;
	return Action:0;
}

public Action:PlayMusic_Cmd(client, args)
{
	new var1;
	if (AllowJingle && !JingleCooldown)
	{
		EmitSoundToAll("music/flu/jukebox/all_i_want_for_xmas.wav", -2, 0, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
		PrintToChatAll("Happy Holidays. Music will stop when round goes live. You can use !unjingle to stop it locally any time.");
		CreateTimer(212.0, MusicTimer, any:0, 0);
		JingleCooldown = true;
	}
	return Action:0;
}

public Action:StopMusic_Cmd(client, args)
{
	StopSound(client, 0, "music/flu/jukebox/all_i_want_for_xmas.wav");
	return Action:0;
}

public Action:KillSnow_Cmd(client, args)
{
	new Team = GetClientTeam(client);
	new var1;
	if (Team == 2 && SurvivorSnow)
	{
		SurvivorSnow = true;
		if (InfectedSnow)
		{
		}
		else
		{
			CPrintToChatAll("Survivors have voted to disable snow. Infected must use !nosnow to confirm.");
		}
	}
	else
	{
		new var2;
		if (Team == 3 && InfectedSnow)
		{
			InfectedSnow = true;
			if (SurvivorSnow)
			{
			}
			else
			{
				CPrintToChatAll("Infected have voted to disable snow. Survivors must use !nosnow to confirm.");
			}
		}
		if (Team == 1)
		{
			PrintToChat(client, "Spectators do not have a say in holiday affairs!");
		}
	}
	new var3;
	if (SurvivorSnow == true && InfectedSnow == true)
	{
		new iSnow = -1;
		while ((iSnow = FindEntityByClassname(iSnow, "func_precipitation")) != -1)
		{
			AcceptEntityInput(iSnow, "Kill", -1, -1, 0);
		}
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "12/10/2015",
	time = "12:51:16"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new Handle:remove_motel_clip;
new Handle:remove_swan_clip;
new Handle:remove_plantation_clip;
new Handle:remove_waterfront_clip;
new Handle:remove_sugarmill_clip;
public Plugin:myinfo =
{
	name = "Clip Removal",
	description = "Allows for removal of some pesky clips.",
	author = "Jacob",
	version = "1.5",
	url = "github.com/jacob404/myplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public OnPluginStart()
{
	remove_motel_clip = CreateConVar("remove_motel_clip", "1", "Should we remove the clip above the motel on c2m1?", 262144, true, 0.0, true, 1.0);
	remove_swan_clip = CreateConVar("remove_swan_clip", "1", "Should we remove the clip above the swan room shelf on c2m3?", 262144, true, 0.0, true, 1.0);
	remove_plantation_clip = CreateConVar("remove_plantation_clip", "1", "Should we remove the clip inside the plantation on c3m4?", 262144, true, 0.0, true, 1.0);
	remove_waterfront_clip = CreateConVar("remove_waterfront_clip", "1", "Should we remove the clip around start saferoom and above end saferoom on c5m1?", 262144, true, 0.0, true, 1.0);
	remove_sugarmill_clip = CreateConVar("remove_sugarmill_clip", "1", "Should we remove the clip over the sugarmill building on c4m2 and c4m3?", 262144, true, 0.0, true, 1.0);
	RegAdminCmd("sm_disableallclips", DisableAllClips_Cmd, 8, "Removes all clips from the map. Possibly used for testing purposes.", "", 0);
	RegAdminCmd("sm_enableallclips", EnableAllClips_Cmd, 8, "Enables all clips on the map. Possibly used for testing purposes.", "", 0);
	return 0;
}

public OnMapStart()
{
	decl String:mapname[64];
	GetCurrentMap(mapname, 64);
	new var1;
	if (StrEqual(mapname, "c2m1_highway", true) && GetConVarBool(remove_motel_clip))
	{
		DisableClips();
	}
	else
	{
		new var2;
		if (StrEqual(mapname, "c2m3_coaster", true) && GetConVarBool(remove_swan_clip))
		{
			DisableClips();
		}
		new var3;
		if (StrEqual(mapname, "c3m4_plantation", true) && GetConVarBool(remove_plantation_clip))
		{
			DisableClips();
		}
		new var4;
		if ((StrEqual(mapname, "c4m2_sugarmill_a", true) || StrEqual(mapname, "c4m3_sugarmill_b", true)) && GetConVarBool(remove_sugarmill_clip))
		{
			DisableClips();
		}
		new var6;
		if (StrEqual(mapname, "c5m1_waterfront", true) && GetConVarBool(remove_waterfront_clip))
		{
			DisableClips();
			DisableFuncBrush();
		}
	}
	return 0;
}

public DisableClips()
{
	ModifyEntity("env_player_blocker", "Disable");
	return 0;
}

public DisableFuncBrush()
{
	ModifyEntity("func_brush", "Kill");
	return 0;
}

public Action:DisableAllClips_Cmd(client, args)
{
	ModifyEntity("env_player_blocker", "Disable");
	ModifyEntity("env_physics_blocker", "Disable");
	PrintToChatAll("All clips have been disabled.");
	return Action:0;
}

public Action:EnableAllClips_Cmd(client, args)
{
	ModifyEntity("env_player_blocker", "Enable");
	ModifyEntity("env_physics_blocker", "Enable");
	PrintToChatAll("All clips have been enabled.");
	return Action:0;
}

ModifyEntity(String:className[], String:inputName[])
{
	new iEntity;
	while ((iEntity = FindEntityByClassname(iEntity, className)) != -1)
	{
		new var1;
		if (!(!IsValidEdict(iEntity) || !IsValidEntity(iEntity)))
		{
			AcceptEntityInput(iEntity, inputName, -1, -1, 0);
		}
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "09/21/2013",
	time = "13:33:49"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new Handle:hGameConfig;
new bool:bIsWindows;
new Handle:hPatchNames;
new Handle:hPatchAddresses;
new Handle:hPatchBytes;
new Handle:hPatchAppliedForward;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

ByteCountToCells(size)
{
	if (!size)
	{
		return 1;
	}
	return size + 3 / 4;
}

GetPackedByte(cell, i)
{
	return cell >>> 3 - i * 8 & 255;
}

SetPackedByte(cell, i, byte)
{
	new mask = 255 << 3 - i * 8;
	return byte << 3 - i * 8 | ~mask & cell;
}

GetBytes(Handle:array, String:bytes[], idx)
{
	new cell = GetArrayCell(array, idx, 0, false);
	new count = GetPackedByte(cell, 0);
	new j;
	new i = 1;
	while (i <= count)
	{
		if (!(i % 4))
		{
			cell = GetArrayCell(array, idx, i / 4, false);
		}
		j++;
		bytes[j] = GetPackedByte(cell, i % 4);
		i++;
	}
	return count;
}

PushBytes(Handle:array, String:bytes[], count)
{
	new nCells = ByteCountToCells(count + 1);
	new cells[nCells];
	cells[0] = SetPackedByte(cells[0], 0, count);
	new j;
	new i = 1;
	while (i <= count)
	{
		if (!(i % 4))
		{
			j++;
		}
		cells[j] = SetPackedByte(cells[j], i % 4, bytes[i + -1]);
		i++;
	}
	PushArrayArray(array, cells, nCells);
	return 0;
}

FormatBytes(String:bytes[], nBytes, String:output[])
{
	new j;
	new i;
	while (i < nBytes)
	{
		new hinibble = bytes[i] >>> 4 & 15;
		new lonibble = bytes[i] & 15;
		if (hinibble > 9)
		{
			j++;
			output[j] = hinibble + 87;
		}
		else
		{
			j++;
			output[j] = hinibble + 48;
		}
		if (lonibble > 9)
		{
			j++;
			output[j] = lonibble + 87;
		}
		else
		{
			j++;
			output[j] = lonibble + 48;
		}
		j++;
		output[j] = MissingTAG:32;
		i++;
	}
	j++;
	output[j] = MissingTAG:0;
	return 0;
}

bool:ParseBytes(String:value[], String:bytes[], count)
{
	new length = strlen(value);
	if (count * 4 != length)
	{
		return false;
	}
	decl String:hex[4];
	new j;
	new i;
	while (i < length)
	{
		if (value[i] != '\')
		{
			return false;
		}
		if (value[i + 1] != 'x')
		{
			return false;
		}
		hex[0] = value[i + 2];
		hex[0] = value[i + 3];
		hex[0] = MissingTAG:0;
		j++;
		bytes[j] = StringToInt(hex, 16);
		i += 4;
	}
	return true;
}

WriteBytesToMemory(Address:addr, String:bytes[], count)
{
	new i;
	while (i < count)
	{
		StoreToAddress(i + addr, bytes[i] & 255, NumberType:0);
		i++;
	}
	return 0;
}

ReadBytesFromMemory(Address:addr, String:bytes[], count)
{
	new i;
	while (i < count)
	{
		bytes[i] = LoadFromAddress(i + addr, NumberType:0);
		i++;
	}
	return 0;
}

FindPatch(String:name[])
{
	decl String:iterName[64];
	new size = GetArraySize(hPatchNames);
	new i;
	while (i < size)
	{
		GetArrayString(hPatchNames, i, iterName, 63);
		if (StrEqual(name, iterName, true))
		{
			return i;
		}
		i++;
	}
	return -1;
}

ApplyPatch(String:name[], Address:addr, String:bytes[], length)
{
	decl oldBytes[length];
	ReadBytesFromMemory(addr, oldBytes, length);
	WriteBytesToMemory(addr, bytes, length);
	PushArrayString(hPatchNames, name);
	PushArrayCell(hPatchAddresses, addr);
	PushBytes(hPatchBytes, oldBytes, length);
	new Action:result;
	Call_StartForward(hPatchAppliedForward);
	Call_PushString(name);
	Call_Finish(result);
	return 0;
}

bool:RevertPatch(String:name[])
{
	new patchId = FindPatch(name);
	if (patchId == -1)
	{
		return false;
	}
	decl String:bytes[256];
	new count = GetBytes(hPatchBytes, bytes, patchId);
	new Address:addr = GetArrayCell(hPatchAddresses, patchId, 0, false);
	WriteBytesToMemory(addr, bytes, count);
	RemoveFromArray(hPatchNames, patchId);
	RemoveFromArray(hPatchAddresses, patchId);
	RemoveFromArray(hPatchBytes, patchId);
	return true;
}

public OnPluginStart()
{
	hPatchAppliedForward = CreateGlobalForward("OnPatchApplied", ExecType:2, 7);
	hGameConfig = LoadGameConfigFile("code_patcher");
	if (!hGameConfig)
	{
		SetFailState("Could not load gamedata");
	}
	bIsWindows = GameConfGetOffset(hGameConfig, "Platform") != 0;
	hPatchNames = CreateArray(ByteCountToCells(64), 0);
	hPatchAddresses = CreateArray(1, 0);
	hPatchBytes = CreateArray(ByteCountToCells(256), 0);
	RegServerCmd("codepatch_list", CodePatchListCommand, "", 0);
	RegServerCmd("codepatch_patch", CodePatchPatchCommand, "", 0);
	RegServerCmd("codepatch_unpatch", CodePatchUnpatchCommand, "", 0);
	return 0;
}

public OnPluginEnd()
{
	new size = GetArraySize(hPatchNames);
	decl String:name[64];
	new i;
	while (i < size)
	{
		GetArrayString(hPatchNames, i, name, 64);
		RevertPatch(name);
		i++;
	}
	return 0;
}

public Action:CodePatchListCommand(args)
{
	decl String:name[64];
	decl String:bytes[256];
	decl String:formattedBytes[768];
	new size = GetArraySize(hPatchNames);
	if (size)
	{
		new i;
		while (i < size)
		{
			new nBytes = GetBytes(hPatchBytes, bytes, i);
			FormatBytes(bytes, nBytes, formattedBytes);
			GetArrayString(hPatchNames, i, name, 64);
			new Address:addr = GetArrayCell(hPatchAddresses, i, 0, false);
			PrintToServer("%d. %s\x090x%x: %s", i + 1, name, addr, formattedBytes);
			i++;
		}
		return Action:0;
	}
	PrintToServer("No patches applied");
	return Action:0;
}

public Action:CodePatchPatchCommand(args)
{
	if (GetCmdArgs() != 1)
	{
		PrintToServer("syntax: codepatch_patch <patch_name>");
		return Action:0;
	}
	decl String:name[64];
	GetCmdArg(1, name, 64);
	new patchId = FindPatch(name);
	if (patchId != -1)
	{
		PrintToServer("Patch '%s' is already loaded", name);
		return Action:0;
	}
	decl String:key[96];
	decl String:value[1024];
	Format(key, 95, "%s_signature", name);
	if (!GameConfGetKeyValue(hGameConfig, key, value, 1021))
	{
		PrintToServer("Could not find key '%s'", key);
		return Action:0;
	}
	new Address:addr = GameConfGetAddress(hGameConfig, value);
	if (!addr)
	{
		PrintToServer("Could not load signature '%s'", value);
		return Action:0;
	}
	Format(key, 95, "%s_offset", name);
	if (!GameConfGetKeyValue(hGameConfig, key, value, 1021))
	{
		PrintToServer("Could not find key '%s'", key);
		return Action:0;
	}
	new offset = GameConfGetOffset(hGameConfig, value);
	if (offset == -1)
	{
		PrintToServer("Could not load offset '%s'", value);
		return Action:0;
	}
	new var1;
	if (bIsWindows)
	{
		var1[0] = 588;
	}
	else
	{
		var1[0] = 596;
	}
	Format(key, 95, "%s_length_%s", name, var1);
	if (!GameConfGetKeyValue(hGameConfig, key, value, 1021))
	{
		PrintToServer("Could not find key '%s'", key);
		return Action:0;
	}
	new length = StringToInt(value, 10);
	new var2;
	if (length < 1 || length > 255)
	{
		new var3;
		if (length < 1)
		{
			var3[0] = 656;
		}
		else
		{
			var3[0] = 660;
		}
		PrintToServer("Too %s patch bytes for '%s'", var3, name);
		return Action:0;
	}
	new var4;
	if (bIsWindows)
	{
		var4[0] = 680;
	}
	else
	{
		var4[0] = 688;
	}
	Format(key, 95, "%s_bytes_%s", name, var4);
	if (!GameConfGetKeyValue(hGameConfig, key, value, 1021))
	{
		PrintToServer("Could not find key '%s'", key);
		return Action:0;
	}
	decl bytes[length];
	if (!ParseBytes(value, bytes, length))
	{
		PrintToServer("Failed to parse patch bytes for '%s'", name);
		return Action:0;
	}
	addr = offset + addr;
	ApplyPatch(name, addr, bytes, length);
	decl String:formattedBytes[768];
	FormatBytes(bytes, length, formattedBytes);
	PrintToServer("Applied patch '%s' [ %s] at 0x%x", name, formattedBytes, addr);
	return Action:0;
}

public Action:CodePatchUnpatchCommand(args)
{
	if (GetCmdArgs() != 1)
	{
		PrintToServer("syntax: codepatch_unpatch <patch_name>");
		return Action:0;
	}
	decl String:name[64];
	GetCmdArg(1, name, 64);
	new patchId = FindPatch(name);
	if (patchId == -1)
	{
		PrintToServer("Patch '%s' is not loaded", name);
		return Action:0;
	}
	RevertPatch(name);
	PrintToServer("Reverted patch '%s'", name);
	return Action:0;
}

public IsPatchApplied(Handle:plugin, nArgs)
{
	new length;
	GetNativeStringLength(1, length);
	if (0 >= length)
	{
		return 0;
	}
	decl name[length + 1];
	GetNativeString(1, name, length + 1, 0);
	new patchId = FindPatch(name);
	return patchId != -1;
}

public GetPatchAddress(Handle:plugin, nArgs)
{
	new length;
	GetNativeStringLength(1, length);
	if (0 >= length)
	{
		return 0;
	}
	decl name[length + 1];
	GetNativeString(1, name, length + 1, 0);
	new patchId = FindPatch(name);
	if (patchId == -1)
	{
		return 0;
	}
	return GetArrayCell(hPatchAddresses, patchId, 0, false);
}

public IsPlatformWindows(Handle:plugin, nArgs)
{
	return bIsWindows;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	CreateNative("IsPatchApplied", IsPatchApplied);
	CreateNative("GetPatchAddress", GetPatchAddress);
	CreateNative("IsPlatformWindows", IsPlatformWindows);
	RegPluginLibrary("code_patcher");
	return APLRes:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "03/24/2014",
	time = "02:29:16"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new result_int;
new String:client_name[32];
new previous_timeC;
new current_timeC;
new previous_timeN;
new current_timeN;
new Handle:delay_time;
new number_max = 20;
public Plugin:myinfo =
{
	name = "Coinflip",
	description = "purpletreefactory's version of coinflip",
	author = "purpletreefactory, epilimic",
	version = "1.0.2",
	url = "http://www.sourcemod.net/"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public OnPluginStart()
{
	delay_time = CreateConVar("coinflip_delay", "-1", "Time delay in seconds between allowed coinflips. Set at -1 if no delay at all is desired.", 0, false, 0.0, false, 0.0);
	RegConsoleCmd("sm_coinflip", Command_Coinflip, "", 0);
	RegConsoleCmd("sm_cf", Command_Coinflip, "", 0);
	RegConsoleCmd("sm_flip", Command_Coinflip, "", 0);
	RegConsoleCmd("sm_roll", Command_Picknumber, "", 0);
	RegConsoleCmd("sm_picknumber", Command_Picknumber, "", 0);
	return 0;
}

public Action:Command_Coinflip(client, args)
{
	current_timeC = GetTime({0,0});
	if (GetConVarInt(delay_time) < current_timeC - previous_timeC)
	{
		result_int = GetURandomInt() % 2;
		GetClientName(client, client_name, 32);
		if (result_int)
		{
			PrintToChatAll("\x01[\x05Coinflip\x01] \x03%s\x01 flipped a coin!\nIt's \x04Tails\x01!", client_name);
		}
		else
		{
			PrintToChatAll("\x01[\x05Coinflip\x01] \x03%s\x01 flipped a coin!\nIt's \x04Heads\x01!", client_name);
		}
		previous_timeC = current_timeC;
	}
	else
	{
		PrintToConsole(client, "[Coinflip] Whoa there buddy, slow down. Wait at least %d seconds.", GetConVarInt(delay_time));
	}
	return Action:3;
}

public Action:Command_Picknumber(client, args)
{
	current_timeN = GetTime({0,0});
	if (GetConVarInt(delay_time) < current_timeN - previous_timeN)
	{
		GetClientName(client, client_name, 32);
		if (GetCmdArgs())
		{
			new String:arg[32];
			new max;
			GetCmdArg(1, arg, 32);
			max = StringToInt(arg, 10);
			result_int = GetURandomInt() % max;
			PrintToChatAll("\x01[\x05Coinflip\x01] \x03%s\x01 rolled a \x03%d \x01sided die!\nIt's \x04%d\x01!", client_name, max, result_int + 1);
		}
		else
		{
			result_int = GetURandomInt() % number_max;
			PrintToChatAll("\x01[\x05Coinflip\x01] \x03%s\x01 rolled a \x03%d \x01sided die!\nIt's \x04%d\x01!", client_name, number_max, result_int + 1);
		}
		previous_timeN = current_timeN;
	}
	else
	{
		PrintToConsole(client, "[Coinflip] Whoa there buddy, slow down. Wait at least %d seconds.", GetConVarInt(delay_time));
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "08/17/2014",
	time = "17:00:43"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new String:MeleeWeaponModels[15][];
new String:MeleeWeaponNames[15][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	0, 0, 0, 0, 843330636, 1920291616, 1870031222, 1917853810, 1701996399, 29555, 1634623811, 1867669860, 1444949112, 1919906665, 0, 1852404304, 1970479220, 1986623090, 1881174639, 1919381362, 544437093, 1713401449, 544698220, 1668441456, 1937010277, 32, 774909490, 49, 1886680168, 791624307, 1752459623, 1663984245, 1093627247, 1851880564, 1917857647, 1685015919, 0, 1356, 1400, 1380, 1444, 1452, 1936876918, 1650422645, 1601401711, 1717990754, 29285, 1600402540, 1651469415, 1885301857, 1701016165, 29806, 49, 1886611780, 544825708, 1936944994
};
new Handle:hCvarPrintToEveryone;
new Handle:hMeleeWeaponModelsTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hSurvivorModelsTrie;
new Handle:hWeaponNamesTrie;
new Handle:survivor_limit;
new Handle:z_max_player_zombies;
new Handle:g_hVsBossBuffer;
public Plugin:myinfo =
{
	name = "L4D2 Survivor Progress",
	description = "Print survivor progress in flow percents ",
	author = "CanadaRox, Visor",
	version = "2.0.1",
	url = "https://github.com/Attano/ProMod"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return oper1 + float(oper2);
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetTerrorNavMesh()
{
	static Address:TheNavMesh;
	if (!TheNavMesh)
	{
		TheNavMesh = GameConfGetAddress(L4D2Direct_GetGameConf(), "TerrorNavMesh");
	}
	return TheNavMesh;
}

Address:L4D2Direct_GetMapMaxFlowDistanceAddr()
{
	static Address:pMapMaxFlowDistance;
	if (!pMapMaxFlowDistance)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "TerrorNavMesh::m_fMapMaxFlowDistance");
		if (offs == -1)
		{
			return Address:0;
		}
		pMapMaxFlowDistance = L4D2Direct_GetTerrorNavMesh() + offs;
	}
	return pMapMaxFlowDistance;
}

Float:L4D2Direct_GetMapMaxFlowDistance()
{
	return LoadFromAddress(L4D2Direct_GetMapMaxFlowDistanceAddr(), NumberType:2);
}

Address:L4D2Direct_GetTerrorNavArea(Float:pos[3], Float:beneathLimit)
{
	static Handle:GetNavAreaSDKCall;
	if (!GetNavAreaSDKCall)
	{
		StartPrepSDKCall(SDKCallType:5);
		if (!PrepSDKCall_SetFromConf(L4D2Direct_GetGameConf(), SDKFuncConfSource:1, "CNavMesh::GetNavArea"))
		{
			return Address:0;
		}
		PrepSDKCall_AddParameter(SDKType:2, SDKPassMethod:3, 0, 0);
		PrepSDKCall_AddParameter(SDKType:5, SDKPassMethod:1, 0, 0);
		PrepSDKCall_SetReturnInfo(SDKType:4, SDKPassMethod:1, 0, 0);
		GetNavAreaSDKCall = EndPrepSDKCall();
		if (!GetNavAreaSDKCall)
		{
			return Address:0;
		}
	}
	return SDKCall(GetNavAreaSDKCall, L4D2Direct_GetTerrorNavMesh(), pos, beneathLimit);
}

Float:L4D2Direct_GetTerrorNavAreaFlow(Address:pTerrorNavArea)
{
	if (pTerrorNavArea)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "TerrorNavArea::m_flow");
		if (offs == -1)
		{
			return 0.0;
		}
		return LoadFromAddress(offs + pTerrorNavArea, NumberType:2);
	}
	return 0.0;
}

public OnPluginStart()
{
	g_hVsBossBuffer = FindConVar("versus_boss_buffer");
	L4D2_InfectedNames[0] = CreateConVar("l4d_global_percent", "1", "Display boss percentages to entire team when using commands", 262144, false, 0.0, false, 0.0);
	RegConsoleCmd("sm_cur", CurrentCmd, "", 0);
	RegConsoleCmd("sm_current", CurrentCmd, "", 0);
	survivor_limit = FindConVar("survivor_limit");
	z_max_player_zombies = FindConVar("z_max_player_zombies");
	return 0;
}

public Action:CurrentCmd(client, args)
{
	new L4D2_Team:team = GetClientTeam(client);
	if (team == L4D2_Team:1)
	{
		PrintCurrentToClient(client);
	}
	else
	{
		if (GetConVarBool(L4D2_InfectedNames[0]))
		{
			PrintCurrentToTeam(team);
		}
		PrintCurrentToClient(client);
	}
	return Action:0;
}

PrintCurrentToClient(client)
{
	new boss_proximity = RoundToNearest(GetBossProximity() * 100.0);
	PrintToChat(client, "\x01Current: \x04%d%%", boss_proximity);
	return 0;
}

PrintCurrentToTeam(L4D2_Team:team)
{
	new members_found;
	new team_max = GetTeamMaxHumans(team);
	new boss_proximity = RoundToNearest(GetBossProximity() * 100.0);
	new client = 1;
	while (client <= MaxClients && members_found < team_max)
	{
		new var2;
		if (IsClientInGame(client) && !IsFakeClient(client) && team == GetClientTeam(client))
		{
			members_found++;
			PrintToChat(client, "\x01Current: \x04%d%%", boss_proximity);
		}
		client++;
	}
	return 0;
}

Float:GetBossProximity()
{
	new Float:proximity = GetMaxSurvivorCompletion() + GetConVarFloat(g_hVsBossBuffer) / L4D2Direct_GetMapMaxFlowDistance();
	new var1;
	if (proximity > 1.0)
	{
		var1 = 1.0;
	}
	else
	{
		var1 = proximity;
	}
	return var1;
}

Float:GetMaxSurvivorCompletion()
{
	new Float:flow = 0.0;
	decl Float:tmp_flow;
	decl Float:origin[3];
	decl Address:pNavArea;
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && GetClientTeam(client) == 2)
		{
			GetClientAbsOrigin(client, origin);
			pNavArea = L4D2Direct_GetTerrorNavArea(origin, 120.0);
			if (pNavArea)
			{
				tmp_flow = L4D2Direct_GetTerrorNavAreaFlow(pNavArea);
				new var2;
				if (flow > tmp_flow)
				{
					var2 = flow;
				}
				else
				{
					var2 = tmp_flow;
				}
				flow = var2;
			}
		}
		client++;
	}
	return flow / L4D2Direct_GetMapMaxFlowDistance();
}

GetTeamMaxHumans(L4D2_Team:team)
{
	if (team == L4D2_Team:2)
	{
		return GetConVarInt(survivor_limit);
	}
	if (team == L4D2_Team:3)
	{
		return GetConVarInt(z_max_player_zombies);
	}
	return MaxClients;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2",
	date = "10/23/2014",
	time = "11:54:56"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new Handle:si_restore_ratio;
public Plugin:myinfo =
{
	name = "Despawn Health",
	description = "Gives Special Infected health back when they despawn.",
	author = "Jacob",
	version = "1.1",
	url = "github.com/jacob404/myplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

SetEntityHealth(entity, amount)
{
	static bool:gotconfig;
	static String:prop[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_iHealth", prop, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(prop, 32, "m_iHealth");
		}
		gotconfig = true;
	}
	decl String:cls[64];
	new PropFieldType:type;
	new offset;
	if (!GetEntityNetClass(entity, cls, 64))
	{
		ThrowError("SetEntityHealth not supported by this mod: Could not get serverclass name");
		return 0;
	}
	offset = FindSendPropInfo(cls, prop, type, 0, 0);
	if (0 >= offset)
	{
		ThrowError("SetEntityHealth not supported by this mod");
		return 0;
	}
	if (type == PropFieldType:2)
	{
		SetEntDataFloat(entity, offset, float(amount), false);
	}
	else
	{
		SetEntProp(entity, PropType:0, prop, amount, 4, 0);
	}
	return 0;
}

public OnPluginStart()
{
	si_restore_ratio = CreateConVar("si_restore_ratio", "0.5", "How much of the clients missing HP should be restored? 1.0 = Full HP", 262144, true, 0.0, true, 1.0);
	return 0;
}

public L4D_OnEnterGhostState(client)
{
	new CurrentHealth = GetClientHealth(client);
	new MaxHealth = GetEntProp(client, PropType:0, "m_iMaxHealth", 4, 0);
	new MissingHealth = MaxHealth - CurrentHealth;
	new NewHP = RoundFloat(GetConVarFloat(si_restore_ratio) * MissingHealth) + CurrentHealth;
	SetEntityHealth(client, NewHP);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "12/10/2015",
	time = "12:51:17"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public SharedPlugin:__pl_l4d2_scoremod =
{
	name = "l4d2_scoremod",
	file = "l4d2_scoremod.smx",
	required = 0,
};
public SharedPlugin:__pl_scoremod2 =
{
	name = "scoremod2",
	file = "scoremod2.smx",
	required = 0,
};
new damageToTank[33];
new Handle:printTankName;
new Handle:printTankDamage;
new Handle:printPlayerHB;
new bool:tankInPlay;
new tankHealth;
new lastTankHealth;
new preTankHB;
new incapOffset;
new scoremode;
public Plugin:myinfo =
{
	name = "Damage During Tank",
	description = "Announce damage dealt during tanks",
	author = "darkid",
	version = "1.4",
	url = "https://github.com/jacob404/Pro-Mod-4.0/releases/latest"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator/(Float:,_:)(Float:oper1, oper2)
{
	return oper1 / float(oper2);
}

public __pl_l4d2_scoremod_SetNTVOptional()
{
	MarkNativeAsOptional("HealthBonus");
	return 0;
}

public __pl_scoremod2_SetNTVOptional()
{
	MarkNativeAsOptional("DamageBonus");
	return 0;
}

public OnPluginStart()
{
	HookEvent("round_start", round_start, EventHookMode:1);
	HookEvent("tank_spawn", tank_spawn, EventHookMode:1);
	HookEvent("player_hurt", player_hurt, EventHookMode:1);
	HookEvent("player_death", tank_death, EventHookMode:1);
	HookEvent("round_end", round_end, EventHookMode:1);
	printTankDamage = CreateConVar("tankdamage_print", "1", "Announce damage done to tank when it dies, or on round end. If set to 2, will also print to the infected.", 0, false, 0.0, false, 0.0);
	printTankName = CreateConVar("tankdamage_print_name", "1", "Print the name of the tank when it dies.", 0, false, 0.0, false, 0.0);
	printPlayerHB = CreateConVar("tankdamage_print_survivor_hb", "1", "Announce damage done to survivor health bonus when the tank dies.", 0, false, 0.0, false, 0.0);
	tankInPlay = false;
	incapOffset = FindSendPropInfo("Tank", "m_isIncapacitated", 0, 0, 0);
	return 0;
}

public OnAllPluginsLoaded()
{
	if (LibraryExists("l4d2_scoremod"))
	{
		scoremode = scoremode | 1;
	}
	if (LibraryExists("scoremod2"))
	{
		scoremode = scoremode | 2;
	}
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (strcmp(name, "l4d2_scoremod", true))
	{
		if (!(strcmp(name, "scoremod2", true)))
		{
			scoremode = scoremode & -3;
		}
	}
	else
	{
		scoremode = scoremode & -2;
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (strcmp(name, "l4d2_scoremod", true))
	{
		if (!(strcmp(name, "scoremod2", true)))
		{
			scoremode = scoremode | 2;
		}
	}
	else
	{
		scoremode = scoremode | 1;
	}
	return 0;
}

public round_start(Handle:event, String:name[], bool:dontBroadcast)
{
	new i;
	while (i < 33)
	{
		damageToTank[i] = 0;
		i++;
	}
	return 0;
}

public tank_spawn(Handle:event, String:name[], bool:dontBroadcast)
{
	tankInPlay = true;
	tankHealth = GetConVarInt(FindConVar("z_tank_health")) * 3 / 2;
	lastTankHealth = tankHealth;
	if (scoremode & 1 == 1)
	{
		preTankHB = HealthBonus();
	}
	else
	{
		if (scoremode & 2 == 2)
		{
			preTankHB = DamageBonus();
		}
	}
	return 0;
}

public player_hurt(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!tankInPlay)
	{
		return 0;
	}
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var1;
	if (attacker <= 0 || attacker > MaxClients)
	{
		return 0;
	}
	if (!IsClientInGame(attacker))
	{
		return 0;
	}
	new var2;
	if (GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0) == 8 && !GetEntData(victim, incapOffset, 4))
	{
		if (attacker == victim)
		{
			new var3 = damageToTank[32];
			var3 = GetEventInt(event, "dmg_health") + var3;
		}
		else
		{
			new var4 = damageToTank[attacker];
			var4 = var4[GetEventInt(event, "dmg_health")];
		}
		lastTankHealth = GetEventInt(event, "health");
	}
	return 0;
}

public tank_death(Handle:event, String:name[], bool:dontBroadcast)
{
	new tank = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (tank <= 0 || tank > MaxClients)
	{
		return 0;
	}
	if (!IsClientInGame(tank))
	{
		return 0;
	}
	if (GetEntProp(tank, PropType:0, "m_zombieClass", 4, 0) != 8)
	{
		return 0;
	}
	TryPrintTankDamage(tank);
	return 0;
}

public round_end(Handle:event, String:name[], bool:dontBroadcast)
{
	decl tank;
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8)
			{
				tank = client;
				TryPrintTankDamage(tank);
				return 0;
			}
		}
		client++;
	}
	TryPrintTankDamage(tank);
	return 0;
}

public sortTankDamage(e1, e2, array[], Handle:handle)
{
	if (damageToTank[e2] < damageToTank[e1])
	{
		return -1;
	}
	if (damageToTank[e2] == damageToTank[e1])
	{
		return 0;
	}
	return 1;
}

public TryPrintTankDamage(tank)
{
	if (!tankInPlay)
	{
		return 0;
	}
	tankInPlay = false;
	new sortArray[33];
	new i;
	while (i < 33)
	{
		sortArray[i] = i;
		i++;
	}
	SortCustom1D(sortArray, 33, sortTankDamage, Handle:0);
	if (GetConVarBool(printTankDamage))
	{
		PrintDamageDealtToTank(tank, sortArray);
	}
	if (GetConVarBool(printPlayerHB))
	{
		new postTankHB;
		if (scoremode & 1 == 1)
		{
			postTankHB = HealthBonus();
		}
		else
		{
			if (scoremode & 2 == 2)
			{
				postTankHB = DamageBonus();
			}
		}
		PrintHBDamageDealtToSurvivors(postTankHB);
	}
	return 0;
}

PrintDamageDealtToTank(tank, sortArray[])
{
	new bool:isTankDead = lastTankHealth <= 0;
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			new var1;
			if (!(GetConVarInt(printTankDamage) != 2 && GetClientTeam(client) == 3))
			{
				if (isTankDead)
				{
					if (GetConVarBool(printTankName))
					{
						PrintToChat(client, "[SM] Tank (\x03%N\x01) had \x05%d\x01 health remaining", tank, lastTankHealth);
					}
					else
					{
						PrintToChat(client, "[SM] Tank had \x05%d\x01 health remaining", lastTankHealth);
					}
				}
				else
				{
					if (GetConVarBool(printTankName))
					{
						PrintToChat(client, "[SM] Damage dealt to tank (\x03%N\x01):", tank);
					}
					PrintToChat(client, "[SM] Damage dealt to tank:");
				}
				new i;
				while (i < 33)
				{
					new j = sortArray[i];
					if (damageToTank[j])
					{
						PrintToChat(client, "\x05%4d\x01 [\x04%.02f%%\x01]:\x09\x03%N\x01", damageToTank[j], 1120403456 * damageToTank[j] / tankHealth, j);
					}
					i++;
				}
			}
		}
		client++;
	}
	return 0;
}

PrintHBDamageDealtToSurvivors(postTankHB)
{
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			new var1;
			if (!(scoremode && GetClientTeam(client) == 2))
			{
				PrintToChat(client, "[SM] Damage dealt to health bonus:\x09\x05%4d\x01", preTankHB - postTankHB);
			}
		}
		client++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "07/06/2016",
	time = "22:19:10"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:MeleeWeaponModels[15][];
new String:MeleeWeaponNames[15][];
new String:SurvivorModels[8][] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:SurvivorNames[8][] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	32, 64, 100, 136, 172, 208, 244, 280, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1868783474, 778593121, 7103597, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1634164594, 1701601901, 1684876914, 108, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1919967090, 1668637807, 1831760485, 27748, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1701666674, 1851877475, 1831756649, 27748, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1634557810, 1701273966, 1684876914
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new Handle:hSurvivorModelsTrie;
new Handle:hMeleeWeaponModelsTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hWeaponNamesTrie;
public Plugin:myinfo =
{
	name = "L4D2 Get-Up Fix",
	description = "Fixes the problem when, after completing a getup animation, you have another one.",
	author = "Darkid, Jacob",
	version = "3.7",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
new bool:lateLoad;
new Handle:rockPunchFix;
new Handle:longerTankPunchGetup;
new bool:DEBUG;
new pendingGetups[8];
new interrupt[8];
new currentSequence[8];
new PlayerState:playerState[8];
new tankFlyAnim[8] =
{
	628, 628, 636, 633, 536, 545, 536, 539
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

bool:IsSurvivor(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 2)
	{
		return false;
	}
	return true;
}

InitSurvivorModelTrie()
{
	L4D2_InfectedTimerEntities[0] = CreateTrie();
	new i;
	while (i < 8)
	{
		SetTrieValue(L4D2_InfectedTimerEntities[0], L4D2_InfectedNames[i], i, true);
		i++;
	}
	return 0;
}

SurvivorCharacter:IdentifySurvivor(client)
{
	new var1;
	if (!client || !IsClientInGame(client) || !IsSurvivor(client))
	{
		return SurvivorCharacter:-1;
	}
	decl String:clientModel[44];
	GetClientModel(client, clientModel, 42);
	return ClientModelToSC(clientModel);
}

SurvivorCharacter:ClientModelToSC(String:model[])
{
	if (!L4D2_InfectedTimerEntities[0])
	{
		InitSurvivorModelTrie();
	}
	new SurvivorCharacter:sc;
	if (GetTrieValue(L4D2_InfectedTimerEntities[0], model, sc))
	{
		return sc;
	}
	return SurvivorCharacter:-1;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!hMeleeWeaponModelsTrie)
	{
		hMeleeWeaponModelsTrie = LoadGameConfigFile("l4d2_direct");
	}
	return hMeleeWeaponModelsTrie;
}

L4D2Direct_DoAnimationEvent(client, event)
{
	new var1;
	if (client <= 0 || client > MaxClients + 1)
	{
		return 0;
	}
	static Handle:DoAnimationEventSDKCall;
	if (!DoAnimationEventSDKCall)
	{
		StartPrepSDKCall(SDKCallType:2);
		if (!PrepSDKCall_SetFromConf(L4D2Direct_GetGameConf(), SDKFuncConfSource:0, "CTerrorPlayer::DoAnimationEvent"))
		{
			return 0;
		}
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		DoAnimationEventSDKCall = EndPrepSDKCall();
		if (!DoAnimationEventSDKCall)
		{
			return 0;
		}
	}
	SDKCall(DoAnimationEventSDKCall, client, event, 0);
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	lateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	rockPunchFix = CreateConVar("rock_punch_fix", "1", "When a tank punches someone who is getting up from a rock, cause them to have an extra getup.", 262144, false, 0.0, false, 0.0);
	longerTankPunchGetup = CreateConVar("longer_tank_punch_getup", "0", "When a tank punches someone give them a slightly longer getup.", 262144, false, 0.0, false, 0.0);
	HookEvent("round_start", round_start, EventHookMode:1);
	HookEvent("tongue_grab", smoker_land, EventHookMode:1);
	HookEvent("jockey_ride", jockey_land, EventHookMode:1);
	HookEvent("jockey_ride_end", jockey_clear, EventHookMode:1);
	HookEvent("tongue_release", smoker_clear, EventHookMode:1);
	HookEvent("pounce_stopped", hunter_clear, EventHookMode:1);
	HookEvent("charger_impact", multi_charge, EventHookMode:1);
	HookEvent("charger_carry_end", charger_land_instant, EventHookMode:1);
	HookEvent("charger_pummel_start", charger_land, EventHookMode:1);
	HookEvent("charger_pummel_end", charger_clear, EventHookMode:1);
	HookEvent("player_incapacitated", player_incap, EventHookMode:1);
	HookEvent("revive_success", player_revive, EventHookMode:1);
	InitSurvivorModelTrie();
	if (lateLoad)
	{
		new client = 1;
		while (client <= MaxClients)
		{
			if (IsClientInGame(client))
			{
				OnClientPostAdminCheck(client);
			}
			client++;
		}
	}
	return 0;
}

public OnClientPostAdminCheck(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public bool:isGettingUp(any:survivor)
{
	switch (playerState[survivor])
	{
		case 4:
		{
			return true;
		}
		case 7:
		{
			return true;
		}
		case 8:
		{
			return true;
		}
		case 9:
		{
			return true;
		}
		case 11:
		{
			return true;
		}
		default:
		{
			return false;
		}
	}
}

public round_start(Handle:event, String:name[], bool:dontBroadcast)
{
	new survivor;
	while (survivor < 8)
	{
		playerState[survivor] = 0;
		survivor++;
	}
	return 0;
}

public smoker_land(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new SurvivorCharacter:survivor = IdentifySurvivor(client);
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	if (playerState[survivor] == PlayerState:4)
	{
		interrupt[survivor] = 1;
	}
	return 0;
}

public jockey_land(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new SurvivorCharacter:survivor = IdentifySurvivor(client);
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	playerState[survivor] = 3;
	return 0;
}

public jockey_clear(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new SurvivorCharacter:survivor = IdentifySurvivor(client);
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	if (playerState[survivor] == PlayerState:3)
	{
		playerState[survivor] = 0;
	}
	return 0;
}

public smoker_clear(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new SurvivorCharacter:survivor = IdentifySurvivor(client);
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	if (playerState[survivor] == PlayerState:1)
	{
		return 0;
	}
	playerState[survivor] = 0;
	_CancelGetup(client);
	return 0;
}

public hunter_clear(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new SurvivorCharacter:survivor = IdentifySurvivor(client);
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	if (playerState[survivor] == PlayerState:1)
	{
		return 0;
	}
	if (isGettingUp(survivor))
	{
		pendingGetups[survivor]++;
		return 0;
	}
	playerState[survivor] = 4;
	_GetupTimer(client);
	return 0;
}

public multi_charge(Handle:event, String:name[], bool:dontBroadcast)
{
	new SurvivorCharacter:survivor = IdentifySurvivor(GetClientOfUserId(GetEventInt(event, "victim")));
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	if (playerState[survivor] == PlayerState:1)
	{
		return 0;
	}
	playerState[survivor] = 8;
	return 0;
}

public charger_land_instant(Handle:event, String:name[], bool:dontBroadcast)
{
	new SurvivorCharacter:survivor = IdentifySurvivor(GetClientOfUserId(GetEventInt(event, "victim")));
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	if (playerState[survivor] == PlayerState:1)
	{
		pendingGetups[survivor]++;
	}
	playerState[survivor] = 5;
	return 0;
}

public charger_land(Handle:event, String:name[], bool:dontBroadcast)
{
	new SurvivorCharacter:survivor = IdentifySurvivor(GetClientOfUserId(GetEventInt(event, "victim")));
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	if (playerState[survivor] == PlayerState:1)
	{
		return 0;
	}
	playerState[survivor] = 6;
	return 0;
}

public charger_clear(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new SurvivorCharacter:survivor = IdentifySurvivor(client);
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	if (playerState[survivor] == PlayerState:1)
	{
		return 0;
	}
	playerState[survivor] = 7;
	_GetupTimer(client);
	return 0;
}

public player_incap(Handle:event, String:name[], bool:dontBroadcast)
{
	new SurvivorCharacter:survivor = IdentifySurvivor(GetClientOfUserId(GetEventInt(event, "userid")));
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	if (playerState[survivor] == PlayerState:5)
	{
		pendingGetups[survivor]++;
	}
	playerState[survivor] = 1;
	return 0;
}

public player_revive(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "subject"));
	new SurvivorCharacter:survivor = IdentifySurvivor(client);
	if (survivor == SurvivorCharacter:-1)
	{
		return 0;
	}
	playerState[survivor] = 0;
	_CancelGetup(client);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	new SurvivorCharacter:survivor = IdentifySurvivor(victim);
	if (survivor == SurvivorCharacter:-1)
	{
		return Action:0;
	}
	decl String:weapon[32];
	GetEdictClassname(inflictor, weapon, 32);
	if (strcmp(weapon, "weapon_tank_claw", true))
	{
		if (!(strcmp(weapon, "tank_rock", true)))
		{
			if (playerState[survivor] == PlayerState:7)
			{
				interrupt[survivor] = 1;
			}
			else
			{
				if (playerState[survivor] == PlayerState:8)
				{
					pendingGetups[survivor]++;
				}
			}
			playerState[survivor] = 9;
			_GetupTimer(victim);
		}
	}
	else
	{
		if (playerState[survivor] == PlayerState:7)
		{
			interrupt[survivor] = 1;
		}
		else
		{
			if (playerState[survivor] == PlayerState:8)
			{
				pendingGetups[survivor]++;
			}
		}
		new var1;
		if (playerState[survivor] == PlayerState:9 && GetConVarBool(rockPunchFix))
		{
			playerState[survivor] = 12;
		}
		else
		{
			if (playerState[survivor] == PlayerState:3)
			{
				playerState[survivor] = 13;
				_TankLandTimer(victim);
			}
			playerState[survivor] = 10;
			_TankLandTimer(victim);
		}
	}
	return Action:0;
}

_TankLandTimer(client)
{
	CreateTimer(0.04, TankLandTimer, client, 3);
	return 0;
}

public Action:TankLandTimer(Handle:timer, any:client)
{
	new SurvivorCharacter:survivor = IdentifySurvivor(client);
	if (survivor == SurvivorCharacter:-1)
	{
		return Action:4;
	}
	new var1;
	if (tankFlyAnim[survivor] != GetEntProp(client, PropType:0, "m_nSequence", 4, 0) && tankFlyAnim[survivor][0] != GetEntProp(client, PropType:0, "m_nSequence", 4, 0))
	{
		return Action:0;
	}
	if (playerState[survivor] == PlayerState:13)
	{
		if (tankFlyAnim[survivor][0] == GetEntProp(client, PropType:0, "m_nSequence", 4, 0))
		{
			return Action:0;
		}
		if (DEBUG)
		{
			PrintToChatAll("[Getup] Giving %N an extra getup...", client);
		}
		if (GetConVarBool(longerTankPunchGetup))
		{
			L4D2Direct_DoAnimationEvent(client, 57);
		}
		L4D2Direct_DoAnimationEvent(client, 96);
	}
	if (playerState[survivor] == PlayerState:10)
	{
		playerState[survivor] = 11;
	}
	if (GetConVarBool(longerTankPunchGetup))
	{
		L4D2Direct_DoAnimationEvent(client, 57);
	}
	else
	{
		L4D2Direct_DoAnimationEvent(client, 96);
	}
	_GetupTimer(client);
	return Action:4;
}

_GetupTimer(client)
{
	CreateTimer(0.04, GetupTimer, client, 3);
	return 0;
}

public Action:GetupTimer(Handle:timer, any:client)
{
	new SurvivorCharacter:survivor = IdentifySurvivor(client);
	if (survivor == SurvivorCharacter:-1)
	{
		return Action:4;
	}
	if (currentSequence[survivor])
	{
		if (interrupt[survivor])
		{
			if (DEBUG)
			{
				PrintToChatAll("[Getup] %N's getup was interrupted!", client);
			}
			interrupt[survivor] = 0;
			return Action:4;
		}
		if (GetEntProp(client, PropType:0, "m_nSequence", 4, 0) == currentSequence[survivor])
		{
			return Action:0;
		}
		if (playerState[survivor] == PlayerState:12)
		{
			if (DEBUG)
			{
				PrintToChatAll("[Getup] Giving %N an extra getup...", client);
			}
			if (GetConVarBool(longerTankPunchGetup))
			{
				L4D2Direct_DoAnimationEvent(client, 57);
				playerState[survivor] = 7;
			}
			else
			{
				L4D2Direct_DoAnimationEvent(client, 96);
				playerState[survivor] = 11;
			}
			currentSequence[survivor] = 0;
			_TankLandTimer(client);
			return Action:4;
		}
		if (DEBUG)
		{
			PrintToChatAll("[Getup] %N finished getting up.", client);
		}
		playerState[survivor] = 0;
		pendingGetups[survivor]--;
		_CancelGetup(client);
		return Action:4;
	}
	if (DEBUG)
	{
		PrintToChatAll("[Getup] %N is getting up...", client);
	}
	currentSequence[survivor] = GetEntProp(client, PropType:0, "m_nSequence", 4, 0);
	pendingGetups[survivor]++;
	return Action:0;
}

_CancelGetup(client)
{
	CreateTimer(0.04, CancelGetup, client, 3);
	return 0;
}

public Action:CancelGetup(Handle:timer, any:client)
{
	new SurvivorCharacter:survivor = IdentifySurvivor(client);
	if (survivor == SurvivorCharacter:-1)
	{
		return Action:4;
	}
	if (0 >= pendingGetups[survivor])
	{
		pendingGetups[survivor] = 0;
		currentSequence[survivor] = 0;
		return Action:4;
	}
	if (DEBUG)
	{
		LogMessage("[Getup] Canceled extra getup for player %d.", survivor);
	}
	pendingGetups[survivor]--;
	SetEntPropFloat(client, PropType:0, "m_flCycle", 1000.0, 0);
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:18"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_l4d2lib =
{
	name = "l4d2lib",
	file = "l4d2lib.smx",
	required = 1,
};
new Handle:hCvarBonusPerSurvivorMultiplier;
new Handle:hCvarPermanentHealthProportion;
new Handle:hCvarSurvivalBonus;
new Handle:hCvarTieBreaker;
new Float:fMapBonus;
new Float:fMapHealthBonus;
new Float:fMapDamageBonus;
new Float:fMapTempHealthBonus;
new Float:fPermHpWorth;
new Float:fTempHpWorth;
new Float:fSurvivorBonus[2];
new iMapDistance;
new iTeamSize;
new iLostTempHealth[2];
new iTempHealth[66];
new String:sSurvivorState[2][32];
new bool:bLateLoad;
new bool:bRoundOver;
public Plugin:myinfo =
{
	name = "L4D2 Equilibrium Scoring System",
	description = "Custom scoring system, designed for Equilibrium 2.0",
	author = "Visor",
	version = "1.5.1",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator/(Float:,_:)(Float:oper1, oper2)
{
	return oper1 / float(oper2);
}

Float:operator/(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) / oper2;
}

bool:operator==(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) == 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator>=(_:,Float:)(oper1, Float:oper2)
{
	return FloatCompare(float(oper1), oper2) >= 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

GetEntityValueFromOffset(entity, String:offset[], NumberType:size, &value)
{
	new Address:pEntity = GetEntityAddress(entity);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), offset);
		if (offs == -1)
		{
			return 0;
		}
		value = LoadFromAddress(offs + pEntity, size);
		return 1;
	}
	return 0;
}

L4D2Direct_GetPreIncapHealthBuffer(client)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return -1;
	}
	decl value;
	if (!GetEntityValueFromOffset(client, "CTerrorPlayer::m_preIncapacitatedHealthBuffer", NumberType:2, value))
	{
		value = -1;
	}
	return value;
}

public __pl_l4d2lib_SetNTVOptional()
{
	MarkNativeAsOptional("L4D2_GetCurrentRound");
	MarkNativeAsOptional("L4D2_CurrentlyInRound");
	MarkNativeAsOptional("L4D2_GetSurvivorCount");
	MarkNativeAsOptional("L4D2_GetSurvivorOfIndex");
	MarkNativeAsOptional("L4D2_IsMapDataAvailable");
	MarkNativeAsOptional("L4D2_IsEntityInSaferoom");
	MarkNativeAsOptional("L4D2_GetMapStartOrigin");
	MarkNativeAsOptional("L4D2_GetMapEndOrigin");
	MarkNativeAsOptional("L4D2_GetMapStartDistance");
	MarkNativeAsOptional("L4D2_GetMapStartExtraDistance");
	MarkNativeAsOptional("L4D2_GetMapEndDistance");
	MarkNativeAsOptional("L4D2_GetMapValueInt");
	MarkNativeAsOptional("L4D2_GetMapValueFloat");
	MarkNativeAsOptional("L4D2_GetMapValueVector");
	MarkNativeAsOptional("L4D2_GetMapValueString");
	MarkNativeAsOptional("L4D2_CopyMapSubsection");
	return 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	hCvarBonusPerSurvivorMultiplier = CreateConVar("eqsm_bonus_per_survivor_multiplier", "0.5", "Total Survivor Bonus = this * Number of Survivors * Map Distance", 262144, true, 0.25, false, 0.0);
	hCvarPermanentHealthProportion = CreateConVar("eqsm_permament_health_proportion", "0.75", "Permanent Health Bonus = this * Map Bonus; rest goes for Temporary Health Bonus", 262144, false, 0.0, false, 0.0);
	hCvarSurvivalBonus = FindConVar("vs_survival_bonus");
	hCvarTieBreaker = FindConVar("vs_tiebreak_bonus");
	HookConVarChange(hCvarBonusPerSurvivorMultiplier, CvarChanged);
	HookConVarChange(hCvarPermanentHealthProportion, CvarChanged);
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	HookEvent("player_ledge_grab", OnPlayerLedgeGrab, EventHookMode:1);
	RegConsoleCmd("sm_health", CmdBonus, "", 0);
	RegConsoleCmd("sm_damage", CmdBonus, "", 0);
	RegConsoleCmd("sm_bonus", CmdBonus, "", 0);
	RegConsoleCmd("sm_mapinfo", CmdMapInfo, "", 0);
	if (bLateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				OnClientPutInServer(i);
			}
			i++;
		}
	}
	return 0;
}

public OnPluginEnd()
{
	ResetConVar(hCvarSurvivalBonus, false, false);
	ResetConVar(hCvarTieBreaker, false, false);
	return 0;
}

public OnConfigsExecuted()
{
	iTeamSize = GetConVarInt(FindConVar("survivor_limit"));
	SetConVarInt(hCvarTieBreaker, 0, false, false);
	iMapDistance = L4D2_GetMapValueInt("max_distance", L4D_GetVersusMaxCompletionScore());
	L4D_SetVersusMaxCompletionScore(iMapDistance);
	new Float:fPermHealthProportion = GetConVarFloat(hCvarPermanentHealthProportion);
	new Float:fTempHealthProportion = 1.0 - fPermHealthProportion;
	fMapBonus = GetConVarFloat(hCvarBonusPerSurvivorMultiplier) * iTeamSize * iMapDistance;
	fMapHealthBonus = fMapBonus * fPermHealthProportion;
	fMapDamageBonus = fMapBonus * fTempHealthProportion;
	fMapTempHealthBonus = iTeamSize * 100 / fPermHealthProportion * fTempHealthProportion;
	fPermHpWorth = fMapBonus / iTeamSize / 100 * fPermHealthProportion;
	fTempHpWorth = fMapBonus * fTempHealthProportion / fMapTempHealthBonus;
	return 0;
}

public OnMapStart()
{
	OnConfigsExecuted();
	iLostTempHealth[0] = 0;
	iLostTempHealth[1] = 0;
	return 0;
}

public CvarChanged(Handle:convar, String:oldValue[], String:newValue[])
{
	OnConfigsExecuted();
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	SDKHook(client, SDKHookType:3, OnTakeDamagePost);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	SDKUnhook(client, SDKHookType:3, OnTakeDamagePost);
	return 0;
}

public OnRoundStart()
{
	new i;
	while (i < 65)
	{
		iTempHealth[i] = 0;
		i++;
	}
	bRoundOver = false;
	return 0;
}

public Action:CmdBonus(client, args)
{
	new var1;
	if (bRoundOver || !client)
	{
		return Action:3;
	}
	decl String:sCmdType[64];
	GetCmdArg(1, sCmdType, 64);
	new Float:fHealthBonus = GetSurvivorHealthBonus();
	new Float:fDamageBonus = GetSurvivorDamageBonus();
	if (StrEqual(sCmdType, "full", true))
	{
		if (InSecondHalfOfRound())
		{
			new var2 = sSurvivorState;
			PrintToChat(client, "\x01[\x04EQSM\x01 :: R\x03#1\x01] Bonus: \x05%d\x01/\x05%d\x01 <\x03%.1f%%\x01> [%s]", RoundToFloor(fSurvivorBonus[0]), RoundToFloor(fMapBonus), CalculateBonusPercent(fSurvivorBonus[0], -1.0), var2[0][var2]);
		}
		PrintToChat(client, "\x01[\x04EQSM\x01 :: R\x03#%i\x01] Bonus: \x05%d\x01 <\x03%.1f%%\x01> [HB: \x05%d\x01 <\x03%.1f%%\x01> | DB: \x05%d\x01 <\x03%.1f%%\x01>]", InSecondHalfOfRound() + 1, RoundToFloor(fHealthBonus + fDamageBonus), CalculateBonusPercent(fHealthBonus + fDamageBonus, fMapHealthBonus + fMapDamageBonus), RoundToFloor(fHealthBonus), CalculateBonusPercent(fHealthBonus, fMapHealthBonus), RoundToFloor(fDamageBonus), CalculateBonusPercent(fDamageBonus, fMapDamageBonus));
	}
	else
	{
		if (StrEqual(sCmdType, "lite", true))
		{
			PrintToChat(client, "\x01[\x04EQSM\x01 :: R\x03#%i\x01] Bonus: \x05%d\x01 <\x03%.1f%%\x01>", InSecondHalfOfRound() + 1, RoundToFloor(fHealthBonus + fDamageBonus), CalculateBonusPercent(fHealthBonus + fDamageBonus, fMapHealthBonus + fMapDamageBonus));
		}
		if (InSecondHalfOfRound())
		{
			PrintToChat(client, "\x01[\x04EQSM\x01 :: R\x03#1\x01] Bonus: \x05%d\x01 <\x03%.1f%%\x01>", RoundToFloor(fSurvivorBonus[0]), CalculateBonusPercent(fSurvivorBonus[0], -1.0));
		}
		PrintToChat(client, "\x01[\x04EQSM\x01 :: R\x03#%i\x01] Bonus: \x05%d\x01 <\x03%.1f%%\x01> [HB: \x03%.0f%%\x01 | DB: \x03%.0f%%\x01]", InSecondHalfOfRound() + 1, RoundToFloor(fHealthBonus + fDamageBonus), CalculateBonusPercent(fHealthBonus + fDamageBonus, fMapHealthBonus + fMapDamageBonus), CalculateBonusPercent(fHealthBonus, fMapHealthBonus), CalculateBonusPercent(fDamageBonus, fMapDamageBonus));
	}
	return Action:3;
}

public Action:CmdMapInfo(client, args)
{
	PrintToChat(client, "\x01[\x04EQSM\x01 :: \x03%iv%i\x01] Map Info", iTeamSize, iTeamSize);
	PrintToChat(client, "\x01Distance: \x05%d\x01", iMapDistance);
	PrintToChat(client, "\x01Bonus: \x05%d\x01 <\x03100.0%%\x01>", RoundToFloor(fMapBonus));
	PrintToChat(client, "\x01Health Bonus: \x05%d\x01 <\x03%.1f%%\x01>", RoundToFloor(fMapHealthBonus), CalculateBonusPercent(fMapHealthBonus, -1.0));
	PrintToChat(client, "\x01Damage Bonus: \x05%d\x01 <\x03%.1f%%\x01>", RoundToFloor(fMapDamageBonus), CalculateBonusPercent(fMapDamageBonus, -1.0));
	return Action:3;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	new var1;
	if (!IsSurvivor(victim) || !IsAnyInfected(attacker) || IsPlayerIncap(victim))
	{
		return Action:0;
	}
	iTempHealth[victim] = GetSurvivorTemporaryHealth(victim);
	return Action:0;
}

public OnPlayerLedgeGrab(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1 = iLostTempHealth[InSecondHalfOfRound()];
	var1 = var1[L4D2Direct_GetPreIncapHealthBuffer(client)];
	return 0;
}

public Action:L4D2_OnRevived(client)
{
	iLostTempHealth[InSecondHalfOfRound()] -= GetSurvivorTemporaryHealth(client);
	return Action:0;
}

public OnTakeDamagePost(victim, attacker, inflictor, Float:damage, damagetype)
{
	new var1;
	if (!IsSurvivor(victim) || !IsAnyInfected(attacker))
	{
		return 0;
	}
	new var3;
	if (!IsPlayerAlive(victim) || (IsPlayerIncap(victim) && !IsPlayerLedged(victim)))
	{
		new var6 = iLostTempHealth[InSecondHalfOfRound()];
		var6 = iTempHealth[victim][var6];
	}
	else
	{
		if (!IsPlayerLedged(victim))
		{
			new var7 = iLostTempHealth[InSecondHalfOfRound()];
			new var4;
			if (iTempHealth[victim])
			{
				var4 = iTempHealth[victim] - GetSurvivorTemporaryHealth(victim);
			}
			else
			{
				var4 = 0;
			}
			var7 = var7[var4];
		}
	}
	new var5;
	if (IsPlayerIncap(victim))
	{
		var5 = 0;
	}
	else
	{
		var5 = GetSurvivorTemporaryHealth(victim);
	}
	iTempHealth[victim] = var5;
	return 0;
}

public Action:L4D2_OnEndVersusModeRound(bool:countSurvivors)
{
	if (bRoundOver)
	{
		return Action:0;
	}
	new team = InSecondHalfOfRound();
	new iSurvivalMultiplier = GetUprightSurvivors();
	fSurvivorBonus[team] = GetSurvivorHealthBonus() + GetSurvivorDamageBonus();
	new var1;
	if (iSurvivalMultiplier > 0 && RoundToFloor(fSurvivorBonus[team] / iSurvivalMultiplier) >= 1065353216)
	{
		SetConVarInt(hCvarSurvivalBonus, RoundToFloor(fSurvivorBonus[team] / iSurvivalMultiplier), false, false);
		fSurvivorBonus[team] = float(iSurvivalMultiplier * GetConVarInt(hCvarSurvivalBonus));
		new var2;
		if (iTeamSize == iSurvivalMultiplier)
		{
			var2[0] = 3232;
		}
		else
		{
			var2[0] = 3236;
		}
		Format(sSurvivorState[team], 32, "%s%i\x01/\x05%i\x01", var2, iSurvivalMultiplier, iTeamSize);
	}
	else
	{
		SetConVarInt(hCvarSurvivalBonus, 0, false, false);
		new var3;
		if (iSurvivalMultiplier)
		{
			var3[0] = 3260;
		}
		else
		{
			var3[0] = 3248;
		}
		Format(sSurvivorState[team], 32, "\x04%s\x01", var3);
	}
	CreateTimer(3.0, PrintRoundEndStats, any:0, 2);
	bRoundOver = true;
	return Action:0;
}

public Action:PrintRoundEndStats(Handle:timer)
{
	new i;
	while (InSecondHalfOfRound() >= i)
	{
		PrintToChatAll("\x01[\x04EQSM\x01 :: Round \x03%i\x01] Bonus: \x05%d\x01/\x05%d\x01 <\x03%.1f%%\x01> [%s]", i + 1, RoundToFloor(fSurvivorBonus[i]), RoundToFloor(fMapBonus), CalculateBonusPercent(fSurvivorBonus[i], -1.0), sSurvivorState[i]);
		i++;
	}
	return Action:0;
}

GetUprightSurvivors()
{
	new aliveCount;
	new survivorCount;
	new i = 1;
	while (i <= MaxClients && survivorCount < iTeamSize)
	{
		if (IsSurvivor(i))
		{
			survivorCount++;
			new var2;
			if (IsPlayerAlive(i) && !IsPlayerIncap(i) && !IsPlayerLedged(i))
			{
				aliveCount++;
			}
		}
		i++;
	}
	return aliveCount;
}

Float:GetSurvivorHealthBonus()
{
	new Float:fHealthBonus = 0.0;
	new survivorCount;
	new survivalMultiplier;
	new i = 1;
	while (i <= MaxClients && survivorCount < iTeamSize)
	{
		if (IsSurvivor(i))
		{
			survivorCount++;
			new var2;
			if (IsPlayerAlive(i) && !IsPlayerIncap(i) && !IsPlayerLedged(i))
			{
				survivalMultiplier++;
				fHealthBonus += fPermHpWorth * GetSurvivorPermanentHealth(i);
			}
		}
		i++;
	}
	return fHealthBonus / iTeamSize * survivalMultiplier;
}

Float:GetSurvivorDamageBonus()
{
	new survivalMultiplier = GetUprightSurvivors();
	new Float:fDamageBonus = fMapTempHealthBonus - float(iLostTempHealth[InSecondHalfOfRound()]) * fTempHpWorth / iTeamSize * survivalMultiplier;
	new var1;
	if (fDamageBonus > 0.0 && survivalMultiplier > 0)
	{
		var2 = fDamageBonus;
	}
	else
	{
		var2 = 0.0;
	}
	return var2;
}

Float:CalculateBonusPercent(Float:score, Float:maxbonus)
{
	new var1;
	if (-1.0 == maxbonus)
	{
		var1 = fMapBonus;
	}
	else
	{
		var1 = maxbonus;
	}
	return score / var1 * 100;
}

InSecondHalfOfRound()
{
	return GameRules_GetProp("m_bInSecondHalfOfRound", 4, 0);
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsAnyInfected(entity)
{
	new var1;
	if (entity > 0 && entity <= MaxClients)
	{
		new var2;
		return IsClientInGame(entity) && GetClientTeam(entity) == 3;
	}
	if (entity > MaxClients)
	{
		decl String:classname[64];
		GetEdictClassname(entity, classname, 64);
		new var3;
		if (StrEqual(classname, "infected", true) || StrEqual(classname, "witch", true))
		{
			return true;
		}
	}
	return false;
}

bool:IsPlayerIncap(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

bool:IsPlayerLedged(client)
{
	return GetEntProp(client, PropType:0, "m_isFallingFromLedge", 4, 0) | GetEntProp(client, PropType:0, "m_isHangingFromLedge", 4, 0);
}

GetSurvivorTemporaryHealth(client)
{
	new temphp = RoundToCeil(GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0) - GetGameTime() - GetEntPropFloat(client, PropType:0, "m_healthBufferTime", 0) * GetConVarFloat(FindConVar("pain_pills_decay_rate"))) + -1;
	new var1;
	if (temphp > 0)
	{
		var1 = temphp;
	}
	else
	{
		var1 = 0;
	}
	return var1;
}

GetSurvivorPermanentHealth(client)
{
	new var1;
	if (GetEntProp(client, PropType:0, "m_currentReviveCount", 4, 0) > 0)
	{
		var1 = 0;
	}
	else
	{
		if (GetEntProp(client, PropType:0, "m_iHealth", 4, 0) > 0)
		{
			var1 = GetEntProp(client, PropType:0, "m_iHealth", 4, 0);
		}
		var1 = 0;
	}
	return var1;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:25"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new Handle:hFirstTankSpawningScheme;
new Handle:hSecondTankSpawningScheme;
new TankSpawningScheme:spawnScheme;
new tankCount;
public Plugin:myinfo =
{
	name = "EQ2 Finale Tank Manager",
	description = "Either two event tanks or one flow and one (second) event tank",
	author = "Visor",
	version = "2.4",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetCDirector()
{
	static Address:TheDirector;
	if (!TheDirector)
	{
		TheDirector = GameConfGetAddress(L4D2Direct_GetGameConf(), "CDirector");
	}
	return TheDirector;
}

Address:L4D2Direct_GetCDirectorVersusMode()
{
	static Address:pVersusModeDirector;
	if (!pVersusModeDirector)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode");
		if (offs == -1)
		{
			return Address:0;
		}
		pVersusModeDirector = L4D2Direct_GetCDirector() + offs;
		pVersusModeDirector = LoadFromAddress(pVersusModeDirector, NumberType:2);
	}
	return pVersusModeDirector;
}

Address:L4D2Direct_GeVSTankToSpawnAddr()
{
	static Address:pTankSpawnThisRound;
	if (!pTankSpawnThisRound)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_bTankThisRound");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankSpawnThisRound = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pTankSpawnThisRound;
}

L4D2Direct_SetVSTankToSpawnThisRound(roundNumber, bool:spawn)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(L4D2Direct_GeVSTankToSpawnAddr() + roundNumber, spawn, NumberType:0);
	return 0;
}

public OnPluginStart()
{
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	hFirstTankSpawningScheme = CreateTrie();
	hSecondTankSpawningScheme = CreateTrie();
	RegServerCmd("tank_map_flow_and_second_event", SetMapFirstTankSpawningScheme, "", 0);
	RegServerCmd("tank_map_only_first_event", SetMapSecondTankSpawningScheme, "", 0);
	return 0;
}

public Action:SetMapFirstTankSpawningScheme(args)
{
	decl String:mapname[64];
	GetCmdArg(1, mapname, 64);
	SetTrieValue(hFirstTankSpawningScheme, mapname, any:1, true);
	return Action:0;
}

public Action:SetMapSecondTankSpawningScheme(args)
{
	decl String:mapname[64];
	GetCmdArg(1, mapname, 64);
	SetTrieValue(hSecondTankSpawningScheme, mapname, any:1, true);
	return Action:0;
}

public OnRoundStart()
{
	CreateTimer(8.0, ProcessTankSpawn, any:0, 0);
	return 0;
}

public Action:ProcessTankSpawn(Handle:timer)
{
	spawnScheme = MissingTAG:0;
	tankCount = 0;
	decl String:mapname[64];
	GetCurrentMap(mapname, 64);
	new bool:dummy;
	if (GetTrieValue(hFirstTankSpawningScheme, mapname, dummy))
	{
		spawnScheme = MissingTAG:1;
	}
	if (GetTrieValue(hSecondTankSpawningScheme, mapname, dummy))
	{
		spawnScheme = MissingTAG:2;
	}
	new var1;
	if (IsTankAllowed() && spawnScheme)
	{
		L4D2Direct_SetVSTankToSpawnThisRound(InSecondHalfOfRound(), spawnScheme == 1);
	}
	return Action:0;
}

public Action:L4D2_OnChangeFinaleStage(&finaleType, String:arg[])
{
	if (finaleType == 8)
	{
		tankCount += 1;
		new var1;
		if ((spawnScheme == TankSpawningScheme:1 && tankCount != 2) || (spawnScheme == TankSpawningScheme:2 && tankCount != 1))
		{
			return Action:3;
		}
	}
	return Action:0;
}

InSecondHalfOfRound()
{
	return GameRules_GetProp("m_bInSecondHalfOfRound", 4, 0);
}

bool:IsTankAllowed()
{
	return GetConVarFloat(FindConVar("versus_tank_chance_finale")) > 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "01/31/2012",
	time = "17:27:56"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Finale Incap Distance Fixifier",
	description = "Kills survivors before the score is calculated so you don't get full distance if you are incapped as the rescue vehicle leaves.",
	author = "CanadaRox",
	version = "1.0",
	url = "https://bitbucket.org/CanadaRox/random-sourcemod-stuff"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	HookEvent("finale_vehicle_leaving", FinaleEnd_Event, EventHookMode:2);
	return 0;
}

public FinaleEnd_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new i = 1;
	while (i < MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && GetClientTeam(i) == 2 && IsPlayerIncap(i))
		{
			ForcePlayerSuicide(i);
		}
		i++;
	}
	return 0;
}

IsPlayerIncap(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "08/23/2014",
	time = "15:06:00"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new Handle:hFinaleExceptionMaps;
new iTankCount[2];
public Plugin:myinfo =
{
	name = "Finale Even-Numbered Tank Blocker",
	description = "Blocks even-numbered non-flow finale tanks.",
	author = "Stabby, Visor",
	version = "2",
	url = "http://github.com/ConfoglTeam/ProMod"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	RegServerCmd("finale_tank_default", SetFinaleExceptionMap, "", 0);
	hFinaleExceptionMaps = CreateTrie();
	return 0;
}

public Action:SetFinaleExceptionMap(args)
{
	decl String:mapname[64];
	GetCmdArg(1, mapname, 64);
	SetTrieValue(hFinaleExceptionMaps, mapname, any:1, true);
	return Action:0;
}

public Action:L4D2_OnChangeFinaleStage(&finaleType, String:arg[])
{
	decl String:mapname[64];
	GetCurrentMap(mapname, 64);
	decl dummy;
	if (GetTrieValue(hFinaleExceptionMaps, mapname, dummy))
	{
		return Action:0;
	}
	if (finaleType == 8)
	{
		new var1 = iTankCount[GameRules_GetProp("m_bInSecondHalfOfRound", 4, 0)];
		var1++;
		if (!(var1 % 2))
		{
			return Action:3;
		}
	}
	return Action:0;
}

public OnMapEnd()
{
	iTankCount[0] = 0;
	iTankCount[1] = 0;
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/24/2016",
	time = "11:00:53"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "[L4D & L4D2] Engine Fix",
	description = "Blocking ladder speed glitch, no fall damage bug, health boost glitch.",
	author = "raziEiL [disawar1]",
	version = "1.1",
	url = "http://steamcommunity.com/id/raziEiL"
};
new Handle:g_hFixGlitchTimer[66];
new g_iHealthToRestore[66];
new g_iLastKnownHealth[66];
new Handle:g_hRestoreTimer[66];
new g_bTempWarnLock[66];
new Float:g_fCvarDecayRate;
new bool:g_bCvarWarnEnabled;
new g_iCvarEngineFlags;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator/(Float:,_:)(Float:oper1, oper2)
{
	return oper1 / float(oper2);
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return oper1 + float(oper2);
}

bool:operator>(Float:,_:)(Float:oper1, oper2)
{
	return oper1 > float(oper2);
}

bool:operator<=(Float:,_:)(Float:oper1, oper2)
{
	return oper1 <= float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:CreateDataTimer(Float:interval, Timer:func, &Handle:datapack, flags)
{
	datapack = CreateDataPack();
	flags |= 512;
	return CreateTimer(interval, func, datapack, flags);
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

MoveType:GetEntityMoveType(entity)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_MoveType", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_MoveType");
		}
		gotconfig = true;
	}
	return GetEntProp(entity, PropType:1, datamap, 4, 0);
}

public OnPluginStart()
{
	new Handle:hCvarDecayRate = FindConVar("pain_pills_decay_rate");
	CreateConVar("engine_fix_version", "1.1", "Engine Fix plugin version", 270592, false, 0.0, false, 0.0);
	new Handle:hCvarWarnEnabled = CreateConVar("engine_warning", "0", "Display a warning message saying that player using expolit: 1=enable, 0=disable.", 262144, true, 0.0, true, 1.0);
	new Handle:hCvarEngineFlags = CreateConVar("engine_fix_flags", "14", "Enables what kind of exploit should be fixed/blocked. Flags (add together): 0=disable, 2=ladder speed glitch, 4=no fall damage bug, 8=health boost glitch.", 262144, true, 0.0, true, 14.0);
	g_fCvarDecayRate = GetConVarFloat(hCvarDecayRate);
	g_bCvarWarnEnabled = GetConVarBool(hCvarWarnEnabled);
	g_iCvarEngineFlags = GetConVarInt(hCvarEngineFlags);
	if (g_iCvarEngineFlags & 8)
	{
		EF_ToogleEvents(true);
	}
	HookConVarChange(hCvarDecayRate, OnConvarChange_DecayRate);
	HookConVarChange(hCvarWarnEnabled, OnConvarChange_WarnEnabled);
	HookConVarChange(hCvarEngineFlags, OnConvarChange_EngineFlags);
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons)
{
	new var1;
	if (g_iCvarEngineFlags && IsValidClient(client) && IsPlayerAlive(client) && !IsFakeClient(client))
	{
		new var2;
		if (g_iCvarEngineFlags & 2 && GetEntityMoveType(client) == 9)
		{
			static iUsingBug[66];
			new var3;
			if (buttons & 8 || buttons & 16)
			{
				if (buttons & 512)
				{
					iUsingBug[client]++;
					buttons = buttons & -513;
				}
				if (buttons & 1024)
				{
					iUsingBug[client]++;
					buttons = buttons & -1025;
				}
				new var4;
				if (g_bCvarWarnEnabled && iUsingBug[client] > 48)
				{
					WarningsMsg(client, 1);
					iUsingBug[client] = 0;
				}
			}
			iUsingBug[client] = 0;
		}
		new var5;
		if (g_iCvarEngineFlags & 4 && GetClientTeam(client) == 2 && IsFallDamage(client) && buttons & 32)
		{
			buttons = buttons & -33;
			new var6;
			if (g_bCvarWarnEnabled && !g_bTempWarnLock[client])
			{
				g_bTempWarnLock[client] = 1;
				WarningsMsg(client, 2);
				CreateTimer(5.0, EF_t_UnlockWarnMsg, client, 0);
			}
		}
	}
	return Action:0;
}

public Action:EF_t_UnlockWarnMsg(Handle:timer, any:client)
{
	g_bTempWarnLock[client] = 0;
	return Action:0;
}

bool:IsFallDamage(client)
{
	return GetEntPropFloat(client, PropType:0, "m_flFallVelocity", 0) > 440;
}

public OnClientDisconnect(client)
{
	new var1;
	if (client && g_iCvarEngineFlags & 8)
	{
		EF_ClearAllVars(client);
	}
	return 0;
}

public EF_ev_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	new i = 1;
	while (i <= MaxClients)
	{
		EF_ClearAllVars(i);
		new var1;
		if (IsClientInGame(i) && IsDrownPropNotEqual(i))
		{
			ForceEqualDrownProp(i);
		}
		i++;
	}
	return 0;
}

public EF_ev_PlayerHurt(Handle:event, String:name[], bool:dontBroadcast)
{
	if (GetEventInt(event, "type") & 16384)
	{
		new client = GetClientOfUserId(GetEventInt(event, "userid"));
		if (IsIncapacitated(client))
		{
			return 0;
		}
		if (GetEventInt(event, "health") == 1)
		{
			new damage = GetEventInt(event, "dmg_health");
			new var1;
			if (g_iLastKnownHealth[client] && damage >= g_iLastKnownHealth[client])
			{
				damage -= g_iLastKnownHealth[client];
				g_iLastKnownHealth[client] += -1;
			}
			if (0 > g_iHealthToRestore[client])
			{
				g_iHealthToRestore[client] = 0;
			}
			if (!g_iHealthToRestore[client])
			{
				EF_KillRestoreTimer(client);
				CreateTimer(0.3, EF_t_CheckRestoring, client, 3);
			}
			new var2 = g_iHealthToRestore[client];
			var2 = var2[damage];
			decl Handle:hdataPack;
			CreateDataTimer(0.1, EF_t_SetDrownDmg, hdataPack, 2);
			WritePackCell(hdataPack, client);
			WritePackCell(hdataPack, g_iLastKnownHealth[client][GetEntProp(client, PropType:1, "m_idrowndmg", 4, 0)]);
			g_iLastKnownHealth[client] = 0;
		}
		else
		{
			g_iLastKnownHealth[client] = GetEventInt(event, "health");
		}
	}
	return 0;
}

public Action:EF_t_SetDrownDmg(Handle:timer, Handle:datapack)
{
	ResetPack(datapack, false);
	new client = ReadPackCell(datapack);
	if (!IsSurvivor(client))
	{
		return Action:0;
	}
	new drowndmg = ReadPackCell(datapack);
	SetEntProp(client, PropType:1, "m_idrowndmg", drowndmg, 4, 0);
	return Action:0;
}

public Action:EF_t_CheckRestoring(Handle:timer, any:client)
{
	new var1;
	if (g_iHealthToRestore[client] <= 0 || !IsSurvivor(client))
	{
		g_iHealthToRestore[client] = 0;
		return Action:4;
	}
	if (IsUnderWater(client))
	{
		return Action:0;
	}
	new Float:fHealthToRestore = float(GetEntProp(client, PropType:1, "m_idrowndmg", 4, 0) - GetEntProp(client, PropType:1, "m_idrownrestored", 4, 0));
	if (fHealthToRestore <= 0.0)
	{
		g_hRestoreTimer[client] = CreateTimer(2.0, EF_t_RestoreTempHealth, client, 3);
		return Action:4;
	}
	new iRestoreCount = RoundToCeil(fHealthToRestore / 10);
	new Float:fRestoreTimeEnd = float(iRestoreCount) * 2.0;
	CreateTimer(fRestoreTimeEnd, EF_t_StartRestoreTempHealth, client, 2);
	return Action:4;
}

public Action:EF_t_StartRestoreTempHealth(Handle:timer, any:client)
{
	new var1;
	if (g_iHealthToRestore[client] <= 0 || !IsSurvivor(client))
	{
		return Action:0;
	}
	g_hRestoreTimer[client] = CreateTimer(2.0, EF_t_RestoreTempHealth, client, 3);
	return Action:0;
}

public Action:EF_t_RestoreTempHealth(Handle:timer, any:client)
{
	new var1;
	if (g_iHealthToRestore[client] <= 0 || !IsSurvivor(client))
	{
		EF_ClearVars(client);
		return Action:4;
	}
	new var2;
	if (!IsUnderWater(client) && !IsDrownPropNotEqual(client))
	{
		new Float:fTemp = GetTempHealth(client);
		new iLimit = 99 - RoundToFloor(fTemp) + GetClientHealth(client);
		decl iTempToRestore;
		new var3;
		if (g_iHealthToRestore[client] >= 10)
		{
			var3 = 10;
		}
		else
		{
			var3 = g_iHealthToRestore[client];
		}
		iTempToRestore = var3;
		if (iTempToRestore > iLimit)
		{
			iTempToRestore = iLimit;
			g_iHealthToRestore[client] = 0;
			if (0 >= iTempToRestore)
			{
				return Action:0;
			}
		}
		SetTempHealth(client, fTemp + iTempToRestore);
		g_iHealthToRestore[client] += -10;
		EF_GlitchWarnFunc(client);
	}
	return Action:0;
}

public EF_ev_HealSuccess(Handle:event, String:name[], bool:dontBroadcast)
{
	decl client;
	new var1;
	if (StrEqual(name, "player_incapacitated", true))
	{
		var1[0] = 3464;
	}
	else
	{
		var1[0] = 3472;
	}
	client = GetClientOfUserId(GetEventInt(event, var1));
	if (IsDrownPropNotEqual(client))
	{
		EF_ClearVars(client);
		ForceEqualDrownProp(client);
	}
	return 0;
}

public EF_ev_PillsUsed(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (IsDrownPropNotEqual(client))
	{
		EF_KillFixGlitchTimer(client);
		g_hFixGlitchTimer[client] = CreateTimer(0.0, EF_t_FixTempHpGlitch, client, 3);
	}
	return 0;
}

public Action:EF_t_FixTempHpGlitch(Handle:timer, any:client)
{
	new var1;
	if (IsSurvivor(client) && !IsIncapacitated(client))
	{
		new Float:fTemp = GetTempHealth(client);
		if (fTemp)
		{
			new iHealth = GetClientHealth(client);
			if (RoundToFloor(fTemp) + iHealth > 99)
			{
				SetTempHealth(client, float(100 - iHealth));
				EF_GlitchWarnFunc(client);
			}
		}
		if (IsDrownPropNotEqual(client))
		{
			return Action:0;
		}
	}
	g_hFixGlitchTimer[client] = 0;
	return Action:4;
}

EF_GlitchWarnFunc(client)
{
	new var1;
	if (g_bCvarWarnEnabled && !g_bTempWarnLock[client])
	{
		g_bTempWarnLock[client] = 1;
		WarningsMsg(client, 3);
		CreateTimer(15.0, EF_t_UnlockWarnMsg, client, 0);
	}
	return 0;
}

EF_KillRestoreTimer(client)
{
	if (g_hRestoreTimer[client])
	{
		KillTimer(g_hRestoreTimer[client], false);
		g_hRestoreTimer[client] = 0;
	}
	return 0;
}

EF_KillFixGlitchTimer(client)
{
	if (g_hFixGlitchTimer[client])
	{
		KillTimer(g_hFixGlitchTimer[client], false);
		g_hFixGlitchTimer[client] = 0;
	}
	return 0;
}

EF_ClearVars(client)
{
	EF_KillRestoreTimer(client);
	g_iHealthToRestore[client] = 0;
	g_iLastKnownHealth[client] = 0;
	return 0;
}

EF_ClearAllVars(client)
{
	EF_ClearVars(client);
	EF_KillFixGlitchTimer(client);
	return 0;
}

bool:IsSurvivor(client)
{
	new var1;
	return IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client);
}

bool:IsUnderWater(client)
{
	return GetEntProp(client, PropType:0, "m_nWaterLevel", 4, 0) == 3;
}

IsIncapacitated(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

bool:IsDrownPropNotEqual(client)
{
	return GetEntProp(client, PropType:1, "m_idrownrestored", 4, 0) != GetEntProp(client, PropType:1, "m_idrowndmg", 4, 0);
}

ForceEqualDrownProp(client)
{
	SetEntProp(client, PropType:1, "m_idrownrestored", GetEntProp(client, PropType:1, "m_idrowndmg", 4, 0), 4, 0);
	return 0;
}

SetTempHealth(client, Float:health)
{
	SetEntPropFloat(client, PropType:0, "m_healthBufferTime", GetGameTime(), 0);
	SetEntPropFloat(client, PropType:0, "m_healthBuffer", health, 0);
	return 0;
}

Float:GetTempHealth(client)
{
	new Float:fTempHealth = GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0);
	fTempHealth -= GetGameTime() - GetEntPropFloat(client, PropType:0, "m_healthBufferTime", 0) * g_fCvarDecayRate;
	new var1;
	if (fTempHealth < 0.0)
	{
		var1 = 0.0;
	}
	else
	{
		var1 = fTempHealth;
	}
	return var1;
}

WarningsMsg(client, msg)
{
	decl String:STEAM_ID[32];
	GetClientAuthString(client, STEAM_ID, 32, true);
	switch (msg)
	{
		case 1:
		{
			PrintToChatAll("%N (%s) attempted to use a ladder speed glitch.", client, STEAM_ID);
		}
		case 2:
		{
			PrintToChatAll("%N (%s) is suspected of using a no fall damage bug.", client, STEAM_ID);
		}
		case 3:
		{
			PrintToChatAll("%N (%s) attempted to use a health boost glitch.", client, STEAM_ID);
		}
		default:
		{
		}
	}
	return 0;
}

public OnConvarChange_DecayRate(Handle:convar, String:oldValue[], String:newValue[])
{
	g_fCvarDecayRate = GetConVarFloat(convar);
	return 0;
}

public OnConvarChange_WarnEnabled(Handle:convar, String:oldValue[], String:newValue[])
{
	g_bCvarWarnEnabled = GetConVarBool(convar);
	return 0;
}

public OnConvarChange_EngineFlags(Handle:convar, String:oldValue[], String:newValue[])
{
	g_iCvarEngineFlags = GetConVarInt(convar);
	EF_ToogleEvents(g_iCvarEngineFlags & 8);
	return 0;
}

EF_ToogleEvents(bool:bHook)
{
	static bool:bIsHooked;
	new var1;
	if (!bIsHooked && bHook)
	{
		new i = 1;
		while (i <= 65)
		{
			EF_ClearAllVars(i);
			i++;
		}
		HookEvent("round_start", EF_ev_RoundStart, EventHookMode:2);
		HookEvent("pills_used", EF_ev_PillsUsed, EventHookMode:1);
		HookEvent("player_hurt", EF_ev_PlayerHurt, EventHookMode:1);
		HookEvent("heal_success", EF_ev_HealSuccess, EventHookMode:1);
		HookEvent("revive_success", EF_ev_HealSuccess, EventHookMode:1);
		HookEvent("player_incapacitated", EF_ev_HealSuccess, EventHookMode:1);
	}
	else
	{
		new var2;
		if (bIsHooked && !bHook)
		{
			UnhookEvent("round_start", EF_ev_RoundStart, EventHookMode:2);
			UnhookEvent("pills_used", EF_ev_PillsUsed, EventHookMode:1);
			UnhookEvent("player_hurt", EF_ev_PlayerHurt, EventHookMode:1);
			UnhookEvent("heal_success", EF_ev_HealSuccess, EventHookMode:1);
			UnhookEvent("revive_success", EF_ev_HealSuccess, EventHookMode:1);
			UnhookEvent("player_incapacitated", EF_ev_HealSuccess, EventHookMode:1);
		}
	}
	return 0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "07/06/2016",
	time = "22:19:09"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new Float:fLastMeleeSwing[66];
new bool:bLate;
public Plugin:myinfo =
{
	name = "Fast melee fix",
	description = "Fixes the bug with too fast melee attacks",
	author = "sheo",
	version = "2.1",
	url = "http://steamcommunity.com/groups/b1com"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

bool:GetEntityClassname(entity, String:clsname[], maxlength)
{
	return !!GetEntPropString(entity, PropType:1, "m_iClassname", clsname, maxlength, 0);
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	bLate = late;
	return APLRes:0;
}

public OnPluginStart()
{
	decl String:gfstring[128];
	GetGameFolderName(gfstring, 128);
	if (!StrEqual(gfstring, "left4dead2", false))
	{
		SetFailState("Plugin supports Left 4 dead 2 only!");
	}
	HookEvent("weapon_fire", Event_WeaponFire, EventHookMode:1);
	CreateConVar("l4d2_fast_melee_fix_version", "2.1", "Fast melee fix version", 262400, false, 0.0, false, 0.0);
	if (bLate)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && !IsFakeClient(i))
			{
				SDKHook(i, SDKHookType:33, OnWeaponSwitched);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	if (!IsFakeClient(client))
	{
		SDKHook(client, SDKHookType:33, OnWeaponSwitched);
	}
	fLastMeleeSwing[client] = 0;
	return 0;
}

public Action:Event_WeaponFire(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client > 0 && !IsFakeClient(client))
	{
		decl String:sBuffer[64];
		GetEventString(event, "weapon", sBuffer, 64);
		if (StrEqual(sBuffer, "melee", true))
		{
			fLastMeleeSwing[client] = GetGameTime();
		}
	}
	return Action:0;
}

public OnWeaponSwitched(client, weapon)
{
	if (!IsFakeClient(client))
	{
		decl String:sBuffer[32];
		GetEntityClassname(weapon, sBuffer, 32);
		if (StrEqual(sBuffer, "weapon_melee", true))
		{
			new Float:fShouldbeNextAttack = fLastMeleeSwing[client][0.92];
			new Float:fByServerNextAttack = GetGameTime() + 0.5;
			new var1;
			if (fShouldbeNextAttack > fByServerNextAttack)
			{
				var1 = fShouldbeNextAttack;
			}
			else
			{
				var1 = fByServerNextAttack;
			}
			SetEntPropFloat(weapon, PropType:0, "m_flNextPrimaryAttack", var1, 0);
		}
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "04/29/2017",
	time = "16:15:10"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Fix frozen tanks",
	description = "",
	author = "sheo",
	version = "2.0",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_incapacitated", Event_PlayerIncap, EventHookMode:1);
	CreateConVar("l4d2_fix_frozen_tank_version", "2.0", "Frozen tank fix version", 262400, false, 0.0, false, 0.0);
	return 0;
}

public Event_PlayerIncap(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client > 0 && IsPlayerTank(client))
	{
		CreateTimer(1.0, KillTank_tCallback, any:0, 0);
	}
	return 0;
}

public Action:KillTank_tCallback(Handle:timer)
{
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsPlayerTank(i) && IsIncapitated(i))
		{
			ForcePlayerSuicide(i);
		}
		i++;
	}
	return Action:0;
}

bool:IsIncapitated(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

bool:IsPlayerTank(client)
{
	new var1;
	if (IsClientInGame(client) && GetClientTeam(client) == 3)
	{
		if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8)
		{
			return true;
		}
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2",
	date = "10/25/2014",
	time = "03:51:06"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 0,
};
new Handle:ghost_hurt_type;
new bool:g_bReadyUpAvailable;
public Plugin:myinfo =
{
	name = "Ghost Hurt Management",
	description = "Allows for modifications of trigger_hurt_ghost",
	author = "Jacob",
	version = "1.1",
	url = "github.com/jacob404/myplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public OnPluginStart()
{
	ghost_hurt_type = CreateConVar("ghost_hurt_type", "0", "When should trigger_hurt_ghost be enabled? 0 = Never, 1 = On Round Start", 262144, true, 0.0, true, 1.0);
	HookEvent("round_start", Event_Round_Start, EventHookMode:2);
	RegServerCmd("sm_reset_ghost_hurt", ResetGhostHurt_Cmd, "Used to reset trigger_hurt_ghost between matches.  This should be in confogl_off.cfg or equivalent for your system", 0);
	return 0;
}

public OnAllPluginsLoaded()
{
	g_bReadyUpAvailable = LibraryExists("readyup");
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		g_bReadyUpAvailable = false;
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		g_bReadyUpAvailable = true;
	}
	return 0;
}

public OnRoundIsLive()
{
	if (GetConVarBool(ghost_hurt_type) == 1)
	{
		EnableGhostHurt();
	}
	return 0;
}

public Action:L4D_OnFirstSurvivorLeftSafeArea(client)
{
	new var1;
	if (!g_bReadyUpAvailable && GetConVarBool(ghost_hurt_type) == 1)
	{
		EnableGhostHurt();
	}
	return Action:0;
}

public OnMapStart()
{
	DisableGhostHurt();
	return 0;
}

public DisableGhostHurt()
{
	ModifyEntity("trigger_hurt_ghost", "Disable");
	return 0;
}

public EnableGhostHurt()
{
	ModifyEntity("trigger_hurt_ghost", "Enable");
	return 0;
}

ModifyEntity(String:className[], String:inputName[])
{
	new iEntity;
	while ((iEntity = FindEntityByClassname(iEntity, className)) != -1)
	{
		new var1;
		if (!(!IsValidEdict(iEntity) || !IsValidEntity(iEntity)))
		{
			AcceptEntityInput(iEntity, inputName, -1, -1, 0);
		}
	}
	return 0;
}

public Event_Round_Start(Handle:event, String:name[], bool:dontBroadcast)
{
	DisableGhostHurt();
	return 0;
}

public Action:ResetGhostHurt_Cmd(args)
{
	DisableGhostHurt();
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4172",
	date = "02/01/2014",
	time = "21:17:29"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_lgofnoc =
{
	name = "lgofnoc",
	file = "lgofnoc.smx",
	required = 0,
};
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 0,
};
public SharedPlugin:__pl_pause =
{
	name = "pause",
	file = "pause.smx",
	required = 0,
};
new Handle:g_hForwardSet;
new Handle:g_hForwardStart;
new Handle:g_hForwardEnd;
new bool:g_bLGOAvailable;
new bool:g_bReadyUpAvailable;
new bool:g_bPauseAvailable;
new bool:g_bInRound;
new bool:g_bPlayersLeftStart;
new bool:g_bSecondHalf;
new g_iTeamSize = 4;
new bool:g_bPaused;
new g_iPauseStart;
new Handle:g_hCvarPointsMode;
new Handle:g_hCvarKeyValuesPath;
new Handle:g_hCvarReportMode;
new Handle:g_kHIData;
new bool:g_bHoldoutActive;
new g_iProgress;
new g_iCharProgress[4];
new bool:g_bHoldoutThisRound;
new Float:g_fHoldoutPointFactor;
new g_iHoldoutPointAbsolute;
new g_iHoldoutTime;
new g_iHoldoutStartTime;
new g_iMapDistance;
new g_iPointsBonus;
new g_iActualBonus;
new String:g_sHoldoutStart[32];
new g_iHoldoutStartHamId;
new String:g_sHoldoutStartClass[32];
new String:g_sHoldoutStartHook[32];
new String:g_sHoldoutEnd[32];
new g_iHoldoutEndHamId;
new String:g_sHoldoutEndClass[32];
new String:g_sHoldoutEndHook[32];
public Plugin:myinfo =
{
	name = "Holdout Bonus",
	description = "Gives bonus for (partially) surviving holdout/camping events. (Requires penalty_bonus.)",
	author = "Tabun",
	version = "0.0.9",
	url = "https://github.com/Tabbernaut/L4D2-Plugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public __pl_lgofnoc_SetNTVOptional()
{
	MarkNativeAsOptional("LGO_BuildConfigPath");
	MarkNativeAsOptional("LGO_ExecuteConfigCfg");
	MarkNativeAsOptional("LGO_IsMapDataAvailable");
	MarkNativeAsOptional("LGO_GetMapValueInt");
	MarkNativeAsOptional("LGO_GetMapValueFloat");
	MarkNativeAsOptional("LGO_GetMapValueVector");
	MarkNativeAsOptional("LGO_GetMapValueString");
	MarkNativeAsOptional("LGO_CopyMapSubsection");
	return 0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public __pl_pause_SetNTVOptional()
{
	MarkNativeAsOptional("IsInPause");
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	RegPluginLibrary("holdout_bonus");
	g_hForwardSet = CreateGlobalForward("OnHoldOutBonusSet", ExecType:0, 2, 2, 2, 2);
	g_hForwardStart = CreateGlobalForward("OnHoldOutBonusStart", ExecType:0, 2);
	g_hForwardEnd = CreateGlobalForward("OnHoldOutBonusEnd", ExecType:0, 2, 2);
	return APLRes:0;
}

public OnAllPluginsLoaded()
{
	g_bLGOAvailable = LibraryExists("lgofnoc");
	g_bReadyUpAvailable = LibraryExists("readyup");
	g_bPauseAvailable = LibraryExists("pause");
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "lgofnoc", true))
	{
		g_bLGOAvailable = false;
	}
	else
	{
		if (StrEqual(name, "readyup", true))
		{
			g_bReadyUpAvailable = false;
		}
		if (StrEqual(name, "pause", true))
		{
			g_bPauseAvailable = false;
		}
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "lgofnoc", true))
	{
		g_bLGOAvailable = true;
	}
	else
	{
		if (StrEqual(name, "readyup", true))
		{
			g_bReadyUpAvailable = true;
		}
		if (StrEqual(name, "pause", true))
		{
			g_bPauseAvailable = true;
		}
	}
	return 0;
}

public OnPluginStart()
{
	HookEvent("round_start", Event_RoundStart, EventHookMode:2);
	HookEvent("player_death", Event_PlayerDeath, EventHookMode:1);
	HookEvent("defibrillator_used", Event_DefibUsed, EventHookMode:1);
	g_hCvarReportMode = CreateConVar("sm_hbonus_report", "2", "The way the bonus is reported. 0: no report; 1: report only on round end; 2: also report after event; 3: also report when event starts; 4: only report on event end", 262144, true, 0.0, false, 0.0);
	g_hCvarPointsMode = CreateConVar("sm_hbonus_pointsmode", "2", "The way the holdout bonus is awarded. 0: disable; 1: leave distance unchanged; 2: substract points from distance.", 262144, true, 0.0, false, 0.0);
	g_hCvarKeyValuesPath = CreateConVar("sm_hbonus_configpath", "configs/holdoutmapinfo.txt", "The path to the holdoutmapinfo.txt with keyvalues for per-map holdout bonus settings.", 262144, false, 0.0, false, 0.0);
	HookConVarChange(g_hCvarKeyValuesPath, ConvarChange_KeyValuesPath);
	g_iTeamSize = 4;
	RegConsoleCmd("sm_hbonus", Cmd_DisplayBonus, "Shows current holdout bonus", 0);
	return 0;
}

public OnPluginEnd()
{
	KV_Close();
	return 0;
}

public OnConfigsExecuted()
{
	g_iTeamSize = GetConVarInt(FindConVar("survivor_limit"));
	KV_Load();
	return 0;
}

public ConvarChange_KeyValuesPath(Handle:convar, String:oldValue[], String:newValue[])
{
	if (g_kHIData)
	{
		KV_Close();
	}
	KV_Load();
	KV_UpdateHoldoutMapInfo();
	return 0;
}

public OnMapStart()
{
	g_bSecondHalf = false;
	KV_UpdateHoldoutMapInfo();
	return 0;
}

public OnMapEnd()
{
	g_bInRound = false;
	if (g_kHIData)
	{
		KvRewind(g_kHIData);
	}
	return 0;
}

public Event_RoundStart(Handle:hEvent, String:name[], bool:dontBroadcast)
{
	if (g_bInRound)
	{
		return 0;
	}
	g_bInRound = true;
	g_bPaused = false;
	ResetTracking();
	if (!g_bSecondHalf)
	{
		CreateTimer(1.0, Timer_SetDisplayPoints, any:0, 2);
	}
	return 0;
}

public Action:Timer_SetDisplayPoints(Handle:timer)
{
	if (g_iHoldoutPointAbsolute)
	{
		g_iPointsBonus = g_iHoldoutPointAbsolute;
	}
	else
	{
		g_iPointsBonus = RoundFloat(float(L4D_GetVersusMaxCompletionScore()) * g_fHoldoutPointFactor);
	}
	return Action:0;
}

public OnRoundIsLive()
{
	RoundReallyStarting();
	return 0;
}

public Action:L4D_OnFirstSurvivorLeftSafeArea(client)
{
	if (!g_bReadyUpAvailable)
	{
		RoundReallyStarting();
	}
	return Action:0;
}

public PBONUS_RequestFinalUpdate(&update)
{
	if (g_bHoldoutActive)
	{
		HoldOutEnds(true);
		update = update + g_iActualBonus;
	}
	return update;
}

public Action:L4D2_OnEndVersusModeRound(bool:countSurvivors)
{
	if (g_bHoldoutThisRound)
	{
		if (g_bHoldoutActive)
		{
			HoldOutEnds(false);
		}
		new iReport = GetConVarInt(g_hCvarReportMode);
		new var1;
		if (iReport && iReport != 4 && GetConVarBool(g_hCvarPointsMode))
		{
			DisplayBonusToAll();
		}
	}
	g_bInRound = false;
	g_bSecondHalf = true;
	g_bPlayersLeftStart = false;
	return Action:0;
}

RoundReallyStarting()
{
	g_bPlayersLeftStart = true;
	if (g_bHoldoutThisRound)
	{
		if (g_bSecondHalf)
		{
			new var1;
			if (GetConVarInt(g_hCvarPointsMode) == 2 && g_iMapDistance - g_iPointsBonus != L4D_GetVersusMaxCompletionScore())
			{
				g_iMapDistance = L4D_GetVersusMaxCompletionScore();
				if (g_iHoldoutPointAbsolute)
				{
					g_iPointsBonus = g_iHoldoutPointAbsolute;
				}
				else
				{
					g_iPointsBonus = RoundFloat(float(g_iMapDistance) * g_fHoldoutPointFactor);
				}
				if (GetConVarInt(g_hCvarPointsMode) == 2)
				{
					L4D_SetVersusMaxCompletionScore(g_iMapDistance - g_iPointsBonus);
				}
			}
		}
		else
		{
			g_iMapDistance = L4D_GetVersusMaxCompletionScore();
			if (g_iHoldoutPointAbsolute)
			{
				g_iPointsBonus = g_iHoldoutPointAbsolute;
			}
			else
			{
				g_iPointsBonus = RoundFloat(float(g_iMapDistance) * g_fHoldoutPointFactor);
			}
			if (GetConVarInt(g_hCvarPointsMode) == 2)
			{
				L4D_SetVersusMaxCompletionScore(g_iMapDistance - g_iPointsBonus);
			}
		}
		Call_StartForward(g_hForwardSet);
		Call_PushCell(g_iPointsBonus);
		Call_PushCell(g_iMapDistance);
		Call_PushCell(g_iHoldoutTime);
		new var2;
		if (GetConVarInt(g_hCvarPointsMode) == 2)
		{
			var2 = MissingTAG:1;
		}
		else
		{
			var2 = MissingTAG:0;
		}
		Call_PushCell(var2);
		Call_Finish(0);
		HookHoldOut();
	}
	return 0;
}

public OnPause()
{
	if (g_bPaused)
	{
		return 0;
	}
	g_bPaused = true;
	g_iPauseStart = GetTime({0,0});
	return 0;
}

public OnUnpause()
{
	g_bPaused = false;
	g_iPauseStart = 0;
	return 0;
}


/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "HoldOutStarts" (number 26)
public HoldOutEnds_Hook(String:output[], caller, activator, Float:delay)
{
	PrintDebug(1, "Holdout Ends (hooked): abs: %i / prg %i / defined %i.", GetTime({0,0}) - g_iHoldoutStartTime, g_iProgress, g_iHoldoutTime);
	if (g_bHoldoutActive)
	{
		g_iProgress = g_iHoldoutTime;
		HoldOutEnds(false);
	}
	return 0;
}

HoldOutEnds(bool:bByRequest)
{
	g_bHoldoutActive = false;
	PrintDebug(1, "Holdout over, awarding bonus: prg %i / defined %i.", g_iProgress, g_iHoldoutTime);
	g_iActualBonus = CalculateHoldOutBonus();
	if (GetConVarBool(g_hCvarPointsMode))
	{
		if (!bByRequest)
		{
			PBONUS_AddRoundBonus(g_iActualBonus);
		}
		if (GetConVarInt(g_hCvarReportMode) > 1)
		{
			DisplayBonusToAll();
		}
	}
	Call_StartForward(g_hForwardEnd);
	Call_PushCell(g_iActualBonus);
	Call_PushCell(g_iProgress);
	Call_Finish(0);
	return 0;
}

public Action:Timer_HoldOutCheck(Handle:timer)
{
	if (!g_bHoldoutActive)
	{
		return Action:4;
	}
	if (g_bPaused)
	{
		return Action:0;
	}
	g_iProgress += 1;
	if (g_iHoldoutTime == g_iProgress)
	{
		HoldOutEnds(false);
		return Action:4;
	}
	return Action:0;
}

HookHoldOut()
{
	new iEntity = -1;
	decl String:sTargetName[128];
	new var1;
	if (strlen(g_sHoldoutStart) || g_iHoldoutStartHamId)
	{
		while ((iEntity = FindEntityByClassname(iEntity, g_sHoldoutStartClass)) != -1)
		{
			if (strlen(g_sHoldoutStart))
			{
				GetEntityName(iEntity, sTargetName, 128);
				if (StrEqual(sTargetName, g_sHoldoutStart, false))
				{
					HookSingleEntityOutput(iEntity, g_sHoldoutStartHook, HoldOutStarts, false);
				}
			}
			else
			{
				new var2;
				if (g_iHoldoutStartHamId && g_iHoldoutStartHamId == GetEntProp(iEntity, PropType:1, "m_iHammerID", 4, 0))
				{
					HookSingleEntityOutput(iEntity, g_sHoldoutStartHook, HoldOutStarts, false);
				}
			}
		}
	}
	new var3;
	if (strlen(g_sHoldoutEnd) || g_iHoldoutEndHamId)
	{
		while ((iEntity = FindEntityByClassname(iEntity, g_sHoldoutEndClass)) != -1)
		{
			if (strlen(g_sHoldoutEnd))
			{
				GetEntityName(iEntity, sTargetName, 128);
				if (StrEqual(sTargetName, g_sHoldoutEnd, false))
				{
					HookSingleEntityOutput(iEntity, g_sHoldoutEndHook, HoldOutEnds_Hook, false);
				}
			}
			else
			{
				new var4;
				if (g_iHoldoutEndHamId && g_iHoldoutEndHamId == GetEntProp(iEntity, PropType:1, "m_iHammerID", 4, 0))
				{
					HookSingleEntityOutput(iEntity, g_sHoldoutEndHook, HoldOutEnds_Hook, false);
				}
			}
		}
	}
	return 0;
}

CalculateHoldOutBonus()
{
	new Float:fBonusPart = float(g_iPointsBonus) / float(4);
	new tmpProg;
	new Float:fBonus = 0.0;
	new chr;
	while (chr < 4)
	{
		if (!(g_iCharProgress[chr] == -1))
		{
			new var1;
			if (g_iCharProgress[chr])
			{
				var1 = g_iCharProgress[chr];
			}
			else
			{
				var1 = g_iProgress;
			}
			tmpProg = var1;
			if (tmpProg != g_iHoldoutTime)
			{
				fBonus += fBonusPart / float(g_iHoldoutTime) * float(tmpProg);
			}
			else
			{
				fBonus += fBonusPart;
			}
		}
		chr++;
	}
	return RoundFloat(fBonus);
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_PlayerDeath" (number 32)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_DefibUsed" (number 33)
public Action:Cmd_DisplayBonus(client, args)
{
	new String:sMsg[128];
	if (!g_bHoldoutThisRound)
	{
		Format(sMsg, 128, "no holdout event this round.");
	}
	else
	{
		if (g_bHoldoutActive)
		{
			Format(sMsg, 128, "\x04%i\x01 out of \x05%i\x01 [\x04%i\x01/\x05%i\x01 sec].", CalculateHoldOutBonus(), g_iPointsBonus, g_iProgress, g_iHoldoutTime);
		}
		if (g_iActualBonus)
		{
			Format(sMsg, 128, "\x04%i\x01 out of \x05%i\x01 [event over].", g_iActualBonus, g_iPointsBonus);
		}
		Format(sMsg, 128, "\x04%i\x01 out of \x05%i\x01 [not started yet].", g_iActualBonus, g_iPointsBonus);
	}
	new var1;
	if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
	{
		PrintToChat(client, "\x01Holdout Bonus: %s", sMsg);
	}
	else
	{
		PrintToServer("\x01Holdout Bonus: %s", sMsg);
	}
	return Action:0;
}

DisplayBonusToAll()
{
	if (g_iActualBonus)
	{
		PrintToChatAll("\x01Holdout Bonus: \x04%i\x01 out of \x05%i\x01.", g_iActualBonus, g_iPointsBonus);
	}
	return 0;
}

KV_Close()
{
	if (g_kHIData)
	{
		CloseHandle(g_kHIData);
		g_kHIData = MissingTAG:0;
		return 0;
	}
	return 0;
}

KV_Load()
{
	decl String:sNameBuff[256];
	GetConVarString(g_hCvarKeyValuesPath, sNameBuff, 256);
	BuildPath(PathType:0, sNameBuff, 256, sNameBuff);
	g_kHIData = CreateKeyValues("HoldoutEvents", "", "");
	if (!FileToKeyValues(g_kHIData, sNameBuff))
	{
		LogError("Couldn't load HoldOutMapInfo data! (file: %s)", sNameBuff);
		KV_Close();
		return 0;
	}
	PrintDebug(1, "Holdout data loaded from file: %s.", sNameBuff);
	return 0;
}

bool:KV_UpdateHoldoutMapInfo()
{
	g_bHoldoutThisRound = false;
	g_fHoldoutPointFactor = 0.0;
	g_iHoldoutPointAbsolute = 0;
	g_iHoldoutTime = 0;
	if (g_kHIData)
	{
		new String:mapname[64];
		GetCurrentMap(mapname, 64);
		if (KvJumpToKey(g_kHIData, mapname, false))
		{
			g_bHoldoutThisRound = KvGetNum(g_kHIData, "holdout", 0);
			g_fHoldoutPointFactor = KvGetFloat(g_kHIData, "pointfactor", 0.0);
			g_iHoldoutPointAbsolute = KvGetNum(g_kHIData, "pointabsolute", 0);
			g_iHoldoutTime = KvGetNum(g_kHIData, "time", 0);
			if (g_bHoldoutThisRound)
			{
				KvGetString(g_kHIData, "t_start", g_sHoldoutStart, 32, "");
				g_iHoldoutStartHamId = KvGetNum(g_kHIData, "t_s_hamid", 0);
				KvGetString(g_kHIData, "t_s_class", g_sHoldoutStartClass, 32, "");
				KvGetString(g_kHIData, "t_s_hook", g_sHoldoutStartHook, 32, "");
				KvGetString(g_kHIData, "t_end", g_sHoldoutEnd, 32, "");
				g_iHoldoutEndHamId = KvGetNum(g_kHIData, "t_e_hamid", 0);
				KvGetString(g_kHIData, "t_e_class", g_sHoldoutEndClass, 32, "");
				KvGetString(g_kHIData, "t_e_hook", g_sHoldoutEndHook, 32, "");
			}
			PrintDebug(1, "Read holdout mapinfo for '%s': %i / (factor: %.2f; abs: %i).", mapname, g_bHoldoutThisRound, g_fHoldoutPointFactor, g_iHoldoutPointAbsolute);
			return true;
		}
		return false;
	}
	return false;
}

ResetTracking()
{
	g_iProgress = 0;
	g_iActualBonus = 0;
	new i;
	while (i < 4)
	{
		g_iCharProgress[i] = 0;
		i++;
	}
	return 0;
}

GetEntityName(iEntity, String:sTargetName[], iSize)
{
	GetEntPropString(iEntity, PropType:1, "m_iName", sTargetName, iSize, 0);
	return 0;
}

GetPlayerCharacter(client)
{
	new tmpChr = GetEntProp(client, PropType:0, "m_survivorCharacter", 4, 0);
	new var1;
	if (tmpChr < 0 || tmpChr >= 4)
	{
		decl String:model[256];
		GetEntPropString(client, PropType:1, "m_ModelName", model, 256, 0);
		if (StrContains(model, "gambler", true) != -1)
		{
			tmpChr = 0;
		}
		else
		{
			if (StrContains(model, "coach", true) != -1)
			{
				tmpChr = 2;
			}
			if (StrContains(model, "mechanic", true) != -1)
			{
				tmpChr = 3;
			}
			if (StrContains(model, "producer", true) != -1)
			{
				tmpChr = 1;
			}
			if (StrContains(model, "namvet", true) != -1)
			{
				tmpChr = 0;
			}
			if (StrContains(model, "teengirl", true) != -1)
			{
				tmpChr = 1;
			}
			if (StrContains(model, "biker", true) != -1)
			{
				tmpChr = 3;
			}
			if (StrContains(model, "manager", true) != -1)
			{
				tmpChr = 2;
			}
			tmpChr = 0;
		}
	}
	return tmpChr;
}

PrintDebug(debugLevel, String:Message[])
{
	decl String:DebugBuff[256];
	VFormat(DebugBuff, 256, Message, 3);
	LogMessage(DebugBuff);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "12/10/2015",
	time = "12:51:19"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:sHunterSound[7][192] =
{
	"player/hunter/voice/idle/hunter_stalk_01.wav",
	"player/hunter/voice/idle/hunter_stalk_04.wav",
	"player/hunter/voice/idle/hunter_stalk_05.wav",
	"player/hunter/voice/idle/hunter_stalk_06.wav",
	"player/hunter/voice/idle/hunter_stalk_07.wav",
	"player/hunter/voice/idle/hunter_stalk_08.wav",
	"player/hunter/voice/idle/hunter_stalk_09.wav"
};
new bool:isHunter[65];
public Plugin:myinfo =
{
	name = "Hunter Crouch Sounds",
	description = "Forces silent but crouched hunters to emitt sounds",
	author = "High Cookie",
	version = "",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

GetClientButtons(client)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_nButtons", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_nButtons");
		}
		gotconfig = true;
	}
	return GetEntProp(client, PropType:1, datamap, 4, 0);
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_spawn", Event_PlayerSpawn, EventHookMode:1);
	HookEvent("player_death", Event_PlayerDeath, EventHookMode:1);
	HookEvent("bot_player_replace", Event_BotPlayerReplace, EventHookMode:1);
	return 0;
}

public OnMapStart()
{
	new i;
	while (i <= 6)
	{
		PrefetchSound(sHunterSound[i]);
		PrecacheSound(sHunterSound[i], true);
		i++;
	}
	return 0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_PlayerSpawn" (number 5)
public Action:HunterCrouchTracking(Handle:timer, any:client)
{
	if (GetClientButtons(client) == 4)
	{
		return Action:0;
	}
	new ducked = GetEntProp(client, PropType:0, "m_bDucked", 4, 0);
	if (ducked)
	{
		new rndPick = GetRandomInt(0, 6);
		EmitSoundToAll(sHunterSound[rndPick], client, 2, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
	}
	if (!isHunter[client])
	{
		return Action:4;
	}
	return Action:0;
}

public Action:Event_PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetEventInt(event, "userid");
	new client = GetClientOfUserId(victim);
	isHunter[client] = 0;
	return Action:0;
}

public Action:Event_BotPlayerReplace(Handle:event, String:name[], bool:dontBroadcast)
{
	new player = GetEventInt(event, "player");
	new client = GetClientOfUserId(player);
	isHunter[client] = 0;
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.5.0-dev+3690",
	date = "02/03/2013",
	time = "08:46:22"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Infected Flow Warp",
	description = "Allows infected to warp to survivors based on their flow",
	author = "CanadaRox",
	version = "1",
	url = "htts://github.com/CanadaRox/sourcemod-plugins/tree/master/infected_flow_warp"
};
new Handle:hNameToCharIDTrie;
new Handle:hFlowArray;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator<(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) < 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Float:L4D2Direct_GetFlowDistance(client)
{
	static Handle:GetFlowDistanceSDKCall;
	if (!GetFlowDistanceSDKCall)
	{
		StartPrepSDKCall(SDKCallType:2);
		if (!PrepSDKCall_SetFromConf(L4D2Direct_GetGameConf(), SDKFuncConfSource:1, "CTerrorPlayer::GetFlowDistance"))
		{
			return 0.0;
		}
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		PrepSDKCall_SetReturnInfo(SDKType:5, SDKPassMethod:1, 0, 0);
		GetFlowDistanceSDKCall = EndPrepSDKCall();
		if (!GetFlowDistanceSDKCall)
		{
			return 0.0;
		}
	}
	return SDKCall(GetFlowDistanceSDKCall, client, 0);
}

public OnPluginStart()
{
	PrepTries();
	hFlowArray = CreateArray(2, 0);
	RegConsoleCmd("sm_warpto", WarpTo_Cmd, "Warps to the specified survivor", 0);
	return 0;
}

PrepTries()
{
	hNameToCharIDTrie = CreateTrie();
	SetTrieValue(hNameToCharIDTrie, "bill", any:0, true);
	SetTrieValue(hNameToCharIDTrie, "zoey", any:1, true);
	SetTrieValue(hNameToCharIDTrie, "louis", any:2, true);
	SetTrieValue(hNameToCharIDTrie, "francis", any:3, true);
	SetTrieValue(hNameToCharIDTrie, "nick", any:0, true);
	SetTrieValue(hNameToCharIDTrie, "rochelle", any:1, true);
	SetTrieValue(hNameToCharIDTrie, "coach", any:2, true);
	SetTrieValue(hNameToCharIDTrie, "ellis", any:3, true);
	return 0;
}

public Action:WarpTo_Cmd(client, args)
{
	if (!IsGhostInfected(client))
	{
		return Action:3;
	}
	if (args != 1)
	{
		ReplyToCommand(client, "Usage: sm_warpto <#|name> (name must be lowercase)");
		return Action:3;
	}
	decl String:arg[12];
	decl survivorFlowRank;
	GetCmdArg(1, arg, 12);
	survivorFlowRank = StringToInt(arg, 10);
	if (survivorFlowRank)
	{
		decl Float:origin[3];
		GetClientAbsOrigin(GetSurvivorOfFlowRank(survivorFlowRank), origin);
		TeleportEntity(client, origin, NULL_VECTOR, NULL_VECTOR);
	}
	else
	{
		decl target;
		if (GetTrieValue(hNameToCharIDTrie, arg, target))
		{
			target = GetClientOfCharID(target);
			decl Float:origin[3];
			GetClientAbsOrigin(target, origin);
			TeleportEntity(client, origin, NULL_VECTOR, NULL_VECTOR);
		}
	}
	return Action:3;
}

GetSurvivorOfFlowRank(rank)
{
	decl survFlowEnum:currentSurv[2];
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && GetClientTeam(client) == 2 && IsPlayerAlive(client))
		{
			currentSurv[0] = client;
			currentSurv[1] = L4D2Direct_GetFlowDistance(client);
			PushArrayArray(hFlowArray, currentSurv, -1);
		}
		client++;
	}
	SortADTArrayCustom(hFlowArray, sortFunc, Handle:0);
	new arraySize = GetArraySize(hFlowArray);
	if (rank + -1 > arraySize)
	{
		rank = arraySize;
	}
	GetArrayArray(hFlowArray, rank + -1, currentSurv, -1);
	ClearArray(hFlowArray);
	return currentSurv[0];
}

public sortFunc(index1, index2, Handle:array, Handle:hndl)
{
	decl item1[2];
	decl item2[2];
	if (item1[1] > item2[1])
	{
		return -1;
	}
	if (item1[1] < item2[1])
	{
		return 1;
	}
	return 0;
}

GetClientOfCharID(characterID)
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && GetClientTeam(client) == 2)
		{
			if (characterID == GetEntProp(client, PropType:0, "m_survivorCharacter", 4, 0))
			{
				return client;
			}
		}
		client++;
	}
	return 0;
}

IsGhostInfected(client)
{
	new var1;
	return GetClientTeam(client) == 3 && IsPlayerAlive(client) && GetEntProp(client, PropType:0, "m_isGhost", 4, 0);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.2",
	date = "06/27/2012",
	time = "22:57:31"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new Handle:hFwdRoundStart;
new Handle:hFwdRoundEnd;
new iRoundNumber;
new bool:bInRound;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_confogl =
{
	name = "confogl",
	file = "confoglcompmod.smx",
	required = 0,
};
new String:MAPINFO_PATH[28] = "configs/l4d2lib/mapinfo.txt";
new bool:confogl_available;
new Handle:kMIData;
new bool:MapDataAvailable;
new Float:Start_Point[3];
new Float:End_Point[3];
new Float:Start_Dist;
new Float:Start_Extra_Dist;
new Float:End_Dist;
new iIsInEditMode[65];
new Float:fLocTemp[65][3];
new Handle:hFwdFirstTankSpawn;
new Handle:hFwdTankPassControl;
new Handle:hFwdTankDeath;
new Handle:hTankDeathTimer;
new bool:bIsTankActive;
new iTankClient = -1;
new iTankPassCount;
new iSurvivorIndex[65];
new iSurvivorCount;
public Plugin:myinfo =
{
	name = "L4D2Lib",
	description = "Useful natives and fowards for L4D2 Plugins",
	author = "Confogl Team",
	version = "1.0",
	url = "https://bitbucket.org/ProdigySim/misc-sourcemod-plugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator<=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) <= 0;
}

ScaleVector(Float:vec[3], Float:scale)
{
	new var1 = vec;
	var1[0] = var1[0] * scale;
	vec[1] *= scale;
	vec[2] *= scale;
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Rounds_OnRoundStart_Update()
{
	if (!bInRound)
	{
		bInRound = true;
		iRoundNumber += 1;
		Call_StartForward(hFwdRoundStart);
		Call_PushCell(iRoundNumber);
		Call_Finish(0);
	}
	return 0;
}

Rounds_OnRoundEnd_Update()
{
	if (bInRound)
	{
		bInRound = false;
		Call_StartForward(hFwdRoundEnd);
		Call_PushCell(iRoundNumber);
		Call_Finish(0);
	}
	return 0;
}

Rounds_OnMapEnd_Update()
{
	iRoundNumber = 0;
	bInRound = false;
	return 0;
}

GetCurrentRound()
{
	return iRoundNumber;
}

bool:CurrentlyInRound()
{
	return bInRound;
}

public __pl_confogl_SetNTVOptional()
{
	MarkNativeAsOptional("LGO_BuildConfigPath");
	MarkNativeAsOptional("LGO_ExecuteConfigCfg");
	MarkNativeAsOptional("LGO_IsMapDataAvailable");
	MarkNativeAsOptional("LGO_GetMapValueInt");
	MarkNativeAsOptional("LGO_GetMapValueFloat");
	MarkNativeAsOptional("LGO__GetMapValueVector");
	MarkNativeAsOptional("LGO_GetMapValueString");
	MarkNativeAsOptional("LGO_CopyMapSubsection");
	return 0;
}

MapInfo_Init()
{
	confogl_available = LibraryExists("confogl");
	MI_KV_Load();
	RegAdminCmd("confogl_midata_save", MI_KV_CmdSave, 256, "", "", 0);
	RegAdminCmd("confogl_save_location", MI_KV_CmdSaveLoc, 256, "", "", 0);
	return 0;
}

MapInfo_OnMapStart_Update()
{
	MI_KV_UpdateMapInfo();
	return 0;
}

MapInfo_OnMapEnd_Update()
{
	KvRewind(kMIData);
	MapDataAvailable = false;
	new i;
	while (i < 65)
	{
		iIsInEditMode[i] = 0;
		i++;
	}
	return 0;
}

MapInfo_OnPluginEnd()
{
	MI_KV_Close();
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "confogl", true))
	{
		confogl_available = false;
		MI_KV_Close();
		MI_KV_Load();
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "confogl", true))
	{
		confogl_available = true;
		MI_KV_Close();
		MI_KV_Load();
	}
	return 0;
}

MapInfo_PlayerDisconnect_Event(Handle:event)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client > -1 && client < 65)
	{
		iIsInEditMode[client] = 0;
	}
	return 0;
}

public Action:MI_KV_CmdSave(client, args)
{
	decl String:sCurMap[128];
	GetCurrentMap(sCurMap, 128);
	if (KvJumpToKey(kMIData, sCurMap, true))
	{
		KvSetVector(kMIData, "start_point", Start_Point);
		KvSetFloat(kMIData, "start_dist", Start_Dist);
		KvSetFloat(kMIData, "start_extra_dist", Start_Extra_Dist);
		decl String:sNameBuff[256];
		if (confogl_available)
		{
			LGO_BuildConfigPath(sNameBuff, 256, "mapinfo.txt");
		}
		else
		{
			BuildPath(PathType:0, sNameBuff, 256, MAPINFO_PATH);
		}
		KvRewind(kMIData);
		KeyValuesToFile(kMIData, sNameBuff);
		ReplyToCommand(client, "%s has been added to %s.", sCurMap, sNameBuff);
	}
	return Action:0;
}

public Action:MI_KV_CmdSaveLoc(client, args)
{
	new bool:updateinfo;
	decl String:sCurMap[128];
	GetCurrentMap(sCurMap, 128);
	if (!iIsInEditMode[client])
	{
		if (!args)
		{
			ReplyToCommand(client, "Move to the location of the medkits, then enter the point type (start_point or end_point)");
			return Action:3;
		}
		decl String:sBuffer[16];
		GetCmdArg(1, sBuffer, 16);
		if (StrEqual(sBuffer, "start_point", true))
		{
			iIsInEditMode[client] = 1;
			ReplyToCommand(client, "Move a few feet from the medkits and enter this command again to set the start_dist for this point");
		}
		else
		{
			if (StrEqual(sBuffer, "end_point", true))
			{
				iIsInEditMode[client] = 2;
				ReplyToCommand(client, "Move to the farthest point in the saferoom and enter this command again to set the end_dist for this point");
			}
			ReplyToCommand(client, "Please enter the location type: start_point, end_point");
			return Action:3;
		}
		if (KvJumpToKey(kMIData, sCurMap, true))
		{
			GetClientAbsOrigin(client, fLocTemp[client]);
			KvSetVector(kMIData, sBuffer, fLocTemp[client]);
		}
		updateinfo = true;
	}
	else
	{
		if (iIsInEditMode[client] == 1)
		{
			iIsInEditMode[client] = 3;
			decl Float:fDistLoc[3];
			decl Float:fDistance;
			GetClientAbsOrigin(client, fDistLoc);
			fDistance = GetVectorDistance(fDistLoc, fLocTemp[client], false);
			if (KvJumpToKey(kMIData, sCurMap, true))
			{
				KvSetFloat(kMIData, "start_dist", fDistance);
			}
			ReplyToCommand(client, "Move to the farthest point in the saferoom and enter this command again to set start_extra_dist for this point");
			updateinfo = true;
		}
		if (iIsInEditMode[client] == 2)
		{
			iIsInEditMode[client] = 0;
			decl Float:fDistLoc[3];
			decl Float:fDistance;
			GetClientAbsOrigin(client, fDistLoc);
			fDistance = GetVectorDistance(fDistLoc, fLocTemp[client], false);
			if (KvJumpToKey(kMIData, sCurMap, true))
			{
				KvSetFloat(kMIData, "end_dist", fDistance);
			}
			updateinfo = true;
		}
		if (iIsInEditMode[client] == 3)
		{
			iIsInEditMode[client] = 0;
			decl Float:fDistLoc[3];
			decl Float:fDistance;
			GetClientAbsOrigin(client, fDistLoc);
			fDistance = GetVectorDistance(fDistLoc, fLocTemp[client], false);
			if (KvJumpToKey(kMIData, sCurMap, true))
			{
				KvSetFloat(kMIData, "start_extra_dist", fDistance);
			}
			updateinfo = true;
		}
	}
	if (updateinfo)
	{
		decl String:sNameBuff[256];
		if (confogl_available)
		{
			LGO_BuildConfigPath(sNameBuff, 256, "mapinfo.txt");
		}
		else
		{
			BuildPath(PathType:0, sNameBuff, 256, MAPINFO_PATH);
		}
		KvRewind(kMIData);
		KeyValuesToFile(kMIData, sNameBuff);
		ReplyToCommand(client, "mapinfo.txt has been updated!");
	}
	return Action:3;
}

MI_KV_Close()
{
	if (kMIData)
	{
		CloseHandle(kMIData);
		kMIData = MissingTAG:0;
		return 0;
	}
	return 0;
}

MI_KV_Load()
{
	decl String:sNameBuff[256];
	kMIData = CreateKeyValues("MapInfo", "", "");
	if (confogl_available)
	{
		LGO_BuildConfigPath(sNameBuff, 256, "mapinfo.txt");
	}
	else
	{
		BuildPath(PathType:0, sNameBuff, 256, MAPINFO_PATH);
	}
	if (!FileToKeyValues(kMIData, sNameBuff))
	{
		LogError("[MI] Couldn't load MapInfo data!");
		MI_KV_Close();
		return 0;
	}
	return 0;
}

MI_KV_UpdateMapInfo()
{
	decl String:sCurMap[128];
	GetCurrentMap(sCurMap, 128);
	if (KvJumpToKey(kMIData, sCurMap, false))
	{
		KvGetVector(kMIData, "start_point", Start_Point, 2716);
		KvGetVector(kMIData, "end_point", End_Point, 2716);
		Start_Dist = KvGetFloat(kMIData, "start_dist", 0.0);
		Start_Extra_Dist = KvGetFloat(kMIData, "start_extra_dist", 0.0);
		End_Dist = KvGetFloat(kMIData, "end_dist", 0.0);
		MapDataAvailable = true;
	}
	else
	{
		MapDataAvailable = false;
		Start_Dist = FindStartPointHeuristic(Start_Point);
		if (Start_Dist > 0.0)
		{
			Start_Extra_Dist = 500.0;
		}
		else
		{
			Start_Dist = -1.0;
			Start_Extra_Dist = -1.0;
		}
		End_Dist = -1.0;
		LogMessage("[MI] MapInfo for %s is missing.", sCurMap);
	}
	return 0;
}

Float:FindStartPointHeuristic(Float:result[3])
{
	new kits;
	new Float:kitOrigin[4][3] = {
		{
			1885431159, 1717530223, 1953722985
		},
		{
			1684627807, 1953065823, 1634759519
		},
		{
			28279, 1702256493, 1769099107
		},
		{
			7235943, 1702256493, 1769099107
		}
	};
	new Float:averageOrigin[3] = 0.0;
	new entcount = GetEntityCount();
	decl String:entclass[128];
	new iEntity = 1;
	while (iEntity <= entcount && kits < 4)
	{
		new var2;
		if (!IsValidEdict(iEntity) || !IsValidEntity(iEntity))
		{
		}
		else
		{
			GetEdictClassname(iEntity, entclass, 128);
			if (StrEqual(entclass, "weapon_first_aid_kit_spawn", true))
			{
				GetEntPropVector(iEntity, PropType:0, "m_vecOrigin", kitOrigin[kits], 0);
				averageOrigin[0] = averageOrigin[0] + kitOrigin[kits][0];
				new var3 = averageOrigin[1];
				var3 = kitOrigin[kits][1][var3];
				new var4 = averageOrigin[2];
				var4 = kitOrigin[kits][2][var4];
				kits++;
			}
		}
		iEntity++;
	}
	if (kits < 4)
	{
		return -1.0;
	}
	ScaleVector(averageOrigin, 0.25);
	new Float:greatestDist = 0.0;
	new Float:tempDist = 0.0;
	new i;
	while (i < 4)
	{
		tempDist = GetVectorDistance(averageOrigin, kitOrigin[i], false);
		if (tempDist > greatestDist)
		{
			greatestDist = tempDist;
		}
		i++;
	}
	return greatestDist + 1.0;
}

bool:IsMapDataAvailable()
{
	return MapDataAvailable;
}

Saferoom:IsEntityInSaferoom(ent)
{
	new Saferoom:result;
	decl Float:origins[3];
	GetEntPropVector(ent, PropType:0, "m_vecOrigin", origins, 0);
	new var1;
	if (Start_Extra_Dist > Start_Dist)
	{
		var1 = Start_Extra_Dist;
	}
	else
	{
		var1 = Start_Dist;
	}
	if (GetVectorDistance(origins, Start_Point, false) <= var1)
	{
		result |= 1;
	}
	if (GetVectorDistance(origins, End_Point, false) <= End_Dist)
	{
		result |= 2;
	}
	return result;
}

GetMapValueInt(String:key[], defvalue)
{
	return KvGetNum(kMIData, key, defvalue);
}

Float:GetMapValueFloat(String:key[], Float:defvalue)
{
	return KvGetFloat(kMIData, key, defvalue);
}

GetMapValueVector(String:key[], Float:vector[3], Float:defvalue[3])
{
	KvGetVector(kMIData, key, vector, defvalue);
	return 0;
}

GetMapValueString(String:key[], String:value[], maxlength, String:defvalue[])
{
	KvGetString(kMIData, key, value, maxlength, defvalue);
	return 0;
}

CopyMapSubsection(Handle:kv, String:section[])
{
	if (KvJumpToKey(kMIData, section, false))
	{
		KvCopySubkeys(kMIData, kv);
		KvGoBack(kMIData);
	}
	return 0;
}

GetMapStartOrigin(Float:origin[3])
{
	return 0;
}

GetMapEndOrigin(Float:origin[3])
{
	return 0;
}

Float:GetMapEndDist()
{
	return End_Dist;
}

Float:GetMapStartDist()
{
	return Start_Dist;
}

Float:GetMapStartExtraDist()
{
	return Start_Extra_Dist;
}

ResetStatus()
{
	bIsTankActive = false;
	iTankClient = -1;
	iTankPassCount = 0;
	if (hTankDeathTimer)
	{
		KillTimer(hTankDeathTimer, false);
		hTankDeathTimer = MissingTAG:0;
	}
	return 0;
}

Tanks_OnMapStart()
{
	ResetStatus();
	return 0;
}

Tanks_RoundStart()
{
	ResetStatus();
	return 0;
}

Tanks_TankSpawn(Handle:event)
{
	if (bIsTankActive)
	{
		return 0;
	}
	bIsTankActive = true;
	iTankClient = GetClientOfUserId(GetEventInt(event, "userid"));
	Call_StartForward(hFwdFirstTankSpawn);
	Call_PushCell(iTankClient);
	Call_Finish(0);
	return 0;
}

Tanks_ItemPickup(Handle:event)
{
	if (!bIsTankActive)
	{
		return 0;
	}
	decl String:item[64];
	GetEventString(event, "item", item, 64);
	if (StrEqual(item, "tank_claw", true))
	{
		new iPrevTank = iTankClient;
		iTankClient = GetClientOfUserId(GetEventInt(event, "userid"));
		if (hTankDeathTimer)
		{
			KillTimer(hTankDeathTimer, false);
			hTankDeathTimer = MissingTAG:0;
		}
		Call_StartForward(hFwdTankPassControl);
		Call_PushCell(iPrevTank);
		Call_PushCell(iTankClient);
		Call_PushCell(iTankPassCount);
		Call_Finish(0);
		iTankPassCount += 1;
	}
	return 0;
}

Tanks_PlayerDeath(Handle:event)
{
	if (!bIsTankActive)
	{
		return 0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (iTankClient != client)
	{
		return 0;
	}
	hTankDeathTimer = CreateTimer(0.5, TankDeath_Timer, any:0, 0);
	return 0;
}

public Action:TankDeath_Timer(Handle:timer)
{
	Call_StartForward(hFwdTankDeath);
	Call_PushCell(iTankClient);
	Call_Finish(0);
	ResetStatus();
	return Action:0;
}

Survivors_RebuildArray_Delay()
{
	CreateTimer(0.3, BuildArray_Timer, any:0, 0);
	return 0;
}

public Action:BuildArray_Timer(Handle:timer)
{
	Survivors_RebuildArray();
	return Action:0;
}

Survivors_RebuildArray()
{
	if (!IsServerProcessing())
	{
		return 0;
	}
	iSurvivorCount = 0;
	new i;
	while (i < 65)
	{
		iSurvivorIndex[i] = 0;
		i++;
	}
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && GetClientTeam(i) == 2 && IsPlayerAlive(i))
		{
			iSurvivorIndex[iSurvivorCount] = i;
			iSurvivorCount += 1;
		}
		i++;
	}
	return 0;
}

GetSurvivorCount()
{
	return iSurvivorCount;
}

GetSurvivorOfIndex(index)
{
	return iSurvivorIndex[index];
}

public OnPluginStart()
{
	HookEvent("round_start", RoundStart_Event, EventHookMode:2);
	HookEvent("round_end", RoundEnd_Event, EventHookMode:2);
	HookEvent("tank_spawn", TankSpawn_Event, EventHookMode:1);
	HookEvent("item_pickup", ItemPickup_Event, EventHookMode:1);
	HookEvent("player_death", PlayerDeath_Event, EventHookMode:1);
	HookEvent("round_start", RoundStart_Event, EventHookMode:2);
	HookEvent("player_spawn", PlayerSpawn_Event, EventHookMode:2);
	HookEvent("player_disconnect", PlayerDisconnect_Event, EventHookMode:2);
	HookEvent("player_bot_replace", PlayerBotReplace_Event, EventHookMode:2);
	HookEvent("bot_player_replace", BotPlayerReplace_Event, EventHookMode:2);
	HookEvent("defibrillator_used", DefibrillatorUsed_Event, EventHookMode:2);
	HookEvent("player_team", PlayerTeam_Event, EventHookMode:2);
	MapInfo_Init();
	return 0;
}

public OnPluginEnd()
{
	MapInfo_OnPluginEnd();
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	CreateNative("L4D2_GetCurrentRound", _native_GetCurrentRound);
	CreateNative("L4D2_CurrentlyInRound", _native_CurrentlyInRound);
	CreateNative("L4D2_GetSurvivorCount", _native_GetSurvivorCount);
	CreateNative("L4D2_GetSurvivorOfIndex", _native_GetSurvivorOfIndex);
	CreateNative("L4D2_IsMapDataAvailable", _native_IsMapDataAvailable);
	CreateNative("L4D2_IsEntityInSaferoom", _native_IsEntityInSaferoom);
	CreateNative("L4D2_GetMapStartOrigin", _native_GetMapStartOrigin);
	CreateNative("L4D2_GetMapEndOrigin", _native_GetMapEndOrigin);
	CreateNative("L4D2_GetMapStartDistance", _native_GetMapStartDist);
	CreateNative("L4D2_GetMapStartExtraDistance", _native_GetMapStartExtraDist);
	CreateNative("L4D2_GetMapEndDistance", _native_GetMapEndDist);
	CreateNative("L4D2_GetMapValueInt", _native_GetMapValueInt);
	CreateNative("L4D2_GetMapValueFloat", _native_GetMapValueFloat);
	CreateNative("L4D2_GetMapValueVector", _native_GetMapValueVector);
	CreateNative("L4D2_GetMapValueString", _native_GetMapValueString);
	CreateNative("L4D2_CopyMapSubsection", _native_CopyMapSubsection);
	hFwdRoundStart = CreateGlobalForward("L4D2_OnRealRoundStart", ExecType:0, 2);
	hFwdRoundEnd = CreateGlobalForward("L4D2_OnRealRoundEnd", ExecType:0, 2);
	hFwdFirstTankSpawn = CreateGlobalForward("L4D2_OnTankFirstSpawn", ExecType:0, 2);
	hFwdTankPassControl = CreateGlobalForward("L4D2_OnTankPassControl", ExecType:0, 2, 2, 2);
	hFwdTankDeath = CreateGlobalForward("L4D2_OnTankDeath", ExecType:0, 2);
	RegPluginLibrary("l4d2lib");
	return APLRes:0;
}

public OnMapStart()
{
	MapInfo_OnMapStart_Update();
	Tanks_OnMapStart();
	return 0;
}

public OnMapEnd()
{
	MapInfo_OnMapEnd_Update();
	Rounds_OnMapEnd_Update();
	return 0;
}

public Action:RoundEnd_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Rounds_OnRoundEnd_Update();
	return Action:0;
}

public Action:RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Rounds_OnRoundStart_Update();
	Tanks_RoundStart();
	Survivors_RebuildArray();
	return Action:0;
}

public Action:TankSpawn_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Tanks_TankSpawn(event);
	return Action:0;
}

public Action:ItemPickup_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Tanks_ItemPickup(event);
	return Action:0;
}

public Action:PlayerDeath_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Tanks_PlayerDeath(event);
	Survivors_RebuildArray();
	return Action:0;
}

public Action:PlayerSpawn_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Survivors_RebuildArray();
	return Action:0;
}

public Action:PlayerDisconnect_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Survivors_RebuildArray();
	MapInfo_PlayerDisconnect_Event(event);
	return Action:0;
}

public Action:PlayerBotReplace_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Survivors_RebuildArray();
	return Action:0;
}

public Action:BotPlayerReplace_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Survivors_RebuildArray();
	return Action:0;
}

public Action:DefibrillatorUsed_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Survivors_RebuildArray();
	return Action:0;
}

public Action:PlayerTeam_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	Survivors_RebuildArray_Delay();
	return Action:0;
}

public _native_GetCurrentRound(Handle:plugin, numParams)
{
	return GetCurrentRound();
}

public _native_CurrentlyInRound(Handle:plugin, numParams)
{
	return CurrentlyInRound();
}

public _native_GetSurvivorCount(Handle:plugin, numParams)
{
	return GetSurvivorCount();
}

public _native_GetSurvivorOfIndex(Handle:plugins, numParams)
{
	return GetSurvivorOfIndex(GetNativeCell(1));
}

public _native_IsMapDataAvailable(Handle:plugin, numParams)
{
	return IsMapDataAvailable();
}

public _native_IsEntityInSaferoom(Handle:plugin, numParams)
{
	return IsEntityInSaferoom(GetNativeCell(1));
}

public _native_GetMapStartOrigin(Handle:plugin, numParams)
{
	decl Float:origin[3];
	GetNativeArray(1, origin, 3);
	GetMapStartOrigin(origin);
	SetNativeArray(1, origin, 3);
	return 0;
}

public _native_GetMapEndOrigin(Handle:plugin, numParams)
{
	decl Float:origin[3];
	GetNativeArray(1, origin, 3);
	GetMapEndOrigin(origin);
	SetNativeArray(1, origin, 3);
	return 0;
}

public _native_GetMapStartDist(Handle:plugin, numParams)
{
	return GetMapStartDist();
}

public _native_GetMapStartExtraDist(Handle:plugin, numParams)
{
	return GetMapStartExtraDist();
}

public _native_GetMapEndDist(Handle:plugin, numParams)
{
	return GetMapEndDist();
}

public _native_GetMapValueInt(Handle:plugin, numParams)
{
	decl len;
	decl defval;
	GetNativeStringLength(1, len);
	new key[len + 1];
	GetNativeString(1, key, len + 1, 0);
	defval = GetNativeCell(2);
	return GetMapValueInt(key, defval);
}

public _native_GetMapValueFloat(Handle:plugin, numParams)
{
	decl len;
	decl Float:defval;
	GetNativeStringLength(1, len);
	new key[len + 1];
	GetNativeString(1, key, len + 1, 0);
	defval = GetNativeCell(2);
	return GetMapValueFloat(key, defval);
}

public _native_GetMapValueVector(Handle:plugin, numParams)
{
	decl len;
	decl Float:defval[3];
	decl Float:value[3];
	GetNativeStringLength(1, len);
	new key[len + 1];
	GetNativeString(1, key, len + 1, 0);
	GetNativeArray(3, defval, 3);
	GetMapValueVector(key, value, defval);
	SetNativeArray(2, value, 3);
	return 0;
}

public _native_GetMapValueString(Handle:plugin, numParams)
{
	decl len;
	GetNativeStringLength(1, len);
	new key[len + 1];
	GetNativeString(1, key, len + 1, 0);
	GetNativeStringLength(4, len);
	new defval[len + 1];
	GetNativeString(4, defval, len + 1, 0);
	len = GetNativeCell(3);
	new buf[len + 1];
	GetMapValueString(key, buf, len, defval);
	SetNativeString(2, buf, len, true, 0);
	return 0;
}

public _native_CopyMapSubsection(Handle:plugin, numParams)
{
	decl len;
	decl Handle:kv;
	GetNativeStringLength(2, len);
	new key[len + 1];
	GetNativeString(2, key, len + 1, 0);
	kv = GetNativeCell(1);
	CopyMapSubsection(kv, key);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+3944",
	date = "07/17/2013",
	time = "21:38:14"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new String:L4D2_InfectedNames[8][32];
new String:MeleeWeaponModels[15][];
new String:MeleeWeaponNames[15][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1414218835, 1936486255, 0, 1953195123, 1936486255, 1954047278, 0, 1164, 1176, 1, 1, 1870290797, 1701405293, 1935764547, 115, 1886351984, 2036887647, 1935894899, 0, 1634230125, 1851872371, 1869367147, 119, 1886351984, 1918985055, 1634492767, 28018, 0, 0, 0, 1867673167, 1399090805, 1953653108, 0, 1867673167, 1164209781, 25710, 0, 0, 0, 0, 0, 1886351984, 2036887647, 1935894899, 0, 1766354511, 1417233012, 7040609, 1886351984, 1634492767, 1667198322, 29281, 1766354511, 1417233012, 7040609
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new Handle:hSurvivorModelsTrie = 1886351984;
new bool:bInRound;
new Handle:hMeleeWeaponModelsTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hWeaponNamesTrie;
new Handle:hFwdOnRoundStart;
new Handle:hFwdOnRoundEnd;
new Handle:hFwdOnTankPunchHittable;
new Handle:hFwdOnTankSpawn;
new Handle:hFwdOnTankPass;
new Handle:hFwdOnTankDeath;
new Handle:hTankClients;
new String:sLibraryName[12] = "l4d2util";
public Plugin:myinfo =
{
	name = "L4D2 Utilities",
	description = "Useful functions and forwards for Left 4 Dead 2 SourceMod plugins",
	author = "Confogl Team",
	version = "1.0",
	url = "https://github.com/ConfoglTeam/l4d2util"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

L4D2_Infected:GetInfectedClass(client)
{
	return GetEntProp(client, PropType:0, L4D2_InfectedTimerEntities, 4, 0);
}

bool:IsTank(client)
{
	new var1;
	return IsClientInGame(client) && GetClientTeam(client) == 3 && GetInfectedClass(client) == 8;
}

bool:IsTankHittable(iEntity)
{
	if (!IsValidEntity(iEntity))
	{
		return false;
	}
	decl String:className[64];
	GetEdictClassname(iEntity, className, 64);
	if (StrEqual(className, hSurvivorModelsTrie, true))
	{
		if (GetEntProp(iEntity, PropType:0, "m_hasTankGlow", 1, 0))
		{
			return true;
		}
	}
	else
	{
		if (StrEqual(className, "prop_car_alarm", true))
		{
			return true;
		}
	}
	return false;
}

FindTankClient(iTankClient)
{
	decl i;
	new var1;
	if (iTankClient < 0)
	{
		var1 = 1;
	}
	else
	{
		var1 = iTankClient + 1;
	}
	i = var1;
	while (MaxClients + 1 > i)
	{
		if (IsTank(i))
		{
			return i;
		}
		i++;
	}
	return -1;
}

NumTanksInPlay()
{
	new count;
	new client = -1;
	while ((client = FindTankClient(client)) != -1)
	{
		count++;
	}
	return count;
}

L4D2Util_Rounds_OnMapEnd()
{
	bInRound = false;
	return 0;
}

L4D2Util_Rounds_OnRoundStart()
{
	if (!bInRound)
	{
		bInRound = true;
		Call_StartForward(hFwdOnRoundStart);
		Call_Finish(0);
	}
	return 0;
}

L4D2Util_Rounds_OnRoundEnd()
{
	if (bInRound)
	{
		bInRound = false;
		Call_StartForward(hFwdOnRoundEnd);
		Call_Finish(0);
	}
	return 0;
}

L4D2Util_Rounds_CreateForwards()
{
	hFwdOnRoundStart = CreateGlobalForward("OnRoundStart", ExecType:0);
	hFwdOnRoundEnd = CreateGlobalForward("OnRoundEnd", ExecType:0);
	return 0;
}

AddTankToArray(client)
{
	PushArrayCell(hTankClients, client);
	return 0;
}

RemoveTankFromArray(client)
{
	new i;
	while (GetArraySize(hTankClients) > i)
	{
		if (client == GetArrayCell(hTankClients, i, 0, false))
		{
			RemoveFromArray(hTankClients, i);
		}
		i++;
	}
	return 0;
}

bool:FindTankInArray(client)
{
	new i;
	while (GetArraySize(hTankClients) > i)
	{
		if (client == GetArrayCell(hTankClients, i, 0, false))
		{
			return true;
		}
		i++;
	}
	return false;
}

L4D2Util_Tanks_Init()
{
	hTankClients = CreateArray(1, 0);
	return 0;
}

L4D2Util_Tanks_OnRoundStart()
{
	ClearArray(hTankClients);
	CreateTimer(0.1, L4D2Util_Tanks_HookProps, any:0, 0);
	return 0;
}

public Action:L4D2Util_Tanks_HookProps(Handle:hTimer)
{
	new iEntity = -1;
	while ((iEntity = FindEntityByClassname(iEntity, "prop_physics")) != -1)
	{
		if (IsTankHittable(iEntity))
		{
			HookSingleEntityOutput(iEntity, "OnHitByTank", TankHittablePunched, false);
		}
	}
	iEntity = -1;
	while ((iEntity = FindEntityByClassname(iEntity, "prop_alarm_car")) != -1)
	{
		HookSingleEntityOutput(iEntity, "OnHitByTank", TankHittablePunched, false);
	}
	return Action:0;
}

public TankHittablePunched(String:output[], caller, activator, Float:delay)
{
	Call_StartForward(hFwdOnTankPunchHittable);
	Call_PushCell(activator);
	Call_PushCell(caller);
	Call_Finish(0);
	return 0;
}

L4D2Util_Tanks_TankSpawn(client)
{
	new iNumTanks = NumTanksInPlay();
	if (GetArraySize(hTankClients) < iNumTanks)
	{
		AddTankToArray(client);
		Call_StartForward(hFwdOnTankSpawn);
		Call_PushCell(client);
		Call_Finish(0);
	}
	return 0;
}

L4D2Util_Tanks_PlayerDeath(client)
{
	if (client)
	{
		if (!IsTank(client))
		{
			return 0;
		}
		CreateTimer(0.1, L4D2Util_Tanks_TankDeathDelay, client, 0);
		return 0;
	}
	return 0;
}

public Action:L4D2Util_Tanks_TankDeathDelay(Handle:hTimer, any:iOldTankClient)
{
	new iTankClient = -1;
	new client = -1;
	while ((client = FindTankClient(client)) != -1)
	{
		if (!FindTankInArray(client))
		{
			iTankClient = client;
			RemoveTankFromArray(iOldTankClient);
			if (iTankClient != -1)
			{
				AddTankToArray(client);
				Call_StartForward(hFwdOnTankPass);
				Call_PushCell(iTankClient);
				Call_PushCell(iOldTankClient);
				Call_Finish(0);
				return Action:0;
			}
			Call_StartForward(hFwdOnTankDeath);
			Call_PushCell(iOldTankClient);
			Call_Finish(0);
			return Action:0;
		}
	}
	RemoveTankFromArray(iOldTankClient);
	if (iTankClient != -1)
	{
		AddTankToArray(client);
		Call_StartForward(hFwdOnTankPass);
		Call_PushCell(iTankClient);
		Call_PushCell(iOldTankClient);
		Call_Finish(0);
		return Action:0;
	}
	Call_StartForward(hFwdOnTankDeath);
	Call_PushCell(iOldTankClient);
	Call_Finish(0);
	return Action:0;
}

L4D2Util_Tanks_CreateForwards()
{
	hFwdOnTankPunchHittable = CreateGlobalForward("OnTankPunchHittable", ExecType:0, 2, 2);
	hFwdOnTankSpawn = CreateGlobalForward("OnTankSpawn", ExecType:0, 2);
	hFwdOnTankPass = CreateGlobalForward("OnTankPass", ExecType:0, 2, 2);
	hFwdOnTankDeath = CreateGlobalForward("OnTankDeath", ExecType:0, 2);
	return 0;
}

public OnPluginStart()
{
	L4D2Util_Tanks_Init();
	HookEvent("round_start", L4D2Util_RoundStart, EventHookMode:1);
	HookEvent("round_end", L4D2Util_RoundEnd, EventHookMode:1);
	HookEvent("tank_spawn", L4D2Util_TankSpawn, EventHookMode:1);
	HookEvent("player_death", L4D2Util_PlayerDeath, EventHookMode:1);
	return 0;
}

public OnMapEnd()
{
	L4D2Util_Rounds_OnMapEnd();
	return 0;
}

public APLRes:AskPluginLoad2(Handle:hPlugin, bool:bLateLoad, String:sError[], iErrMax)
{
	L4D2Util_Rounds_CreateForwards();
	L4D2Util_Tanks_CreateForwards();
	RegPluginLibrary(sLibraryName);
	return APLRes:0;
}

public Action:L4D2Util_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	L4D2Util_Rounds_OnRoundStart();
	L4D2Util_Tanks_OnRoundStart();
	return Action:0;
}

public Action:L4D2Util_RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	L4D2Util_Rounds_OnRoundEnd();
	return Action:0;
}

public Action:L4D2Util_TankSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	new iTank = GetClientOfUserId(GetEventInt(event, "userid"));
	L4D2Util_Tanks_TankSpawn(iTank);
	return Action:0;
}

public Action:L4D2Util_PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new iPlayer = GetClientOfUserId(GetEventInt(event, "userid"));
	L4D2Util_Tanks_PlayerDeath(iPlayer);
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "09/12/2016",
	time = "20:50:14"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new bool:bLateLoad;
new Handle:hCvarPounceInterrupt;
new iHunterSkeetDamage[66];
new bool:bIsPouncing[66];
public Plugin:myinfo =
{
	name = "Bot SI skeet/level damage fix",
	description = "Makes AI SI take (and do) damage like human SI.",
	author = "Tabun",
	version = "1.0.1",
	url = "nope"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return oper1 + float(oper2);
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	hCvarPounceInterrupt = FindConVar("z_pounce_damage_interrupt");
	HookEvent("round_start", Event_RoundStart, EventHookMode:2);
	HookEvent("player_death", Event_PlayerDeath, EventHookMode:1);
	HookEvent("player_shoved", Event_PlayerShoved, EventHookMode:1);
	HookEvent("ability_use", Event_AbilityUse, EventHookMode:1);
	if (bLateLoad)
	{
		new i = 1;
		while (MaxClients + 1 > i)
		{
			if (IsClientAndInGame(i))
			{
				SDKHook(i, SDKHookType:2, OnTakeDamage);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPostAdminCheck(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	new var1;
	if (!IsClientAndInGame(victim) || !IsClientAndInGame(attacker) || 0.0 == damage)
	{
		return Action:0;
	}
	new var2;
	if (GetClientTeam(victim) == 3 && IsFakeClient(victim))
	{
		new zombieClass = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
		new abilityEnt;
		switch (zombieClass)
		{
			case 3:
			{
				new var6 = iHunterSkeetDamage[victim];
				var6 = var6[RoundToFloor(damage)];
				new var4;
				if (bIsPouncing[victim] && iHunterSkeetDamage[victim] >= GetConVarInt(hCvarPounceInterrupt))
				{
					bIsPouncing[victim] = 0;
					iHunterSkeetDamage[victim] = 0;
					damage = float(GetClientHealth(victim));
					return Action:1;
				}
			}
			case 6:
			{
				abilityEnt = GetEntPropEnt(victim, PropType:0, "m_customAbility", 0);
				new bool:isCharging;
				if (0 < abilityEnt)
				{
					new var3;
					if (GetEntProp(abilityEnt, PropType:0, "m_isCharging", 4, 0) > 0)
					{
						var3 = 1;
					}
					else
					{
						var3 = 0;
					}
					isCharging = var3;
				}
				if (isCharging)
				{
					damage = damage * 3 + 1;
					return Action:1;
				}
			}
			default:
			{
			}
		}
	}
	new var5;
	if (GetClientTeam(attacker) == 3 && IsFakeClient(attacker))
	{
		if (GetEntPropFloat(attacker, PropType:0, "m_staggerDist", 0) > 0.0)
		{
			if (0 < GetEntPropEnt(victim, PropType:0, "m_pummelAttacker", 0))
			{
				return Action:0;
			}
			damage = 0;
			return Action:1;
		}
	}
	return Action:0;
}

public Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	new i = 1;
	while (i <= MaxClients)
	{
		iHunterSkeetDamage[i] = 0;
		bIsPouncing[i] = 0;
		i++;
	}
	return 0;
}

public Event_PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "userId"));
	if (!IsClientAndInGame(victim))
	{
		return 0;
	}
	bIsPouncing[victim] = 0;
	return 0;
}

public Event_PlayerShoved(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "userId"));
	if (!IsClientAndInGame(victim))
	{
		return 0;
	}
	bIsPouncing[victim] = 0;
	return 0;
}

public Event_AbilityUse(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new String:abilityName[64];
	new var1;
	if (!IsClientAndInGame(client) || GetClientTeam(client) == 3)
	{
		return 0;
	}
	GetEventString(event, "ability", abilityName, 64);
	new var2;
	if (!bIsPouncing[client] && strcmp(abilityName, "ability_lunge", false))
	{
		bIsPouncing[client] = 1;
		iHunterSkeetDamage[client] = 0;
		CreateTimer(0.1, Timer_GroundTouch, client, 1);
	}
	return 0;
}

public Action:Timer_GroundTouch(Handle:timer, any:client)
{
	if (IsClientAndInGame(client))
	{
		new var1;
		if (IsGrounded(client) || !IsPlayerAlive(client))
		{
			bIsPouncing[client] = 0;
			return Action:4;
		}
		return Action:0;
	}
	return Action:4;
}

public bool:IsGrounded(client)
{
	return GetEntProp(client, PropType:1, "m_fFlags", 4, 0) & 1 > 0;
}

bool:IsClientAndInGame(index)
{
	new var1;
	if (index > 0 && index < MaxClients)
	{
		return IsClientInGame(index);
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "07/06/2016",
	time = "22:19:10"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 1,
};
public SharedPlugin:__pl_pause =
{
	name = "pause",
	file = "pause.smx",
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCvarTimerStartDelay;
new Handle:hCvarHordeCountdown;
new Handle:hCvarMinProgressThreshold;
new Float:timerStartDelay;
new Float:hordeCountdown;
new Float:minProgress;
new Float:aliveSince[66];
new Float:startingSurvivorCompletion;
new z_max_player_zombies;
new hordeDelayChecks;
new L4D2SI:zombieclass[66];
public Plugin:myinfo =
{
	name = "L4D2 Antibaiter",
	description = "Makes you think twice before attempting to bait that shit",
	author = "Visor",
	version = "1.3",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

Float:operator-(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) - oper2;
}

bool:operator!=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) != 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator>=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) >= 0;
}

bool:operator>=(Float:,_:)(Float:oper1, oper2)
{
	return FloatCompare(oper1, float(oper2)) >= 0;
}

bool:operator>=(_:,Float:)(oper1, Float:oper2)
{
	return FloatCompare(float(oper1), oper2) >= 0;
}

bool:operator<=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) <= 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetCDirector()
{
	static Address:TheDirector;
	if (!TheDirector)
	{
		TheDirector = GameConfGetAddress(L4D2Direct_GetGameConf(), "CDirector");
	}
	return TheDirector;
}

Address:L4D2Direct_GetCDirectorScavengeMode()
{
	static Address:pScavengeModeDirector;
	if (!pScavengeModeDirector)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorScavengeMode");
		if (offs == -1)
		{
			return Address:0;
		}
		pScavengeModeDirector = L4D2Direct_GetCDirector() + offs;
		pScavengeModeDirector = LoadFromAddress(pScavengeModeDirector, NumberType:2);
	}
	return pScavengeModeDirector;
}

Address:L4D2Direct_GetTerrorNavMesh()
{
	static Address:TheNavMesh;
	if (!TheNavMesh)
	{
		TheNavMesh = GameConfGetAddress(L4D2Direct_GetGameConf(), "TerrorNavMesh");
	}
	return TheNavMesh;
}

Address:L4D2Direct_GetTankCountAddr()
{
	static Address:pTankCount;
	if (!pTankCount)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirector::m_iTankCount");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankCount = L4D2Direct_GetCDirector() + offs;
	}
	return pTankCount;
}

Address:L4D2Direct_GetMapMaxFlowDistanceAddr()
{
	static Address:pMapMaxFlowDistance;
	if (!pMapMaxFlowDistance)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "TerrorNavMesh::m_fMapMaxFlowDistance");
		if (offs == -1)
		{
			return Address:0;
		}
		pMapMaxFlowDistance = L4D2Direct_GetTerrorNavMesh() + offs;
	}
	return pMapMaxFlowDistance;
}

CTimer_Start(CountdownTimer:timer, Float:duration)
{
	CTimer_SetTimestamp(timer, GetGameTime() + duration);
	CTimer_SetDuration(timer, duration);
	return 0;
}

CTimer_Invalidate(CountdownTimer:timer)
{
	CTimer_SetTimestamp(timer, -1.0);
	return 0;
}

bool:CTimer_HasStarted(CountdownTimer:timer)
{
	return CTimer_GetTimestamp(timer) >= 0;
}

bool:CTimer_IsElapsed(CountdownTimer:timer)
{
	return GetGameTime() >= CTimer_GetTimestamp(timer);
}

Float:CTimer_GetRemainingTime(CountdownTimer:timer)
{
	return CTimer_GetTimestamp(timer) - GetGameTime();
}

CTimer_SetDuration(CountdownTimer:timer, Float:duration)
{
	StoreToAddress(timer + 4, duration, NumberType:2);
	return 0;
}

Float:CTimer_GetTimestamp(CountdownTimer:timer)
{
	return LoadFromAddress(timer + 8, NumberType:2);
}

CTimer_SetTimestamp(CountdownTimer:timer, Float:timestamp)
{
	StoreToAddress(timer + 8, timestamp, NumberType:2);
	return 0;
}

L4D2Direct_GetTankCount()
{
	return LoadFromAddress(L4D2Direct_GetTankCountAddr(), NumberType:2);
}

CountdownTimer:L4D2Direct_GetMobSpawnTimer()
{
	static Address:pMobSpawnTimer;
	if (!pMobSpawnTimer)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirector::MobSpawnTimer");
		if (offs == -1)
		{
			return CountdownTimer:0;
		}
		pMobSpawnTimer = L4D2Direct_GetCDirector() + offs;
	}
	return pMobSpawnTimer;
}

CountdownTimer:L4D2Direct_GetScavengeRoundSetupTimer()
{
	static Address:pRoundSetupTimer;
	if (!pRoundSetupTimer)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorScavengeMode::RoundSetupTimer");
		if (offs == -1)
		{
			return CountdownTimer:0;
		}
		pRoundSetupTimer = L4D2Direct_GetCDirectorScavengeMode() + offs;
	}
	return pRoundSetupTimer;
}

Float:L4D2Direct_GetMapMaxFlowDistance()
{
	return LoadFromAddress(L4D2Direct_GetMapMaxFlowDistanceAddr(), NumberType:2);
}

Float:L4D2Direct_GetFlowDistance(client)
{
	static Handle:GetFlowDistanceSDKCall;
	if (!GetFlowDistanceSDKCall)
	{
		StartPrepSDKCall(SDKCallType:2);
		if (!PrepSDKCall_SetFromConf(L4D2Direct_GetGameConf(), SDKFuncConfSource:1, "CTerrorPlayer::GetFlowDistance"))
		{
			return 0.0;
		}
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		PrepSDKCall_SetReturnInfo(SDKType:5, SDKPassMethod:1, 0, 0);
		GetFlowDistanceSDKCall = EndPrepSDKCall();
		if (!GetFlowDistanceSDKCall)
		{
			return 0.0;
		}
	}
	return SDKCall(GetFlowDistanceSDKCall, client, 0);
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public __pl_pause_SetNTVOptional()
{
	MarkNativeAsOptional("IsInPause");
	return 0;
}

public OnPluginStart()
{
	hCvarTimerStartDelay = CreateConVar("l4d2_antibaiter_delay", "20", "Delay in seconds before the antibait algorithm kicks in", 262144, false, 0.0, false, 0.0);
	hCvarHordeCountdown = CreateConVar("l4d2_antibaiter_horde_timer", "60", "Countdown in seconds to the panic horde", 262144, false, 0.0, false, 0.0);
	hCvarMinProgressThreshold = CreateConVar("l4d2_antibaiter_progress", "0.03", "Minimum progress the survivors must make to reset the antibaiter timer", 262144, false, 0.0, false, 0.0);
	CreateTimer(1.0, AntibaiterThink, any:0, 1);
	return 0;
}

public OnConfigsExecuted()
{
	z_max_player_zombies = GetConVarInt(FindConVar("z_max_player_zombies"));
	timerStartDelay = GetConVarFloat(hCvarTimerStartDelay);
	hordeCountdown = GetConVarFloat(hCvarHordeCountdown);
	minProgress = GetConVarFloat(hCvarMinProgressThreshold);
	return 0;
}

public OnRoundIsLive()
{
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsInfected(i))
		{
			if (IsPlayerAlive(i))
			{
				zombieclass[i] = GetZombieClass(i);
				aliveSince[i] = GetGameTime();
			}
		}
		i++;
	}
	return 0;
}

public Action:AntibaiterThink(Handle:timer)
{
	new var1;
	if (IsInReady() || IsInPause() || IsPanicEventInProgress() || L4D2Direct_GetTankCount() > 0)
	{
		hordeDelayChecks = 0;
		HideCountdown();
		StopCountdown();
		return Action:3;
	}
	new eligibleZombies;
	new i = 1;
	while (i <= MaxClients)
	{
		new var2;
		if (!IsInfected(i) || IsFakeClient(i))
		{
		}
		else
		{
			if (IsPlayerAlive(i))
			{
				zombieclass[i] = GetZombieClass(i);
				new var3;
				if (zombieclass[i] > L4D2SI:0 && zombieclass[i] < L4D2SI:7 && -1.0 != aliveSince[i] && GetGameTime() - aliveSince[i] >= timerStartDelay)
				{
					eligibleZombies++;
				}
			}
			else
			{
				aliveSince[i] = -1082130432;
				hordeDelayChecks = 0;
				HideCountdown();
				StopCountdown();
			}
		}
		i++;
	}
	if (eligibleZombies > z_max_player_zombies)
	{
		return Action:0;
	}
	if (z_max_player_zombies == eligibleZombies)
	{
		new Float:survivorCompletion = GetMaxSurvivorCompletion();
		new Float:progress = survivorCompletion - startingSurvivorCompletion;
		new var4;
		if (progress <= minProgress && hordeDelayChecks >= RoundToNearest(timerStartDelay))
		{
			if (IsCountdownRunning())
			{
				if (HasCountdownElapsed())
				{
					HideCountdown();
					LaunchHorde();
					hordeDelayChecks = 0;
				}
			}
			else
			{
				InitiateCountdown();
			}
		}
		else
		{
			if (!hordeDelayChecks)
			{
				startingSurvivorCompletion = survivorCompletion;
			}
			if (progress > minProgress)
			{
				startingSurvivorCompletion = survivorCompletion;
				hordeDelayChecks = 0;
			}
			hordeDelayChecks += 1;
			HideCountdown();
			StopCountdown();
		}
	}
	return Action:3;
}

public L4D_OnEnterGhostState(client)
{
	zombieclass[client] = GetZombieClass(client);
	aliveSince[client] = GetGameTime();
	return 0;
}

InitiateCountdown()
{
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i))
		{
			ShowVGUIPanel(i, "ready_countdown", Handle:0, true);
		}
		i++;
	}
	CTimer_Start(CountdownPointer(), hordeCountdown);
	return 0;
}

bool:IsCountdownRunning()
{
	return CTimer_HasStarted(CountdownPointer());
}

bool:HasCountdownElapsed()
{
	return CTimer_IsElapsed(CountdownPointer());
}

StopCountdown()
{
	CTimer_Invalidate(CountdownPointer());
	return 0;
}

HideCountdown()
{
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i))
		{
			ShowVGUIPanel(i, "ready_countdown", Handle:0, false);
		}
		i++;
	}
	return 0;
}

LaunchHorde()
{
	new client = -1;
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i))
		{
			client = i;
			if (client != -1)
			{
				new String:command[28] = "director_force_panic_event";
				new flags = GetCommandFlags(command);
				SetCommandFlags(command, flags & -16385);
				FakeClientCommand(client, command);
				SetCommandFlags(command, flags);
			}
			return 0;
		}
		i++;
	}
	if (client != -1)
	{
		new String:command[28] = "director_force_panic_event";
		new flags = GetCommandFlags(command);
		SetCommandFlags(command, flags & -16385);
		FakeClientCommand(client, command);
		SetCommandFlags(command, flags);
	}
	return 0;
}

CountdownTimer:CountdownPointer()
{
	return L4D2Direct_GetScavengeRoundSetupTimer();
}

Float:GetMaxSurvivorCompletion()
{
	new Float:flow = 0.0;
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsSurvivor(i) && IsPlayerAlive(i) && !IsIncapped(i))
		{
			new var2;
			if (flow > L4D2Direct_GetFlowDistance(i))
			{
				var2 = flow;
			}
			else
			{
				var2 = L4D2Direct_GetFlowDistance(i);
			}
			flow = var2;
		}
		i++;
	}
	return flow / L4D2Direct_GetMapMaxFlowDistance();
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

L4D2SI:GetZombieClass(client)
{
	return GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
}

bool:IsIncapped(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

bool:IsPanicEventInProgress()
{
	new CountdownTimer:pPanicCountdown = L4D2_GetCDirectorScriptedEventManager() + 300;
	if (!CTimer_IsElapsed(pPanicCountdown))
	{
		return true;
	}
	if (CTimer_HasStarted(L4D2Direct_GetMobSpawnTimer()))
	{
		return RoundFloat(CTimer_GetRemainingTime(L4D2Direct_GetMobSpawnTimer())) <= 10;
	}
	return false;
}

Address:L4D2_GetCDirectorScriptedEventManager()
{
	static Address:pScriptedEventManager;
	if (!pScriptedEventManager)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorScriptedEventManager");
		if (offs == -1)
		{
			return Address:0;
		}
		pScriptedEventManager = L4D2Direct_GetCDirector() + offs;
		pScriptedEventManager = LoadFromAddress(pScriptedEventManager, NumberType:2);
	}
	return pScriptedEventManager;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "12/26/2018",
	time = "11:08:11"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new String:L4D2WeaponName[56][];
new String:L4D2WeaponWorldModel[56][];
new String:L4DResourceName[7][];
new Handle:g_hWeaponNameTrie = 1970298733;
new String:WeaponNames[56][];
public Plugin:myinfo =
{
	name = "L4D2 Anti Godframe Abuse",
	description = "Prevent Players from abusing team switching to not take damage.",
	author = "Penguin",
	version = "1.0.0",
	url = ""
};
new m_countafk[8];
new Handle:m_hThresh;
new Handle:m_hDamage;
new m_2sec;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

SetEntityHealth(entity, amount)
{
	static bool:gotconfig;
	static String:prop[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_iHealth", prop, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(prop, 32, "m_iHealth");
		}
		gotconfig = true;
	}
	decl String:cls[64];
	new PropFieldType:type;
	new offset;
	if (!GetEntityNetClass(entity, cls, 64))
	{
		ThrowError("SetEntityHealth not supported by this mod: Could not get serverclass name");
		return 0;
	}
	offset = FindSendPropInfo(cls, prop, type, 0, 0);
	if (0 >= offset)
	{
		ThrowError("SetEntityHealth not supported by this mod");
		return 0;
	}
	if (type == PropFieldType:2)
	{
		SetEntDataFloat(entity, offset, float(amount), false);
	}
	else
	{
		SetEntProp(entity, PropType:0, prop, amount, 4, 0);
	}
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

L4D2_GetInfectedAttacker(client)
{
	new attacker = GetEntPropEnt(client, PropType:0, L4D2WeaponName, 0);
	if (0 < attacker)
	{
		return attacker;
	}
	attacker = GetEntPropEnt(client, PropType:0, "m_carryAttacker", 0);
	if (0 < attacker)
	{
		return attacker;
	}
	attacker = GetEntPropEnt(client, PropType:0, "m_pounceAttacker", 0);
	if (0 < attacker)
	{
		return attacker;
	}
	attacker = GetEntPropEnt(client, PropType:0, "m_tongueOwner", 0);
	if (0 < attacker)
	{
		return attacker;
	}
	attacker = GetEntPropEnt(client, PropType:0, "m_jockeyAttacker", 0);
	if (0 < attacker)
	{
		return attacker;
	}
	return -1;
}

L4D_GetPlayerTempHealth(client)
{
	static Handle:painPillsDecayCvar;
	if (!painPillsDecayCvar)
	{
		painPillsDecayCvar = FindConVar("pain_pills_decay_rate");
		if (!painPillsDecayCvar)
		{
			return -1;
		}
	}
	new tempHealth = RoundToCeil(GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0) - GetGameTime() - GetEntPropFloat(client, PropType:0, "m_healthBufferTime", 0) * GetConVarFloat(painPillsDecayCvar)) + -1;
	new var1;
	if (tempHealth < 0)
	{
		var1 = 0;
	}
	else
	{
		var1 = tempHealth;
	}
	return var1;
}

L4D_SetPlayerTempHealth(client, tempHealth)
{
	SetEntPropFloat(client, PropType:0, "m_healthBuffer", float(tempHealth), 0);
	SetEntPropFloat(client, PropType:0, "m_healthBufferTime", GetGameTime(), 0);
	return 0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client > MaxClients || client < 1 || !IsClientConnected(client) || !IsClientInGame(client) || GetClientTeam(client) == 2)
	{
		return false;
	}
	return true;
}

public void:OnPluginStart()
{
	CreateConVar("l4d2_antiafkgodframe_version", "1.0.0", "The version", 262144, false, 0.0, false, 0.0);
	HookEvent("player_bot_replace", OnPlayerBotReplace, EventHookMode:1);
	HookEvent("bot_player_replace", OnBotPlayerReplace, EventHookMode:1);
	m_hThresh = CreateConVar("l4d2_threshafknum", "3", "TakeBreak->Playing->TakeBreak AFK GodFrame threshhold", 0, false, 0.0, false, 0.0);
	m_hDamage = CreateConVar("l4d2_PenaltyDamage", "50", "AFKGodFramer Penalty", 0, false, 0.0, false, 0.0);
	CreateTimer(0.5, CycCheck, any:0, 1);
	return void:0;
}

public Action:OnPlayerBotReplace(Handle:event, String:name[], bool:dontBroadcast)
{
	new player = GetClientOfUserId(GetEventInt(event, "player", 0));
	new bot = GetClientOfUserId(GetEventInt(event, "bot", 0));
	new var1;
	if (!IsValidClient(player) || !IsValidClient(bot))
	{
		return Action:0;
	}
	new chara = GetEntProp(bot, PropType:0, "m_survivorCharacter", 1, 0);
	new var2;
	if (L4D2_GetInfectedAttacker(player) == -1 && L4D2_GetInfectedAttacker(bot) == -1)
	{
		m_countafk[chara] += 1;
	}
	return Action:0;
}

public Action:OnBotPlayerReplace(Handle:event, String:name[], bool:dontBroadcast)
{
	new bot = GetClientOfUserId(GetEventInt(event, "bot", 0));
	new player = GetClientOfUserId(GetEventInt(event, "player", 0));
	new chara = GetEntProp(player, PropType:0, "m_survivorCharacter", 1, 0);
	new var1;
	if (!IsValidClient(player) || !IsValidClient(bot))
	{
		return Action:0;
	}
	new var2;
	if (L4D2_GetInfectedAttacker(player) == -1 && L4D2_GetInfectedAttacker(bot) == -1)
	{
		m_countafk[chara] += 1;
	}
	return Action:0;
}

public Action:CycCheck(Handle:hTimer)
{
	m_2sec += 1;
	new thresh = GetConVarInt(m_hThresh);
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsValidClient(client))
		{
			new chara = GetEntProp(client, PropType:0, "m_survivorCharacter", 1, 0);
			if (m_countafk[chara] >= thresh)
			{
				SetPenaltyHealth(client);
				CPrintToChat(client, "{default}[{red}Exploit{default}] Please stop trying to abuse an exploit, you have been penalized.");
				m_countafk[chara] = 0;
			}
			if (m_2sec >= 4)
			{
				if (0 < m_countafk[chara])
				{
					m_countafk[chara] += -1;
				}
				m_2sec = 0;
			}
		}
		client++;
	}
	return Action:0;
}

SetPenaltyHealth(client)
{
	new health = GetEntProp(client, PropType:0, "m_iHealth", 4, 0);
	new temp = L4D_GetPlayerTempHealth(client);
	new damage = GetConVarInt(m_hDamage);
	if (damage < health)
	{
		SetEntityHealth(client, health - damage);
	}
	else
	{
		new var1;
		if (health == damage && temp < 1)
		{
			SetEntityHealth(client, 1);
		}
		if (2 <= health)
		{
			new hurthealth = health + -1;
			SetEntityHealth(client, 1);
			if (0 < temp - damage - hurthealth)
			{
				L4D_SetPlayerTempHealth(client, temp - damage - hurthealth);
			}
			else
			{
				L4D_SetPlayerTempHealth(client, 0);
			}
		}
		if (0 < temp - damage)
		{
			L4D_SetPlayerTempHealth(client, temp - damage);
		}
		L4D_SetPlayerTempHealth(client, 0);
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/13/2016",
	time = "20:51:43"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCvarMeleeNerfPercentage;
new bool:lateLoad;
public Plugin:myinfo =
{
	name = "L4D2 AntiMelee",
	description = "Nerfes melee damage against tanks by a set amount of %",
	author = "Visor",
	version = "1.0",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	lateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	hCvarMeleeNerfPercentage = CreateConVar("l4d2_melee_tank_nerf", "0", "Percentage of melee damage nerf against tank", 16640, true, 0.0, true, 100.0);
	if (lateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				OnClientPutInServer(i);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (!IsSurvivor(attacker) || !IsTank(victim) || !IsMelee(weapon))
	{
		return Action:0;
	}
	damage = damage / 100.0 * 100.0 - GetConVarFloat(hCvarMeleeNerfPercentage);
	return Action:1;
}

bool:IsMelee(entity)
{
	new var1;
	if (entity > 0 && IsValidEntity(entity) && IsValidEdict(entity))
	{
		decl String:strClassName[64];
		GetEdictClassname(entity, strClassName, 64);
		return StrContains(strClassName, "melee", false) != -1;
	}
	return false;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsTank(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4140",
	date = "11/19/2013",
	time = "13:27:28"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:WeaponNames[56][] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced",
	"weapon_shotgun_chrome",
	"weapon_rifle_desert",
	"weapon_sniper_military",
	"weapon_shotgun_spas",
	"weapon_first_aid_kit",
	"weapon_molotov",
	"weapon_pipe_bomb",
	"weapon_pain_pills",
	"weapon_gascan",
	"weapon_propanetank",
	"weapon_oxygentank",
	"weapon_melee",
	"weapon_chainsaw",
	"weapon_grenade_launcher",
	"weapon_ammo_pack",
	"weapon_adrenaline",
	"weapon_defibrillator",
	"weapon_vomitjar",
	"weapon_rifle_ak47",
	"weapon_gnome",
	"weapon_cola_bottles",
	"weapon_fireworkcrate",
	"weapon_upgradepack_incendiary",
	"weapon_upgradepack_explosive",
	"weapon_pistol_magnum",
	"weapon_smg_mp5",
	"weapon_rifle_sg552",
	"weapon_sniper_awp",
	"weapon_sniper_scout",
	"weapon_rifle_m60",
	"weapon_tank_claw",
	"weapon_hunter_claw",
	"weapon_charger_claw",
	"weapon_boomer_claw",
	"weapon_smoker_claw",
	"weapon_spitter_claw",
	"weapon_jockey_claw",
	"weapon_machinegun",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:WeaponModels[56][];
new WeaponSlots[56] =
{
	0, 1885431159, 1935634031, 1853317488, 0, 1702322029, 1852797025, 17481, 1634759519, 28279, 1852402754, 1850286180, 1952671078, 25701, 1634623811, 1867669860, 1344285816, 1768189810, 1767078247, 109, 1701079368, 1886593139, 1718182757, 543450473, 1885431159, 544435823, 1836020326, 1701344288, 1718511904, 1702126437, 1702109284, 1965059425, 1818850414, 1701344288, 1918967929, 1881677925, 1769173871, 695823458, 1936291360, 1701601897, 544175136, 543518319, 1948280431, 1931502952, 1769370229, 1936879478, 544175136, 1986359920, 544501349, 1931495763, 1953853283, 543649385, 543516788, 7364973, 3157553, 1886680168
};
new Handle:hWeaponNamesTrie;
public Plugin:myinfo =
{
	name = "Blind Infected",
	description = "Hides specified weapons from the infected team until they are (possibly) visible to one of the survivors to prevent SI scouting the map",
	author = "CanadaRox, ProdigySim",
	version = "1.0",
	url = "https://github.com/CanadaRox/sourcemod-plugins/tree/master/blind_infected_l4d2"
};
new WeaponId:iIdsToBlock[30] =
{
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 19, 20, 21, 22, 23, 24, 25, 26, 30, 31, 32, 33, 34, 36, 35
};
new Handle:hBlockedEntities;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator>=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) >= 0;
}

MakeVectorFromPoints(Float:pt1[3], Float:pt2[3], Float:output[3])
{
	output[0] = pt2[0] - pt1[0];
	output[1] = pt2[1] - pt1[1];
	output[2] = pt2[2] - pt1[2];
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

L4D2Weapons_Init()
{
	if (!WeaponModels[0])
	{
		InitWeaponNamesTrie();
	}
	return 0;
}

WeaponId:WeaponNameToId(String:weaponName[])
{
	if (!WeaponModels[0])
	{
		InitWeaponNamesTrie();
	}
	new WeaponID:id;
	if (GetTrieValue(WeaponModels[0], weaponName, id))
	{
		return id;
	}
	return WeaponId:0;
}

InitWeaponNamesTrie()
{
	WeaponModels[0] = CreateTrie();
	new i;
	while (i < 56)
	{
		SetTrieValue(WeaponModels[0], WeaponNames[i], i, true);
		i++;
	}
	return 0;
}

WeaponId:IdentifyWeapon(entity)
{
	new var1;
	if (!entity || !IsValidEntity(entity) || !IsValidEdict(entity))
	{
		return WeaponId:0;
	}
	decl String:class[64];
	if (!GetEdictClassname(entity, class, 64))
	{
		return WeaponId:0;
	}
	if (StrEqual(class, "weapon_spawn", true))
	{
		return GetEntProp(entity, PropType:0, "m_weaponID", 4, 0);
	}
	new len = strlen(class);
	new var2;
	if (len + -6 > 0 && StrEqual(class[len + -6], "_spawn", true))
	{
		class[len + -6] = MissingTAG:0;
		return WeaponNameToId(class);
	}
	return WeaponNameToId(class);
}

public OnPluginStart()
{
	L4D2Weapons_Init();
	HookEvent("round_start", RoundStart_Event, EventHookMode:2);
	hBlockedEntities = CreateArray(2, 0);
	CreateTimer(1.0, EntCheck_Timer, any:0, 1);
	return 0;
}

public Action:EntCheck_Timer(Handle:timer)
{
	new size = GetArraySize(hBlockedEntities);
	decl currentEnt[2];
	new i;
	while (i < size)
	{
		GetArrayArray(hBlockedEntities, i, currentEnt, -1);
		new ent = EntRefToEntIndex(currentEnt[0]);
		new var1;
		if (ent != -1 && !currentEnt[1] && IsVisibleToSurvivors(ent))
		{
			decl String:tmp[128];
			GetEntPropString(ent, PropType:1, "m_ModelName", tmp, 128, 0);
			currentEnt[1] = 1;
			SetArrayArray(hBlockedEntities, i, currentEnt, -1);
		}
		i++;
	}
	return Action:0;
}

public RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	ClearArray(hBlockedEntities);
	CreateTimer(1.2, RoundStartDelay_Timer, any:0, 0);
	return 0;
}

public Action:RoundStartDelay_Timer(Handle:timer)
{
	decl bhTemp[2];
	decl WeaponId:weapon;
	new psychonic = GetEntityCount();
	new i = MaxClients;
	while (i < psychonic)
	{
		weapon = IdentifyWeapon(i);
		if (weapon)
		{
			new j;
			while (j < 30)
			{
				if (iIdsToBlock[j] == weapon)
				{
					SDKHook(i, SDKHookType:6, OnTransmit);
					bhTemp[0] = EntIndexToEntRef(i);
					bhTemp[1] = 0;
					PushArrayArray(hBlockedEntities, bhTemp, -1);
				}
				j++;
			}
		}
		i++;
	}
	return Action:0;
}

public Action:OnTransmit(entity, client)
{
	if (GetClientTeam(client) != 3)
	{
		return Action:0;
	}
	new size = GetArraySize(hBlockedEntities);
	decl currentEnt[2];
	new i;
	while (i < size)
	{
		GetArrayArray(hBlockedEntities, i, currentEnt, -1);
		if (EntRefToEntIndex(currentEnt[0]) == entity)
		{
			if (currentEnt[1])
			{
				return Action:0;
			}
			return Action:3;
		}
		i++;
	}
	return Action:0;
}

bool:IsVisibleToSurvivors(entity)
{
	new iSurv;
	new i = 1;
	while (i <= MaxClients && iSurv < 4)
	{
		new var2;
		if (IsClientInGame(i) && GetClientTeam(i) == 2)
		{
			iSurv++;
			new var3;
			if (IsPlayerAlive(i) && IsVisibleTo(i, entity))
			{
				return true;
			}
		}
		i++;
	}
	return false;
}

bool:IsVisibleTo(client, entity)
{
	decl Float:vAngles[3];
	decl Float:vOrigin[3];
	decl Float:vEnt[3];
	decl Float:vLookAt[3];
	GetClientEyePosition(client, vOrigin);
	GetEntPropVector(entity, PropType:0, "m_vecOrigin", vEnt, 0);
	MakeVectorFromPoints(vOrigin, vEnt, vLookAt);
	GetVectorAngles(vLookAt, vAngles);
	new Handle:trace = TR_TraceRayFilterEx(vOrigin, vAngles, 1174421507, RayType:1, TraceFilter, any:0);
	new bool:isVisible;
	if (TR_DidHit(trace))
	{
		decl Float:vStart[3];
		TR_GetEndPosition(vStart, trace);
		if (GetVectorDistance(vOrigin, vStart, false) + 75.0 >= GetVectorDistance(vOrigin, vEnt, false))
		{
			isVisible = true;
		}
	}
	else
	{
		isVisible = true;
	}
	CloseHandle(trace);
	return isVisible;
}

public bool:TraceFilter(entity, contentsMask)
{
	new var1;
	if (entity <= MaxClients || !IsValidEntity(entity))
	{
		return false;
	}
	decl String:class[128];
	GetEdictClassname(entity, class, 128);
	return !StrEqual(class, "prop_physics", false);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:24"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new bool:lateLoad;
public Plugin:myinfo =
{
	name = "L4D2 Black&White Rock Hit",
	description = "Stops rocks from passing through soon-to-be-dead Survivors",
	author = "Visor",
	version = "1.0",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	lateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	if (lateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				OnClientPutInServer(i);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (!IsSurvivor(victim) || !IsTank(attacker) || !IsTankRock(inflictor))
	{
		return Action:0;
	}
	if (!IsOnCriticalStrike(victim))
	{
		return Action:0;
	}
	if (GetConVarInt(FindConVar("vs_tank_damage")) >= GetSurvivorTemporaryHealth(victim))
	{
		CTankRock__Detonate(inflictor);
	}
	return Action:0;
}

GetSurvivorTemporaryHealth(client)
{
	new temphp = RoundToCeil(GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0) - GetGameTime() - GetEntPropFloat(client, PropType:0, "m_healthBufferTime", 0) * GetConVarFloat(FindConVar("pain_pills_decay_rate"))) + -1;
	new var1;
	if (temphp > 0)
	{
		var1 = temphp;
	}
	else
	{
		var1 = 0;
	}
	return var1;
}

IsOnCriticalStrike(client)
{
	return GetEntProp(client, PropType:0, "m_currentReviveCount", 4, 0) == GetConVarInt(FindConVar("survivor_max_incapacitated_count"));
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsTank(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8 && IsPlayerAlive(client);
}

bool:IsTankRock(entity)
{
	new var1;
	if (entity > 0 && IsValidEntity(entity) && IsValidEdict(entity))
	{
		decl String:classname[64];
		GetEdictClassname(entity, classname, 64);
		return StrEqual(classname, "tank_rock", true);
	}
	return false;
}

CTankRock__Detonate(rock)
{
	static Handle:call;
	if (!call)
	{
		StartPrepSDKCall(SDKCallType:1);
		if (!PrepSDKCall_SetSignature(SDKLibrary:0, "@_ZN9CTankRock8DetonateEv", 0))
		{
			return 0;
		}
		call = EndPrepSDKCall();
		if (!call)
		{
			return 0;
		}
	}
	SDKCall(call, rock);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "05/20/2017",
	time = "18:34:09"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Car Alarm Hittable Fix",
	description = "Disables the Car Alarm when a Tank hittable hits the alarmed car.",
	author = "Sir",
	version = "1.0",
	url = "nah"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnEntityCreated(entity, String:classname[])
{
	if (!StrEqual(classname, "prop_car_alarm", true))
	{
		return 0;
	}
	SDKHook(entity, SDKHookType:10, OnAlarmCarTouch);
	return 0;
}

public OnAlarmCarTouch(car, entity)
{
	if (!IsValidEntity(entity))
	{
		return 0;
	}
	new String:eClassname[64];
	GetEdictClassname(entity, eClassname, 64);
	if (StrEqual(eClassname, "prop_physics", true))
	{
		if (0 < GetEntProp(entity, PropType:0, "m_hasTankGlow", 4, 0))
		{
			AcceptEntityInput(car, "Disable", -1, -1, 0);
			CreateTimer(0.3, DisableAlarm, car, 0);
			SDKUnhook(car, SDKHookType:10, OnAlarmCarTouch);
		}
	}
	return 0;
}

public Action:DisableAlarm(Handle:timer, any:car)
{
	new Tank = GetTank();
	if (Tank != -1)
	{
		SDKHooks_TakeDamage(car, Tank, Tank, 0.0, 0, -1, NULL_VECTOR, NULL_VECTOR);
	}
	return Action:0;
}

GetTank()
{
	new Tank = -1;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsValidTank(i))
		{
			Tank = i;
			return Tank;
		}
		i++;
	}
	return Tank;
}

bool:IsValidTank(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	new var2;
	return IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.3",
	date = "11/12/2012",
	time = "19:50:07"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new Handle:hCvarMaxZombies;
public Plugin:myinfo =
{
	name = "Character Fix",
	description = "Fixes character change exploit in 1v1, 2v2, 3v3",
	author = "someone",
	version = "0.1",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	AddCommandListener(TeamCmd, "jointeam");
	hCvarMaxZombies = FindConVar("z_max_player_zombies");
	return 0;
}

public Action:TeamCmd(client, String:command[], argc)
{
	new var1;
	if (client && argc > 0)
	{
		static String:sBuffer[128];
		GetCmdArg(1, sBuffer, 128);
		new newteam = StringToInt(sBuffer, 10);
		new var3;
		if (GetClientTeam(client) == 2 && (StrEqual("Infected", sBuffer, false) || newteam == 3))
		{
			new zombies;
			new i = 1;
			while (i <= MaxClients)
			{
				new var4;
				if (IsClientInGame(i) && GetClientTeam(i) == 3)
				{
					zombies++;
				}
				i++;
			}
			if (GetConVarInt(hCvarMaxZombies) <= zombies)
			{
				return Action:3;
			}
		}
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "04/26/2018",
	time = "18:09:39"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_collisionhook =
{
	name = "CollisionHook",
	file = "collisionhook.ext",
	autoload = 1,
	required = 1,
};
new bool:isPulled[66];
new String:sModelCharged[64];
new Handle:hRockFix;
new Handle:hPullThrough;
new Handle:hRockThroughIncap;
new bool:bRockFix;
new bool:bPullThrough;
new bool:bRockThroughIncap;
new String:sEntityCName[20];
new String:sEntityCNameTwo[20];
public Plugin:myinfo =
{
	name = "L4D2 Collision Adjustments",
	description = "Allows messing with pesky Collisions in Left 4 Dead 2",
	author = "Sir",
	version = "1.2",
	url = "https://github.com/SirPlease/SirCoding"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	HookEvent("tongue_grab", Event_SurvivorPulled, EventHookMode:1);
	HookEvent("tongue_release", Event_PullEnd, EventHookMode:1);
	HookEvent("round_start", Event_RoundStart, EventHookMode:1);
	HookEvent("charger_killed", Event_ChargerKilled, EventHookMode:1);
	HookEvent("charger_carry_start", Event_CarryStart, EventHookMode:1);
	HookEvent("charger_pummel_end", Event_PummelEnd, EventHookMode:1);
	RegConsoleCmd("sm_tellme", TellMe_Cmd, "", 0);
	hRockFix = CreateConVar("collision_tankrock_common", "1", "Will Rocks go through Common Infected (and also kill them) instead of possibly getting stuck on them?", 0, false, 0.0, false, 0.0);
	hPullThrough = CreateConVar("collision_smoker_common", "0", "Will Pulled Survivors go through Common Infected?", 0, false, 0.0, false, 0.0);
	hRockThroughIncap = CreateConVar("collision_tankrock_incap", "0", "Will Rocks go through Incapacitated Survivors? (Won't go through new incaps caused by the Rock)", 0, false, 0.0, false, 0.0);
	bRockFix = GetConVarBool(hRockFix);
	bPullThrough = GetConVarBool(hPullThrough);
	bRockThroughIncap = GetConVarBool(hRockThroughIncap);
	HookConVarChange(hRockFix, cvarChanged);
	HookConVarChange(hPullThrough, cvarChanged);
	HookConVarChange(hRockThroughIncap, cvarChanged);
	return 0;
}

public Action:TellMe_Cmd(client, args)
{
	PrintToChat(client, "sModelCharged = %s", sModelCharged);
	return Action:0;
}

public Action:CH_PassFilter(ent1, ent2, &bool:result)
{
	new var1;
	if (!IsValidEdict(ent1) || !IsValidEdict(ent2))
	{
		return Action:3;
	}
	GetEdictClassname(ent1, sEntityCName, 20);
	GetEdictClassname(ent2, sEntityCNameTwo, 20);
	if (StrEqual(sEntityCName, "infected", true))
	{
		new var2;
		if (bRockFix && StrEqual(sEntityCNameTwo, "tank_rock", true))
		{
			result = 0;
			return Action:3;
		}
		new var3;
		if (bPullThrough && IsSurvivor(ent2) && isPulled[ent2])
		{
			result = 0;
			return Action:3;
		}
	}
	else
	{
		if (StrEqual(sEntityCNameTwo, "infected", true))
		{
			new var4;
			if (bRockFix && StrEqual(sEntityCName, "tank_rock", true))
			{
				result = 0;
				return Action:3;
			}
			new var5;
			if (bPullThrough && IsSurvivor(ent1) && isPulled[ent1])
			{
				result = 0;
				return Action:3;
			}
		}
		if (StrEqual(sEntityCName, "tank_rock", true))
		{
			new var6;
			if (bRockThroughIncap && IsIncapacitated(ent2))
			{
				result = 0;
				return Action:3;
			}
		}
		if (StrEqual(sEntityCNameTwo, "tank_rock", true))
		{
			new var7;
			if (bRockThroughIncap && IsIncapacitated(ent1))
			{
				result = 0;
				return Action:3;
			}
		}
		new var8;
		if (!StrEqual("Nobody", sModelCharged, true) && IsValidClient(ent1) && IsValidClient(ent2))
		{
			new var9;
			if (GetClientTeam(ent1) == 2 && GetClientTeam(ent2) == 3 && GetEntProp(ent2, PropType:0, "m_zombieClass", 4, 0) < 6)
			{
				new String:sModel[64];
				GetClientModel(ent1, sModel, 64);
				if (StrEqual(sModel, sModelCharged, true))
				{
					result = 0;
					return Action:3;
				}
			}
			new var10;
			if (GetClientTeam(ent2) == 2 && GetClientTeam(ent1) == 3 && GetEntProp(ent1, PropType:0, "m_zombieClass", 4, 0) < 6)
			{
				new String:sModel[64];
				GetClientModel(ent2, sModel, 64);
				if (StrEqual(sModel, sModelCharged, true))
				{
					result = 0;
					return Action:3;
				}
			}
		}
	}
	return Action:0;
}

public Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	return 0;
}

public Event_ChargerKilled(Handle:event, String:name[], bool:dontBroadcast)
{
	return 0;
}

public Event_CarryStart(Handle:event, String:name[], bool:dontBroadcast)
{
	new Victim = GetClientOfUserId(GetEventInt(event, "victim"));
	GetClientModel(Victim, sModelCharged, 64);
	return 0;
}

public Event_PummelEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	return 0;
}

public Event_SurvivorPulled(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	isPulled[victim] = 1;
	return 0;
}

public Event_PullEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	isPulled[victim] = 0;
	return 0;
}

public cvarChanged(Handle:cvar, String:oldValue[], String:newValue[])
{
	bRockFix = GetConVarBool(hRockFix);
	bPullThrough = GetConVarBool(hPullThrough);
	bRockThroughIncap = GetConVarBool(hRockThroughIncap);
	return 0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

bool:IsSurvivor(client)
{
	new var1;
	return IsValidClient(client) && GetClientTeam(client) == 2;
}

bool:IsIncapacitated(client)
{
	new bool:bIsIncapped;
	if (IsSurvivor(client))
	{
		if (0 < GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0))
		{
			bIsIncapped = true;
		}
		if (!IsPlayerAlive(client))
		{
			bIsIncapped = true;
		}
	}
	return bIsIncapped;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.2",
	date = "05/20/2012",
	time = "22:43:47"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new Handle:hCommonLimit;
new iCommonLimit;
public Plugin:myinfo =
{
	name = "Director-scripted common limit blocker",
	description = "Prevents director scripted overrides of z_common_limit. Only affects scripted common limits higher than the cvar.",
	author = "Tabun",
	version = "0.1a",
	url = "nope"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	hCommonLimit = FindConVar("z_common_limit");
	iCommonLimit = GetConVarInt(hCommonLimit);
	HookConVarChange(hCommonLimit, Cvar_CommonLimitChange);
	return 0;
}

public Cvar_CommonLimitChange(Handle:cvar, String:oldValue[], String:newValue[])
{
	iCommonLimit = StringToInt(newValue, 10);
	return 0;
}

public OnMapStart()
{
	return 0;
}

public L4D_OnGetScriptValueInt(String:key[], &retVal)
{
	if (StrEqual(key, "CommonLimit", true))
	{
		if (retVal > iCommonLimit)
		{
			retVal = iCommonLimit;
			return 3;
		}
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.2",
	date = "06/03/2012",
	time = "21:02:50"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new g_iDominators = 53;
new Address:g_pDominatorsAddress;
new Handle:g_hCvarDominators;
public Plugin:myinfo =
{
	name = "Dominators Control",
	description = "Changes bIsDominator flag for infected classes. Allows to have native-order quad-caps.",
	author = "vintik",
	version = "1.1",
	url = "https://bitbucket.org/vintik/various-plugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public OnPluginStart()
{
	decl String:sGame[256];
	GetGameFolderName(sGame, 256);
	if (!StrEqual(sGame, "left4dead2", false))
	{
		SetFailState("Plugin 'Dominators Control' supports Left 4 Dead 2 only!");
	}
	new Handle:hGConf = LoadGameConfigFile("l4d2_dominators");
	new var1;
	if (hGConf && (g_pDominatorsAddress = GameConfGetAddress(hGConf, "bIsDominator")))
	{
		SetFailState("Can't find 'bIsDominator' signature!");
	}
	g_hCvarDominators = CreateConVar("l4d2_dominators", "53", "Which infected class is considered as dominator (bitmask: 1 - smoker, 2 - boomer, 4 - hunter, 8 - spitter, 16 - jockey, 32 - charger)", 262208, false, 0.0, false, 0.0);
	new iCvarValue = GetConVarInt(g_hCvarDominators);
	if (!IsValidCvarValue(iCvarValue))
	{
		SetConVarInt(g_hCvarDominators, 53, false, false);
		iCvarValue = 53;
	}
	if (iCvarValue != g_iDominators)
	{
		g_iDominators = iCvarValue;
		SetDominators();
	}
	HookConVarChange(g_hCvarDominators, OnCvarDominatorsChange);
	return 0;
}

public OnPluginEnd()
{
	g_iDominators = 53;
	SetDominators();
	return 0;
}

public OnCvarDominatorsChange(Handle:hCvar, String:sOldVal[], String:sNewVal[])
{
	new iNewVal = StringToInt(sNewVal, 10);
	if (g_iDominators == iNewVal)
	{
		return 0;
	}
	if (IsValidCvarValue(iNewVal))
	{
		g_iDominators = iNewVal;
		SetDominators();
	}
	else
	{
		PrintToChatAll("[SM] Incorrect value of 'sm_dominators'! min: 0, max: %d", 63);
		SetConVarString(hCvar, sOldVal, false, false);
	}
	return 0;
}

bool:IsValidCvarValue(iValue)
{
	new var1;
	return iValue >= 0 && iValue < 64;
}

SetDominators()
{
	new bool:bIsDominator;
	new i;
	while (i < 6)
	{
		bIsDominator = g_iDominators & 1 << i != 0;
		StoreToAddress(i + g_pDominatorsAddress, bIsDominator, NumberType:0);
		i++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:19"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new String:WeaponNames[56][] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced",
	"weapon_shotgun_chrome",
	"weapon_rifle_desert",
	"weapon_sniper_military",
	"weapon_shotgun_spas",
	"weapon_first_aid_kit",
	"weapon_molotov",
	"weapon_pipe_bomb",
	"weapon_pain_pills",
	"weapon_gascan",
	"weapon_propanetank",
	"weapon_oxygentank",
	"weapon_melee",
	"weapon_chainsaw",
	"weapon_grenade_launcher",
	"weapon_ammo_pack",
	"weapon_adrenaline",
	"weapon_defibrillator",
	"weapon_vomitjar",
	"weapon_rifle_ak47",
	"weapon_gnome",
	"weapon_cola_bottles",
	"weapon_fireworkcrate",
	"weapon_upgradepack_incendiary",
	"weapon_upgradepack_explosive",
	"weapon_pistol_magnum",
	"weapon_smg_mp5",
	"weapon_rifle_sg552",
	"weapon_sniper_awp",
	"weapon_sniper_scout",
	"weapon_rifle_m60",
	"weapon_tank_claw",
	"weapon_hunter_claw",
	"weapon_charger_claw",
	"weapon_boomer_claw",
	"weapon_smoker_claw",
	"weapon_spitter_claw",
	"weapon_jockey_claw",
	"weapon_machinegun",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:LongWeaponNames[56][];
new String:MeleeWeaponNames[15][] =
{
	"",
	"knife",
	"baseball_bat",
	"chainsaw",
	"cricket_bat",
	"crowbar",
	"didgeridoo",
	"electric_guitar",
	"fireaxe",
	"frying_pan",
	"golfclub",
	"katana",
	"machete",
	"riotshield",
	"tonfa"
};
new String:LongMeleeWeaponNames[15][] =
{
	"",
	"/w_models/weapons/w_knife_t.mdl",
	"/weapons/melee/w_bat.mdl",
	"/weapons/melee/w_chainsaw.mdl",
	"/weapons/melee/w_cricket_bat.mdl",
	"/weapons/melee/w_crowbar.mdl",
	"/weapons/melee/w_didgeridoo.mdl",
	"/weapons/melee/w_electric_guitar.mdl",
	"/weapons/melee/w_fireaxe.mdl",
	"/weapons/melee/w_frying_pan.mdl",
	"/weapons/melee/w_golfclub.mdl",
	"/weapons/melee/w_katana.mdl",
	"/weapons/melee/w_machete.mdl",
	"/weapons/melee/w_riotshield.mdl",
	"/weapons/melee/w_tonfa.mdl"
};
new String:MeleeWeaponModels[15][] =
{
	"",
	"/w_models/weapons/w_knife_t.mdl",
	"/weapons/melee/w_bat.mdl",
	"/weapons/melee/w_chainsaw.mdl",
	"/weapons/melee/w_cricket_bat.mdl",
	"/weapons/melee/w_crowbar.mdl",
	"/weapons/melee/w_didgeridoo.mdl",
	"/weapons/melee/w_electric_guitar.mdl",
	"/weapons/melee/w_fireaxe.mdl",
	"/weapons/melee/w_frying_pan.mdl",
	"/weapons/melee/w_golfclub.mdl",
	"/weapons/melee/w_katana.mdl",
	"/weapons/melee/w_machete.mdl",
	"/weapons/melee/w_riotshield.mdl",
	"/weapons/melee/w_tonfa.mdl"
};
new String:WeaponModels[56][];
new WeaponSlots[56] =
{
	0, 0, 0, 1885431159, 1935634031, 1853317488, 0, 1702322029, 1852797025, 17481, 1634759519, 28279, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
new Handle:hWeaponNamesTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hMeleeWeaponModelsTrie;
new g_PlayerSecondaryWeapons[66];
public Plugin:myinfo =
{
	name = "L4D2 Drop Secondary",
	description = "Survivor players will drop their secondary weapon when they die",
	author = "Jahze, Visor",
	version = "2.0",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

InitWeaponNamesTrie()
{
	WeaponSlots[0] = CreateTrie();
	new i;
	while (i < 56)
	{
		SetTrieValue(WeaponSlots[0], WeaponNames[i], i, true);
		i++;
	}
	hMeleeWeaponNamesTrie = CreateTrie();
	hMeleeWeaponModelsTrie = CreateTrie();
	new i;
	while (i < 15)
	{
		SetTrieValue(hMeleeWeaponNamesTrie, LongWeaponNames[i], i, true);
		SetTrieString(hMeleeWeaponModelsTrie, LongMeleeWeaponNames[i], LongWeaponNames[i], true);
		i++;
	}
	return 0;
}

WeaponId:WeaponNameToId(String:weaponName[])
{
	new WeaponID:id;
	if (!WeaponSlots[0])
	{
		InitWeaponNamesTrie();
	}
	if (GetTrieValue(WeaponSlots[0], weaponName, id))
	{
		return id;
	}
	return WeaponId:0;
}

WeaponId:IdentifyWeapon(entity)
{
	new var1;
	if (!entity || !IsValidEntity(entity) || !IsValidEdict(entity))
	{
		return WeaponId:0;
	}
	decl String:class[64];
	if (!GetEdictClassname(entity, class, 64))
	{
		return WeaponId:0;
	}
	if (StrEqual(class, "weapon_spawn", true))
	{
		return GetEntProp(entity, PropType:0, "m_weaponID", 4, 0);
	}
	new len = strlen(class);
	new var2;
	if (len + -6 > 0 && StrEqual(class[len + -6], "_spawn", true))
	{
		class[len + -6] = MissingTAG:0;
		return WeaponNameToId(class);
	}
	return WeaponNameToId(class);
}

public OnPluginStart()
{
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	HookEvent("player_use", OnPlayerUse, EventHookMode:1);
	HookEvent("player_bot_replace", OnBotSwap, EventHookMode:1);
	HookEvent("bot_player_replace", OnBotSwap, EventHookMode:1);
	HookEvent("player_death", OnPlayerDeath, EventHookMode:0);
	return 0;
}

public OnRoundStart()
{
	new i;
	while (i <= 65)
	{
		g_PlayerSecondaryWeapons[i] = -1;
		i++;
	}
	return 0;
}

public Action:OnPlayerUse(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (IsClientIndex(client))
	{
		new weapon = GetPlayerWeaponSlot(client, 1);
		if (IsSecondary(weapon))
		{
			new var1;
			if (weapon == -1)
			{
				var1 = weapon;
			}
			else
			{
				var1 = EntIndexToEntRef(weapon);
			}
			g_PlayerSecondaryWeapons[client] = var1;
		}
	}
	return Action:0;
}

public Action:OnBotSwap(Handle:event, String:name[], bool:dontBroadcast)
{
	new bot = GetClientOfUserId(GetEventInt(event, "bot"));
	new player = GetClientOfUserId(GetEventInt(event, "player"));
	new var1;
	if (IsClientIndex(bot) && IsClientIndex(player))
	{
		if (StrEqual(name, "player_bot_replace", true))
		{
			g_PlayerSecondaryWeapons[bot] = g_PlayerSecondaryWeapons[player];
			g_PlayerSecondaryWeapons[player] = -1;
		}
		g_PlayerSecondaryWeapons[player] = g_PlayerSecondaryWeapons[bot];
		g_PlayerSecondaryWeapons[bot] = -1;
	}
	return Action:0;
}

public Action:OnPlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (IsSurvivor(client))
	{
		new weapon = EntRefToEntIndex(g_PlayerSecondaryWeapons[client]);
		new var1;
		if (IdentifyWeapon(weapon) && GetWeaponOwner(weapon) == client)
		{
			SDKHooks_DropWeapon(client, weapon, NULL_VECTOR, NULL_VECTOR);
		}
	}
	return Action:0;
}

bool:IsSecondary(weapon)
{
	new WeaponId:wepid = IdentifyWeapon(weapon);
	new var1;
	return wepid == WeaponId:1 || wepid == WeaponId:32 || wepid == WeaponId:19;
}

GetWeaponOwner(weapon)
{
	return GetEntPropEnt(weapon, PropType:1, "m_hOwner", 0);
}

bool:IsClientIndex(client)
{
	new var1;
	return client > 0 && client <= MaxClients;
}

bool:IsSurvivor(client)
{
	new var1;
	return IsClientIndex(client) && IsClientInGame(client) && GetClientTeam(client) == 2;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "04/26/2018",
	time = "12:15:15"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Plugin:myinfo =
{
	name = "Duplicate Survivor Fix",
	description = "As simple as the title.",
	author = "Sir",
	version = "1.0",
	url = "Nope"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	AddCommandListener(Listener_Join, "jointeam");
	return 0;
}

public Action:Listener_Join(client, String:command[], argc)
{
	new var1;
	if (IsValidClient(client) && argc >= 2)
	{
		new String:sJoinPlayer[128];
		new String:sJoin[32];
		GetCmdArg(1, sJoin, 32);
		GetCmdArg(2, sJoinPlayer, 128);
		if (StringToInt(sJoin, 10) != 2)
		{
			return Action:0;
		}
		new i = 1;
		while (i <= MaxClients)
		{
			new var2;
			if (IsValidClient(i) && GetClientTeam(i) == 2)
			{
				if (!IsFakeClient(i))
				{
					new String:sModel[64];
					new String:sPlayer[64];
					GetClientModel(i, sModel, 64);
					if (StrEqual(sModel, "models/survivors/survivor_coach.mdl", true))
					{
						Format(sPlayer, 64, "Coach");
					}
					else
					{
						if (StrEqual(sModel, "models/survivors/survivor_gambler.mdl", true))
						{
							Format(sPlayer, 64, "Nick");
						}
						if (StrEqual(sModel, "models/survivors/survivor_producer.mdl", true))
						{
							Format(sPlayer, 64, "Rochelle");
						}
						if (StrEqual(sModel, "models/survivors/survivor_mechanic.mdl", true))
						{
							Format(sPlayer, 64, "Ellis");
						}
						if (StrEqual(sModel, "models/survivors/survivor_manager.mdl", true))
						{
							Format(sPlayer, 64, "Louis");
						}
						if (StrEqual(sModel, "models/survivors/survivor_teenangst.mdl", true))
						{
							Format(sPlayer, 64, "Zoey");
						}
						if (StrEqual(sModel, "models/survivors/survivor_namvet.mdl", true))
						{
							Format(sPlayer, 64, "Bill");
						}
						if (StrEqual(sModel, "models/survivors/survivor_biker.mdl", true))
						{
							Format(sPlayer, 64, "Francis");
						}
					}
					if (StrEqual(sJoinPlayer, sPlayer, false))
					{
						return Action:3;
					}
				}
				if (HasIdlePlayer(i))
				{
					new String:sModel[64];
					new String:sPlayer[64];
					GetClientModel(i, sModel, 64);
					if (StrEqual(sModel, "models/survivors/survivor_coach.mdl", true))
					{
						Format(sPlayer, 64, "Coach");
					}
					else
					{
						if (StrEqual(sModel, "models/survivors/survivor_gambler.mdl", true))
						{
							Format(sPlayer, 64, "Nick");
						}
						if (StrEqual(sModel, "models/survivors/survivor_producer.mdl", true))
						{
							Format(sPlayer, 64, "Rochelle");
						}
						if (StrEqual(sModel, "models/survivors/survivor_mechanic.mdl", true))
						{
							Format(sPlayer, 64, "Ellis");
						}
						if (StrEqual(sModel, "models/survivors/survivor_manager.mdl", true))
						{
							Format(sPlayer, 64, "Louis");
						}
						if (StrEqual(sModel, "models/survivors/survivor_teenangst.mdl", true))
						{
							Format(sPlayer, 64, "Zoey");
						}
						if (StrEqual(sModel, "models/survivors/survivor_namvet.mdl", true))
						{
							Format(sPlayer, 64, "Bill");
						}
						if (StrEqual(sModel, "models/survivors/survivor_biker.mdl", true))
						{
							Format(sPlayer, 64, "Francis");
						}
					}
					if (StrEqual(sJoinPlayer, sPlayer, false))
					{
						return Action:3;
					}
				}
			}
			i++;
		}
		return Action:0;
	}
	return Action:0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

bool:HasIdlePlayer(bot)
{
	new client = GetClientOfUserId(GetEntProp(bot, PropType:0, "m_humanSpectatorUserID", 4, 0));
	if (client)
	{
		new var1;
		if (IsValidClient(client) && !IsFakeClient(client) && GetClientTeam(client) == 1)
		{
			return true;
		}
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "04/18/2017",
	time = "03:17:00"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new bool:bLateLoad;
public Plugin:myinfo =
{
	name = "L4D2 Explosion Damage Prevention",
	description = "No more explosion from attacker(world)",
	author = "Sir",
	version = "1.0",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	if (bLateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				OnClientPutInServer(i);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	new var1;
	if (!IsInfected(victim) || IsValidClient(attacker) || !damagetype & 64)
	{
		return Action:0;
	}
	return Action:3;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return false;
	}
	return IsClientInGame(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "01/09/2016",
	time = "19:42:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Fireworks Noise Blocker",
	description = "Focus on SI!",
	author = "Visor",
	version = "0.3",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	AddNormalSoundHook(OnNormalSound);
	AddAmbientSoundHook(OnAmbientSound);
	return 0;
}

public Action:OnNormalSound(clients[64], &numClients, String:sample[256], &entity, &channel, &Float:volume, &level, &pitch, &flags)
{
	new var1;
	if (StrContains(sample, "firewerks", true) > -1)
	{
		var1 = MissingTAG:3;
	}
	else
	{
		var1 = MissingTAG:0;
	}
	return var1;
}

public Action:OnAmbientSound(String:sample[256], &entity, &Float:volume, &level, &pitch, Float:pos[3], &flags, &Float:delay)
{
	new var1;
	if (StrContains(sample, "firewerks", true) > -1)
	{
		var1 = MissingTAG:3;
	}
	else
	{
		var1 = MissingTAG:0;
	}
	return var1;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "01/27/2013",
	time = "15:16:54"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Fix Death Spit",
	description = "Removes invisible death spit",
	author = "Jahze",
	version = "1.0",
	url = "https://github.com/Jahze/l4d2_plugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:GetEntityAddress(entity)
{
	if (!IsValidEntity(entity))
	{
		return Address:0;
	}
	static Handle:GetBaseEntitySDKCall;
	if (!GetBaseEntitySDKCall)
	{
		StartPrepSDKCall(SDKCallType:1);
		if (!PrepSDKCall_SetFromConf(L4D2Direct_GetGameConf(), SDKFuncConfSource:0, "CBaseEntity::GetBaseEntity"))
		{
			return Address:0;
		}
		PrepSDKCall_SetReturnInfo(SDKType:4, SDKPassMethod:1, 0, 0);
		GetBaseEntitySDKCall = EndPrepSDKCall();
		if (!GetBaseEntitySDKCall)
		{
			return Address:0;
		}
	}
	return SDKCall(GetBaseEntitySDKCall, entity);
}

GetEntityValueFromOffset(entity, String:offset[], NumberType:size, &value)
{
	new Address:pEntity = GetEntityAddress(entity);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), offset);
		if (offs == -1)
		{
			return 0;
		}
		value = LoadFromAddress(offs + pEntity, size);
		return 1;
	}
	return 0;
}

SetEntityValueFromOffset(entity, String:offset[], NumberType:size, value)
{
	new Address:pEntity = GetEntityAddress(entity);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), offset);
		if (offs == -1)
		{
			return 0;
		}
		StoreToAddress(offs + pEntity, value, size);
		return 1;
	}
	return 0;
}

L4D2Direct_GetInfernoMaxFlames(entity)
{
	new flames;
	if (GetEntityValueFromOffset(entity, "CInferno::m_maxFlames", NumberType:2, flames))
	{
		return flames;
	}
	return -1;
}

L4D2Direct_SetInfernoMaxFlames(entity, flames)
{
	SetEntityValueFromOffset(entity, "CInferno::m_maxFlames", NumberType:2, flames);
	return 0;
}

public OnPluginStart()
{
	HookEvent("spitter_killed", SpitterKilledEvent, EventHookMode:2);
	return 0;
}

public SpitterKilledEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	CreateTimer(1.0, FindDeathSpit, any:0, 0);
	return 0;
}

public Action:FindDeathSpit(Handle:timer)
{
	new entity = -1;
	while ((entity = FindEntityByClassname(entity, "insect_swarm")) != -1)
	{
		new maxFlames = L4D2Direct_GetInfernoMaxFlames(entity);
		new currentFlames = GetEntProp(entity, PropType:0, "m_fireCount", 4, 0);
		new var1;
		if (maxFlames == 2 && currentFlames == 2)
		{
			SetEntProp(entity, PropType:0, "m_fireCount", any:1, 4, 0);
			L4D2Direct_SetInfernoMaxFlames(entity, 1);
		}
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.3",
	date = "11/20/2012",
	time = "15:05:32"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:MeleeWeaponModels[15][];
new String:MeleeWeaponNames[15][];
new String:SurvivorModels[8][] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:SurvivorNames[8][] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	32, 64, 100, 136, 172, 208, 244, 280, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1868783474, 778593121, 7103597, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1634164594, 1701601901, 1684876914, 108, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1919967090, 1668637807, 1831760485, 27748, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1701666674, 1851877475, 1831756649, 27748, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1634557810, 1701273966, 1684876914
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new Handle:hSurvivorModelsTrie;
new Handle:hMeleeWeaponModelsTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hWeaponNamesTrie;
public Plugin:myinfo =
{
	name = "L4D2 Get-Up Fix",
	description = "Double/no/self-clear get-up fix.",
	author = "Blade, ProdigySim, DieTeetasse, Stabby, Jahze",
	version = "1.7",
	url = "http://bitbucket.org/ProdigySim/misc-sourcemod-plugins/"
};
new getUpAnimations[8][4] =
{
	{
		621, 656, 660, 661
	},
	{
		620, 667, 671, 672
	},
	{
		629, 674, 678, 679
	},
	{
		625, 671, 675, 676
	},
	{
		528, 759, 763, 764
	},
	{
		537, 819, 823, 824
	},
	{
		528, 759, 763, 764
	},
	{
		531, 762, 766, 767
	}
};
new incapAnimations[8][2] =
{
	{
		613, 614
	},
	{
		612, 613
	},
	{
		621, 622
	},
	{
		617, 618
	},
	{
		520, 521
	},
	{
		525, 526
	},
	{
		520, 521
	},
	{
		523, 524
	}
};
new PropOff_nSequence;
new bArClientAlreadyChecked[66];
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:IsSurvivor(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 2)
	{
		return false;
	}
	return true;
}

InitSurvivorModelTrie()
{
	L4D2_InfectedTimerEntities[0] = CreateTrie();
	new i;
	while (i < 8)
	{
		SetTrieValue(L4D2_InfectedTimerEntities[0], L4D2_InfectedNames[i], i, true);
		i++;
	}
	return 0;
}

SurvivorCharacter:IdentifySurvivor(client)
{
	new var1;
	if (!client || !IsClientInGame(client) || !IsSurvivor(client))
	{
		return SurvivorCharacter:-1;
	}
	decl String:clientModel[44];
	GetClientModel(client, clientModel, 42);
	return ClientModelToSC(clientModel);
}

SurvivorCharacter:ClientModelToSC(String:model[])
{
	if (!L4D2_InfectedTimerEntities[0])
	{
		InitSurvivorModelTrie();
	}
	new SurvivorCharacter:sc;
	if (GetTrieValue(L4D2_InfectedTimerEntities[0], model, sc))
	{
		return sc;
	}
	return SurvivorCharacter:-1;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!hMeleeWeaponModelsTrie)
	{
		hMeleeWeaponModelsTrie = LoadGameConfigFile("l4d2_direct");
	}
	return hMeleeWeaponModelsTrie;
}

L4D2Direct_DoAnimationEvent(client, event)
{
	new var1;
	if (client <= 0 || client > MaxClients + 1)
	{
		return 0;
	}
	static Handle:DoAnimationEventSDKCall;
	if (!DoAnimationEventSDKCall)
	{
		StartPrepSDKCall(SDKCallType:2);
		if (!PrepSDKCall_SetFromConf(L4D2Direct_GetGameConf(), SDKFuncConfSource:0, "CTerrorPlayer::DoAnimationEvent"))
		{
			return 0;
		}
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		DoAnimationEventSDKCall = EndPrepSDKCall();
		if (!DoAnimationEventSDKCall)
		{
			return 0;
		}
	}
	SDKCall(DoAnimationEventSDKCall, client, event, 0);
	return 0;
}

public OnPluginStart()
{
	HookEvent("pounce_end", Event_PounceOrPummel, EventHookMode:1);
	HookEvent("charger_pummel_end", Event_PounceOrPummel, EventHookMode:1);
	HookEvent("charger_killed", ChargerKilled, EventHookMode:1);
	PropOff_nSequence = FindSendPropInfo("CTerrorPlayer", "m_nSequence", 0, 0, 0);
	return 0;
}

public Event_PounceOrPummel(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	if (client)
	{
		if (!IsClientInGame(client))
		{
			return 0;
		}
		CreateTimer(0.1, Timer_ProcessClient, client, 0);
		return 0;
	}
	return 0;
}

public Action:Timer_ProcessClient(Handle:timer, any:client)
{
	ProcessClient(client);
	return Action:0;
}

ProcessClient(client)
{
	new SurvivorCharacter:charIndex = IdentifySurvivor(client);
	if (charIndex == SurvivorCharacter:-1)
	{
		return 0;
	}
	new sequence = GetEntData(client, PropOff_nSequence, 4);
	new var1;
	if (getUpAnimations[charIndex][0] != sequence && getUpAnimations[charIndex][1] != sequence && getUpAnimations[charIndex][3] != sequence && getUpAnimations[charIndex][2] != sequence)
	{
		new var2;
		if (incapAnimations[charIndex][0] != sequence && incapAnimations[charIndex][1] != sequence)
		{
			L4D2Direct_DoAnimationEvent(client, 78);
		}
		return 0;
	}
	new Handle:tempStack = CreateStack(3);
	PushStackCell(tempStack, client);
	PushStackCell(tempStack, sequence);
	if (getUpAnimations[charIndex][0] == sequence)
	{
		CreateTimer(2.2, Timer_CheckClient, tempStack, 0);
	}
	else
	{
		if (getUpAnimations[charIndex][1] == sequence)
		{
			CreateTimer(2.9, Timer_CheckClient, tempStack, 0);
		}
		if (getUpAnimations[charIndex][2] == sequence)
		{
			CreateTimer(3.9 - GetEntPropFloat(client, PropType:0, "m_flCycle", 0) * 2.5, Timer_CheckClient, tempStack, 0);
		}
		CreateTimer(4.0 - GetEntPropFloat(client, PropType:0, "m_flCycle", 0) * 2.5, Timer_CheckClient, tempStack, 0);
	}
	return 0;
}

public Action:Timer_CheckClient(Handle:timer, any:tempStack)
{
	decl client;
	decl oldSequence;
	decl Float:duration;
	PopStackCell(tempStack, oldSequence, 0, false);
	PopStackCell(tempStack, client, 0, false);
	new SurvivorCharacter:charIndex = IdentifySurvivor(client);
	if (charIndex == SurvivorCharacter:-1)
	{
		return Action:0;
	}
	new newSequence = GetEntData(client, PropOff_nSequence, 4);
	if (oldSequence == newSequence)
	{
		return Action:0;
	}
	if (getUpAnimations[charIndex][0] == newSequence)
	{
		duration = 2.2;
	}
	else
	{
		if (getUpAnimations[charIndex][1] == newSequence)
		{
			duration = 2.9;
		}
		if (getUpAnimations[charIndex][2] == newSequence)
		{
			duration = 3.9;
		}
		if (getUpAnimations[charIndex][3] == newSequence)
		{
			duration = 4.0;
		}
		return Action:0;
	}
	SetEntPropFloat(client, PropType:0, "m_flCycle", duration, 0);
	return Action:0;
}

public Action:ChargerKilled(Handle:event, String:name[], bool:dontBroadcast)
{
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var1;
	if (attacker <= 0 || attacker > MaxClients + 1)
	{
		return Action:0;
	}
	CreateTimer(0.5, GetupTimer, attacker, 0);
	return Action:0;
}

public Action:ResetAlreadyCheckedBool(Handle:timer, any:client)
{
	bArClientAlreadyChecked[client] = 0;
	return Action:0;
}

public Action:GetupTimer(Handle:timer, any:attacker)
{
	new n = 1;
	while (n <= MaxClients)
	{
		new var1;
		if (IsClientInGame(n) && GetClientTeam(n) == 2 && !bArClientAlreadyChecked[n])
		{
			new seq = GetEntProp(n, PropType:0, "m_nSequence", 4, 0);
			new SurvivorCharacter:character = IdentifySurvivor(n);
			if (character == SurvivorCharacter:-1)
			{
				return Action:0;
			}
			if (getUpAnimations[character][2] == seq)
			{
				if (attacker == n)
				{
					SetEntPropFloat(attacker, PropType:0, "m_flCycle", 3.9, 0);
				}
				else
				{
					bArClientAlreadyChecked[n] = 1;
					CreateTimer(3.9, ResetAlreadyCheckedBool, n, 0);
					ProcessClient(n);
				}
				return Action:0;
			}
			if (getUpAnimations[character][3] == seq)
			{
				if (attacker == n)
				{
					SetEntPropFloat(attacker, PropType:0, "m_flCycle", 4.0, 0);
				}
				else
				{
					bArClientAlreadyChecked[n] = 1;
					CreateTimer(4.0, ResetAlreadyCheckedBool, n, 0);
					ProcessClient(n);
				}
				return Action:0;
			}
		}
		n++;
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "07/13/2017",
	time = "07:29:58"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:SurvivorModels[8][] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:SurvivorNames[8][] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	32, 64, 100, 136, 172, 208, 244, 280, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1868783474, 778593121, 7103597, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1634164594, 1701601901, 1684876914, 108, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1919967090, 1668637807, 1831760485, 27748, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1701666674, 1851877475, 1831756649, 27748, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1634557810, 1701273966, 1684876914
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new Handle:hSurvivorModelsTrie;
new Handle:hWeaponNamesTrie = 845427820;
public SharedPlugin:__pl_l4d2util =
{
	name = "l4d2util",
	file = "l4d2util.smx",
	required = 1,
};
new bool:isSurvivorStaggerBlocked[8];
new getUpAnimations[8][5] =
{
	{
		621, 656, 660, 661, 629
	},
	{
		620, 667, 671, 672, 629
	},
	{
		629, 674, 678, 679, 637
	},
	{
		625, 671, 675, 676, 634
	},
	{
		528, 759, 763, 764, 537
	},
	{
		537, 819, 823, 824, 546
	},
	{
		528, 759, 763, 764, 537
	},
	{
		531, 762, 766, 767, 540
	}
};
public Plugin:myinfo =
{
	name = "Stagger Blocker",
	description = "Block players from being staggered by Jockeys and Hunters for a time while getting up from a Hunter pounce, Charger pummel or Charger impact.",
	author = "Standalone (aka Manu), Visor, Sir",
	version = "1.3",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:IsInfected(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 3)
	{
		return false;
	}
	return true;
}

L4D2_Infected:GetInfectedClass(client)
{
	return GetEntProp(client, PropType:0, L4D2_InfectedTimerEntities, 4, 0);
}

bool:IsSurvivor(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 2)
	{
		return false;
	}
	return true;
}

InitSurvivorModelTrie()
{
	hSurvivorModelsTrie = CreateTrie();
	new i;
	while (i < 8)
	{
		SetTrieValue(hSurvivorModelsTrie, L4D2_InfectedNames[i], i, true);
		i++;
	}
	return 0;
}

SurvivorCharacter:IdentifySurvivor(client)
{
	new var1;
	if (!client || !IsClientInGame(client) || !IsSurvivor(client))
	{
		return SurvivorCharacter:-1;
	}
	decl String:clientModel[44];
	GetClientModel(client, clientModel, 42);
	return ClientModelToSC(clientModel);
}

SurvivorCharacter:ClientModelToSC(String:model[])
{
	if (!hSurvivorModelsTrie)
	{
		InitSurvivorModelTrie();
	}
	new SurvivorCharacter:sc;
	if (GetTrieValue(hSurvivorModelsTrie, model, sc))
	{
		return sc;
	}
	return SurvivorCharacter:-1;
}

public __pl_l4d2util_SetNTVOptional()
{
	return 0;
}

public OnPluginStart()
{
	HookEvent("pounce_stopped", Event_PounceChargeEnd, EventHookMode:1);
	HookEvent("charger_pummel_end", Event_PounceChargeEnd, EventHookMode:1);
	HookEvent("charger_carry_end", Event_PounceChargeEnd, EventHookMode:1);
	HookEvent("charger_impact", Event_Impact, EventHookMode:1);
	HookEvent("player_bot_replace", Event_PlayerBotReplace, EventHookMode:1);
	HookEvent("bot_player_replace", Event_BotPlayerReplace, EventHookMode:1);
	HookEvent("round_end", Event_RoundEnd, EventHookMode:2);
	return 0;
}

public Action:Event_RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	ResetStaggerBlocked();
	return Action:0;
}

public OnMapEnd()
{
	ResetStaggerBlocked();
	return 0;
}

public Action:Event_BotPlayerReplace(Handle:event, String:name[], bool:dontBroadcast)
{
	new player = GetClientOfUserId(GetEventInt(event, "player"));
	new SurvivorCharacter:charIndex = IdentifySurvivor(player);
	if (charIndex == SurvivorCharacter:-1)
	{
		return Action:0;
	}
	if (isSurvivorStaggerBlocked[charIndex])
	{
		SDKHook(player, SDKHookType:5, OnThink);
	}
	return Action:0;
}

public Action:Event_PlayerBotReplace(Handle:event, String:name[], bool:dontBroadcast)
{
	new bot = GetClientOfUserId(GetEventInt(event, "bot"));
	new SurvivorCharacter:charIndex = IdentifySurvivor(bot);
	if (charIndex == SurvivorCharacter:-1)
	{
		return Action:0;
	}
	if (isSurvivorStaggerBlocked[charIndex])
	{
		SDKHook(bot, SDKHookType:5, OnThink);
	}
	return Action:0;
}

public Action:Event_Impact(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new SurvivorCharacter:charIndex = IdentifySurvivor(client);
	if (charIndex == SurvivorCharacter:-1)
	{
		return Action:0;
	}
	if (GetEntityFlags(client) & 1)
	{
		CreateTimer(0.2, HookOnThink, client, 0);
		isSurvivorStaggerBlocked[charIndex] = 1;
	}
	else
	{
		CreateTimer(0.1, Timer_Recheck, client, 1);
	}
	return Action:0;
}

public Action:Timer_Recheck(Handle:timer, any:client)
{
	new SurvivorCharacter:charIndex = IdentifySurvivor(client);
	if (charIndex == SurvivorCharacter:-1)
	{
		return Action:4;
	}
	if (GetEntityFlags(client) & 1)
	{
		SDKHook(client, SDKHookType:5, OnThink);
		isSurvivorStaggerBlocked[charIndex] = 1;
		return Action:4;
	}
	return Action:0;
}

public Action:Event_PounceChargeEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new SurvivorCharacter:charIndex = IdentifySurvivor(client);
	if (charIndex == SurvivorCharacter:-1)
	{
		return Action:0;
	}
	CreateTimer(0.2, HookOnThink, client, 0);
	isSurvivorStaggerBlocked[charIndex] = 1;
	return Action:0;
}

public Action:HookOnThink(Handle:timer, any:client)
{
	new var1;
	if (client && IsClientInGame(client) && IsSurvivor(client))
	{
		SDKHook(client, SDKHookType:5, OnThink);
	}
	return Action:0;
}

public OnThink(client)
{
	new SurvivorCharacter:charIndex = IdentifySurvivor(client);
	if (charIndex == SurvivorCharacter:-1)
	{
		return 0;
	}
	new sequence = GetEntProp(client, PropType:0, "m_nSequence", 4, 0);
	new var1;
	if (getUpAnimations[charIndex][0] != sequence && getUpAnimations[charIndex][1] != sequence && getUpAnimations[charIndex][2] != sequence && getUpAnimations[charIndex][3] != sequence && getUpAnimations[charIndex][4] != sequence)
	{
		isSurvivorStaggerBlocked[charIndex] = 0;
		SDKUnhook(client, SDKHookType:5, OnThink);
	}
	return 0;
}

public Action:L4D2_OnStagger(target, source)
{
	new var1;
	if (source && IsInfected(source))
	{
		new L4D2_Infected:sourceClass = GetInfectedClass(source);
		new var2;
		if (sourceClass == L4D2_Infected:3 || sourceClass == L4D2_Infected:5)
		{
			new SurvivorCharacter:charIndex = IdentifySurvivor(target);
			if (charIndex == SurvivorCharacter:-1)
			{
				return Action:0;
			}
			if (isSurvivorStaggerBlocked[charIndex])
			{
				return Action:3;
			}
		}
	}
	return Action:0;
}

public Action:L4D2_OnPounceOrLeapStumble(victim, attacker)
{
	if (IsInfected(attacker))
	{
		new L4D2_Infected:sourceClass = GetInfectedClass(attacker);
		new var1;
		if (sourceClass == L4D2_Infected:3 || sourceClass == L4D2_Infected:5)
		{
			new SurvivorCharacter:charIndex = IdentifySurvivor(victim);
			if (charIndex == SurvivorCharacter:-1)
			{
				return Action:0;
			}
			if (isSurvivorStaggerBlocked[charIndex])
			{
				return Action:3;
			}
		}
	}
	return Action:0;
}

public ResetStaggerBlocked()
{
	new i;
	while (i < 8)
	{
		isSurvivorStaggerBlocked[i] = 0;
		i++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "04/17/2017",
	time = "09:36:05"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	845427820, 1818850421, 0, 845427820, 1818850421, 2020438830, 0, 1620, 1632, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 264, 324, 384, 444, 504, 564, 624, 684, 744, 804, 864, 924, 984, 1044, 1104, 1164, 1224, 1284, 1344, 1404, 1464, 1524
};
new Handle:hSurvivorModelsTrie = 845427820;
new Handle:hWeaponNamesTrie = 845427820;
public SharedPlugin:__pl_l4d2util =
{
	name = "l4d2util",
	file = "l4d2util.smx",
	required = 1,
};
new Handle:hRageRock;
new Handle:hRageHittables;
new Handle:hHittable;
new Handle:hWitch;
new Handle:hFF;
new Handle:hSpit;
new Handle:hCommon;
new Handle:hHunter;
new Handle:hSmoker;
new Handle:hJockey;
new Handle:hCharger;
new Handle:hSpitFlags;
new Handle:hCommonFlags;
new Handle:hGodframeGlows;
new Handle:hCvarEnableShotFF;
new Handle:hCvarModifier;
new Handle:hCvarMinFF;
new Handle:hCvarMaxFF;
new Handle:buckshotTimer;
new Handle:g_cvarEnable;
new Handle:g_cvarBlockZeroDmg;
new Handle:g_cvarPermDamageFraction;
new g_EnabledFlags;
new g_BlockZeroDmg;
new g_lastHealth[66][16][2];
new g_lastReviveCount[66];
new g_currentUndo[66];
new g_targetTempHealth[66];
new g_lastPerm[66] =
{
	100, ...
};
new g_lastTemp[66];
new Float:g_flPermFrac;
new bool:g_chargerCarryNoFF[66];
new bool:g_stupidGuiltyBots[66];
new Float:fFakeGodframeEnd[66];
new iLastSI[66];
new pelletsShot[65][65];
new frustrationOffset[66];
new bool:bLateLoad;
public Plugin:myinfo =
{
	name = "L4D2 Godframes Control combined with FF Plugins",
	description = "Allows for control of what gets godframed and what doesnt along with integrated FF Support from l4d2_survivor_ff (by dcx and Visor) and l4d2_shotgun_ff (by Visor)",
	author = "Stabby, CircleSquared, Tabun, Visor, dcx, Sir",
	version = "0.4",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return oper1 + float(oper2);
}

bool:operator>(Float:,_:)(Float:oper1, oper2)
{
	return oper1 > float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

GetEntSendPropOffs(ent, String:prop[], bool:actual)
{
	decl String:cls[64];
	if (!GetEntityNetClass(ent, cls, 64))
	{
		return -1;
	}
	if (actual)
	{
		return FindSendPropInfo(cls, prop, 0, 0, 0);
	}
	return FindSendPropOffs(cls, prop);
}

bool:GetEntityClassname(entity, String:clsname[], maxlength)
{
	return !!GetEntPropString(entity, PropType:1, "m_iClassname", clsname, maxlength, 0);
}

SetEntityRenderMode(entity, RenderMode:mode)
{
	static bool:gotconfig;
	static String:prop[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_nRenderMode", prop, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(prop, 32, "m_nRenderMode");
		}
		gotconfig = true;
	}
	SetEntProp(entity, PropType:0, prop, mode, 1, 0);
	return 0;
}

SetEntityRenderColor(entity, r, g, b, a)
{
	static bool:gotconfig;
	static String:prop[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_clrRender", prop, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(prop, 32, "m_clrRender");
		}
		gotconfig = true;
	}
	new offset = GetEntSendPropOffs(entity, prop, false);
	if (0 >= offset)
	{
		ThrowError("SetEntityRenderColor not supported by this mod");
	}
	SetEntData(entity, offset, r, 1, true);
	SetEntData(entity, offset + 1, g, 1, true);
	SetEntData(entity, offset + 2, b, 1, true);
	SetEntData(entity, offset + 3, a, 1, true);
	return 0;
}

SetEntityHealth(entity, amount)
{
	static bool:gotconfig;
	static String:prop[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_iHealth", prop, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(prop, 32, "m_iHealth");
		}
		gotconfig = true;
	}
	decl String:cls[64];
	new PropFieldType:type;
	new offset;
	if (!GetEntityNetClass(entity, cls, 64))
	{
		ThrowError("SetEntityHealth not supported by this mod: Could not get serverclass name");
		return 0;
	}
	offset = FindSendPropInfo(cls, prop, type, 0, 0);
	if (0 >= offset)
	{
		ThrowError("SetEntityHealth not supported by this mod");
		return 0;
	}
	if (type == PropFieldType:2)
	{
		SetEntDataFloat(entity, offset, float(amount), false);
	}
	else
	{
		SetEntProp(entity, PropType:0, prop, amount, 4, 0);
	}
	return 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

CTimer_Invalidate(CountdownTimer:timer)
{
	CTimer_SetTimestamp(timer, -1.0);
	return 0;
}

CTimer_SetTimestamp(CountdownTimer:timer, Float:timestamp)
{
	StoreToAddress(timer + 8, timestamp, NumberType:2);
	return 0;
}

CountdownTimer:L4D2Direct_GetInvulnerabilityTimer(client)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return CountdownTimer:0;
	}
	new Address:pEntity = GetEntityAddress(client);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CTerrorPlayer::InvulnerabilityTimer");
		if (offs == -1)
		{
			return CountdownTimer:0;
		}
		return offs + pEntity;
	}
	return CountdownTimer:0;
}

public __pl_l4d2util_SetNTVOptional()
{
	return 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	hGodframeGlows = CreateConVar("gfc_godframe_glows", "1", "Changes the rendering of survivors while godframed (red/transparent).", 262144, true, 0.0, true, 1.0);
	hRageHittables = CreateConVar("gfc_hittable_rage_override", "1", "Allow tank to gain rage from hittable hits. 0 blocks rage gain.", 262144, true, 0.0, true, 1.0);
	hRageRock = CreateConVar("gfc_rock_rage_override", "1", "Allow tank to gain rage from godframed hits. 0 blocks rage gain.", 262144, true, 0.0, true, 1.0);
	hHittable = CreateConVar("gfc_hittable_override", "1", "Allow hittables to always ignore godframes.", 262144, true, 0.0, true, 1.0);
	hWitch = CreateConVar("gfc_witch_override", "1", "Allow witches to always ignore godframes.", 262144, true, 0.0, true, 1.0);
	hFF = CreateConVar("gfc_ff_min_time", "0.3", "Minimum time before FF damage is allowed.", 262144, true, 0.0, true, 3.0);
	hSpit = CreateConVar("gfc_spit_extra_time", "0.7", "Additional godframe time before spit damage is allowed.", 262144, true, 0.0, true, 3.0);
	hCommon = CreateConVar("gfc_common_extra_time", "0.0", "Additional godframe time before common damage is allowed.", 262144, true, 0.0, true, 3.0);
	hHunter = CreateConVar("gfc_hunter_duration", "2.1", "How long should godframes after a pounce last?", 262144, true, 0.0, true, 3.0);
	hJockey = CreateConVar("gfc_jockey_duration", "0.0", "How long should godframes after a ride last?", 262144, true, 0.0, true, 3.0);
	hSmoker = CreateConVar("gfc_smoker_duration", "0.0", "How long should godframes after a pull or choke last?", 262144, true, 0.0, true, 3.0);
	hCharger = CreateConVar("gfc_charger_duration", "2.1", "How long should godframes after a pummel last?", 262144, true, 0.0, true, 3.0);
	hSpitFlags = CreateConVar("gfc_spit_zc_flags", "6", "Which classes will be affected by extra spit protection time. 1 - Hunter. 2 - Smoker. 4 - Jockey. 8 - Charger.", 262144, true, 0.0, true, 15.0);
	hCommonFlags = CreateConVar("gfc_common_zc_flags", "0", "Which classes will be affected by extra common protection time. 1 - Hunter. 2 - Smoker. 4 - Jockey. 8 - Charger.", 262144, true, 0.0, true, 15.0);
	g_cvarEnable = CreateConVar("l4d2_undoff_enable", "7", "Bit flag: Enables plugin features (add together): 1=too close, 2=Charger carry, 4=guilty bots, 7=all, 0=off", 262400, false, 0.0, false, 0.0);
	g_cvarBlockZeroDmg = CreateConVar("l4d2_undoff_blockzerodmg", "7", "Bit flag: Block 0 damage friendly fire effects like recoil and vocalizations/stats (add together): 4=bot hits human block recoil, 2=block vocals/stats on ALL difficulties, 1=block vocals/stats on everything EXCEPT Easy (flag 2 has precedence), 0=off", 262400, false, 0.0, false, 0.0);
	g_cvarPermDamageFraction = CreateConVar("l4d2_undoff_permdmgfrac", "1.0", "Minimum fraction of damage applied to permanent health", 262400, true, 0.0, true, 1.0);
	hCvarEnableShotFF = CreateConVar("l4d2_shotgun_ff_enable", "1", "Enable Shotgun FF Module?", 0, false, 0.0, false, 0.0);
	hCvarModifier = CreateConVar("l4d2_shotgun_ff_multi", "0.5", "Shotgun FF damage modifier value", 262144, true, 0.0, true, 5.0);
	hCvarMinFF = CreateConVar("l4d2_shotgun_ff_min", "1.0", "Minimum allowed shotgun FF damage; 0 for no limit", 262144, true, 0.0, false, 0.0);
	hCvarMaxFF = CreateConVar("l4d2_shotgun_ff_max", "6.0", "Maximum allowed shotgun FF damage; 0 for no limit", 262144, true, 0.0, false, 0.0);
	HookConVarChange(g_cvarEnable, OnUndoFFEnableChanged);
	HookConVarChange(g_cvarBlockZeroDmg, OnUndoFFBlockZeroDmgChanged);
	HookConVarChange(g_cvarPermDamageFraction, OnPermFracChanged);
	g_EnabledFlags = GetConVarInt(g_cvarEnable);
	g_BlockZeroDmg = GetConVarInt(g_cvarBlockZeroDmg);
	g_flPermFrac = GetConVarFloat(g_cvarPermDamageFraction);
	HookEvent("player_hurt", Event_PlayerHurt, EventHookMode:1);
	HookEvent("friendly_fire", Event_FriendlyFire, EventHookMode:0);
	HookEvent("charger_carry_start", Event_ChargerCarryStart, EventHookMode:1);
	HookEvent("charger_carry_end", Event_ChargerCarryEnd, EventHookMode:1);
	HookEvent("heal_begin", Event_HealBegin, EventHookMode:0);
	HookEvent("heal_end", Event_HealEnd, EventHookMode:0);
	HookEvent("heal_success", Event_HealSuccess, EventHookMode:0);
	HookEvent("player_incapacitated_start", Event_PlayerIncapStart, EventHookMode:0);
	HookEvent("tongue_release", PostSurvivorRelease, EventHookMode:1);
	HookEvent("pounce_end", PostSurvivorRelease, EventHookMode:1);
	HookEvent("jockey_ride_end", PostSurvivorRelease, EventHookMode:1);
	HookEvent("charger_pummel_end", PostSurvivorRelease, EventHookMode:1);
	if (bLateLoad)
	{
		InitializeHooks(-1);
	}
	return 0;
}

public OnRoundStart()
{
	new i = 1;
	while (i <= MaxClients)
	{
		fFakeGodframeEnd[i] = 0;
		i++;
	}
	return 0;
}

public PostSurvivorRelease(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	if (!IsClientAndInGame(victim))
	{
		return 0;
	}
	if (StrContains(name, "tongue", true) != -1)
	{
		fFakeGodframeEnd[victim] = GetGameTime() + GetConVarFloat(hSmoker);
		iLastSI[victim] = 2;
	}
	else
	{
		if (StrContains(name, "pounce", true) != -1)
		{
			fFakeGodframeEnd[victim] = GetGameTime() + GetConVarFloat(hHunter);
			iLastSI[victim] = 1;
		}
		if (StrContains(name, "jockey", true) != -1)
		{
			fFakeGodframeEnd[victim] = GetGameTime() + GetConVarFloat(hJockey);
			iLastSI[victim] = 4;
		}
		if (StrContains(name, "charger", true) != -1)
		{
			fFakeGodframeEnd[victim] = GetGameTime() + GetConVarFloat(hCharger);
			iLastSI[victim] = 8;
		}
	}
	new var1;
	if (fFakeGodframeEnd[victim] > GetGameTime() && GetConVarBool(hGodframeGlows))
	{
		SetGodframedGlow(victim);
		CreateTimer(fFakeGodframeEnd[victim] - GetGameTime(), Timed_ResetGlow, victim, 0);
	}
	return 0;
}

public OnClientPutInServer(client)
{
	InitializeHooks(client);
	return 0;
}

InitializeHooks(client)
{
	new i = 1;
	while (i <= MaxClients)
	{
		if (client > -1)
		{
			i = client;
		}
		if (IsClientInGame(i))
		{
			SDKHook(i, SDKHookType:2, OnTakeDamage);
			SDKHook(i, SDKHookType:11, TraceAttackUndoFF);
		}
		new j;
		while (j < 16)
		{
			g_lastHealth[i][j][0] = 0;
			g_lastHealth[i][j][1] = 0;
			j++;
		}
		if (client > -1)
		{
			return 0;
		}
		i++;
	}
	return 0;
}

public Action:Timed_SetFrustration(Handle:timer, any:client)
{
	new var1;
	if (IsClientConnected(client) && IsPlayerAlive(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8)
	{
		new frust = GetEntProp(client, PropType:0, "m_frustration", 4, 0);
		frust = frustrationOffset[client][frust];
		if (frust > 100)
		{
			frust = 100;
		}
		else
		{
			if (0 > frust)
			{
				frust = 0;
			}
		}
		SetEntProp(client, PropType:0, "m_frustration", frust, 4, 0);
		frustrationOffset[client] = 0;
	}
	return Action:0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "OnTakeDamage" (number 23)
IsClientAndInGame(client)
{
	new var1;
	if (0 < client && client < MaxClients)
	{
		return IsClientInGame(client);
	}
	return 0;
}

IsSurvivorBusy(client)
{
	new var1;
	return GetEntPropEnt(client, PropType:0, "m_pummelAttacker", 0) > 0 || GetEntPropEnt(client, PropType:0, "m_carryAttacker", 0) > 0 || GetEntPropEnt(client, PropType:0, "m_pounceAttacker", 0) > 0 || GetEntPropEnt(client, PropType:0, "m_jockeyAttacker", 0) > 0 || GetEntPropEnt(client, PropType:0, "m_tongueOwner", 0) > 0;
}

public Action:Timed_ResetGlow(Handle:timer, any:client)
{
	ResetGlow(client);
	return Action:0;
}

ResetGlow(client)
{
	if (IsClientAndInGame(client))
	{
		SetEntityRenderMode(client, RenderMode:0);
		SetEntityRenderColor(client, 255, 255, 255, 255);
	}
	return 0;
}

SetGodframedGlow(client)
{
	new var1;
	if (IsClientAndInGame(client) && IsPlayerAlive(client) && GetClientTeam(client) == 2)
	{
		SetEntityRenderMode(client, RenderMode:3);
		SetEntityRenderColor(client, 255, 0, 0, 200);
	}
	return 0;
}

public OnMapStart()
{
	new i;
	while (i <= MaxClients)
	{
		ResetGlow(i);
		i++;
	}
	return 0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "TraceAttackUndoFF" (number 30)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_PlayerHurt" (number 31)
public Action:Event_PlayerIncapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	g_currentUndo[victim] = g_currentUndo[victim][0] % 16;
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var1;
	return (attacker > 0 && attacker <= MaxClients) && IsClientInGame(attacker) && GetClientTeam(attacker) == 2 && (g_EnabledFlags & 4 && g_stupidGuiltyBots[victim]);
}

public Action:Event_FriendlyFire(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_EnabledFlags & 4)
	{
		return Action:0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "guilty"));
	if (IsFakeClient(client))
	{
		g_stupidGuiltyBots[client] = 1;
		CreateTimer(0.4, StupidGuiltyBotDelay, client, 0);
	}
	return Action:0;
}

public Action:StupidGuiltyBotDelay(Handle:timer, any:client)
{
	g_stupidGuiltyBots[client] = 0;
	return Action:0;
}

public Action:Event_ChargerCarryStart(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_EnabledFlags & 2)
	{
		return Action:0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	g_chargerCarryNoFF[client] = 1;
	return Action:0;
}

public Action:Event_ChargerCarryEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	CreateTimer(1.0, ChargerCarryFFDelay, client, 0);
	return Action:0;
}

public Action:ChargerCarryFFDelay(Handle:timer, any:client)
{
	g_chargerCarryNoFF[client] = 0;
	return Action:0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_HealBegin" (number 38)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_HealEnd" (number 39)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_HealSuccess" (number 40)

/* ERROR! null */
 function "UndoDamage" (number 41)
Float:GetClientsDistance(victim, attacker)
{
	decl Float:attackerPos[3];
	decl Float:victimPos[3];
	decl Float:mins[3];
	decl Float:maxs[3];
	decl Float:halfHeight;
	GetClientMins(victim, mins);
	GetClientMaxs(victim, maxs);
	halfHeight = maxs[2] - mins[2] + 10;
	GetClientAbsOrigin(victim, victimPos);
	GetClientAbsOrigin(attacker, attackerPos);
	new Float:posHeightDiff = attackerPos[2] - victimPos[2];
	if (posHeightDiff > halfHeight)
	{
		attackerPos[2] -= halfHeight;
	}
	else
	{
		if (posHeightDiff < halfHeight * -1.0)
		{
			victimPos[2] -= halfHeight;
		}
		attackerPos[2] = victimPos[2];
	}
	return GetVectorDistance(victimPos, attackerPos, false);
}

public Float:GetWeaponFFDist(String:weaponName[])
{
	new var1;
	if (StrEqual(weaponName, "weapon_melee", true) || StrEqual(weaponName, "weapon_pistol", true))
	{
		return 25.0;
	}
	new var2;
	if (StrEqual(weaponName, "weapon_smg", true) || StrEqual(weaponName, "weapon_smg_silenced", true) || StrEqual(weaponName, "weapon_smg_mp5", true) || StrEqual(weaponName, "weapon_pistol_magnum", true))
	{
		return 30.0;
	}
	new var3;
	if (StrEqual(weaponName, "weapon_pumpshotgun", true) || StrEqual(weaponName, "weapon_shotgun_chrome", true) || StrEqual(weaponName, "weapon_hunting_rifle", true) || StrEqual(weaponName, "weapon_sniper_scout", true) || StrEqual(weaponName, "weapon_sniper_awp", true))
	{
		return 37.0;
	}
	return 0.0;
}

GetSafeEntityName(entity, String:TheName[], TheNameSize)
{
	new var1;
	if (entity > 0 && IsValidEntity(entity))
	{
		GetEntityClassname(entity, TheName, TheNameSize);
	}
	else
	{
		strcopy(TheName, TheNameSize, "Invalid");
	}
	return 0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "L4D_GetPlayerTempHealth" (number 45)
L4D_SetPlayerTempHealth(client, tempHealth)
{
	SetEntPropFloat(client, PropType:0, "m_healthBuffer", float(tempHealth), 0);
	SetEntPropFloat(client, PropType:0, "m_healthBufferTime", GetGameTime(), 0);
	return 0;
}

L4D_GetPlayerReviveCount(client)
{
	return GetEntProp(client, PropType:0, "m_currentReviveCount", 4, 0);
}

L4D_SetPlayerReviveCount(client, any:count)
{
	return SetEntProp(client, PropType:0, "m_currentReviveCount", count, 4, 0);
}

bool:L4D_IsPlayerIncapacitated(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 1, 0);
}

CheatCommand(client, String:command[], String:arguments[])
{
	new flags = GetCommandFlags(command);
	SetCommandFlags(command, flags & -16385);
	FakeClientCommand(client, "%s %s", command, arguments);
	SetCommandFlags(command, flags);
	return 0;
}

public OnUndoFFEnableChanged(Handle:cvar, String:oldVal[], String:newVal[])
{
	g_EnabledFlags = StringToInt(newVal, 10);
	return 0;
}

public OnUndoFFBlockZeroDmgChanged(Handle:cvar, String:oldVal[], String:newVal[])
{
	g_BlockZeroDmg = StringToInt(newVal, 10);
	return 0;
}

public OnPermFracChanged(Handle:cvar, String:oldVal[], String:newVal[])
{
	g_flPermFrac = StringToFloat(newVal);
	return 0;
}

bool:IsT1Shotgun(weapon)
{
	if (!IsValidEdict(weapon))
	{
		return false;
	}
	decl String:classname[64];
	GetEdictClassname(weapon, classname, 64);
	new var1;
	return StrEqual(classname, "weapon_pumpshotgun", true) || StrEqual(classname, "weapon_shotgun_chrome", true);
}

public Action:ProcessShot(Handle:timer, any:stack)
{
	static weapon;
	static attacker;
	static victim;
	if (!IsStackEmpty(stack))
	{
		PopStackCell(stack, victim, 0, false);
		PopStackCell(stack, attacker, 0, false);
		PopStackCell(stack, weapon, 0, false);
	}
	new var1;
	if ((victim > 0 && victim <= MaxClients) && IsClientInGame(victim) && ((attacker > 0 && attacker <= MaxClients) && IsClientInGame(attacker)))
	{
		new Float:minFF = GetConVarFloat(hCvarMinFF);
		decl Float:maxFF;
		new var6;
		if (GetConVarFloat(hCvarMaxFF) <= 0.0)
		{
			var6 = 1203982208;
		}
		else
		{
			var6 = GetConVarFloat(hCvarMaxFF);
		}
		maxFF = var6;
		decl Float:damage;
		new var7;
		if (GetConVarFloat(hCvarModifier) * pelletsShot[victim][attacker] < maxFF)
		{
			var7 = GetConVarFloat(hCvarModifier) * pelletsShot[victim][attacker];
		}
		else
		{
			var7 = maxFF;
		}
		new var8;
		if (minFF > var7)
		{
			var8 = minFF;
		}
		else
		{
			if (GetConVarFloat(hCvarModifier) * pelletsShot[victim][attacker] < maxFF)
			{
				var8 = GetConVarFloat(hCvarModifier) * pelletsShot[victim][attacker];
			}
			var8 = maxFF;
		}
		damage = var8;
		new newPelletCount = RoundFloat(damage);
		pelletsShot[victim][attacker] = 0;
		new i;
		while (i < newPelletCount)
		{
			SDKHooks_TakeDamage(victim, attacker, attacker, 1.0, 16777216, weapon, NULL_VECTOR, NULL_VECTOR);
			i++;
		}
	}
	ClearTimer(buckshotTimer);
	return Action:0;
}

ClearTimer(&Handle:timer)
{
	if (timer)
	{
		KillTimer(timer, false);
		timer = 0;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "06/24/2017",
	time = "09:12:35"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new bool:bIsBridge;
new bool:bIgnoreOverkill[66];
new Handle:hBridgeCarDamage;
new Handle:hLogStandingDamage;
new Handle:hCarStandingDamage;
new Handle:hBumperCarStandingDamage;
new Handle:hHandtruckStandingDamage;
new Handle:hForkliftStandingDamage;
new Handle:hBHLogStandingDamage;
new Handle:hDumpsterStandingDamage;
new Handle:hHaybaleStandingDamage;
new Handle:hBaggageStandingDamage;
new Handle:hStandardIncapDamage;
new Handle:hTankSelfDamage;
new Handle:hOverHitInterval;
public Plugin:myinfo =
{
	name = "L4D2 Hittable Control",
	description = "Allows for customisation of hittable damage values.",
	author = "Stabby, Visor",
	version = "0.4",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator!=(Float:,_:)(Float:oper1, oper2)
{
	return oper1 != float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	hBridgeCarDamage = CreateConVar("hc_bridge_car_damage", "25.0", "Damage of cars in the parish bridge finale. Overrides standard incap damage on incapacitated players.", 262144, true, 0.0, true, 300.0);
	hLogStandingDamage = CreateConVar("hc_sflog_standing_damage", "48.0", "Damage of hittable swamp fever logs to non-incapped survivors.", 262144, true, 0.0, true, 300.0);
	hBHLogStandingDamage = CreateConVar("hc_bhlog_standing_damage", "100.0", "Damage of hittable blood harvest logs to non-incapped survivors.", 262144, true, 0.0, true, 300.0);
	hCarStandingDamage = CreateConVar("hc_car_standing_damage", "100.0", "Damage of hittable non-parish-bridge cars to non-incapped survivors.", 262144, true, 0.0, true, 300.0);
	hBumperCarStandingDamage = CreateConVar("hc_bumpercar_standing_damage", "100.0", "Damage of hittable bumper cars to non-incapped survivors.", 262144, true, 0.0, true, 300.0);
	hHandtruckStandingDamage = CreateConVar("hc_handtruck_standing_damage", "8.0", "Damage of hittable handtrucks (aka dollies) to non-incapped survivors.", 262144, true, 0.0, true, 300.0);
	hForkliftStandingDamage = CreateConVar("hc_forklift_standing_damage", "100.0", "Damage of hittable forklifts to non-incapped survivors.", 262144, true, 0.0, true, 300.0);
	hDumpsterStandingDamage = CreateConVar("hc_dumpster_standing_damage", "100.0", "Damage of hittable dumpsters to non-incapped survivors.", 262144, true, 0.0, true, 300.0);
	hHaybaleStandingDamage = CreateConVar("hc_haybale_standing_damage", "48.0", "Damage of hittable haybales to non-incapped survivors.", 262144, true, 0.0, true, 300.0);
	hBaggageStandingDamage = CreateConVar("hc_baggage_standing_damage", "48.0", "Damage of hittable baggage carts to non-incapped survivors.", 262144, true, 0.0, true, 300.0);
	hStandardIncapDamage = CreateConVar("hc_incap_standard_damage", "100", "Damage of all hittables to incapped players. -1 will have incap damage default to valve's standard incoherent damages. -2 will have incap damage default to each hittable's corresponding standing damage.", 262144, true, -2.0, true, 300.0);
	hTankSelfDamage = CreateConVar("hc_disable_self_damage", "0", "If set, tank will not damage itself with hittables.", 262144, true, 0.0, true, 1.0);
	hOverHitInterval = CreateConVar("hc_overhit_time", "1.2", "The amount of time to wait before allowing consecutive hits from the same hittable to register. Recommended values: 0.0-0.5: instant kill; 0.5-0.7: sizeable overhit; 0.7-1.0: standard overhit; 1.0-1.2: reduced overhit; 1.2+: no overhit unless the car rolls back on top. Set to tank's punch interval (default 1.5) to fully remove all possibility of overhit.", 262144, true, 0.0, false, 0.0);
	return 0;
}

public OnMapStart()
{
	decl String:buffer[64];
	GetCurrentMap(buffer, 64);
	if (StrContains(buffer, "c5m5", true) != -1)
	{
		bIsBridge = true;
	}
	else
	{
		bIsBridge = false;
	}
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damageType)
{
	new var1;
	if (!IsValidEdict(attacker) || !IsValidEdict(victim) || !IsValidEdict(inflictor))
	{
		return Action:0;
	}
	decl String:sClass[64];
	GetEdictClassname(inflictor, sClass, 64);
	new var2;
	if (StrEqual(sClass, "prop_physics", true) || StrEqual(sClass, "prop_car_alarm", true))
	{
		if (bIgnoreOverkill[victim])
		{
			return Action:3;
		}
		new var3;
		if (attacker == victim && GetConVarBool(hTankSelfDamage))
		{
			return Action:3;
		}
		if (GetClientTeam(victim) != 2)
		{
			return Action:0;
		}
		decl String:sModelName[128];
		GetEntPropString(inflictor, PropType:1, "m_ModelName", sModelName, 128, 0);
		new Float:val = GetConVarFloat(hStandardIncapDamage);
		new var4;
		if (GetEntProp(victim, PropType:0, "m_isIncapacitated", 4, 0) && val != NaN)
		{
			if (val >= 0.0)
			{
				damage = val;
			}
			return Action:0;
		}
		else
		{
			new var5;
			if (StrContains(sModelName, "cara_", true) == -1 && StrContains(sModelName, "taxi_", true) == -1 && StrContains(sModelName, "police_car", true) == -1)
			{
				if (bIsBridge)
				{
					damage = GetConVarFloat(hBridgeCarDamage) * 4.0;
					inflictor = 0;
				}
				else
				{
					damage = GetConVarFloat(hCarStandingDamage);
				}
			}
			if (StrContains(sModelName, "dumpster", true) != -1)
			{
				damage = GetConVarFloat(hDumpsterStandingDamage);
			}
			if (StrEqual(sModelName, "models/props/cs_assault/forklift.mdl", true))
			{
				damage = GetConVarFloat(hForkliftStandingDamage);
			}
			if (StrEqual(sModelName, "models/props_vehicles/airport_baggage_cart2.mdl", true))
			{
				damage = GetConVarFloat(hBaggageStandingDamage);
			}
			if (StrEqual(sModelName, "models/props_unique/haybails_single.mdl", true))
			{
				damage = GetConVarFloat(hHaybaleStandingDamage);
			}
			if (StrEqual(sModelName, "models/props_foliage/Swamp_FallenTree01_bare.mdl", true))
			{
				damage = GetConVarFloat(hLogStandingDamage);
			}
			if (StrEqual(sModelName, "models/props_foliage/tree_trunk_fallen.mdl", true))
			{
				damage = GetConVarFloat(hBHLogStandingDamage);
			}
			if (StrEqual(sModelName, "models/props_fairgrounds/bumpercar.mdl", true))
			{
				damage = GetConVarFloat(hBumperCarStandingDamage);
			}
			if (StrEqual(sModelName, "models/props/cs_assault/handtruck.mdl", true))
			{
				damage = GetConVarFloat(hHandtruckStandingDamage);
			}
		}
		new Float:interval = GetConVarFloat(hOverHitInterval);
		if (interval >= 0.0)
		{
			bIgnoreOverkill[victim] = 1;
			CreateTimer(interval, Timed_ClearInvulnerability, victim, 0);
		}
		return Action:1;
	}
	return Action:0;
}

public Action:Timed_ClearInvulnerability(Handle:thisTimer, any:victim)
{
	bIgnoreOverkill[victim] = 0;
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "06/26/2017",
	time = "00:14:41"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_l4d2lib =
{
	name = "l4d2lib",
	file = "l4d2lib.smx",
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new Handle:hCvarNoEventHordeDuringTanks;
new Handle:hCvarHordeCheckpointAnnounce;
new Address:pZombieManager;
new commonLimit;
new commonTank;
new commonTotal;
new lastCheckpoint;
new bool:announcedInChat;
new bool:checkpointAnnounced[4];
public Plugin:myinfo =
{
	name = "L4D2 Horde Equaliser",
	description = "Make certain event hordes finite",
	author = "Visor (original idea by Sir)",
	version = "3.0.6",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

Float:operator-(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) - oper2;
}

bool:operator>=(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) >= oper2;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetCDirector()
{
	static Address:TheDirector;
	if (!TheDirector)
	{
		TheDirector = GameConfGetAddress(L4D2Direct_GetGameConf(), "CDirector");
	}
	return TheDirector;
}

bool:CTimer_HasStarted(CountdownTimer:timer)
{
	return CTimer_GetTimestamp(timer) >= 0.0;
}

Float:CTimer_GetRemainingTime(CountdownTimer:timer)
{
	return CTimer_GetTimestamp(timer) - GetGameTime();
}

Float:CTimer_GetTimestamp(CountdownTimer:timer)
{
	return LoadFromAddress(timer + 8, NumberType:2);
}

CountdownTimer:L4D2Direct_GetMobSpawnTimer()
{
	static Address:pMobSpawnTimer;
	if (!pMobSpawnTimer)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirector::MobSpawnTimer");
		if (offs == -1)
		{
			return CountdownTimer:0;
		}
		pMobSpawnTimer = L4D2Direct_GetCDirector() + offs;
	}
	return pMobSpawnTimer;
}

public __pl_l4d2lib_SetNTVOptional()
{
	MarkNativeAsOptional("L4D2_GetCurrentRound");
	MarkNativeAsOptional("L4D2_CurrentlyInRound");
	MarkNativeAsOptional("L4D2_GetSurvivorCount");
	MarkNativeAsOptional("L4D2_GetSurvivorOfIndex");
	MarkNativeAsOptional("L4D2_IsMapDataAvailable");
	MarkNativeAsOptional("L4D2_IsEntityInSaferoom");
	MarkNativeAsOptional("L4D2_GetMapStartOrigin");
	MarkNativeAsOptional("L4D2_GetMapEndOrigin");
	MarkNativeAsOptional("L4D2_GetMapStartDistance");
	MarkNativeAsOptional("L4D2_GetMapStartExtraDistance");
	MarkNativeAsOptional("L4D2_GetMapEndDistance");
	MarkNativeAsOptional("L4D2_GetMapValueInt");
	MarkNativeAsOptional("L4D2_GetMapValueFloat");
	MarkNativeAsOptional("L4D2_GetMapValueVector");
	MarkNativeAsOptional("L4D2_GetMapValueString");
	MarkNativeAsOptional("L4D2_CopyMapSubsection");
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	new Handle:gamedata = LoadGameConfigFile("left4downtown.l4d2");
	if (!gamedata)
	{
		SetFailState("Left4Downtown2 gamedata missing or corrupt");
	}
	pZombieManager = GameConfGetAddress(gamedata, "ZombieManager");
	if (!pZombieManager)
	{
		SetFailState("Couldn't find the 'ZombieManager' address");
	}
	hCvarNoEventHordeDuringTanks = CreateConVar("l4d2_heq_no_tank_horde", "0", "Put infinite hordes on a 'hold up' during Tank fights", 0, false, 0.0, false, 0.0);
	hCvarHordeCheckpointAnnounce = CreateConVar("l4d2_heq_checkpoint_sound", "1", "Play the incoming mob sound at checkpoints (each 1/4 of total commons killed off) to simulate L4D1 behaviour", 0, false, 0.0, false, 0.0);
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	return 0;
}

public OnMapStart()
{
	commonLimit = L4D2_GetMapValueInt("horde_limit", -1);
	commonTank = L4D2_GetMapValueInt("horde_tank", -1);
	PrecacheSound("/npc/mega_mob/mega_mob_incoming.wav", false);
	return 0;
}

public OnRoundStart()
{
	commonTotal = 0;
	lastCheckpoint = 0;
	announcedInChat = false;
	new i;
	while (i < 4)
	{
		checkpointAnnounced[i] = 0;
		i++;
	}
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	new var1;
	if (StrEqual(classname, "infected", false) && IsInfiniteHordeActive())
	{
		new var2;
		if (GetConVarBool(hCvarNoEventHordeDuringTanks) && IsTankUp())
		{
			return 0;
		}
		if (commonLimit < 120)
		{
			return 0;
		}
		if (commonTotal >= commonLimit)
		{
			return 0;
		}
		commonTotal += 1;
		new var3;
		if (GetConVarBool(hCvarHordeCheckpointAnnounce) && commonTotal >= RoundFloat(float(commonLimit / 4)) * lastCheckpoint + 1)
		{
			EmitSoundToAll("/npc/mega_mob/mega_mob_incoming.wav", -2, 0, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
			new remaining = commonLimit - commonTotal;
			if (remaining)
			{
				CPrintToChatAll("<{olive}Horde{default}> {red}%i {default}common remaining..", remaining);
			}
			checkpointAnnounced[lastCheckpoint] = 1;
			lastCheckpoint += 1;
		}
	}
	return 0;
}

public Action:L4D_OnSpawnMob(&amount)
{
	new var1;
	if ((GetConVarBool(hCvarNoEventHordeDuringTanks) || commonTank > 0) && (IsTankUp() && IsInfiniteHordeActive()))
	{
		SetPendingMobCount(0);
		amount = 0;
		return Action:3;
	}
	if (0 > commonLimit)
	{
		return Action:0;
	}
	if (IsInfiniteHordeActive())
	{
		if (!announcedInChat)
		{
			CPrintToChatAll("<{olive}Horde{default}> A {blue}finite event{default} of {olive}%i{default} commons has started! Rush or wait it out, the choice is yours!", commonLimit);
			announcedInChat = true;
		}
		if (commonTotal >= commonLimit)
		{
			SetPendingMobCount(0);
			amount = 0;
			return Action:3;
		}
	}
	return Action:0;
}

bool:IsInfiniteHordeActive()
{
	new countdown = GetHordeCountdown();
	new var1;
	return countdown > -1 && countdown <= 10;
}

SetPendingMobCount(count)
{
	return StoreToAddress(pZombieManager + 528, count, NumberType:2);
}

GetHordeCountdown()
{
	new var1;
	if (CTimer_HasStarted(L4D2Direct_GetMobSpawnTimer()))
	{
		var1 = RoundFloat(CTimer_GetRemainingTime(L4D2Direct_GetMobSpawnTimer()));
	}
	else
	{
		var1 = -1;
	}
	return var1;
}

bool:IsTankUp()
{
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && GetClientTeam(i) == 3 && GetEntProp(i, PropType:0, "m_zombieClass", 4, 0) == 8 && IsPlayerAlive(i))
		{
			return true;
		}
		i++;
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "01/10/2019",
	time = "21:40:55"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_l4d2lib =
{
	name = "l4d2lib",
	file = "l4d2lib.smx",
	required = 1,
};
new Handle:hCvarBonusPerSurvivorMultiplier;
new Handle:hCvarPermanentHealthProportion;
new Handle:hCvarPillsHpFactor;
new Handle:hCvarPillsMaxBonus;
new Handle:hCvarValveSurvivalBonus;
new Handle:hCvarValveTieBreaker;
new Float:fMapBonus;
new Float:fMapHealthBonus;
new Float:fMapDamageBonus;
new Float:fMapTempHealthBonus;
new Float:fPermHpWorth;
new Float:fTempHpWorth;
new Float:fSurvivorBonus[2];
new iMapDistance;
new iTeamSize;
new iPillWorth;
new iLostTempHealth[2];
new iTempHealth[66];
new iSiDamage[2];
new String:sSurvivorState[2][32];
new bool:bLateLoad;
new bool:bRoundOver;
new bool:bTiebreakerEligibility[2];
public Plugin:myinfo =
{
	name = "L4D2 Scoremod+",
	description = "The next generation scoring mod",
	author = "Visor",
	version = "2.2.2",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator/(Float:,_:)(Float:oper1, oper2)
{
	return oper1 / float(oper2);
}

Float:operator/(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) / oper2;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

GetEntityValueFromOffset(entity, String:offset[], NumberType:size, &value)
{
	new Address:pEntity = GetEntityAddress(entity);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), offset);
		if (offs == -1)
		{
			return 0;
		}
		value = LoadFromAddress(offs + pEntity, size);
		return 1;
	}
	return 0;
}

L4D2Direct_GetPreIncapHealthBuffer(client)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return -1;
	}
	new health;
	if (GetEntityValueFromOffset(client, "CTerrorPlayer::m_preIncapacitatedHealthBuffer", NumberType:2, health))
	{
		return health;
	}
	return -1;
}

public __pl_l4d2lib_SetNTVOptional()
{
	MarkNativeAsOptional("L4D2_GetCurrentRound");
	MarkNativeAsOptional("L4D2_CurrentlyInRound");
	MarkNativeAsOptional("L4D2_GetSurvivorCount");
	MarkNativeAsOptional("L4D2_GetSurvivorOfIndex");
	MarkNativeAsOptional("L4D2_IsMapDataAvailable");
	MarkNativeAsOptional("L4D2_IsEntityInSaferoom");
	MarkNativeAsOptional("L4D2_GetMapStartOrigin");
	MarkNativeAsOptional("L4D2_GetMapEndOrigin");
	MarkNativeAsOptional("L4D2_GetMapStartDistance");
	MarkNativeAsOptional("L4D2_GetMapStartExtraDistance");
	MarkNativeAsOptional("L4D2_GetMapEndDistance");
	MarkNativeAsOptional("L4D2_GetMapValueInt");
	MarkNativeAsOptional("L4D2_GetMapValueFloat");
	MarkNativeAsOptional("L4D2_GetMapValueVector");
	MarkNativeAsOptional("L4D2_GetMapValueString");
	MarkNativeAsOptional("L4D2_CopyMapSubsection");
	return 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	CreateNative("SMPlus_GetHealthBonus", Native_GetHealthBonus);
	CreateNative("SMPlus_GetDamageBonus", Native_GetDamageBonus);
	CreateNative("SMPlus_GetPillsBonus", Native_GetPillsBonus);
	CreateNative("SMPlus_GetMaxHealthBonus", Native_GetMaxHealthBonus);
	CreateNative("SMPlus_GetMaxDamageBonus", Native_GetMaxDamageBonus);
	CreateNative("SMPlus_GetMaxPillsBonus", Native_GetMaxPillsBonus);
	RegPluginLibrary("l4d2_hybrid_scoremod_zone");
	bLateLoad = late;
	return APLRes:0;
}

public void:OnPluginStart()
{
	hCvarBonusPerSurvivorMultiplier = CreateConVar("sm2_bonus_per_survivor_multiplier", "0.5", "Total Survivor Bonus = this * Number of Survivors * Map Distance", 262144, false, 0.0, false, 0.0);
	hCvarPermanentHealthProportion = CreateConVar("sm2_permament_health_proportion", "0.75", "Permanent Health Bonus = this * Map Bonus; rest goes for Temporary Health Bonus", 262144, false, 0.0, false, 0.0);
	hCvarPillsHpFactor = CreateConVar("sm2_pills_hp_factor", "6.0", "Unused pills HP worth = map bonus HP value / this", 262144, false, 0.0, false, 0.0);
	hCvarPillsMaxBonus = CreateConVar("sm2_pills_max_bonus", "30", "Unused pills cannot be worth more than this", 262144, false, 0.0, false, 0.0);
	hCvarValveSurvivalBonus = FindConVar("vs_survival_bonus");
	hCvarValveTieBreaker = FindConVar("vs_tiebreak_bonus");
	HookConVarChange(hCvarBonusPerSurvivorMultiplier, CvarChanged);
	HookConVarChange(hCvarPermanentHealthProportion, CvarChanged);
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	HookEvent("player_ledge_grab", OnPlayerLedgeGrab, EventHookMode:1);
	HookEvent("player_hurt", OnPlayerHurt, EventHookMode:1);
	RegConsoleCmd("sm_health", CmdBonus, "", 0);
	RegConsoleCmd("sm_damage", CmdBonus, "", 0);
	RegConsoleCmd("sm_bonus", CmdBonus, "", 0);
	RegConsoleCmd("sm_mapinfo", CmdMapInfo, "", 0);
	if (bLateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				OnClientPutInServer(i);
			}
			i++;
		}
	}
	return void:0;
}

public void:OnPluginEnd()
{
	ResetConVar(hCvarValveSurvivalBonus, false, false);
	ResetConVar(hCvarValveTieBreaker, false, false);
	return void:0;
}

public void:OnConfigsExecuted()
{
	iTeamSize = GetConVarInt(FindConVar("survivor_limit"));
	SetConVarInt(hCvarValveTieBreaker, 0, false, false);
	iMapDistance = L4D2_GetMapValueInt("max_distance", L4D_GetVersusMaxCompletionScore());
	L4D_SetVersusMaxCompletionScore(iMapDistance);
	new Float:fPermHealthProportion = GetConVarFloat(hCvarPermanentHealthProportion);
	new Float:fTempHealthProportion = 1.0 - fPermHealthProportion;
	fMapBonus = GetConVarFloat(hCvarBonusPerSurvivorMultiplier) * iTeamSize * iMapDistance;
	fMapHealthBonus = fMapBonus * fPermHealthProportion;
	fMapDamageBonus = fMapBonus * fTempHealthProportion;
	fMapTempHealthBonus = iTeamSize * 100 / fPermHealthProportion * fTempHealthProportion;
	fPermHpWorth = fMapBonus / iTeamSize / 100 * fPermHealthProportion;
	fTempHpWorth = fMapBonus * fTempHealthProportion / fMapTempHealthBonus;
	new var1;
	if (RoundToNearest(fPermHpWorth / GetConVarFloat(hCvarPillsHpFactor) * 50 / 5) * 5 > GetConVarInt(hCvarPillsMaxBonus))
	{
		var1 = GetConVarInt(hCvarPillsMaxBonus);
	}
	else
	{
		if (RoundToNearest(fPermHpWorth / GetConVarFloat(hCvarPillsHpFactor) * 50 / 5) * 5 < 5)
		{
			var1 = 5;
		}
		var1 = RoundToNearest(fPermHpWorth / GetConVarFloat(hCvarPillsHpFactor) * 50 / 5) * 5;
	}
	iPillWorth = var1;
	return void:0;
}

public void:OnMapStart()
{
	OnConfigsExecuted();
	iLostTempHealth[0] = 0;
	iLostTempHealth[1] = 0;
	iSiDamage[0] = 0;
	iSiDamage[1] = 0;
	bTiebreakerEligibility[0] = 0;
	bTiebreakerEligibility[1] = 0;
	return void:0;
}

public CvarChanged(Handle:convar, String:oldValue[], String:newValue[])
{
	OnConfigsExecuted();
	return 0;
}

public void:OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	SDKHook(client, SDKHookType:3, OnTakeDamagePost);
	return void:0;
}

public void:OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	SDKUnhook(client, SDKHookType:3, OnTakeDamagePost);
	return void:0;
}

public OnRoundStart()
{
	new i;
	while (i < 65)
	{
		iTempHealth[i] = 0;
		i++;
	}
	bRoundOver = false;
	return 0;
}

public Native_GetHealthBonus(Handle:plugin, numParams)
{
	return RoundToFloor(GetSurvivorHealthBonus());
}

public Native_GetMaxHealthBonus(Handle:plugin, numParams)
{
	return RoundToFloor(fMapHealthBonus);
}

public Native_GetDamageBonus(Handle:plugin, numParams)
{
	return RoundToFloor(GetSurvivorDamageBonus());
}

public Native_GetMaxDamageBonus(Handle:plugin, numParams)
{
	return RoundToFloor(fMapDamageBonus);
}

public Native_GetPillsBonus(Handle:plugin, numParams)
{
	return RoundToFloor(GetSurvivorPillBonus());
}

public Native_GetMaxPillsBonus(Handle:plugin, numParams)
{
	return iTeamSize * iPillWorth;
}

public Action:CmdBonus(client, args)
{
	new var1;
	if (bRoundOver || !client)
	{
		return Action:3;
	}
	decl String:sCmdType[64];
	GetCmdArg(1, sCmdType, 64);
	new Float:fHealthBonus = GetSurvivorHealthBonus();
	new Float:fDamageBonus = GetSurvivorDamageBonus();
	new Float:fPillsBonus = GetSurvivorPillBonus();
	new Float:fMaxPillsBonus = float(iTeamSize * iPillWorth);
	if (StrEqual(sCmdType, "full", true))
	{
		if (InSecondHalfOfRound())
		{
			new var2 = sSurvivorState;
			PrintToChat(client, "%s\x01R\x04#1\x01 Bonus: \x05%d\x01/\x05%d\x01 <\x03%.1f%%\x01> [%s]", "", RoundToFloor(fSurvivorBonus[0]), RoundToFloor(fMapBonus + fMaxPillsBonus), CalculateBonusPercent(fSurvivorBonus[0], -1.0), var2[0][var2]);
		}
		PrintToChat(client, "%s\x01R\x04#%i\x01 Bonus: \x05%d\x01 <\x03%.1f%%\x01> [HB: \x05%d\x01 <\x03%.1f%%\x01> | DB: \x05%d\x01 <\x03%.1f%%\x01> | Pills: \x05%d\x01 <\x03%.1f%%\x01>]", "", InSecondHalfOfRound() + 1, RoundToFloor(fHealthBonus + fDamageBonus + fPillsBonus), CalculateBonusPercent(fHealthBonus + fDamageBonus + fPillsBonus, fMapHealthBonus + fMapDamageBonus + fMaxPillsBonus), RoundToFloor(fHealthBonus), CalculateBonusPercent(fHealthBonus, fMapHealthBonus), RoundToFloor(fDamageBonus), CalculateBonusPercent(fDamageBonus, fMapDamageBonus), RoundToFloor(fPillsBonus), CalculateBonusPercent(fPillsBonus, fMaxPillsBonus));
	}
	else
	{
		if (StrEqual(sCmdType, "lite", true))
		{
			PrintToChat(client, "%s\x01R\x04#%i\x01 Bonus: \x05%d\x01 <\x03%.1f%%\x01>", "", InSecondHalfOfRound() + 1, RoundToFloor(fHealthBonus + fDamageBonus + fPillsBonus), CalculateBonusPercent(fHealthBonus + fDamageBonus + fPillsBonus, fMapHealthBonus + fMapDamageBonus + fMaxPillsBonus));
		}
		if (InSecondHalfOfRound())
		{
			PrintToChat(client, "%s\x01R\x04#1\x01 Bonus: \x05%d\x01 <\x03%.1f%%\x01>", "", RoundToFloor(fSurvivorBonus[0]), CalculateBonusPercent(fSurvivorBonus[0], -1.0));
		}
		PrintToChat(client, "%s\x01R\x04#%i\x01 Bonus: \x05%d\x01 <\x03%.1f%%\x01> [HB: \x03%.0f%%\x01 | DB: \x03%.0f%%\x01 | Pills: \x03%.0f%%\x01]", "", InSecondHalfOfRound() + 1, RoundToFloor(fHealthBonus + fDamageBonus + fPillsBonus), CalculateBonusPercent(fHealthBonus + fDamageBonus + fPillsBonus, fMapHealthBonus + fMapDamageBonus + fMaxPillsBonus), CalculateBonusPercent(fHealthBonus, fMapHealthBonus), CalculateBonusPercent(fDamageBonus, fMapDamageBonus), CalculateBonusPercent(fPillsBonus, fMaxPillsBonus));
	}
	return Action:3;
}

public Action:CmdMapInfo(client, args)
{
	new Float:fMaxPillsBonus = float(iTeamSize * iPillWorth);
	new Float:fTotalBonus = fMapBonus + fMaxPillsBonus;
	PrintToChat(client, "\x01[\x04Hybrid Bonus\x01 :: \x03%iv%i\x01] Map Info", iTeamSize, iTeamSize);
	PrintToChat(client, "\x01Distance: \x05%d\x01", iMapDistance);
	PrintToChat(client, "\x01Total Bonus: \x05%d\x01 <\x03100.0%%\x01>", RoundToFloor(fTotalBonus));
	PrintToChat(client, "\x01Health Bonus: \x05%d\x01 <\x03%.1f%%\x01>", RoundToFloor(fMapHealthBonus), CalculateBonusPercent(fMapHealthBonus, fTotalBonus));
	PrintToChat(client, "\x01Damage Bonus: \x05%d\x01 <\x03%.1f%%\x01>", RoundToFloor(fMapDamageBonus), CalculateBonusPercent(fMapDamageBonus, fTotalBonus));
	PrintToChat(client, "\x01Pills Bonus: \x05%d\x01(max \x05%d\x01) <\x03%.1f%%\x01>", iPillWorth, RoundToFloor(fMaxPillsBonus), CalculateBonusPercent(fMaxPillsBonus, fTotalBonus));
	PrintToChat(client, "\x01Tiebreaker: \x05%d\x01", iPillWorth);
	return Action:3;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	new var1;
	if (!IsSurvivor(victim) || IsPlayerIncap(victim))
	{
		return Action:0;
	}
	iTempHealth[victim] = GetSurvivorTemporaryHealth(victim);
	if (!IsAnyInfected(attacker))
	{
		new var3 = iSiDamage[InSecondHalfOfRound()];
		new var2;
		if (damage <= 100.0)
		{
			var2 = RoundFloat(damage);
		}
		else
		{
			var2 = 100;
		}
		var3 = var3[var2];
	}
	return Action:0;
}

public OnPlayerLedgeGrab(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	new var1 = iLostTempHealth[InSecondHalfOfRound()];
	var1 = var1[L4D2Direct_GetPreIncapHealthBuffer(client)];
	return 0;
}

public Action:L4D2_OnRevived(client)
{
	iLostTempHealth[InSecondHalfOfRound()] -= GetSurvivorTemporaryHealth(client);
	return Action:0;
}

public Action:OnPlayerHurt(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "userid", 0));
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker", 0));
	new damage = GetEventInt(event, "dmg_health", 0);
	new damagetype = GetEventInt(event, "type", 0);
	new fFakeDamage = damage;
	new var1;
	if (!IsSurvivor(victim) || !IsSurvivor(attacker) || IsPlayerIncap(victim) || damagetype == 16777216 || fFakeDamage < GetSurvivorPermanentHealth(victim))
	{
		return Action:0;
	}
	iTempHealth[victim] = GetSurvivorTemporaryHealth(victim);
	if (iTempHealth[victim] < fFakeDamage)
	{
		fFakeDamage = iTempHealth[victim];
	}
	new var2 = iLostTempHealth[InSecondHalfOfRound()];
	var2 = var2[fFakeDamage];
	iTempHealth[victim] = GetSurvivorTemporaryHealth(victim) - fFakeDamage;
	return Action:0;
}

public OnTakeDamagePost(victim, attacker, inflictor, Float:damage, damagetype)
{
	if (!IsSurvivor(victim))
	{
		return 0;
	}
	new var2;
	if (!IsPlayerAlive(victim) || (IsPlayerIncap(victim) && !IsPlayerLedged(victim)))
	{
		new var5 = iLostTempHealth[InSecondHalfOfRound()];
		var5 = iTempHealth[victim][var5];
	}
	else
	{
		if (!IsPlayerLedged(victim))
		{
			new var6 = iLostTempHealth[InSecondHalfOfRound()];
			new var3;
			if (iTempHealth[victim])
			{
				var3 = iTempHealth[victim] - GetSurvivorTemporaryHealth(victim);
			}
			else
			{
				var3 = 0;
			}
			var6 = var6[var3];
		}
	}
	new var4;
	if (IsPlayerIncap(victim))
	{
		var4 = 0;
	}
	else
	{
		var4 = GetSurvivorTemporaryHealth(victim);
	}
	iTempHealth[victim] = var4;
	return 0;
}

public L4D2_ADM_OnTemporaryHealthSubtracted(client, oldHealth, newHealth)
{
	new healthLost = oldHealth - newHealth;
	iTempHealth[client] = newHealth;
	new var1 = iLostTempHealth[InSecondHalfOfRound()];
	var1 = var1[healthLost];
	new var2 = iSiDamage[InSecondHalfOfRound()];
	var2 = var2[healthLost];
	return 0;
}

public Action:L4D2_OnEndVersusModeRound(bool:countSurvivors)
{
	if (bRoundOver)
	{
		return Action:0;
	}
	new team = InSecondHalfOfRound();
	new iSurvivalMultiplier = GetUprightSurvivors();
	fSurvivorBonus[team] = GetSurvivorHealthBonus() + GetSurvivorDamageBonus() + GetSurvivorPillBonus();
	fSurvivorBonus[team] = float(iTeamSize * RoundToFloor(fSurvivorBonus[team] / float(iTeamSize)));
	new var1;
	if (iSurvivalMultiplier > 0 && RoundToFloor(fSurvivorBonus[team] / iSurvivalMultiplier) >= iTeamSize)
	{
		SetConVarInt(hCvarValveSurvivalBonus, RoundToFloor(fSurvivorBonus[team] / iSurvivalMultiplier), false, false);
		fSurvivorBonus[team] = float(iSurvivalMultiplier * GetConVarInt(hCvarValveSurvivalBonus));
		new var2;
		if (iTeamSize == iSurvivalMultiplier)
		{
			var2[0] = 4760;
		}
		else
		{
			var2[0] = 4764;
		}
		Format(sSurvivorState[team], 32, "%s%i\x01/\x05%i\x01", var2, iSurvivalMultiplier, iTeamSize);
	}
	else
	{
		fSurvivorBonus[team] = 0;
		SetConVarInt(hCvarValveSurvivalBonus, 0, false, false);
		new var3;
		if (iSurvivalMultiplier)
		{
			var3[0] = 4788;
		}
		else
		{
			var3[0] = 4776;
		}
		Format(sSurvivorState[team], 32, "\x04%s\x01", var3);
		bTiebreakerEligibility[team] = iTeamSize == iSurvivalMultiplier;
	}
	new var4;
	if (team > 0 && bTiebreakerEligibility[0] && bTiebreakerEligibility[1])
	{
		GameRules_SetProp("m_iChapterDamage", iSiDamage[0], 4, 0, true);
		GameRules_SetProp("m_iChapterDamage", iSiDamage[1], 4, 1, true);
		if (iSiDamage[1] != iSiDamage[0])
		{
			SetConVarInt(hCvarValveTieBreaker, iPillWorth, false, false);
		}
	}
	CreateTimer(3.0, PrintRoundEndStats, any:0, 2);
	bRoundOver = true;
	return Action:0;
}

public Action:PrintRoundEndStats(Handle:timer)
{
	new i;
	while (InSecondHalfOfRound() >= i)
	{
		PrintToChatAll("%s\x01Round \x04%i\x01 Bonus: \x05%d\x01/\x05%d\x01 <\x03%.1f%%\x01> [%s]", 4892, i + 1, RoundToFloor(fSurvivorBonus[i]), RoundToFloor(fMapBonus + float(iTeamSize * iPillWorth)), CalculateBonusPercent(fSurvivorBonus[i], -1.0), sSurvivorState[i]);
		i++;
	}
	new var1;
	if (InSecondHalfOfRound() && bTiebreakerEligibility[0] && bTiebreakerEligibility[1])
	{
		PrintToChatAll("%s\x03TIEBREAKER\x01: Team \x04%#1\x01 - \x05%i\x01, Team \x04%#2\x01 - \x05%i\x01", 4952, iSiDamage, 3196 + 4);
		if (iSiDamage[1] == iSiDamage[0])
		{
			PrintToChatAll("%s\x05Teams have performed absolutely equal! Impossible to decide a clear round winner", 5040);
		}
	}
	return Action:0;
}

Float:GetSurvivorHealthBonus()
{
	new Float:fHealthBonus = 0.0;
	new survivorCount;
	new survivalMultiplier;
	new i = 1;
	while (i <= MaxClients && survivorCount < iTeamSize)
	{
		if (IsSurvivor(i))
		{
			survivorCount++;
			new var2;
			if (IsPlayerAlive(i) && !IsPlayerIncap(i) && !IsPlayerLedged(i))
			{
				survivalMultiplier++;
				fHealthBonus += fPermHpWorth * GetSurvivorPermanentHealth(i);
			}
		}
		i++;
	}
	return fHealthBonus / iTeamSize * survivalMultiplier;
}

Float:GetSurvivorDamageBonus()
{
	new survivalMultiplier = GetUprightSurvivors();
	new Float:fDamageBonus = fMapTempHealthBonus - float(iLostTempHealth[InSecondHalfOfRound()]) * fTempHpWorth / iTeamSize * survivalMultiplier;
	new var1;
	if (fDamageBonus > 0.0 && survivalMultiplier > 0)
	{
		var2 = fDamageBonus;
	}
	else
	{
		var2 = 0.0;
	}
	return var2;
}

Float:GetSurvivorPillBonus()
{
	new pillsBonus;
	new survivorCount;
	new i = 1;
	while (i <= MaxClients && survivorCount < iTeamSize)
	{
		if (IsSurvivor(i))
		{
			survivorCount++;
			new var2;
			if (IsPlayerAlive(i) && HasPills(i))
			{
				pillsBonus = iPillWorth + pillsBonus;
			}
		}
		i++;
	}
	return float(pillsBonus);
}

Float:CalculateBonusPercent(Float:score, Float:maxbonus)
{
	new var1;
	if (-1.0 == maxbonus)
	{
		var1 = fMapBonus + float(iTeamSize * iPillWorth);
	}
	else
	{
		var1 = maxbonus;
	}
	return score / var1 * 100;
}

InSecondHalfOfRound()
{
	return GameRules_GetProp("m_bInSecondHalfOfRound", 4, 0);
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsAnyInfected(entity)
{
	new var1;
	if (entity > 0 && entity <= MaxClients)
	{
		new var2;
		return IsClientInGame(entity) && GetClientTeam(entity) == 3;
	}
	if (entity > MaxClients)
	{
		decl String:classname[64];
		GetEdictClassname(entity, classname, 64);
		new var3;
		if (StrEqual(classname, "infected", true) || StrEqual(classname, "witch", true))
		{
			return true;
		}
	}
	return false;
}

bool:IsPlayerIncap(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

bool:IsPlayerLedged(client)
{
	return GetEntProp(client, PropType:0, "m_isFallingFromLedge", 4, 0) | GetEntProp(client, PropType:0, "m_isHangingFromLedge", 4, 0);
}

GetUprightSurvivors()
{
	new aliveCount;
	new survivorCount;
	new i = 1;
	while (i <= MaxClients && survivorCount < iTeamSize)
	{
		if (IsSurvivor(i))
		{
			survivorCount++;
			new var2;
			if (IsPlayerAlive(i) && !IsPlayerIncap(i) && !IsPlayerLedged(i))
			{
				aliveCount++;
			}
		}
		i++;
	}
	return aliveCount;
}

GetSurvivorTemporaryHealth(client)
{
	new temphp = RoundToCeil(GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0) - GetGameTime() - GetEntPropFloat(client, PropType:0, "m_healthBufferTime", 0) * GetConVarFloat(FindConVar("pain_pills_decay_rate"))) + -1;
	new var1;
	if (temphp > 0)
	{
		var1 = temphp;
	}
	else
	{
		var1 = 0;
	}
	return var1;
}

GetSurvivorPermanentHealth(client)
{
	new var1;
	if (GetEntProp(client, PropType:0, "m_currentReviveCount", 4, 0) > 0)
	{
		var1 = 0;
	}
	else
	{
		if (GetEntProp(client, PropType:0, "m_iHealth", 4, 0) > 0)
		{
			var1 = GetEntProp(client, PropType:0, "m_iHealth", 4, 0);
		}
		var1 = 0;
	}
	return var1;
}

bool:HasPills(client)
{
	new item = GetPlayerWeaponSlot(client, 4);
	if (IsValidEdict(item))
	{
		decl String:buffer[64];
		GetEdictClassname(item, buffer, 64);
		return StrEqual(buffer, "weapon_pain_pills", true);
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "03/24/2014",
	time = "18:02:41"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_dhooks =
{
	name = "dhooks",
	file = "dhooks.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCLeap_OnTouch;
public Plugin:myinfo =
{
	name = "L4D2 Jockeyed Charger Fix",
	description = "Prevent jockeys and chargers from capping the same target simultaneously",
	author = "Visor",
	version = "1.3",
	url = "https://github.com/Attano/smplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	hCLeap_OnTouch = DHookCreate(215, HookType:0, ReturnType:1, ThisPointerType:1, CLeap_OnTouch);
	DHookAddParam(hCLeap_OnTouch, HookParamType:8);
	DHookAddEntityListener(ListenType:0, OnEntityCreated);
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	if (StrEqual(classname, "ability_leap", true))
	{
		DHookEntity(hCLeap_OnTouch, false, entity, DHookRemovalCB:-1);
	}
	return 0;
}

public MRESReturn:CLeap_OnTouch(ability, Handle:hParams)
{
	new jockey = GetEntPropEnt(ability, PropType:0, "m_owner", 0);
	new survivor = DHookGetParam(hParams, 1);
	new var1;
	if (IsValidJockey(jockey) && IsSurvivor(survivor))
	{
		new var2;
		if (IsValidCharger(GetCarrier(survivor)) || IsValidCharger(GetPummelQueueAttacker(survivor)) || IsValidCharger(GetPummelAttacker(survivor)))
		{
			return MRESReturn:3;
		}
	}
	return MRESReturn:0;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsValidJockey(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 5;
}

bool:IsValidCharger(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 6;
}

GetCarrier(survivor)
{
	return GetEntDataEnt2(survivor, 10860);
}

GetPummelQueueAttacker(survivor)
{
	return GetEntDataEnt2(survivor, 15988);
}

GetPummelAttacker(survivor)
{
	return GetEntDataEnt2(survivor, 15976);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:24"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_collisionhook =
{
	name = "CollisionHook",
	file = "collisionhook.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Jockeyed Survivor Ladder Fix",
	description = "Fixes jockeyed Survivors slowly sliding down the ladders",
	author = "Visor",
	version = "1.1",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public Action:CH_PassFilter(entity1, entity2, &bool:result)
{
	new var1;
	if ((IsJockeyedSurvivor(entity1) || IsJockeyedSurvivor(entity2)) && (IsLadder(entity1) || IsLadder(entity2)))
	{
		result = 0;
		return Action:3;
	}
	return Action:0;
}

bool:IsLadder(entity)
{
	new var1;
	if (entity > 0 && IsValidEntity(entity) && IsValidEdict(entity))
	{
		decl String:strClassName[64];
		GetEdictClassname(entity, strClassName, 64);
		return StrContains(strClassName, "ladder", true) > 0;
	}
	return false;
}

bool:IsJockeyedSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2 && IsJockeyed(client);
}

bool:IsJockey(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 5;
}

bool:IsJockeyed(survivor)
{
	return IsJockey(GetEntDataEnt2(survivor, 16128));
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_dhooks =
{
	name = "dhooks",
	file = "dhooks.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCLeap_OnTouch;
new bool:blockJumpCap[66];
public Plugin:myinfo =
{
	name = "L4D2 Jockey Jump-Cap Patch",
	description = "Prevent Jockeys from being able to land caps with non-ability jumps in unfair situations",
	author = "Visor",
	version = "1.2",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	hCLeap_OnTouch = DHookCreate(215, HookType:0, ReturnType:1, ThisPointerType:1, CLeap_OnTouch);
	DHookAddParam(hCLeap_OnTouch, HookParamType:8);
	DHookAddEntityListener(ListenType:0, OnEntityCreated);
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	HookEvent("player_shoved", OnPlayerShoved, EventHookMode:1);
	return 0;
}

public OnRoundStart()
{
	new i = 1;
	while (i <= MaxClients)
	{
		blockJumpCap[i] = 0;
		i++;
	}
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	if (StrEqual(classname, "ability_leap", true))
	{
		DHookEntity(hCLeap_OnTouch, false, entity, DHookRemovalCB:-1);
	}
	return 0;
}

public Action:OnPlayerShoved(Handle:event, String:name[], bool:dontBroadcast)
{
	new shovee = GetClientOfUserId(GetEventInt(event, "userid"));
	new shover = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var1;
	if (IsSurvivor(shover) && IsJockey(shovee))
	{
		blockJumpCap[shovee] = 1;
		CreateTimer(3.0, ResetJumpcapState, shovee, 2);
	}
	return Action:0;
}

public Action:ResetJumpcapState(Handle:timer, any:jockey)
{
	blockJumpCap[jockey] = 0;
	return Action:3;
}

public MRESReturn:CLeap_OnTouch(ability, Handle:hParams)
{
	new jockey = GetEntPropEnt(ability, PropType:0, "m_owner", 0);
	new survivor = DHookGetParam(hParams, 1);
	new var1;
	if (IsJockey(jockey) && !IsFakeClient(jockey) && IsSurvivor(survivor))
	{
		new var2;
		if (!IsAbilityActive(ability) && blockJumpCap[jockey])
		{
			return MRESReturn:3;
		}
	}
	return MRESReturn:0;
}

bool:IsAbilityActive(ability)
{
	return GetEntData(ability, 1148, 4);
}

bool:IsJockey(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 5;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/21/2014",
	time = "20:51:57"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new Handle:z_leap_damage_interrupt;
new Handle:z_jockey_health;
new Handle:jockey_skeet_report;
new Float:jockeySkeetDmg;
new Float:jockeyHealth;
new Float:inflictedDamage[66][66];
new bool:reportJockeySkeets;
new bool:lateLoad;
public Plugin:myinfo =
{
	name = "L4D2 Jockey Skeet",
	description = "A dream come true",
	author = "Visor",
	version = "1.3",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator>=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) >= 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	BfWriteByte(hBuffer, author);
	BfWriteByte(hBuffer, 1);
	BfWriteString(hBuffer, szMessage);
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	lateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	z_leap_damage_interrupt = CreateConVar("z_leap_damage_interrupt", "195.0", "Taking this much damage interrupts a leap attempt", 262144, true, 10.0, true, 325.0);
	jockey_skeet_report = CreateConVar("jockey_skeet_report", "1", "Report jockey skeets in chat?", 262144, true, 0.0, true, 1.0);
	z_jockey_health = FindConVar("z_jockey_health");
	if (lateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				SDKHook(i, SDKHookType:2, OnTakeDamage);
			}
			i++;
		}
	}
	return 0;
}

public OnConfigsExecuted()
{
	jockeySkeetDmg = GetConVarFloat(z_leap_damage_interrupt);
	reportJockeySkeets = GetConVarBool(jockey_skeet_report);
	jockeyHealth = GetConVarFloat(z_jockey_health);
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (!IsJockey(victim) || !IsSurvivor(attacker) || IsFakeClient(attacker))
	{
		return Action:0;
	}
	new var2;
	if (!HasJockeyTarget(victim) && IsAttachable(victim) && IsShotgun(weapon))
	{
		new var5 = inflictedDamage[victim][attacker];
		var5 = var5[damage];
		if (inflictedDamage[victim][attacker] >= jockeySkeetDmg)
		{
			if (reportJockeySkeets)
			{
				CPrintToChat(victim, "{green}{default} You were {blue}skeeted{default} by {olive}%N{default}.", attacker);
				CPrintToChat(attacker, "{green}{default} You {blue}skeeted {olive}%N{default}'s Jockey.", victim);
				new i = 1;
				while (i <= MaxClients)
				{
					new var3;
					if (victim != i && attacker != i)
					{
					}
					else
					{
						new var4;
						if (IsClientInGame(i) && !IsFakeClient(i))
						{
							CPrintToChat(i, "{green}{default} {olive}%N{default}'s Jockey was {blue}skeeted{default} by {olive}%N{default}.", victim, attacker);
						}
					}
					i++;
				}
			}
			damage = jockeyHealth;
			return Action:1;
		}
		CreateTimer(0.1, ResetDamageCounter, victim, 0);
	}
	return Action:0;
}

public Action:ResetDamageCounter(Handle:timer, any:jockey)
{
	new i = 1;
	while (i <= MaxClients)
	{
		inflictedDamage[jockey][i] = 0.0;
		i++;
	}
	return Action:0;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsJockey(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 5 && GetEntProp(client, PropType:0, "m_isGhost", 4, 0) != 1;
}

bool:HasJockeyTarget(infected)
{
	new client = GetEntDataEnt2(infected, 16124);
	new var1;
	return IsSurvivor(client) && IsPlayerAlive(client);
}

bool:IsAttachable(jockey)
{
	return !GetEntityFlags(jockey) & 1;
}

bool:IsShotgun(weapon)
{
	decl String:classname[64];
	GetEdictClassname(weapon, classname, 64);
	new var1;
	return StrEqual(classname, "weapon_pumpshotgun", true) || StrEqual(classname, "weapon_shotgun_chrome", true);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "11/19/2013",
	time = "13:17:14"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "sdkhooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new inCharge[66];
public Plugin:myinfo =
{
	name = "StopTrolls",
	description = "Prevents people from blocking players who climb on the ladder.",
	author = "raziEiL [disawar1]",
	version = "1.0",
	url = "http://steamcommunity.com/id/raziEiL"
};
new Handle:g_hFlags;
new Handle:g_hImmune;
new g_iCvarFlags;
new g_iCvarImmune;
new bool:g_bLoadLate;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:operator<(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) < 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

MoveType:GetEntityMoveType(entity)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_MoveType", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_MoveType");
		}
		gotconfig = true;
	}
	return GetEntProp(entity, PropType:1, datamap, 4, 0);
}

public OnPluginStart()
{
	CreateConVar("stop_trolls_version", "1.0", "StopTrolls plugin version", 8448, false, 0.0, false, 0.0);
	g_hFlags = CreateConVar("stop_trolls_flags", "862", "Who can push trolls when climbs on the ladder. 0=Disable, 2=Smoker, 4=Boomer, 8=Hunter, 16=Spitter, 64=Charger, 256=Tank, 512=Survivors, 862=All", 0, false, 0.0, false, 0.0);
	g_hImmune = CreateConVar("stop_trolls_immune", "256", "What class is immune. 0=Disable, 2=Smoker, 4=Boomer, 8=Hunter, 16=Spitter, 32=Jockey, 64=Charger, 256=Tank, 512=Survivors, 894=All", 0, false, 0.0, false, 0.0);
	HookEvent("charger_charge_start", Charging, EventHookMode:1);
	HookEvent("charger_charge_end", NotCharging, EventHookMode:1);
	HookConVarChange(g_hFlags, OnCvarChange_Flags);
	HookConVarChange(g_hImmune, OnCvarChange_Immune);
	ST_GetCvars();
	new var1;
	if (g_iCvarFlags && g_bLoadLate)
	{
		ST_ToogleHook(true);
	}
	return 0;
}

public OnClientPutInServer(client)
{
	inCharge[client] = 0;
	new var1;
	if (g_iCvarFlags && client)
	{
		SDKHook(client, SDKHookType:10, SDKHook_cb_Touch);
	}
	return 0;
}

public Charging(Handle:event, String:name[], bool:dontBroadcast)
{
	new ChargerID = GetEventInt(event, "userid");
	new charger = GetClientOfUserId(ChargerID);
	inCharge[charger] = 1;
	return 0;
}

public NotCharging(Handle:event, String:name[], bool:dontBroadcast)
{
	new ChargerID = GetEventInt(event, "userid");
	new charger = GetClientOfUserId(ChargerID);
	inCharge[charger] = 0;
	return 0;
}

public Action:SDKHook_cb_Touch(entity, other)
{
	new var1;
	if (other > MaxClients || other < 1)
	{
		return Action:0;
	}
	if (IsGuyTroll(entity, other))
	{
		new iClass = GetEntProp(entity, PropType:0, "m_zombieClass", 4, 0);
		new var2;
		if (iClass != 5 && 1 << iClass & g_iCvarFlags)
		{
			new var3;
			if (iClass == 8 && IsFakeClient(entity))
			{
				return Action:0;
			}
			iClass = GetEntProp(other, PropType:0, "m_zombieClass", 4, 0);
			if (1 << iClass & g_iCvarImmune)
			{
				return Action:0;
			}
			if (inCharge[other])
			{
				return Action:0;
			}
			if (IsOnLadder(other))
			{
				decl Float:vOrg[3];
				GetClientAbsOrigin(other, vOrg);
				vOrg[2] += 2.5;
				TeleportEntity(other, vOrg, NULL_VECTOR, NULL_VECTOR);
			}
			TeleportEntity(other, NULL_VECTOR, NULL_VECTOR, 1256);
		}
	}
	return Action:0;
}

bool:IsGuyTroll(victim, troll)
{
	new var1;
	return IsOnLadder(victim) && GetClientTeam(troll) != GetClientTeam(victim) && GetEntPropFloat(victim, PropType:0, "m_vecOrigin[2]", 0) < GetEntPropFloat(troll, PropType:0, "m_vecOrigin[2]", 0);
}

bool:IsOnLadder(entity)
{
	return GetEntityMoveType(entity) == 9;
}

ST_ToogleHook(bool:bHook)
{
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			if (bHook)
			{
				SDKHook(i, SDKHookType:10, SDKHook_cb_Touch);
			}
			else
			{
				SDKUnhook(i, SDKHookType:10, SDKHook_cb_Touch);
			}
		}
		i++;
	}
	return 0;
}

public OnCvarChange_Flags(Handle:convar_hndl, String:oldValue[], String:newValue[])
{
	if (StrEqual(oldValue, newValue, true))
	{
		return 0;
	}
	g_iCvarFlags = GetConVarInt(g_hFlags);
	if (!StringToInt(oldValue, 10))
	{
		ST_ToogleHook(true);
	}
	else
	{
		if (!g_iCvarFlags)
		{
			ST_ToogleHook(false);
		}
	}
	return 0;
}

public OnCvarChange_Immune(Handle:convar_hndl, String:oldValue[], String:newValue[])
{
	if (!StrEqual(oldValue, newValue, true))
	{
		g_iCvarImmune = GetConVarInt(g_hImmune);
	}
	return 0;
}

ST_GetCvars()
{
	g_iCvarFlags = GetConVarInt(g_hFlags);
	g_iCvarImmune = GetConVarInt(g_hImmune);
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	if (GuessSDKVersion() != 50)
	{
		strcopy(error, err_max, "Plugin only support L4D2 engine");
		return APLRes:1;
	}
	g_bLoadLate = late;
	return APLRes:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "11/24/2014",
	time = "19:20:02"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new String:L4D2_InfectedNames[8][32];
new String:MeleeWeaponModels[15][];
new String:MeleeWeaponNames[15][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1414218835, 1936486255, 0, 1953195123, 1936486255, 1954047278, 0, 1164, 1176, 1, 1, 32, 44, 56, 68, 80, 92, 104, 104, 1818845793, 1601795177, 1735290740, 25973, 1818845793, 1601795177, 1768779638, 116, 1818845793, 1601795177, 1735292268, 101, 1818845793, 1601795177, 1953067123, 0, 1818845793, 1601795177, 1885431148, 0, 1818845793, 1601795177, 1918986339, 25959, 0, 0, 1870290797, 1701405293, 1935764547, 115, 2003787629, 7497070, 1769234285, 1953719661, 7368033, 1969512301, 1769234802
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedTimerEntities[8][] =
{
	"ability_tongue",
	"ability_vomit",
	"ability_lunge",
	"ability_spit",
	"ability_leap",
	"ability_charge",
	"",
	""
};
new String:L4D2_InfectedVictimNetprops[8][];
new Handle:hMeleeWeaponModelsTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hSurvivorModelsTrie;
new Handle:hWeaponNamesTrie;
new Handle:hMaxShovePenaltyCvar;
new Handle:hShovePenaltyAmtCvar;
new Handle:hPounceCrouchDelayCvar;
new Handle:hMaxStaggerDurationCvar;
new Handle:hLeapIntervalCvar;
new Handle:hPenaltyIncreaseCvar;
new g_iPenaltyIncrease;
new bool:g_NoHunterM2;
public Plugin:myinfo =
{
	name = "L4D2 M2 Control",
	description = "Blocks instant repounces and gives m2 penalty after a deadstop",
	author = "Jahze, Visor",
	version = "1.3",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

Handle:FindPluginByFile(String:filename[])
{
	decl String:buffer[256];
	new Handle:iter = GetPluginIterator();
	new Handle:pl;
	while (MorePlugins(iter))
	{
		pl = ReadPlugin(iter);
		GetPluginFilename(pl, buffer, 256);
		if (!(strcmp(buffer, filename, false)))
		{
			CloseHandle(iter);
			return pl;
		}
	}
	CloseHandle(iter);
	return Handle:0;
}

bool:IsInfected(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 3)
	{
		return false;
	}
	return true;
}

L4D2_Infected:GetInfectedClass(client)
{
	return GetEntProp(client, PropType:0, L4D2_InfectedVictimNetprops, 4, 0);
}

GetInfectedAbilityTimerEntity(owner, String:type[])
{
	new iEntity = -1;
	while ((iEntity = FindEntityByClassname(iEntity, type)) != -1)
	{
		if (owner == GetEntPropEnt(iEntity, PropType:0, "m_owner", 0))
		{
			return iEntity;
		}
	}
	return iEntity;
}

bool:GetInfectedAbilityTimer(client, &Float:timestamp, &Float:duration)
{
	new L4D2_Infected:zClass = GetInfectedClass(client);
	new ability = -1;
	if (strlen(L4D2_InfectedTimerEntities[zClass + -1]))
	{
		ability = GetInfectedAbilityTimerEntity(client, L4D2_InfectedTimerEntities[zClass + -1]);
		if (ability == -1)
		{
			return false;
		}
		timestamp = GetEntPropFloat(ability, PropType:0, "m_timestamp", 0);
		duration = GetEntPropFloat(ability, PropType:0, "m_duration", 0);
		return true;
	}
	return false;
}

bool:SetInfectedAbilityTimer(client, Float:timestamp, Float:duration)
{
	new L4D2_Infected:zClass = GetInfectedClass(client);
	new ability = -1;
	if (strlen(L4D2_InfectedTimerEntities[zClass + -1]))
	{
		ability = GetInfectedAbilityTimerEntity(client, L4D2_InfectedTimerEntities[zClass + -1]);
		if (ability == -1)
		{
			return false;
		}
		SetEntPropFloat(ability, PropType:0, "m_timestamp", timestamp, 0);
		SetEntPropFloat(ability, PropType:0, "m_duration", duration, 0);
		return true;
	}
	return false;
}

bool:IsSurvivor(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 2)
	{
		return false;
	}
	return true;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!hMeleeWeaponModelsTrie)
	{
		hMeleeWeaponModelsTrie = LoadGameConfigFile("l4d2_direct");
	}
	return hMeleeWeaponModelsTrie;
}

GetEntityValueFromOffset(entity, String:offset[], NumberType:size, &value)
{
	new Address:pEntity = GetEntityAddress(entity);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), offset);
		if (offs == -1)
		{
			return 0;
		}
		value = LoadFromAddress(offs + pEntity, size);
		return 1;
	}
	return 0;
}

SetEntityValueFromOffset(entity, String:offset[], NumberType:size, value)
{
	new Address:pEntity = GetEntityAddress(entity);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), offset);
		if (offs == -1)
		{
			return 0;
		}
		StoreToAddress(offs + pEntity, value, size);
		return 1;
	}
	return 0;
}

L4D2Direct_GetShovePenalty(client)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return -1;
	}
	new value;
	if (GetEntityValueFromOffset(client, "CTerrorPlayer::m_iShovePenalty", NumberType:2, value))
	{
		return value;
	}
	return -1;
}

L4D2Direct_SetShovePenalty(client, penalty)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return 0;
	}
	SetEntityValueFromOffset(client, "CTerrorPlayer::m_iShovePenalty", NumberType:2, penalty);
	return 0;
}

L4D2Direct_SetNextShoveTime(client, Float:time)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return 0;
	}
	SetEntityValueFromOffset(client, "CTerrorPlayer::m_fNextShoveTime", NumberType:2, time);
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_shoved", OutSkilled, EventHookMode:1);
	hMaxShovePenaltyCvar = FindConVar("z_gun_swing_vs_max_penalty");
	hShovePenaltyAmtCvar = FindConVar("z_gun_swing_vs_amt_penalty");
	hPounceCrouchDelayCvar = FindConVar("z_pounce_crouch_delay");
	hMaxStaggerDurationCvar = FindConVar("z_max_stagger_duration");
	hLeapIntervalCvar = FindConVar("z_leap_interval");
	hPenaltyIncreaseCvar = CreateConVar("l4d2_deadstop_penalty", "6", "How much penalty gets added when you deadstop a hunter or jockey", 0, false, 0.0, false, 0.0);
	HookConVarChange(hPenaltyIncreaseCvar, PenaltyIncreaseChange);
	g_iPenaltyIncrease = GetConVarInt(hPenaltyIncreaseCvar);
	return 0;
}

public OnAllPluginsLoaded()
{
	g_NoHunterM2 = FindPluginByFile("l4d2_no_hunter_deadstops") != 0;
	return 0;
}

public PenaltyIncreaseChange(Handle:hCvar, String:oldVal[], String:newVal[])
{
	g_iPenaltyIncrease = StringToInt(newVal, 10);
	return 0;
}

public Action:OutSkilled(Handle:event, String:name[], bool:dontBroadcast)
{
	new shovee = GetClientOfUserId(GetEventInt(event, "userid"));
	new shover = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var1;
	if (!IsSurvivor(shover) || !IsInfected(shovee))
	{
		return Action:0;
	}
	new L4D2_Infected:zClass = GetInfectedClass(shovee);
	new var2;
	if (zClass == L4D2_Infected:3 || zClass == L4D2_Infected:5 || zClass == L4D2_Infected:1)
	{
		new maxPenalty = GetConVarInt(hMaxShovePenaltyCvar);
		new penalty = L4D2Direct_GetShovePenalty(shover);
		penalty = g_iPenaltyIncrease + penalty;
		if (penalty > maxPenalty)
		{
			penalty = maxPenalty;
		}
		L4D2Direct_SetShovePenalty(shover, penalty);
		L4D2Direct_SetNextShoveTime(shover, CalcNextShoveTime(penalty, maxPenalty));
		new var4;
		if (zClass == L4D2_Infected:1 || (zClass == L4D2_Infected:3 && g_NoHunterM2))
		{
			return Action:0;
		}
		new Float:staggerTime = GetConVarFloat(hMaxStaggerDurationCvar);
		CreateTimer(staggerTime - 0.1, ResetAbilityTimer, shovee, 0);
	}
	return Action:0;
}

public Action:ResetAbilityTimer(Handle:event, any:shovee)
{
	new Float:time = GetGameTime();
	new L4D2_Infected:zClass = GetInfectedClass(shovee);
	new Float:recharge = 0.0;
	if (zClass == L4D2_Infected:3)
	{
		recharge = GetConVarFloat(hPounceCrouchDelayCvar);
	}
	else
	{
		recharge = GetConVarFloat(hLeapIntervalCvar);
	}
	new Float:timestamp = 0.0;
	new Float:duration = 0.0;
	if (!GetInfectedAbilityTimer(shovee, timestamp, duration))
	{
		return Action:0;
	}
	duration = time + recharge + 0.1;
	if (duration > timestamp)
	{
		SetInfectedAbilityTimer(shovee, duration, recharge);
	}
	return Action:0;
}

Float:CalcNextShoveTime(penalty, max)
{
	new Float:time = GetGameTime();
	new Float:maxPenalty = float(max);
	new Float:currentPenalty = float(penalty);
	new Float:ratio = currentPenalty / maxPenalty;
	new Float:maxTime = GetConVarFloat(hShovePenaltyAmtCvar);
	return time + ratio * maxTime + 0.7;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "07/20/2017",
	time = "13:37:26"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new String:L4D2_InfectedNames[8][32];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1414218835, 1936486255, 0, 1953195123, 1936486255, 1954047278, 0, 1020, 1032, 1, 1, 32, 44, 56, 68, 80, 92, 104, 104, 1818845793, 1601795177, 1735290740, 25973, 1818845793, 1601795177, 1768779638, 116, 1818845793, 1601795177, 1735292268, 101, 1818845793, 1601795177, 1953067123, 0, 1818845793, 1601795177, 1885431148, 0, 1818845793, 1601795177, 1918986339, 25959, 0, 0, 1870290797, 1701405293, 1935764547, 115, 2003787629, 7497070, 1769234285, 1953719661, 7368033, 1969512301, 1769234802
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedTimerEntities[8][] =
{
	"ability_tongue",
	"ability_vomit",
	"ability_lunge",
	"ability_spit",
	"ability_leap",
	"ability_charge",
	"",
	""
};
new String:L4D2_InfectedVictimNetprops[8][];
new Handle:hSurvivorModelsTrie;
new Handle:hWeaponNamesTrie;
new Handle:hMaxShovePenaltyCvar;
new Handle:hShovePenaltyAmtCvar;
new Handle:hPounceCrouchDelayCvar;
new Handle:hMaxStaggerDurationCvar;
new Handle:hLeapIntervalCvar;
new Handle:hPenaltyIncreaseHunterCvar;
new Handle:hPenaltyIncreaseJockeyCvar;
new Handle:hPenaltyIncreaseSmokerCvar;
new bool:g_NoHunterM2;
public Plugin:myinfo =
{
	name = "L4D2 M2 Control",
	description = "Blocks instant repounces and gives m2 penalty after a shove/deadstop",
	author = "Jahze, Visor",
	version = "1.5",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Handle:FindPluginByFile(String:filename[])
{
	decl String:buffer[256];
	new Handle:iter = GetPluginIterator();
	new Handle:pl;
	while (MorePlugins(iter))
	{
		pl = ReadPlugin(iter);
		GetPluginFilename(pl, buffer, 256);
		if (!(strcmp(buffer, filename, false)))
		{
			CloseHandle(iter);
			return pl;
		}
	}
	CloseHandle(iter);
	return Handle:0;
}

bool:IsInfected(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 3)
	{
		return false;
	}
	return true;
}

L4D2_Infected:GetInfectedClass(client)
{
	return GetEntProp(client, PropType:0, L4D2_InfectedVictimNetprops, 4, 0);
}

GetInfectedAbilityTimerEntity(owner, String:type[])
{
	new iEntity = -1;
	while ((iEntity = FindEntityByClassname(iEntity, type)) != -1)
	{
		if (owner == GetEntPropEnt(iEntity, PropType:0, "m_owner", 0))
		{
			return iEntity;
		}
	}
	return iEntity;
}

bool:GetInfectedAbilityTimer(client, &Float:timestamp, &Float:duration)
{
	new L4D2_Infected:zClass = GetInfectedClass(client);
	new ability = -1;
	if (strlen(L4D2_InfectedTimerEntities[zClass + -1]))
	{
		ability = GetInfectedAbilityTimerEntity(client, L4D2_InfectedTimerEntities[zClass + -1]);
		if (ability == -1)
		{
			return false;
		}
		timestamp = GetEntPropFloat(ability, PropType:0, "m_timestamp", 0);
		duration = GetEntPropFloat(ability, PropType:0, "m_duration", 0);
		return true;
	}
	return false;
}

bool:SetInfectedAbilityTimer(client, Float:timestamp, Float:duration)
{
	new L4D2_Infected:zClass = GetInfectedClass(client);
	new ability = -1;
	if (strlen(L4D2_InfectedTimerEntities[zClass + -1]))
	{
		ability = GetInfectedAbilityTimerEntity(client, L4D2_InfectedTimerEntities[zClass + -1]);
		if (ability == -1)
		{
			return false;
		}
		SetEntPropFloat(ability, PropType:0, "m_timestamp", timestamp, 0);
		SetEntPropFloat(ability, PropType:0, "m_duration", duration, 0);
		return true;
	}
	return false;
}

bool:IsSurvivor(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 2)
	{
		return false;
	}
	return true;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!hSurvivorModelsTrie)
	{
		hSurvivorModelsTrie = LoadGameConfigFile("l4d2_direct");
	}
	return hSurvivorModelsTrie;
}

GetEntityValueFromOffset(entity, String:offset[], NumberType:size, &value)
{
	new Address:pEntity = GetEntityAddress(entity);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), offset);
		if (offs == -1)
		{
			return 0;
		}
		value = LoadFromAddress(offs + pEntity, size);
		return 1;
	}
	return 0;
}

SetEntityValueFromOffset(entity, String:offset[], NumberType:size, value)
{
	new Address:pEntity = GetEntityAddress(entity);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), offset);
		if (offs == -1)
		{
			return 0;
		}
		StoreToAddress(offs + pEntity, value, size);
		return 1;
	}
	return 0;
}

L4D2Direct_GetShovePenalty(client)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return -1;
	}
	new value;
	if (GetEntityValueFromOffset(client, "CTerrorPlayer::m_iShovePenalty", NumberType:2, value))
	{
		return value;
	}
	return -1;
}

L4D2Direct_SetShovePenalty(client, penalty)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return 0;
	}
	SetEntityValueFromOffset(client, "CTerrorPlayer::m_iShovePenalty", NumberType:2, penalty);
	return 0;
}

L4D2Direct_SetNextShoveTime(client, Float:time)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return 0;
	}
	SetEntityValueFromOffset(client, "CTerrorPlayer::m_fNextShoveTime", NumberType:2, time);
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_shoved", OutSkilled, EventHookMode:1);
	hMaxShovePenaltyCvar = FindConVar("z_gun_swing_vs_max_penalty");
	hShovePenaltyAmtCvar = FindConVar("z_gun_swing_vs_amt_penalty");
	hPounceCrouchDelayCvar = FindConVar("z_pounce_crouch_delay");
	hMaxStaggerDurationCvar = FindConVar("z_max_stagger_duration");
	hLeapIntervalCvar = FindConVar("z_leap_interval");
	hPenaltyIncreaseHunterCvar = CreateConVar("l4d2_m2_hunter_penalty", "0", "How much penalty gets added when you shove a Hunter", 0, false, 0.0, false, 0.0);
	hPenaltyIncreaseJockeyCvar = CreateConVar("l4d2_m2_jockey_penalty", "0", "How much penalty gets added when you shove a Jockey", 0, false, 0.0, false, 0.0);
	hPenaltyIncreaseSmokerCvar = CreateConVar("l4d2_m2_smoker_penalty", "0", "How much penalty gets added when you shove a Smoker", 0, false, 0.0, false, 0.0);
	return 0;
}

public OnAllPluginsLoaded()
{
	g_NoHunterM2 = FindPluginByFile("optional/l4d2_no_hunter_deadstops.smx") != 0;
	return 0;
}

public Action:OutSkilled(Handle:event, String:name[], bool:dontBroadcast)
{
	new shovee = GetClientOfUserId(GetEventInt(event, "userid"));
	new shover = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var1;
	if (!IsSurvivor(shover) || !IsInfected(shovee))
	{
		return Action:0;
	}
	new penaltyIncrease;
	new L4D2_Infected:zClass = GetInfectedClass(shovee);
	if (zClass == L4D2_Infected:3)
	{
		penaltyIncrease = GetConVarInt(hPenaltyIncreaseHunterCvar);
	}
	else
	{
		if (zClass == L4D2_Infected:5)
		{
			penaltyIncrease = GetConVarInt(hPenaltyIncreaseJockeyCvar);
		}
		if (zClass == L4D2_Infected:1)
		{
			penaltyIncrease = GetConVarInt(hPenaltyIncreaseSmokerCvar);
		}
		return Action:0;
	}
	new maxPenalty = GetConVarInt(hMaxShovePenaltyCvar);
	new penalty = L4D2Direct_GetShovePenalty(shover);
	penalty = penaltyIncrease + penalty;
	if (penalty > maxPenalty)
	{
		penalty = maxPenalty;
	}
	L4D2Direct_SetShovePenalty(shover, penalty);
	L4D2Direct_SetNextShoveTime(shover, CalcNextShoveTime(penalty, maxPenalty));
	new var3;
	if (zClass == L4D2_Infected:1 || (zClass == L4D2_Infected:3 && g_NoHunterM2))
	{
		return Action:0;
	}
	new Float:staggerTime = GetConVarFloat(hMaxStaggerDurationCvar);
	CreateTimer(staggerTime - 0.1, ResetAbilityTimer, shovee, 0);
	return Action:0;
}

public Action:ResetAbilityTimer(Handle:event, any:shovee)
{
	new Float:time = GetGameTime();
	new L4D2_Infected:zClass = GetInfectedClass(shovee);
	new Float:recharge = 0.0;
	if (zClass == L4D2_Infected:3)
	{
		recharge = GetConVarFloat(hPounceCrouchDelayCvar);
	}
	else
	{
		recharge = GetConVarFloat(hLeapIntervalCvar);
	}
	new Float:timestamp = 0.0;
	new Float:duration = 0.0;
	if (!GetInfectedAbilityTimer(shovee, timestamp, duration))
	{
		return Action:0;
	}
	duration = time + recharge + 0.1;
	if (duration > timestamp)
	{
		SetInfectedAbilityTimer(shovee, duration, recharge);
	}
	return Action:0;
}

Float:CalcNextShoveTime(penalty, max)
{
	new Float:time = GetGameTime();
	new Float:maxPenalty = float(max);
	new Float:currentPenalty = float(penalty);
	new Float:ratio = currentPenalty / maxPenalty;
	new Float:maxTime = GetConVarFloat(hShovePenaltyAmtCvar);
	return time + ratio * maxTime + 0.7;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.3.4",
	date = "10/02/2011",
	time = "00:14:00"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_geoip =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "sdkhooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_smsock =
{
	name = "Socket",
	file = "socket.ext",
	autoload = 1,
	required = 1,
};
new OUT_SERVER = 1;
new OUT_CHAT = 2;
new OUT_LOG = 4;
new CHANNEL_ALL = -1;
new String:CHANNEL_GENERAL_NAME[8] = "General";
new String:SETTINGS_NAME_KEY[8] = "_name";
new String:SETTINGS_FLAG_KEY[8] = "_flag";
new Handle:g_hChannelsTrie;
new g_iNextChannel_Flag = 1;
new g_iNextChannel_Index = 1;
new g_iOutputFlags;
new g_iChannelFlags;
new String:CALL_ON_START[16] = "OnPluginStartEx";
new Handle:g_hEventForwards[12];
new bool:g_bIsPluginEnabled;
new String:PUBLIC_TRIGGER[4] = "!";
new String:PRIVAT_TRIGGER[4] = "/";
new MAX_COMMAND_LENGTH = 64;
new Handle:g_aSayCommands;
new SurvivorCount;
new SurvivorIndex[65];
new InfectedCount;
new InfectedIndex[65];
new SpectateCount;
new SpectateIndex[65];
new Float:REBUILD_DELAY = 1050253722;
new String:CLASSNAME_CHANGELEVEL[20] = "\x05";
new String:CLASSNAME_FINALETRIGGER[16] = "\x05";
new FLOWTYPE_DEFAULT = 5;
new String:GAMECONFIG_INFECTED_FLOW[28] = "\x05";
new String:GAMECONFIG_PLAYER_FLOW[32] = "\x05";
new ZOMBIECLASS_TANK = 5;
new bool:g_bIsModuleSetup = 5;
new Handle:g_hGetInfectedFlowDistance = 5;
new Handle:g_hGetPlayerFlowDistance = 5;
new String:CLASSNAME_TANK[8] = "Tank";
new String:NETPROP_FRUSTRATION[16] = "m_frustration";
new String:NETPROP_INCAPACITATED[20] = "m_isIncapacitated";
new String:NETPROP_ZOMBIECLASS[16] = "m_zombieClass";
new g_iOffset_Frustration;
new g_iOffset_Incapacitated;
new g_iTankClient;
new bool:g_bIsTankInPlay;
new Handle:g_hFwd_TankSpawn;
new Handle:g_hFwd_TankKilled;
new Handle:g_hFwd_TankPassed;
new String:TEAMNAME_INFECTED[12] = "%s_%s";
new String:TEAMNAME_SPECTATOR[12] = "%s_%s";
new String:TEAMNAME_SPECTATORS[12] = "%s_%s";
new String:TEAMNAME_SURVIVOR[12] = "%s_%s";
new String:TEAMNAME_SURVIVORS[12] = "%s_%s";
new g_nonFatiguedMeleePenalty = 1;
new Handle:g_hNonFatiguedMeleePenalty_CVAR;
new MAX_EXISTING_FATIGUE = 3;
new Float:MELEE_DURATION = 1058642330;
new bool:soundHookDelay[65];
new g_iDebugChannel;
new String:DEBUG_CHANNEL_NAME[16] = "MeleeFatigue";
new String:MELEE_SOUND_NAME_SEARCH[8] = "Swish";
new bool:g_bIsZACKLoaded;
public Plugin:myinfo =
{
	name = "L4D2 Melee Fatigue Control",
	description = "Allows players to set custom fatigue levels.",
	author = "Blade",
	version = "0.0.2",
	url = "http://code.google.com/p/metafogl/"
};
new g_var190;
new g_var8d8;
new g_varbac;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public _H_D_Channel_CvarChange(Handle:convar, String:oldValue[], String:newValue[])
{
	g_iChannelFlags = StringToInt(newValue, 10);
	return 0;
}

public _H_D_Output_CvarChange(Handle:convar, String:oldValue[], String:newValue[])
{
	g_iOutputFlags = StringToInt(newValue, 10);
	return 0;
}

public Action:_H_D_Status_Command(client, args)
{
	decl channelFlag;
	decl String:channelName[64];
	decl String:buffer[64];
	decl String:result[2048];
	new channelCounter;
	Format(result, 2048, "\n==================================================\n");
	Format(result, 2048, "%s%s\n\n  Debug status:\n    Current channel flag: %i\n    Current output flag: %i\n\n", result, "L4D2 Melee Fatigue Control", g_iChannelFlags, g_iOutputFlags);
	Format(result, 2048, "%s  Channel Listing:\n    Index. Name - Flag \n    -----\n", result);
	new i;
	while (i < g_iNextChannel_Index)
	{
		Format(buffer, 64, "%s%s", i, SETTINGS_FLAG_KEY);
		if (GetTrieValue(g_hChannelsTrie, buffer, channelFlag))
		{
			Format(buffer, 64, "%s%s", i, SETTINGS_NAME_KEY);
			if (GetTrieString(g_hChannelsTrie, buffer, channelName, 64, 0))
			{
				Format(result, 2048, "%s    %i. \"%s\" - %i\n", result, i, channelName, channelFlag);
				channelCounter++;
			}
		}
		i++;
	}
	Format(result, 2048, "%s    -----\n    Total channels: %i\n\n", result, channelCounter);
	Format(result, 2048, "%s==================================================\n", result);
	if (client)
	{
		ReplyToCommand(client, "[%s] Debug status printed to console", "l4d2_meleecontrol");
		PrintToConsole(client, result);
	}
	else
	{
		PrintToServer(result);
	}
	return Action:3;
}

DebugAddChannel(String:channelName[])
{
	if (!SetupModule())
	{
		ThrowError("Unable to set up debug trie!");
	}
	new channelIndex = g_iNextChannel_Index;
	new channelFlag = g_iNextChannel_Flag;
	decl String:buffer[64];
	Format(buffer, 64, "%s%s", channelIndex, SETTINGS_FLAG_KEY);
	SetTrieValue(g_hChannelsTrie, buffer, channelFlag, true);
	Format(buffer, 64, "%s%s", channelIndex, SETTINGS_NAME_KEY);
	SetTrieString(g_hChannelsTrie, buffer, channelName, true);
	g_iNextChannel_Index += 1;
	g_iNextChannel_Flag = g_iNextChannel_Flag * 2;
	return channelIndex;
}

DebugPrintToAll(channelIndex, String:format[])
{
	new var1;
	if (!g_iOutputFlags || !SetupModule())
	{
		return 0;
	}
	decl String:buffer[1024];
	decl channelFlag;
	Format(buffer, 1024, "%s%s", channelIndex, SETTINGS_FLAG_KEY);
	if (!GetTrieValue(g_hChannelsTrie, buffer, channelFlag))
	{
		return 0;
	}
	new var2;
	if (!channelFlag & g_iChannelFlags && CHANNEL_ALL != g_iChannelFlags)
	{
		return 0;
	}
	decl String:channelName[64];
	Format(buffer, 1024, "%s%s", channelIndex, SETTINGS_NAME_KEY);
	GetTrieString(g_hChannelsTrie, buffer, channelName, 64, 0);
	VFormat(buffer, 1024, format, 3);
	if (OUT_SERVER & g_iOutputFlags)
	{
		PrintToServer("[%s][%s] %s", "l4d2_meleecontrol", channelName, buffer);
	}
	if (OUT_CHAT & g_iOutputFlags)
	{
		PrintToChatAll("[%s][%s] %s", "l4d2_meleecontrol", channelName, buffer);
	}
	if (OUT_LOG & g_iOutputFlags)
	{
		LogMessage("[%s] %s", channelName, buffer);
	}
	return 0;
}

bool:SetupModule()
{
	if (g_var190)
	{
		return true;
	}
	g_hChannelsTrie = CreateTrie();
	if (g_hChannelsTrie)
	{
		decl String:buffer[64];
		Format(buffer, 64, "%s%s", 0, SETTINGS_FLAG_KEY);
		SetTrieValue(g_hChannelsTrie, buffer, any:0, true);
		Format(buffer, 64, "%s%s", 0, SETTINGS_NAME_KEY);
		SetTrieString(g_hChannelsTrie, buffer, CHANNEL_GENERAL_NAME, true);
		new Handle:cvar = CreateConVarEx("debug_channel", "0", "Sum of debug channel flags. -1 - Log all channels, 0 - General channel only, 0+ - Log channel of flag", 262144, false, 0.0, false, 0.0);
		g_iChannelFlags = GetConVarInt(cvar);
		HookConVarChange(cvar, _H_D_Channel_CvarChange);
		cvar = CreateConVarEx("debug_output", "0", "Sum of debug output flags. 0 - No logging, 1 - Print to server, 2 - Print to chat, 4 - Log to SM logs", 262144, false, 0.0, false, 0.0);
		g_iOutputFlags = GetConVarInt(cvar);
		HookConVarChange(cvar, _H_D_Output_CvarChange);
		RegAdminCmdEx("debug_status", _H_D_Status_Command, 16384, "Writes report of channels and what is current listen to", "", 262144);
		g_var190 = 1;
		return true;
	}
	return false;
}

public OnPluginStart()
{
	g_hEventForwards[0] = CreateForward(ExecType:0);
	g_hEventForwards[1] = CreateForward(ExecType:0);
	g_hEventForwards[2] = CreateForward(ExecType:0);
	g_hEventForwards[3] = CreateForward(ExecType:0);
	g_hEventForwards[4] = CreateForward(ExecType:0);
	g_hEventForwards[5] = CreateForward(ExecType:0, 2);
	g_hEventForwards[6] = CreateForward(ExecType:0, 2);
	g_hEventForwards[7] = CreateForward(ExecType:0, 2);
	g_hEventForwards[8] = CreateForward(ExecType:0, 2);
	g_hEventForwards[9] = CreateForward(ExecType:0, 2, 7);
	g_hEventForwards[10] = CreateForward(ExecType:0, 2);
	g_hEventForwards[11] = CreateForward(ExecType:0, 2, 3, 3, 9, 9, 3);
	new Function:func = GetFunctionByName(Handle:0, CALL_ON_START);
	if (func != -1)
	{
		Call_StartFunction(Handle:0, func);
		Call_Finish(0);
	}
	return 0;
}

public OnPluginEnd()
{
	Call_StartForward(g_hEventForwards[0]);
	Call_Finish(0);
	return 0;
}

public OnMapStart()
{
	Call_StartForward(g_hEventForwards[3]);
	Call_Finish(0);
	return 0;
}

public OnMapEnd()
{
	Call_StartForward(g_hEventForwards[4]);
	Call_Finish(0);
	return 0;
}

public OnClientConnected(client)
{
	Call_StartForward(g_hEventForwards[5]);
	Call_PushCell(client);
	Call_Finish(0);
	return 0;
}

public OnClientPutInServer(client)
{
	Call_StartForward(g_hEventForwards[6]);
	Call_PushCell(client);
	Call_Finish(0);
	return 0;
}

public OnClientDisconnect_Post(client)
{
	Call_StartForward(g_hEventForwards[7]);
	Call_PushCell(client);
	Call_Finish(0);
	return 0;
}

public OnClientPostAdminCheck(client)
{
	Call_StartForward(g_hEventForwards[8]);
	Call_PushCell(client);
	Call_Finish(0);
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	new var1;
	if (entity <= 2048 && entity > 0 && IsValidEntity(entity))
	{
		Call_StartForward(g_hEventForwards[9]);
		Call_PushCell(entity);
		Call_PushString(classname);
		Call_Finish(0);
	}
	return 0;
}

public OnEntityDestroyed(entity)
{
	new var1;
	if (entity <= 2048 && entity > 0 && IsValidEntity(entity))
	{
		Call_StartForward(g_hEventForwards[10]);
		Call_PushCell(entity);
		Call_Finish(0);
	}
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	Call_StartForward(g_hEventForwards[11]);
	Call_PushCell(client);
	Call_PushCellRef(buttons);
	Call_PushCellRef(impulse);
	Call_PushArray(vel, 3);
	Call_PushArray(angles, 3);
	Call_PushCellRef(weapon);
	Call_Finish(0);
	return Action:0;
}

bool:HookPublicEvent(EVENT_TYPE:type, Function:func)
{
	new Handle:fwd = GetEventForward(type);
	if (fwd)
	{
		return AddToForward(fwd, Handle:0, func);
	}
	return false;
}

bool:UnhookPublicEvent(EVENT_TYPE:type, Function:func)
{
	new Handle:fwd = GetEventForward(type);
	if (fwd)
	{
		return RemoveFromForward(fwd, Handle:0, func);
	}
	return false;
}

SetPluginState(bool:enabled)
{
	if (enabled == g_bIsPluginEnabled)
	{
		return 0;
	}
	g_bIsPluginEnabled = enabled;
	if (enabled)
	{
		Call_StartForward(g_hEventForwards[1]);
		Call_Finish(0);
	}
	else
	{
		Call_StartForward(g_hEventForwards[2]);
		Call_Finish(0);
	}
	return 0;
}

Handle:GetEventForward(EVENT_TYPE:type)
{
	new i;
	while (i < 12)
	{
		if (type == i)
		{
			return g_hEventForwards[i];
		}
		i++;
	}
	return Handle:0;
}

public _H_CommandManager_OnPluginStart()
{
	g_aSayCommands = CreateArray(MAX_COMMAND_LENGTH, 0);
	AddCommandListener(H_CM_Say_Command, "say");
	AddCommandListener(H_CM_Say_Command, "say_team");
	return 0;
}

public Action:H_CM_Say_Command(client, String:command[], argc)
{
	new var1;
	if (argc == 1 && client)
	{
		return Action:0;
	}
	decl String:buffer[128];
	decl bool:bHide;
	GetCmdArg(1, buffer, 128);
	decl pos;
	if ((pos = StrContains(buffer, PRIVAT_TRIGGER, true)))
	{
		if ((pos = StrContains(buffer, PUBLIC_TRIGGER, true)))
		{
			return Action:0;
		}
		bHide = false;
	}
	else
	{
		bHide = true;
	}
	strcopy(buffer, 128, buffer[pos + 1]);
	if (FindStringInArray(g_aSayCommands, buffer) != -1)
	{
		if (StrContains(buffer, "l4d2_meleecontrol", false) == -1)
		{
			Format(buffer, 128, "%s_%s", "l4d2_meleecontrol", buffer);
		}
		FakeClientCommandEx(client, buffer);
		if (bHide)
		{
			return Action:3;
		}
	}
	return Action:0;
}

public _H_ClientIndexes_OnPluginStart()
{
	HookPublicEvent(EVENT_TYPE:1, _CI_OnPluginEnabled);
	HookPublicEvent(EVENT_TYPE:2, _CI_OnPluginDisabled);
	HookPublicEvent(EVENT_TYPE:3, _CI_OnMapStart);
	HookPublicEvent(EVENT_TYPE:4, _CI_OnMapEnd);
	g_var8d8 = DebugAddChannel("ClientIndexes");
	sub_244c("Module is now setup");
	return 0;
}

public _CI_OnPluginEnabled()
{
	RebuildIndex();
	HookEvent("round_start", _CI_Event_TempStop_Event, EventHookMode:2);
	HookEvent("round_end", _CI_Event_TempStop_Event, EventHookMode:2);
	HookEvent("player_team", _CI_Event_TempStop_Event, EventHookMode:2);
	HookEvent("player_spawn", _CI_Event, EventHookMode:2);
	HookEvent("player_disconnect", _CI_Event, EventHookMode:2);
	HookEvent("player_death", _CI_Event, EventHookMode:2);
	HookEvent("player_bot_replace", _CI_Event, EventHookMode:2);
	HookEvent("bot_player_replace", _CI_Event, EventHookMode:2);
	sub_244c("Module is now loaded");
	return 0;
}

public _CI_OnPluginDisabled()
{
	UnhookEvent("round_start", _CI_Event_TempStop_Event, EventHookMode:2);
	UnhookEvent("round_end", _CI_Event_TempStop_Event, EventHookMode:2);
	UnhookEvent("player_team", _CI_Event_TempStop_Event, EventHookMode:2);
	UnhookEvent("player_spawn", _CI_Event, EventHookMode:2);
	UnhookEvent("player_disconnect", _CI_Event, EventHookMode:2);
	UnhookEvent("player_death", _CI_Event, EventHookMode:2);
	UnhookEvent("player_bot_replace", _CI_Event, EventHookMode:2);
	UnhookEvent("bot_player_replace", _CI_Event, EventHookMode:2);
	ResetCounts();
	sub_244c("Module is now unloaded");
	return 0;
}

public _CI_OnMapStart()
{
	ResetCounts();
	sub_244c("Map start, resetting indexes");
	return 0;
}

public _CI_OnMapEnd()
{
	ResetCounts();
	sub_244c("Map end, resetting indexes");
	return 0;
}

public _CI_Event_TempStop_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	sub_244c("Event \"%s\" was fired, rebuild indexes in %f secs", name, REBUILD_DELAY);
	ResetCounts();
	CreateTimer(REBUILD_DELAY, _CI_RebuildIndex_Timer, any:0, 0);
	return 0;
}

public _CI_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	sub_244c("Event \"%s\" was fired, rebuild indexes", name);
	RebuildIndex();
	return 0;
}

public Action:_CI_RebuildIndex_Timer(Handle:timer)
{
	sub_244c("Rebuild index timer executed, rebuilding indexes");
	RebuildIndex();
	return Action:0;
}

RebuildIndex()
{
	ResetCounts();
	if (!IsServerProcessing())
	{
		return 0;
	}
	decl team;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			team = GetClientTeam(i);
			switch (team)
			{
				case 1:
				{
					SpectateIndex[SpectateCount] = i;
					SpectateCount += 1;
				}
				case 2:
				{
					if (IsPlayerAlive(i))
					{
						SurvivorIndex[SurvivorCount] = i;
						SurvivorCount += 1;
					}
				}
				case 3:
				{
					InfectedIndex[InfectedCount] = i;
					InfectedCount += 1;
				}
				default:
				{
				}
			}
		}
		i++;
	}
	sub_244c("Indexes is now rebuild. Survivor count: %i, Infected count: %i, Spectate count: %i", SurvivorCount, InfectedCount, SpectateCount);
	return 0;
}

ResetCounts()
{
	SurvivorCount = 0;
	InfectedCount = 0;
	SpectateCount = 0;
	return 0;
}

public _H_TankManager_OnPluginStart()
{
	HookPublicEvent(EVENT_TYPE:1, _H_TM_OnPluginEnabled);
	HookPublicEvent(EVENT_TYPE:2, _H_TM_OnPluginDisabled);
	g_iOffset_Frustration = FindSendPropInfo(CLASSNAME_TANK, NETPROP_FRUSTRATION, 0, 0, 0);
	g_iOffset_Incapacitated = FindSendPropInfo(CLASSNAME_TANK, NETPROP_INCAPACITATED, 0, 0, 0);
	g_varbac = DebugAddChannel("TankManager");
	sub_2ec0("Module is now setup");
	return 0;
}

public _H_TM_OnPluginEnabled()
{
	g_bIsTankInPlay = false;
	g_iTankClient = 0;
	HookEvent("tank_spawn", _H_TM_TankSpawn_Event, EventHookMode:1);
	HookEvent("player_death", _H_TM_TankKilled_Event, EventHookMode:1);
	HookEvent("round_start", _H_TM_RoundStart_Event, EventHookMode:1);
	HookPublicEvent(EVENT_TYPE:7, _H_TM_OnClientDisconnect_Post);
	g_hFwd_TankSpawn = CreateForward(ExecType:0);
	g_hFwd_TankKilled = CreateForward(ExecType:0);
	g_hFwd_TankPassed = CreateForward(ExecType:0);
	sub_2ec0("Module is now loaded");
	return 0;
}

public _H_TM_OnPluginDisabled()
{
	UnhookEvent("tank_spawn", _H_TM_TankSpawn_Event, EventHookMode:1);
	UnhookEvent("player_death", _H_TM_TankKilled_Event, EventHookMode:1);
	UnhookEvent("round_start", _H_TM_RoundStart_Event, EventHookMode:1);
	UnhookPublicEvent(EVENT_TYPE:7, _H_TM_OnClientDisconnect_Post);
	g_bIsTankInPlay = false;
	g_iTankClient = 0;
	RemoveAllFromForward(g_hFwd_TankSpawn, Handle:0);
	CloseHandle(g_hFwd_TankSpawn);
	RemoveAllFromForward(g_hFwd_TankKilled, Handle:0);
	CloseHandle(g_hFwd_TankKilled);
	RemoveAllFromForward(g_hFwd_TankPassed, Handle:0);
	CloseHandle(g_hFwd_TankPassed);
	sub_2ec0("Module is now unloaded");
	return 0;
}

public _H_TM_OnClientDisconnect_Post(client)
{
	new var1;
	if (!g_bIsTankInPlay || g_iTankClient == client)
	{
		return 0;
	}
	sub_2ec0("Tank client left the game, find new tank client");
	CreateTimer(0.1, _H_TM_TankKilled_Timer, client, 0);
	return 0;
}

public _H_TM_RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	sub_2ec0("Round start; reset vars");
	g_bIsTankInPlay = false;
	return 0;
}

public _H_TM_TankSpawn_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	g_iTankClient = client;
	if (g_bIsTankInPlay)
	{
		sub_2ec0("Tank spawned, updated tank client var. Client %i: \"%N\"", client, client);
		Call_StartForward(g_hFwd_TankPassed);
		Call_Finish(0);
		return 0;
	}
	sub_2ec0("Tank spawned, tank is now in play. Client %i: \"%N\"", client, client);
	g_bIsTankInPlay = true;
	Call_StartForward(g_hFwd_TankSpawn);
	Call_Finish(0);
	return 0;
}

public _H_TM_TankKilled_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_bIsTankInPlay)
	{
		return 0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (g_iTankClient != client)
	{
		return 0;
	}
	sub_2ec0("Tank was killed, find new tank client. Client %i: \"%N\"", client, client);
	CreateTimer(0.1, _H_TM_TankKilled_Timer, client, 0);
	return 0;
}

public Action:_H_TM_TankKilled_Timer(Handle:timer, any:oldtankclient)
{
	if (oldtankclient != g_iTankClient)
	{
		return Action:0;
	}
	new tankclient = FindTankClient();
	new var1;
	if (tankclient && oldtankclient != tankclient)
	{
		g_iTankClient = tankclient;
		sub_2ec0("Found new tank client. Client %i: \"%N\"", tankclient, tankclient);
		Call_StartForward(g_hFwd_TankPassed);
		Call_Finish(0);
		return Action:0;
	}
	sub_2ec0("Tank was killed and is no longer in play. Forward event");
	g_bIsTankInPlay = false;
	Call_StartForward(g_hFwd_TankKilled);
	Call_Finish(0);
	return Action:0;
}

FindTankClient()
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (!(!IsClientInGame(client) || GetClientTeam(client) == 3 || !IsPlayerAlive(client) || CLASSNAME_CHANGELEVEL[0] == GetEntProp(client, PropType:0, NETPROP_ZOMBIECLASS, 4)))
		{
			return client;
		}
		client++;
	}
	return 0;
}

Handle:CreateConVarEx(String:name[], String:defaultValue[], String:description[], flags, bool:hasMin, Float:min, bool:hasMax, Float:max)
{
	decl String:buffer[256];
	Format(buffer, 256, TEAMNAME_INFECTED, 3508, name);
	return CreateConVar(buffer, defaultValue, description, flags, hasMin, min, hasMax, max);
}

RegAdminCmdEx(String:cmd[], ConCmd:callback, adminflags, String:description[], String:group[], flags)
{
	decl String:buffer[256];
	Format(buffer, 256, "%s_%s", "l4d2_meleecontrol", cmd);
	RegAdminCmd(buffer, callback, adminflags, description, group, flags);
	return 0;
}

public _MeleeFatigue_OnPluginStart()
{
	HookPublicEvent(EVENT_TYPE:1, _MF_OnPluginEnabled);
	HookPublicEvent(EVENT_TYPE:2, _MF_OnPluginDisabled);
	CreateIntConVar(g_hNonFatiguedMeleePenalty_CVAR, "melee_penalty", "Sets the value to be added to a survivor's shove penalty.  This _only_ gets added when that survivor is not already fatigued (so basically, setting this to a large value will make the survivors become fatigued more quickly, but the cooldown effect won't change once fatigue has set in)", g_nonFatiguedMeleePenalty);
	UpdateNonFatiguedMeleePenalty();
	g_iDebugChannel = DebugAddChannel(DEBUG_CHANNEL_NAME);
	DebugPrintToAllEx("Module is now setup.", g_iDebugChannel);
	return 0;
}

CreateIntConVar(&Handle:conVar, String:cvarName[], String:cvarDescription[], initialValue)
{
	decl String:buffer[12];
	IntToString(initialValue, buffer, 10);
	conVar = CreateConVarEx(cvarName, buffer, cvarDescription, 262400, false, 0.0, false, 0.0);
	if (!conVar)
	{
		ThrowError("Unable to create enable cvar named %s!", cvarName);
	}
	return 0;
}

public _MF_OnPluginEnabled()
{
	UpdateNonFatiguedMeleePenalty();
	AddNormalSoundHook(HookSound_Callback);
	HookConVarChange(g_hNonFatiguedMeleePenalty_CVAR, _MF_MeleePenalty_CvarChange);
	DebugPrintToAllEx("Module is now loaded");
	return 0;
}

public _MF_OnPluginDisabled()
{
	RemoveNormalSoundHook(HookSound_Callback);
	UnhookConVarChange(g_hNonFatiguedMeleePenalty_CVAR, _MF_MeleePenalty_CvarChange);
	DebugPrintToAllEx("Module is now unloaded");
	return 0;
}

public _MF_MeleePenalty_CvarChange(Handle:convar, String:oldValue[], String:newValue[])
{
	DebugPrintToAllEx("melee penalty changed. Old value %s, new value %s", oldValue, newValue);
	UpdateNonFatiguedMeleePenalty();
	return 0;
}

public Action:HookSound_Callback(Clients[64], &NumClients, String:StrSample[256], &Entity)
{
	if (!ShouldPerformCustomFatigueLogic(StrSample, Entity))
	{
		return Action:0;
	}
	soundHookDelay[Entity] = 1;
	CreateTimer(MELEE_DURATION, ResetsoundHookDelay, Entity, 0);
	new shovePenalty = L4D_GetMeleeFatigue(Entity) + -1;
	if (0 > shovePenalty)
	{
		shovePenalty = 0;
	}
	DebugPrintToAllEx("Current shove penalty: %i", shovePenalty);
	if (shovePenalty >= MAX_EXISTING_FATIGUE)
	{
		DebugPrintToAllEx("Current shove penalty is %i, aborting", shovePenalty);
		return Action:0;
	}
	new newFatigue = g_nonFatiguedMeleePenalty + shovePenalty;
	L4D_SetMeleeFatigue(Entity, newFatigue);
	DebugPrintToAllEx("Set shove penalty to %i", newFatigue);
	return Action:0;
}

L4D_GetMeleeFatigue(client)
{
	return GetEntProp(client, PropType:0, "m_iShovePenalty", 4);
}

L4D_SetMeleeFatigue(client, value)
{
	SetEntProp(client, PropType:0, "m_iShovePenalty", value, 4);
	return 0;
}

public Action:ResetsoundHookDelay(Handle:timer, any:client)
{
	soundHookDelay[client] = 0;
	return Action:0;
}

bool:ShouldPerformCustomFatigueLogic(String:StrSample[256], entity)
{
	if (g_nonFatiguedMeleePenalty <= 1)
	{
		return false;
	}
	if (entity > 64)
	{
		return false;
	}
	if (soundHookDelay[entity])
	{
		return false;
	}
	if (StrContains(StrSample, MELEE_SOUND_NAME_SEARCH, false) == -1)
	{
		return false;
	}
	return true;
}

UpdateNonFatiguedMeleePenalty()
{
	g_nonFatiguedMeleePenalty = GetConVarInt(g_hNonFatiguedMeleePenalty_CVAR);
	DebugPrintToAllEx("Updated non fatigued melee penalty global var; %b", g_nonFatiguedMeleePenalty);
	return 0;
}

DebugPrintToAllEx(String:format[])
{
	decl String:buffer[1024];
	VFormat(buffer, 1024, format, 2);
	DebugPrintToAll(g_iDebugChannel, buffer);
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	if (!IsDedicatedServer())
	{
		strcopy(error, err_max, "Plugin only support dedicated servers");
		return APLRes:1;
	}
	decl String:buffer[128];
	GetGameFolderName(buffer, 128);
	if (!StrEqual(buffer, "left4dead2", false))
	{
		strcopy(error, err_max, "Plugin only support Left 4 Dead 2");
		return APLRes:1;
	}
	return APLRes:0;
}

public OnPluginStartEx()
{
	DebugPrintToAll(0, "[Main] Setting up...");
	decl String:buffer[128];
	Format(buffer, 128, "%s version", "L4D2 Melee Fatigue Control");
	new Handle:convar = CreateConVarEx("version", "0.0.2", buffer, 262400, false, 0.0, false, 0.0);
	SetConVarString(convar, "0.0.2", false, false);
	if (GetMaxEntities() > 2048)
	{
		ThrowError("Max entities exceeded, %d. Plugin needs a recompile with a updated max entity const, current value %d.", GetMaxEntities(), 2048);
	}
	_MeleeFatigue_OnPluginStart();
	Format(buffer, 128, "Sets whether %s is enabled", "L4D2 Melee Fatigue Control");
	convar = CreateConVarEx("enable", "0", buffer, 262400, false, 0.0, false, 0.0);
	if (!convar)
	{
		ThrowError("Unable to create main enable cvar!");
	}
	new var1;
	if (GetConVarBool(convar) && !IsDedicatedServer())
	{
		SetConVarBool(convar, false, false, false);
		DebugPrintToAll(0, "[Main] Unable to enable rotoblin, running on a listen server!");
	}
	else
	{
		SetPluginState(GetConVarBool(convar));
	}
	HookConVarChange(convar, _Main_Enable_CvarChange);
	DebugPrintToAll(0, "[Main] Done setting up!");
	return 0;
}

public OnAllPluginsLoaded()
{
	if (LibraryExists("zack"))
	{
		g_bIsZACKLoaded = true;
	}
	else
	{
		g_bIsZACKLoaded = false;
	}
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "zack", true))
	{
		g_bIsZACKLoaded = false;
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "zack", true))
	{
		g_bIsZACKLoaded = true;
	}
	return 0;
}

public _Main_Enable_CvarChange(Handle:convar, String:oldValue[], String:newValue[])
{
	DebugPrintToAll(0, "[Main] Enable cvar was changed. Old value %s, new value %s", oldValue, newValue);
	new var1;
	if (GetConVarBool(convar) && !IsDedicatedServer())
	{
		SetConVarBool(convar, false, false, false);
		DebugPrintToAll(0, "[Main] Unable to enable rotoblin, running on a listen server!");
		PrintToChatAll("[%s] Unable to enable %s! %s only support dedicated servers", "l4d2_meleecontrol", "L4D2 Melee Fatigue Control", "L4D2 Melee Fatigue Control");
		return 0;
	}
	SetPluginState(StringToInt(newValue, 10));
	return 0;
}

sub_244c(String:format[])
{
	decl String:buffer[1024];
	VFormat(buffer, 1024, format, 2);
	DebugPrintToAll(g_var8d8, buffer);
	return 0;
}

sub_2ec0(String:format[])
{
	decl String:buffer[1024];
	VFormat(buffer, 1024, format, 2);
	DebugPrintToAll(g_varbac, buffer);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "04/10/2017",
	time = "01:44:59"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCvarDmg;
new Float:fCvarDmg;
new bool:bLateLoad;
public Plugin:myinfo =
{
	name = "Fix Melee Weapons",
	description = "Fix those darn Melee Weapons not applying correct damage values and allows for a way to manipulate damage on Chargers.",
	author = "Sir",
	version = "1.1",
	url = "https://github.com/SirPlease/SirCoding"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	hCvarDmg = CreateConVar("melee_damage_charger", "0.0", "Damage dealt to Chargers per swing, 0.0 to leave in default behaviour", 0, false, 0.0, false, 0.0);
	fCvarDmg = GetConVarFloat(hCvarDmg);
	HookConVarChange(hCvarDmg, cvarChanged);
	if (bLateLoad)
	{
		new i = 1;
		while (MaxClients + 1 > i)
		{
			if (IsValidClient(i))
			{
				SDKHook(i, SDKHookType:2, OnTakeDamage);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	new var1;
	if (IsSurvivor(attacker) && IsSi(victim) && GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0) <= 6 && 0.0 != damage)
	{
		decl String:sWeapon[32];
		GetEdictClassname(inflictor, sWeapon, 32);
		if (StrEqual(sWeapon, "weapon_melee", true))
		{
			new class = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
			if (class <= 5)
			{
				damage = float(GetClientHealth(victim));
				return Action:1;
			}
			if (0.0 != fCvarDmg)
			{
				if (float(GetClientHealth(victim)) < fCvarDmg)
				{
					damage = float(GetClientHealth(victim));
				}
				else
				{
					damage = fCvarDmg;
				}
				return Action:1;
			}
		}
	}
	return Action:0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

bool:IsSurvivor(client)
{
	new var1;
	return IsValidClient(client) && GetClientTeam(client) == 2;
}

bool:IsSi(client)
{
	new var1;
	return IsValidClient(client) && GetClientTeam(client) == 3;
}

public cvarChanged(Handle:cvar, String:oldValue[], String:newValue[])
{
	fCvarDmg = GetConVarFloat(hCvarDmg);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "01/13/2018",
	time = "08:15:13"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Shove Shenanigans - REVAMPED",
	description = "Stops Shoves slowing the Tank and Charger",
	author = "Sir",
	version = "1.1",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public Action:L4D_OnShovedBySurvivor(shover, shovee, Float:vector[3])
{
	new var1;
	if (!IsSurvivor(shover) || !IsInfected(shovee))
	{
		return Action:0;
	}
	if (IsTankOrCharger(shovee))
	{
		return Action:3;
	}
	return Action:0;
}

public Action:L4D2_OnEntityShoved(shover, shovee_ent, weapon, Float:vector[3], bool:bIsHunterDeadstop)
{
	new var1;
	if (!IsSurvivor(shover) || !IsInfected(shovee_ent))
	{
		return Action:0;
	}
	if (IsTankOrCharger(shovee_ent))
	{
		return Action:3;
	}
	return Action:0;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

bool:IsTankOrCharger(client)
{
	if (!IsPlayerAlive(client))
	{
		return false;
	}
	if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8)
	{
		return true;
	}
	if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 6)
	{
		return true;
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "01/29/2014",
	time = "04:10:31"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_dhooks =
{
	name = "dhooks",
	file = "dhooks.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCLunge_ActivateAbility;
new Float:fSuspectedBackjump[66];
public Plugin:myinfo =
{
	name = "L4D2 No Backjump",
	description = "Gah",
	author = "Visor",
	version = "1.2",
	url = "https://github.com/Attano/smplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	new Handle:gameConf = LoadGameConfigFile("l4d2_nobackjump");
	new LungeActivateAbilityOffset = GameConfGetOffset(gameConf, "CLunge_ActivateAbility");
	hCLunge_ActivateAbility = DHookCreate(LungeActivateAbilityOffset, HookType:0, ReturnType:1, ThisPointerType:1, CLunge_ActivateAbility);
	DHookAddEntityListener(ListenType:0, OnEntityCreated);
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	HookEvent("player_jump", OnPlayerJump, EventHookMode:1);
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	if (StrEqual(classname, "ability_lunge", true))
	{
		DHookEntity(hCLunge_ActivateAbility, false, entity, DHookRemovalCB:-1);
	}
	return 0;
}

public OnRoundStart(Handle:event, String:name[], bool:bDontBroadcast)
{
	new i = 1;
	while (i <= MaxClients)
	{
		fSuspectedBackjump[i] = 0;
		i++;
	}
	return 0;
}

public Action:OnPlayerJump(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (IsHunter(client) && !IsGhost(client) && IsOutwardJump(client))
	{
		fSuspectedBackjump[client] = GetGameTime();
	}
	return Action:0;
}

public MRESReturn:CLunge_ActivateAbility(ability, Handle:hParams)
{
	new client = GetEntPropEnt(ability, PropType:0, "m_owner", 0);
	if (fSuspectedBackjump[client][1.5] > GetGameTime())
	{
		PrintToChat(client, "\x01[SM] No \x03backjumps\x01, sorry");
		return MRESReturn:3;
	}
	return MRESReturn:0;
}

bool:IsOutwardJump(client)
{
	new var1;
	return GetEntProp(client, PropType:0, "m_isAttemptingToPounce", 4, 0) && !GetEntityFlags(client) & 1;
}

bool:IsHunter(client)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return false;
	}
	new var2;
	if (!IsClientInGame(client) || !IsPlayerAlive(client))
	{
		return false;
	}
	new var3;
	if (GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 3)
	{
		return false;
	}
	return true;
}

bool:IsGhost(client)
{
	return GetEntProp(client, PropType:0, "m_isGhost", 4, 0) == 1;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/24/2016",
	time = "10:56:55"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Simple Anti-Bunnyhop",
	description = "Stops bunnyhops by restricting speed when a player lands on the ground to their MaxSpeed",
	author = "CanadaRox, ProdigySim, blodia, CircleSquared",
	version = "0.2",
	url = "https://bitbucket.org/CanadaRox/random-sourcemod-stuff/"
};
new Handle:hCvarEnable;
new Handle:hCvarSIExcept;
new Handle:hCvarSurvivorExcept;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

ScaleVector(Float:vec[3], Float:scale)
{
	new var1 = vec;
	var1[0] = var1[0] * scale;
	vec[1] *= scale;
	vec[2] *= scale;
	return 0;
}

public OnPluginStart()
{
	hCvarEnable = CreateConVar("simple_antibhop_enable", "1", "Enable or disable the Simple Anti-Bhop plugin", 262144, false, 0.0, false, 0.0);
	hCvarSIExcept = CreateConVar("bhop_except_si_flags", "0", "Bitfield for exempting SI in anti-bhop functionality. From least significant: Smoker, Boomer, Hunter, Spitter, Jockey, Charger, Tank", 262144, false, 0.0, false, 0.0);
	hCvarSurvivorExcept = CreateConVar("bhop_allow_survivor", "0", "Allow Survivors to bhop while plugin is enabled", 262144, false, 0.0, false, 0.0);
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	static Float:LeftGroundMaxSpeed[66];
	if (!GetConVarBool(hCvarEnable))
	{
		return Action:0;
	}
	new var1;
	if (IsValidClient(client) && IsPlayerAlive(client))
	{
		if (GetClientTeam(client) == 3)
		{
			new class = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
			if (class == 8)
			{
				class--;
			}
			class--;
			new except = GetConVarInt(hCvarSIExcept);
			new var2;
			if (class >= 0 && class <= 6 && except & 1 << class)
			{
				return Action:0;
			}
		}
		if (GetClientTeam(client) == 2)
		{
			if (GetConVarBool(hCvarSurvivorExcept))
			{
				return Action:0;
			}
		}
		new ClientFlags = GetEntityFlags(client);
		if (ClientFlags & 1)
		{
			if (-1.0 != LeftGroundMaxSpeed[client])
			{
				new Float:CurVelVec[3] = 0.0;
				GetEntPropVector(client, PropType:1, "m_vecAbsVelocity", CurVelVec, 0);
				if (GetVectorLength(CurVelVec, false) > LeftGroundMaxSpeed[client])
				{
					NormalizeVector(CurVelVec, CurVelVec);
					ScaleVector(CurVelVec, LeftGroundMaxSpeed[client]);
					TeleportEntity(client, NULL_VECTOR, NULL_VECTOR, CurVelVec);
				}
				LeftGroundMaxSpeed[client] = -1082130432;
			}
		}
		else
		{
			if (-1.0 == LeftGroundMaxSpeed[client])
			{
				LeftGroundMaxSpeed[client] = GetEntPropFloat(client, PropType:1, "m_flMaxspeed", 0);
			}
		}
	}
	return Action:0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "11/01/2016",
	time = "21:00:51"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Ghost-Cheat Preventer",
	description = "Don't broadcast Infected entities to Survivors while in ghost mode, disabling them from hooking onto the entities with 3rd party programs.",
	author = "Sir",
	version = "1.0",
	url = "Nawl."
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:6, Hook_SetTransmit);
	return 0;
}

public OnPluginStart()
{
	new client = 1;
	while (client <= 65)
	{
		if (IsValidClient(client))
		{
			SDKHook(client, SDKHookType:6, Hook_SetTransmit);
		}
		client++;
	}
	return 0;
}

public Action:Hook_SetTransmit(client, entity)
{
	new var1;
	if (IsValidClient(client) && IsValidClient(entity) && GetClientTeam(client) == 3 && GetClientTeam(entity) == 2 && GetEntProp(client, PropType:0, "m_isGhost", 4, 0) == 1)
	{
		return Action:3;
	}
	return Action:0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/19/2016",
	time = "13:12:14"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new L4D2_SI_Victim_Slots[10] =
{
	-1, 13280, -1, 16004, -1, 16124, 15972, -1, -1, -1
};
new Handle:bot_kick_delay;
public Plugin:myinfo =
{
	name = "L4D2 No Second Chances",
	description = "Previously human-controlled SI bots with a cap won't die",
	author = "Visor + Jacob",
	version = "1.1",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_bot_replace", PlayerBotReplace, EventHookMode:1);
	bot_kick_delay = CreateConVar("bot_kick_delay", "0", "How long should we wait before kicking infected bots?", 262144, true, 0.0, true, 30.0);
	return 0;
}

public PlayerBotReplace(Handle:event, String:name[], bool:dontBroadcast)
{
	new bot = GetClientOfUserId(GetEventInt(event, "bot"));
	new Float:delay = GetConVarFloat(bot_kick_delay);
	new var1;
	if (IsClientConnected(bot) && IsClientInGame(bot) && GetClientTeam(bot) == 3 && IsFakeClient(bot))
	{
		if (delay >= 1.0)
		{
			CreateTimer(delay, KillBot, bot, 0);
		}
		if (ShouldBeKicked(bot))
		{
			ForcePlayerSuicide(bot);
		}
	}
	return 0;
}

bool:ShouldBeKicked(infected)
{
	new Address:pEntity = GetEntityAddress(infected);
	if (pEntity)
	{
		new zcOffset = L4D2_SI_Victim_Slots[GetEntProp(infected, PropType:0, "m_zombieClass", 4, 0)];
		if (zcOffset == -1)
		{
			return false;
		}
		new hasTarget = LoadFromAddress(zcOffset + pEntity, NumberType:2);
		new var1;
		if (hasTarget > 0)
		{
			var1 = false;
		}
		else
		{
			var1 = true;
		}
		return var1;
	}
	return false;
}

public Action:KillBot(Handle:timer, any:bot)
{
	new var1;
	if (IsClientConnected(bot) && IsClientInGame(bot) && GetClientTeam(bot) == 3 && IsFakeClient(bot) && ShouldBeKicked(bot))
	{
		ForcePlayerSuicide(bot);
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:21"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32] =
{
	"Smoker",
	"Boomer",
	"Hunter",
	"Spitter",
	"Jockey",
	"Charger",
	"Witch",
	"Tank"
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new String:MeleeWeaponModels[15][];
new String:MeleeWeaponNames[15][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1870290797, 1701405293, 1935764547, 115, 0, 264, 524, 784, 1044, 1304, 1564, 1824, 2084, 2344, 2604, 2864, 3124, 3384, 3644, 3904, 4164, 4424, 4684, 4944, 5204, 5464, 5724, 5984, 6244, 6504, 6764, 7024, 7284, 7544, 7804, 8064, 8324, 8584, 8844, 9104, 9364, 9624, 9884, 10144, 10404, 10664, 10924, 11184, 11444, 11704, 11964, 12224, 12484, 12744, 13004, 13264
};
new Handle:hMeleeWeaponModelsTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hSurvivorModelsTrie;
new Handle:hTongueParalyzeTimer;
new Handle:hWeaponNamesTrie;
new iDamage[66][66];
new Float:fGhostDelay;
new Float:fReported[66][66];
public Plugin:myinfo =
{
	name = "L4D2 Display Infected HP",
	description = "Survivors receive damage reports after they get capped",
	author = "Visor",
	version = "1.2",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator>=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) >= 0;
}

bool:IsInfected(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 3)
	{
		return false;
	}
	return true;
}

L4D2_Infected:GetInfectedClass(client)
{
	return GetEntProp(client, PropType:0, L4D2_InfectedTimerEntities, 4, 0);
}

bool:IsSurvivor(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 2)
	{
		return false;
	}
	return true;
}

public OnPluginStart()
{
	HookEvent("player_hurt", Event_PlayerHurt, EventHookMode:1);
	HookEvent("player_death", Event_PlayerDeath, EventHookMode:1);
	HookEvent("charger_carry_start", Event_CHJ_Attack, EventHookMode:1);
	HookEvent("charger_pummel_start", Event_CHJ_Attack, EventHookMode:1);
	HookEvent("lunge_pounce", Event_CHJ_Attack, EventHookMode:1);
	HookEvent("jockey_ride", Event_CHJ_Attack, EventHookMode:1);
	HookEvent("tongue_grab", Event_SmokerAttackFirst, EventHookMode:1);
	HookEvent("choke_start", Event_SmokerAttackSecond, EventHookMode:1);
	return 0;
}

public OnConfigsExecuted()
{
	fGhostDelay = GetConVarFloat(FindConVar("z_ghost_delay_min"));
	return 0;
}

public Event_PlayerHurt(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (!IsInfected(victim) || IsTargetedSi(victim) < 0)
	{
		return 0;
	}
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var2;
	if (attacker && !IsClientInGame(attacker) && !IsSurvivor(attacker) && IsFakeClient(attacker) && !IsPlayerAlive(attacker))
	{
		return 0;
	}
	new var3 = iDamage[attacker][victim];
	var3 = var3[GetEventInt(event, "dmg_health")];
	return 0;
}

public Action:Event_PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client && !IsClientInGame(client) && !IsInfected(client))
	{
		return Action:0;
	}
	new zombieclass = IsTargetedSi(client);
	if (0 > zombieclass)
	{
		return Action:0;
	}
	new i = 1;
	while (i <= MaxClients)
	{
		iDamage[i][client] = 0;
		i++;
	}
	if (zombieclass == 1)
	{
		ClearTimer(hMeleeWeaponModelsTrie);
	}
	return Action:0;
}

public Event_CHJ_Attack(Handle:event, String:name[], bool:dontBroadcast)
{
	new attacker = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (attacker && !IsClientInGame(attacker) && !IsInfected(attacker) && !IsPlayerAlive(attacker))
	{
		return 0;
	}
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	new var2;
	if (victim && !IsClientInGame(victim) && !IsSurvivor(victim) && IsFakeClient(victim) && !IsPlayerAlive(victim))
	{
		return 0;
	}
	PrintInflictedDamage(victim, attacker);
	return 0;
}

public Event_SmokerAttackFirst(Handle:event, String:name[], bool:dontBroadcast)
{
	new attacker = GetClientOfUserId(GetEventInt(event, "userid"));
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	new checks;
	new Handle:hEventMembers = CreateStack(3);
	PushStackCell(hEventMembers, attacker);
	PushStackCell(hEventMembers, victim);
	PushStackCell(hEventMembers, checks);
	hMeleeWeaponModelsTrie = CreateTimer(1.1, CheckSurvivorState, hEventMembers, 2);
	return 0;
}

public Action:CheckSurvivorState(Handle:timer, any:hEventMembers)
{
	static attacker;
	static victim;
	static checks;
	if (!IsStackEmpty(hEventMembers))
	{
		PopStackCell(hEventMembers, checks, 0, false);
		PopStackCell(hEventMembers, victim, 0, false);
		PopStackCell(hEventMembers, attacker, 0, false);
	}
	if (IsSurvivorParalyzed(victim))
	{
		PrintInflictedDamage(victim, attacker);
	}
	return Action:0;
}

bool:IsSurvivorParalyzed(client)
{
	new var1;
	return GetGameTime() - GetEntDataFloat(client, 13292) >= 1065353216 && GetEntData(client, 13284, 4) > 0;
}

public Event_SmokerAttackSecond(Handle:event, String:name[], bool:dontBroadcast)
{
	new attacker = GetClientOfUserId(GetEventInt(event, "userid"));
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	ClearTimer(hMeleeWeaponModelsTrie);
	PrintInflictedDamage(victim, attacker);
	return 0;
}

public PrintInflictedDamage(iSurvivor, iInfected)
{
	new Float:fGameTime = GetGameTime();
	if (fReported[iSurvivor][iInfected][fGhostDelay] >= fGameTime)
	{
		return 0;
	}
	if (iDamage[iSurvivor][iInfected])
	{
		PrintToChat(iSurvivor, "\x04[DmgReport]\x01 \x03%N\x01(\x04%s\x01) took \x05%d\x01 damage from you!", iInfected, L4D2_InfectedNames[GetEntProp(iInfected, PropType:0, "m_zombieClass", 4, 0) + -1], iDamage[iSurvivor][iInfected]);
		fReported[iSurvivor][iInfected] = GetGameTime();
		iDamage[iSurvivor][iInfected] = 0;
		return 0;
	}
	return 0;
}

IsTargetedSi(client)
{
	new L4D2_Infected:zombieclass = GetInfectedClass(client);
	new var1;
	if (zombieclass == L4D2_Infected:6 || zombieclass == L4D2_Infected:3 || zombieclass == L4D2_Infected:5 || zombieclass == L4D2_Infected:1)
	{
		return zombieclass;
	}
	return -1;
}

ClearTimer(&Handle:timer)
{
	if (timer)
	{
		KillTimer(timer, false);
		timer = 0;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "03/23/2014",
	time = "20:13:19"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Plugin:myinfo =
{
	name = "No Spitter During Tank",
	description = "Prevents the director from giving the infected team a spitter while the tank is alive",
	author = "Don, epilimic",
	version = "1.7",
	url = "https://bitbucket.org/DonSanchez/random-sourcemod-stuff"
};
new bool:g_bIsTankAlive;
new Handle:g_hSpitterLimit;
new g_iOldSpitterLimit;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	decl String:sGame[12];
	GetGameFolderName(sGame, 12);
	if (StrEqual(sGame, "left4dead2", true))
	{
		return APLRes:0;
	}
	strcopy(error, err_max, "Plugin only supports L4D2");
	return APLRes:1;
}

public OnPluginStart()
{
	HookEvent("tank_spawn", Event_tank_spawn_Callback, EventHookMode:1);
	HookEvent("player_death", Event_player_death_Callback, EventHookMode:1);
	HookEvent("round_end", Event_round_end_Callback, EventHookMode:1);
	g_hSpitterLimit = FindConVar("z_versus_spitter_limit");
	return 0;
}

public Event_tank_spawn_Callback(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_bIsTankAlive)
	{
		g_iOldSpitterLimit = GetConVarInt(g_hSpitterLimit);
		SetConVarInt(g_hSpitterLimit, 0, false, false);
		g_bIsTankAlive = true;
	}
	return 0;
}

public Event_player_death_Callback(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bIsTankAlive)
	{
		new String:sVictimName[8];
		GetEventString(event, "victimname", sVictimName, 8);
		if (StrEqual(sVictimName, "Tank", true))
		{
			SetConVarInt(g_hSpitterLimit, g_iOldSpitterLimit, false, false);
			g_bIsTankAlive = false;
		}
	}
	return 0;
}

public Event_round_end_Callback(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bIsTankAlive)
	{
		SetConVarInt(g_hSpitterLimit, g_iOldSpitterLimit, false, false);
		g_bIsTankAlive = false;
	}
	return 0;
}

public OnPluginEnd()
{
	if (g_bIsTankAlive)
	{
		SetConVarInt(g_hSpitterLimit, g_iOldSpitterLimit, false, false);
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new TEAM_INFECTED = 3;
new g_iZombieClass_Tank = 8;
new g_iSpitterLimit;
new g_iTankClient;
new bool:g_bIsTankInPlay;
new Handle:g_hSpitterLimit;
public Plugin:myinfo =
{
	name = "No Spitter During Tank",
	description = "Prevents the director from giving the infected team a spitter while the tank is alive",
	author = "Don, epilimic, Griffin",
	version = "2.0",
	url = "https://bitbucket.org/DonSanchez/random-sourcemod-stuff"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	decl String:sGame[12];
	GetGameFolderName(sGame, 12);
	if (StrEqual(sGame, "left4dead2", true))
	{
		return APLRes:0;
	}
	strcopy(error, err_max, "Plugin only supports L4D2");
	return APLRes:1;
}

public OnPluginStart()
{
	HookEvent("tank_spawn", Event_TankSpawn, EventHookMode:1);
	HookEvent("player_death", Event_PlayerKilled, EventHookMode:1);
	HookEvent("round_start", Event_RoundStart, EventHookMode:1);
	HookEvent("round_end", Event_RoundEnd, EventHookMode:1);
	g_hSpitterLimit = FindConVar("z_versus_spitter_limit");
	HookConVarChange(g_hSpitterLimit, Cvar_SpitterLimit);
	g_iSpitterLimit = GetConVarInt(g_hSpitterLimit);
	return 0;
}

public Cvar_SpitterLimit(Handle:convar, String:oldValue[], String:newValue[])
{
	new var1;
	if (g_bIsTankInPlay || StringToInt(oldValue, 10))
	{
		return 0;
	}
	g_iSpitterLimit = StringToInt(newValue, 10);
	return 0;
}

public OnMapStart()
{
	new var1;
	if (g_iSpitterLimit > 0 && GetConVarInt(g_hSpitterLimit))
	{
		SetConVarInt(g_hSpitterLimit, g_iSpitterLimit, false, false);
	}
	return 0;
}

public OnClientDisconnect_Post(client)
{
	new var1;
	if (!g_bIsTankInPlay || g_iTankClient == client)
	{
		return 0;
	}
	CreateTimer(0.5, Timer_CheckTank, client, 0);
	return 0;
}

public Event_PlayerKilled(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_bIsTankInPlay)
	{
		return 0;
	}
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	if (g_iTankClient != victim)
	{
		return 0;
	}
	CreateTimer(0.5, Timer_CheckTank, victim, 0);
	return 0;
}

public Event_TankSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	g_iTankClient = client;
	if (g_bIsTankInPlay)
	{
		return 0;
	}
	g_bIsTankInPlay = true;
	SetConVarInt(g_hSpitterLimit, 0, false, false);
	return 0;
}

public Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	g_bIsTankInPlay = false;
	g_iTankClient = 0;
	new var1;
	if (g_iSpitterLimit > 0 && GetConVarInt(g_hSpitterLimit))
	{
		SetConVarInt(g_hSpitterLimit, g_iSpitterLimit, false, false);
	}
	return 0;
}

public Event_RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	g_bIsTankInPlay = false;
	new var1;
	if (g_iSpitterLimit > 0 && GetConVarInt(g_hSpitterLimit))
	{
		SetConVarInt(g_hSpitterLimit, g_iSpitterLimit, false, false);
	}
	return 0;
}

public Action:Timer_CheckTank(Handle:timer, any:oldtankclient)
{
	if (oldtankclient != g_iTankClient)
	{
		return Action:0;
	}
	new tankclient = FindTankClient();
	new var1;
	if (tankclient && oldtankclient != tankclient)
	{
		g_iTankClient = tankclient;
		return Action:0;
	}
	g_bIsTankInPlay = false;
	new var2;
	if (g_iSpitterLimit > 0 && GetConVarInt(g_hSpitterLimit))
	{
		SetConVarInt(g_hSpitterLimit, g_iSpitterLimit, false, false);
	}
	return Action:0;
}

FindTankClient()
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (!(!IsClientInGame(client) || TEAM_INFECTED == GetClientTeam(client) || !IsPlayerAlive(client) || g_iZombieClass_Tank == GetEntProp(client, PropType:0, "m_zombieClass", 4, 0)))
		{
			return client;
		}
		client++;
	}
	return 0;
}

public OnPluginEnd()
{
	new var1;
	if (g_iSpitterLimit > 0 && GetConVarInt(g_hSpitterLimit))
	{
		SetConVarInt(g_hSpitterLimit, g_iSpitterLimit, false, false);
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:21"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Plugin:myinfo =
{
	name = "L4D2 Tank Claw Fix",
	description = "Removes the Tank claw's undocumented auto-aiming ability",
	author = "Jahze(patch data) & Visor(SM)",
	version = "0.1",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	new Handle:hGamedata = LoadGameConfigFile("l4d2_notankautoaim");
	new Address:pAddress;
	if (!hGamedata)
	{
		SetFailState("Gamedata 'l4d2_notankautoaim.txt' missing or corrupt");
	}
	pAddress = GameConfGetAddress(hGamedata, "OnWindupFinished_Sig");
	if (!pAddress)
	{
		SetFailState("Couldn't find the 'OnWindupFinished_Sig' address");
	}
	new bool:bIsWin = GameConfGetOffset(hGamedata, "Platform") == 1;
	new iOffset = GameConfGetOffset(hGamedata, "ClawTargetScan");
	new offsetCheck[2] = {15,132};
	new patchBytes[3] = {233,139,0};
	if (!bIsWin)
	{
	}
	new var1;
	if (offsetCheck[0] == LoadFromAddress(iOffset + pAddress, NumberType:0) && offsetCheck[1] == LoadFromAddress(iOffset + 1 + pAddress, NumberType:0))
	{
		new i;
		while (i < 3)
		{
			if (!(0 > patchBytes[i]))
			{
				StoreToAddress(i + iOffset + pAddress, patchBytes[i], NumberType:0);
				PrintToServer("Set %x@%i", patchBytes[i], i);
				i++;
			}
		}
	}
	CloseHandle(hGamedata);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "01/03/2017",
	time = "18:30:42"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new deadstopSequences[4] =
{
	64, 67, 11, 8
};
public Plugin:myinfo =
{
	name = "L4D2 No Hunter Deadstops",
	description = "Self-descriptive",
	author = "Visor",
	version = "3.3",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public Action:L4D_OnShovedBySurvivor(shover, shovee, Float:vector[3])
{
	new var1;
	if (!IsSurvivor(shover) || !IsHunter(shovee))
	{
		return Action:0;
	}
	if (HasTarget(shovee))
	{
		return Action:0;
	}
	if (IsPlayingDeadstopAnimation(shovee))
	{
		return Action:3;
	}
	return Action:0;
}

public Action:L4D2_OnEntityShoved(shover, shovee_ent, weapon, Float:vector[3], bool:bIsHunterDeadstop)
{
	new var1;
	if (!IsSurvivor(shover) || !IsHunter(shovee_ent))
	{
		return Action:0;
	}
	if (HasTarget(shovee_ent))
	{
		return Action:0;
	}
	if (IsPlayingDeadstopAnimation(shovee_ent))
	{
		return Action:3;
	}
	return Action:0;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

bool:IsHunter(client)
{
	if (!IsInfected(client))
	{
		return false;
	}
	if (!IsPlayerAlive(client))
	{
		return false;
	}
	if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) != 3)
	{
		return false;
	}
	return true;
}

bool:IsPlayingDeadstopAnimation(hunter)
{
	new sequence = GetEntProp(hunter, PropType:0, "m_nSequence", 4, 0);
	new i;
	while (i < 4)
	{
		if (sequence == deadstopSequences[i])
		{
			return true;
		}
		i++;
	}
	return false;
}

bool:HasTarget(hunter)
{
	new target = GetEntDataEnt2(hunter, 16004);
	new var1;
	return IsSurvivor(target) && IsPlayerAlive(target);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "07/09/2017",
	time = "01:00:16"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 No Hunter Deadstops",
	description = "Self-descriptive",
	author = "Visor",
	version = "3.3",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public Action:L4D_OnShovedBySurvivor(shover, shovee, Float:vector[3])
{
	new var1;
	if (!IsSurvivor(shover) || !IsHunter(shovee) || HasTarget(shovee))
	{
		return Action:0;
	}
	return Action:3;
}

public Action:L4D2_OnEntityShoved(shover, shovee_ent, weapon, Float:vector[3], bool:bIsHunterDeadstop)
{
	new var1;
	if (!IsSurvivor(shover) || !IsHunter(shovee_ent) || HasTarget(shovee_ent))
	{
		return Action:0;
	}
	return Action:3;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

bool:IsHunter(client)
{
	if (!IsInfected(client))
	{
		return false;
	}
	if (!IsPlayerAlive(client))
	{
		return false;
	}
	if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) != 3)
	{
		return false;
	}
	return true;
}

bool:HasTarget(hunter)
{
	new target = GetEntDataEnt2(hunter, 16004);
	new var1;
	return IsSurvivor(target) && IsPlayerAlive(target);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "04/25/2017",
	time = "16:45:29"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 No Post-Jockeyed Shoves",
	description = "Self-descriptive",
	author = "Sir",
	version = "1.0",
	url = "nah"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public Action:L4D_OnShovedBySurvivor(shover, shovee, Float:vector[3])
{
	new var1;
	if (!IsSurvivor(shover) || !IsJockey(shovee))
	{
		return Action:0;
	}
	if (IsJockeyed(shover))
	{
		return Action:3;
	}
	return Action:0;
}

public Action:L4D2_OnEntityShoved(shover, shovee_ent, weapon, Float:vector[3], bool:bIsHunterDeadstop)
{
	new var1;
	if (!IsSurvivor(shover) || !IsJockey(shovee_ent))
	{
		return Action:0;
	}
	if (IsJockeyed(shover))
	{
		return Action:3;
	}
	return Action:0;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

bool:IsJockey(client)
{
	if (!IsInfected(client))
	{
		return false;
	}
	if (!IsPlayerAlive(client))
	{
		return false;
	}
	if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) != 5)
	{
		return false;
	}
	return true;
}

bool:IsJockeyed(client)
{
	return GetEntPropEnt(client, PropType:0, "m_jockeyAttacker", 0) > 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "01/26/2014",
	time = "00:05:36"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new String:MeleeWeaponModels[15][];
new String:MeleeWeaponNames[15][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1870290797, 1701405293, 1935764547, 115, 845427820, 1818850421, 0, 845427820, 1818850421, 2020438830, 0, 296, 308, 1, 1634624848, 544830572, 1970171746, 2037588083, 1835365491, 0, 1969381716, 110, 1869376577, 1864397687, 1919248500, 1970040864, 1936615783, 544175136, 544499059, 1970171746, 544433523, 544370534, 1869750369, 543452789, 1952540788, 1818851104, 1700929644, 1986619168, 1696624229, 544105846, 1948280425, 1931502952, 1919247969, 544042863, 1847620457, 1914729583, 1751343461, 3040357, 774975024, 49, 0, 336, 368, 360, 472, 480
};
new Handle:hMeleeWeaponModelsTrie = 845427820;
new Handle:hMeleeWeaponNamesTrie = 845427820;
new Handle:hSurvivorModelsTrie = 845427820;
new Handle:hWeaponNamesTrie = 845427820;
public SharedPlugin:__pl_l4d2util =
{
	name = "l4d2util",
	file = "l4d2util.smx",
	required = 1,
};
public Plugin:myinfo =
{
	name = "Penalty bonus system",
	description = "Allows other plugins to set bonuses for a round that will be given even if the saferoom is not reached.",
	author = "Tabun",
	version = "0.1.1",
	url = ""
};
new Handle:g_hForwardRequestUpdate;
new Handle:g_hCvarEnabled;
new Handle:g_hCvarDoDisplay;
new Handle:g_hCvarReportChange;
new Handle:g_hCvarBonusTank;
new Handle:g_hCvarBonusWitch;
new bool:g_bSecondHalf;
new bool:g_bFirstMapStartDone;
new Handle:g_hCvarDefibPenalty;
new g_iOriginalPenalty = 25;
new bool:g_bSetSameChange = 1;
new g_iSameChange;
new bool:g_bRoundOver[2];
new g_iDefibsUsed[2];
new g_iBonus[2];
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

L4D2_Infected:GetInfectedClass(client)
{
	return GetEntProp(client, PropType:0, L4D2_InfectedNames, 4, 0);
}

bool:IsTank(client)
{
	new var1;
	return IsClientInGame(client) && GetClientTeam(client) == 3 && GetInfectedClass(client) == 8;
}

public __pl_l4d2util_SetNTVOptional()
{
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	g_hForwardRequestUpdate = CreateGlobalForward("PBONUS_RequestFinalUpdate", ExecType:1, 3);
	CreateNative("PBONUS_GetRoundBonus", Native_GetRoundBonus);
	CreateNative("PBONUS_ResetRoundBonus", Native_ResetRoundBonus);
	CreateNative("PBONUS_SetRoundBonus", Native_SetRoundBonus);
	CreateNative("PBONUS_AddRoundBonus", Native_AddRoundBonus);
	CreateNative("PBONUS_GetDefibsUsed", Native_GetDefibsUsed);
	CreateNative("PBONUS_SetDefibPenalty", Native_SetDefibPenalty);
	RegPluginLibrary("penaltybonus");
	return APLRes:0;
}

public Native_GetRoundBonus(Handle:plugin, numParams)
{
	return g_iBonus[RoundNum()];
}

public Native_ResetRoundBonus(Handle:plugin, numParams)
{
	g_iBonus[RoundNum()] = 0;
	g_iSameChange = 0;
	g_bSetSameChange = true;
	return 0;
}

public Native_SetRoundBonus(Handle:plugin, numParams)
{
	new bonus = GetNativeCell(1);
	if (g_bSetSameChange)
	{
		g_iSameChange = g_iBonus[RoundNum()] - bonus;
	}
	else
	{
		if (g_iBonus[RoundNum()] - bonus != g_iSameChange)
		{
			g_iSameChange = 0;
			g_bSetSameChange = false;
		}
	}
	g_iBonus[RoundNum()] = bonus;
	if (GetConVarBool(g_hCvarReportChange))
	{
		ReportChange(0, -1, 1);
	}
	return 0;
}

public Native_AddRoundBonus(Handle:plugin, numParams)
{
	new bool:bNoReport;
	new bonus = GetNativeCell(1);
	new var1 = g_iBonus[RoundNum()];
	var1 = var1[bonus];
	if (g_bSetSameChange)
	{
		g_iSameChange = bonus;
	}
	else
	{
		if (bonus != g_iSameChange)
		{
			g_iSameChange = 0;
			g_bSetSameChange = false;
		}
	}
	if (numParams > 1)
	{
		bNoReport = GetNativeCell(2);
	}
	if (!bNoReport)
	{
		if (GetConVarBool(g_hCvarReportChange))
		{
			ReportChange(bonus, -1, 0);
		}
	}
	return 0;
}

public Native_GetDefibsUsed(Handle:plugin, numParams)
{
	return g_iDefibsUsed[RoundNum()];
}

public Native_SetDefibPenalty(Handle:plugin, numParams)
{
	new penalty = GetNativeCell(1);
	g_iOriginalPenalty = penalty;
	return 0;
}

public OnPluginStart()
{
	g_hCvarDefibPenalty = FindConVar("vs_defib_penalty");
	g_hCvarEnabled = CreateConVar("sm_pbonus_enable", "1", "Whether the penalty-bonus system is enabled.", 262144, true, 0.0, true, 1.0);
	g_hCvarDoDisplay = CreateConVar("sm_pbonus_display", "1", "Whether to display bonus at round-end and with !bonus.", 262144, true, 0.0, true, 1.0);
	g_hCvarReportChange = CreateConVar("sm_pbonus_reportchanges", "1", "Whether to report changes when they are made to the current bonus.", 262144, true, 0.0, true, 1.0);
	g_hCvarBonusTank = CreateConVar("sm_pbonus_tank", "0", "Give this much bonus when a tank is killed (0 to disable entirely).", 262144, true, 0.0, false, 0.0);
	g_hCvarBonusWitch = CreateConVar("sm_pbonus_witch", "0", "Give this much bonus when a witch is killed (0 to disable entirely).", 262144, true, 0.0, false, 0.0);
	HookEvent("defibrillator_used", Event_DefibUsed, EventHookMode:2);
	HookEvent("witch_killed", Event_WitchKilled, EventHookMode:2);
	HookEvent("player_death", Event_PlayerDeath, EventHookMode:1);
	AddCommandListener(Command_Say, "say");
	AddCommandListener(Command_Say, "say_team");
	RegConsoleCmd("sm_bonus", Cmd_Bonus, "Prints the current extra bonus(es) for this round.", 0);
	return 0;
}

public OnPluginEnd()
{
	SetConVarInt(g_hCvarDefibPenalty, g_iOriginalPenalty, false, false);
	return 0;
}

public OnMapStart()
{
	if (!g_bFirstMapStartDone)
	{
		g_iOriginalPenalty = GetConVarInt(g_hCvarDefibPenalty);
		g_bFirstMapStartDone = true;
	}
	SetConVarInt(g_hCvarDefibPenalty, g_iOriginalPenalty, false, false);
	g_bSecondHalf = false;
	g_bRoundOver[0] = 0;
	g_bRoundOver[1] = 0;
	g_iDefibsUsed[0] = 0;
	g_iDefibsUsed[1] = 0;
	return 0;
}

public OnMapEnd()
{
	g_bSecondHalf = false;
	return 0;
}

public OnRoundStart()
{
	SetConVarInt(g_hCvarDefibPenalty, g_iOriginalPenalty, false, false);
	g_iBonus[RoundNum()] = 0;
	g_iSameChange = -1;
	return 0;
}

public OnRoundEnd()
{
	g_bRoundOver[RoundNum()] = 1;
	g_bSecondHalf = true;
	new var1;
	if (GetConVarBool(g_hCvarEnabled) && GetConVarBool(g_hCvarDoDisplay))
	{
		DisplayBonus(-1);
	}
	return 0;
}

public Action:Cmd_Bonus(client, args)
{
	new var1;
	if (!GetConVarBool(g_hCvarEnabled) || !GetConVarBool(g_hCvarDoDisplay))
	{
		return Action:0;
	}
	DisplayBonus(client);
	return Action:3;
}

public Action:Command_Say(client, String:command[], args)
{
	new var1;
	if (!GetConVarBool(g_hCvarEnabled) || !GetConVarBool(g_hCvarDoDisplay))
	{
		return Action:0;
	}
	if (IsChatTrigger())
	{
		decl String:sMessage[32];
		GetCmdArg(1, sMessage, 32);
		if (StrEqual(sMessage, "!bonus", true))
		{
			return Action:3;
		}
		if (StrEqual(sMessage, "!sm_bonus", true))
		{
			return Action:3;
		}
	}
	return Action:0;
}

public Event_PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!GetConVarBool(g_hCvarEnabled))
	{
		return 0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client && IsTank(client))
	{
		TankKilled();
	}
	return 0;
}

public TankKilled()
{
	new var1;
	if (GetConVarInt(g_hCvarBonusTank) && g_bRoundOver[RoundNum()])
	{
		return 0;
	}
	new var2 = g_iBonus[RoundNum()];
	var2 = var2[GetConVarInt(g_hCvarBonusTank)];
	if (g_bSetSameChange)
	{
		g_iSameChange = GetConVarInt(g_hCvarBonusTank);
	}
	else
	{
		if (GetConVarInt(g_hCvarBonusTank) != g_iSameChange)
		{
			g_iSameChange = 0;
			g_bSetSameChange = false;
		}
	}
	ReportChange(GetConVarInt(g_hCvarBonusTank), -1, 0);
	return 0;
}

public Action:Event_WitchKilled(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!GetConVarBool(g_hCvarEnabled))
	{
		return Action:0;
	}
	new var1;
	if (GetConVarInt(g_hCvarBonusWitch) && g_bRoundOver[RoundNum()])
	{
		return Action:0;
	}
	new var2 = g_iBonus[RoundNum()];
	var2 = var2[GetConVarInt(g_hCvarBonusWitch)];
	if (g_bSetSameChange)
	{
		g_iSameChange = GetConVarInt(g_hCvarBonusWitch);
	}
	else
	{
		if (GetConVarInt(g_hCvarBonusWitch) != g_iSameChange)
		{
			g_iSameChange = 0;
			g_bSetSameChange = false;
		}
	}
	ReportChange(GetConVarInt(g_hCvarBonusWitch), -1, 0);
	return Action:0;
}

public Action:L4D2_OnEndVersusModeRound(bool:countSurvivors)
{
	new updateScore;
	new updateResult;
	Call_StartForward(g_hForwardRequestUpdate);
	Call_PushCellRef(updateScore);
	Call_Finish(updateResult);
	new var1 = g_iBonus[RoundNum()];
	var1 = var1[updateResult];
	g_iSameChange = 0;
	g_bSetSameChange = false;
	SetBonus();
	return Action:0;
}

public SetBonus()
{
	if (g_iBonus[RoundNum()])
	{
		new bonus = CalculateBonus();
		new fakeDefibs = 1;
		new var1;
		if (g_bSetSameChange && g_iSameChange && !g_iDefibsUsed[RoundNum()])
		{
			fakeDefibs = g_iBonus[RoundNum()] / g_iSameChange;
			bonus = 0 - g_iSameChange;
			if (fakeDefibs > 15)
			{
				fakeDefibs = 1;
				bonus = 0 - g_iBonus[RoundNum()];
			}
		}
		SetConVarInt(g_hCvarDefibPenalty, bonus, false, false);
		new var2;
		if (bonus)
		{
			var2 = fakeDefibs;
		}
		else
		{
			var2 = MissingTAG:0;
		}
		GameRules_SetProp("m_iVersusDefibsUsed", var2, 4, GameRules_GetProp("m_bAreTeamsFlipped", 4, 0), false);
		return 0;
	}
	SetConVarInt(g_hCvarDefibPenalty, g_iOriginalPenalty, false, false);
	return 0;
}

public CalculateBonus()
{
	return g_iDefibsUsed[RoundNum()] * g_iOriginalPenalty - g_iBonus[RoundNum()];
}

DisplayBonus(client)
{
	new String:msgPartHdr[48];
	new String:msgPartBon[48];
	new round;
	while (RoundNum() >= round)
	{
		if (g_bRoundOver[round])
		{
			Format(msgPartHdr, 48, "Round \x05%i\x01 extra bonus", round + 1);
		}
		else
		{
			Format(msgPartHdr, 48, "Current extra bonus");
		}
		Format(msgPartBon, 48, "\x04%4d\x01", g_iBonus[round]);
		if (g_iDefibsUsed[round])
		{
			Format(msgPartBon, 48, "%s (- \x04%d\x01 defib penalty)", msgPartBon, g_iDefibsUsed[round] * g_iOriginalPenalty);
		}
		if (client == -1)
		{
			PrintToChatAll("\x01%s: %s", msgPartHdr, msgPartBon);
		}
		else
		{
			if (client)
			{
				PrintToChat(client, "\x01%s: %s", msgPartHdr, msgPartBon);
			}
			PrintToServer("\x01%s: %s", msgPartHdr, msgPartBon);
		}
		round++;
	}
	return 0;
}

ReportChange(bonusChange, client, absoluteSet)
{
	new var1;
	if (bonusChange && !absoluteSet)
	{
		return 0;
	}
	new String:msgPartBon[48];
	if (absoluteSet)
	{
		Format(msgPartBon, 48, "Extra bonus set to: \x04%i\x01", g_iBonus[RoundNum()]);
	}
	else
	{
		new var2;
		if (bonusChange > 0)
		{
			var2[0] = 1572;
		}
		else
		{
			var2[0] = 1576;
		}
		Format(msgPartBon, 48, "Extra bonus change: %s\x04%i\x01", var2, RoundFloat(FloatAbs(float(bonusChange))));
	}
	if (client == -1)
	{
		PrintToChatAll("\x01%s", msgPartBon);
	}
	else
	{
		if (client)
		{
			PrintToChat(client, "\x01%s", msgPartBon);
		}
		PrintToServer("\x01%s", msgPartBon);
	}
	return 0;
}

public Event_DefibUsed(Handle:event, String:name[], bool:dontBroadcast)
{
	g_iDefibsUsed[RoundNum()]++;
	return 0;
}

RoundNum()
{
	new var1;
	if (g_bSecondHalf)
	{
		var1 = 1;
	}
	else
	{
		var1 = 0;
	}
	return var1;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "01/03/2017",
	time = "20:14:04"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:WeaponNames[56][] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced",
	"weapon_shotgun_chrome",
	"weapon_rifle_desert",
	"weapon_sniper_military",
	"weapon_shotgun_spas",
	"weapon_first_aid_kit",
	"weapon_molotov",
	"weapon_pipe_bomb",
	"weapon_pain_pills",
	"weapon_gascan",
	"weapon_propanetank",
	"weapon_oxygentank",
	"weapon_melee",
	"weapon_chainsaw",
	"weapon_grenade_launcher",
	"weapon_ammo_pack",
	"weapon_adrenaline",
	"weapon_defibrillator",
	"weapon_vomitjar",
	"weapon_rifle_ak47",
	"weapon_gnome",
	"weapon_cola_bottles",
	"weapon_fireworkcrate",
	"weapon_upgradepack_incendiary",
	"weapon_upgradepack_explosive",
	"weapon_pistol_magnum",
	"weapon_smg_mp5",
	"weapon_rifle_sg552",
	"weapon_sniper_awp",
	"weapon_sniper_scout",
	"weapon_rifle_m60",
	"weapon_tank_claw",
	"weapon_hunter_claw",
	"weapon_charger_claw",
	"weapon_boomer_claw",
	"weapon_smoker_claw",
	"weapon_spitter_claw",
	"weapon_jockey_claw",
	"weapon_machinegun",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:WeaponModels[56][];
new WeaponSlots[56] =
{
	0, 24, 32, 36, 48, 52, 56, 1717920891, 1953264993, 125, 1701996411, 8220261, 1734962299, 1919382632, 2104386917, 0, 1684370043, 125, 1970037371, 32101, 1768714107, 8217974, 24, 24, 24, 24, 24, 24, 1, 4, 3, 3, 3, 5, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
new Handle:hWeaponNamesTrie;
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new bool:bLateLoad;
new bool:bTanked[66];
new bool:bCantSwitchHealth[66];
new bool:bCantSwitchSecondary[66];
new bool:bPreventValveSwitch[66];
new Handle:hSecondary[66];
new Handle:hHealth[66];
new Handle:hTanked[66];
new Handle:hValveSwitch[66];
new Handle:hSwitchFlags;
new Handle:hIncapPickupFlags;
new iSwitchFlags[66];
new SwitchFlags;
new IncapFlags;
public Plugin:myinfo =
{
	name = "L4D2 Pick-up Changes",
	description = "Alters a few things regarding picking up/giving items and incapped Players.",
	author = "Sir",
	version = "1.2",
	url = "Nawl."
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

bool:GetEntityClassname(entity, String:clsname[], maxlength)
{
	return !!GetEntPropString(entity, PropType:1, "m_iClassname", clsname, maxlength, 0);
}

WeaponId:WeaponNameToId(String:weaponName[])
{
	if (!WeaponModels[0])
	{
		InitWeaponNamesTrie();
	}
	new WeaponID:id;
	if (GetTrieValue(WeaponModels[0], weaponName, id))
	{
		return id;
	}
	return WeaponId:0;
}

InitWeaponNamesTrie()
{
	WeaponModels[0] = CreateTrie();
	new i;
	while (i < 56)
	{
		SetTrieValue(WeaponModels[0], WeaponNames[i], i, true);
		i++;
	}
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	hSwitchFlags = CreateConVar("pickup_switch_flags", "3", "Flags for Switching from current item (1:Melee Weapons, 2: Passed Pills)", 0, false, 0.0, false, 0.0);
	hIncapPickupFlags = CreateConVar("pickup_incap_flags", "7", "Flags for Stopping Pick-up progress on Incapped Survivors (1:Spit Damage, 2:TankPunch, 4:TankRock", 0, false, 0.0, false, 0.0);
	HookConVarChange(hSwitchFlags, CVarChanged);
	HookConVarChange(hIncapPickupFlags, CVarChanged);
	SwitchFlags = GetConVarInt(hSwitchFlags);
	IncapFlags = GetConVarInt(hIncapPickupFlags);
	RegConsoleCmd("sm_secondary", ChangeSecondaryFlags, "", 0);
	if (bLateLoad)
	{
		new i = 1;
		while (MaxClients + 1 > i)
		{
			HookValidClient(i, true);
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	HookValidClient(client, true);
	if (iSwitchFlags[client] < 2)
	{
		iSwitchFlags[client] = SwitchFlags;
	}
	return 0;
}

public OnClientDisconnect_Post(client)
{
	KillActiveTimers(client);
	HookValidClient(client, false);
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	if (bTanked[client])
	{
		buttons = buttons & -33;
		if (!hTanked[client])
		{
			hTanked[client] = CreateTimer(0.2, DelayUse, client, 0);
		}
	}
	return Action:0;
}

public Action:ChangeSecondaryFlags(client, args)
{
	if (IsValidClient(client))
	{
		if (iSwitchFlags[client] != 3)
		{
			iSwitchFlags[client] = 3;
			CPrintToChat(client, "{blue}[{default}ItemSwitch{blue}] {default}Switch to Melee on pick-up: {blue}OFF");
		}
		iSwitchFlags[client] = 2;
		CPrintToChat(client, "{blue}[{default}ItemSwitch{blue}] {default}Switch to Melee on pick-up: {blue}ON");
	}
	return Action:3;
}

public Action:DelayUse(Handle:timer, any:client)
{
	bTanked[client] = 0;
	hTanked[client] = 0;
	return Action:0;
}

public Action:DelaySwitchHealth(Handle:timer, any:client)
{
	bCantSwitchHealth[client] = 0;
	hHealth[client] = 0;
	return Action:0;
}

public Action:DelaySwitchSecondary(Handle:timer, any:client)
{
	bCantSwitchSecondary[client] = 0;
	hSecondary[client] = 0;
	return Action:0;
}

public Action:DelayValveSwitch(Handle:timer, any:client)
{
	bPreventValveSwitch[client] = 0;
	hValveSwitch[client] = 0;
	return Action:0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (victim <= 0 || victim > MaxClients || !IsSurvivor(victim) || !IsValidEdict(inflictor))
	{
		return Action:0;
	}
	new var2;
	if (IncapFlags & 1 && IsIncapacitated(victim))
	{
		decl String:classname[64];
		GetEdictClassname(inflictor, classname, 64);
		if (StrEqual(classname, "insect_swarm", true))
		{
			damageType = 0;
			return Action:1;
		}
	}
	if (IsPlayerTank(attacker))
	{
		if (IsTankRock(inflictor))
		{
			if (IncapFlags & 4)
			{
				bTanked[victim] = 1;
			}
		}
		if (IncapFlags & 2)
		{
		}
	}
	return Action:0;
}

public Action:WeaponCanSwitchTo(client, weapon)
{
	if (!IsValidEntity(weapon))
	{
		return Action:0;
	}
	decl String:sWeapon[64];
	GetEntityClassname(weapon, sWeapon, 64);
	new WeaponId:wep = WeaponNameToId(sWeapon);
	new var2;
	if (iSwitchFlags[client] & 2 && (wep == WeaponId:15 || wep == WeaponId:23) && bCantSwitchHealth[client])
	{
		return Action:4;
	}
	new var4;
	if (iSwitchFlags[client] & 1 && (wep == WeaponId:19 || wep == WeaponId:32 || wep == WeaponId:1) && bCantSwitchSecondary[client])
	{
		return Action:4;
	}
	return Action:0;
}

public Action:WeaponEquip(client, weapon)
{
	if (!IsValidEntity(weapon))
	{
		return Action:0;
	}
	decl String:weapon_name[64];
	GetClientWeapon(client, weapon_name, 64);
	new WeaponId:wepname = WeaponNameToId(weapon_name);
	decl String:sWeapon[64];
	GetEntityClassname(weapon, sWeapon, 64);
	new WeaponId:wep = WeaponNameToId(sWeapon);
	new var1;
	if (wep == WeaponId:15 || wep == WeaponId:23)
	{
		bCantSwitchHealth[client] = 1;
		hHealth[client] = CreateTimer(0.1, DelaySwitchHealth, client, 0);
	}
	else
	{
		new var2;
		if (!IsIncapacitated(client) && !bPreventValveSwitch[client])
		{
			new var3;
			if (wep == WeaponId:19 || wep == WeaponId:32 || wep == WeaponId:1)
			{
				new var4;
				if (wepname == WeaponId:19 || wepname == WeaponId:1 || wepname == WeaponId:32)
				{
					return Action:0;
				}
				bCantSwitchSecondary[client] = 1;
				hSecondary[client] = CreateTimer(0.1, DelaySwitchSecondary, client, 0);
			}
		}
	}
	return Action:0;
}

public Action:WeaponDrop(client, weapon)
{
	if (!IsValidEntity(weapon))
	{
		return Action:0;
	}
	decl String:weapon_name[64];
	GetClientWeapon(client, weapon_name, 64);
	new WeaponId:wepname = WeaponNameToId(weapon_name);
	new Secondary = GetPlayerWeaponSlot(client, 1);
	decl String:sWeapon[64];
	GetEntityClassname(weapon, sWeapon, 64);
	new WeaponId:wep = WeaponNameToId(sWeapon);
	new var1;
	if (!IsIncapacitated(client) && IsPlayerAlive(client))
	{
		new var2;
		if (wep == WeaponId:1 && GetEntProp(Secondary, PropType:0, "m_isDualWielding", 4, 0) && wepname != WeaponId:19 && wepname != WeaponId:1 && wepname != WeaponId:32)
		{
			SetEntProp(Secondary, PropType:0, "m_isDualWielding", any:0, 4, 0);
			SDKHooks_DropWeapon(client, Secondary, NULL_VECTOR, NULL_VECTOR);
			SetEntProp(Secondary, PropType:0, "m_isDualWielding", any:1, 4, 0);
		}
		new var3;
		if ((wep == WeaponId:19 || wep == WeaponId:1 || wep == WeaponId:32) && (wepname == WeaponId:19 || wepname == WeaponId:1 || wepname == WeaponId:32))
		{
			bPreventValveSwitch[client] = 1;
			hValveSwitch[client] = CreateTimer(0.1, DelayValveSwitch, client, 0);
		}
	}
	return Action:0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

bool:IsSurvivor(client)
{
	new var1;
	return IsValidClient(client) && GetClientTeam(client) == 2;
}

bool:IsIncapacitated(client)
{
	new bool:bIsIncapped;
	if (IsSurvivor(client))
	{
		if (0 < GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0))
		{
			bIsIncapped = true;
		}
		if (!IsPlayerAlive(client))
		{
			bIsIncapped = true;
		}
	}
	return bIsIncapped;
}

bool:IsPlayerTank(client)
{
	new var1;
	return IsValidClient(client) && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8;
}

bool:IsTankRock(entity)
{
	new var1;
	if (entity > 0 && IsValidEntity(entity) && IsValidEdict(entity))
	{
		decl String:classname[64];
		GetEdictClassname(entity, classname, 64);
		return StrEqual(classname, "tank_rock", true);
	}
	return false;
}

KillActiveTimers(client)
{
	if (hTanked[client])
	{
		KillTimer(hTanked[client], false);
	}
	if (hHealth[client])
	{
		KillTimer(hHealth[client], false);
	}
	if (hSecondary[client])
	{
		KillTimer(hSecondary[client], false);
	}
	if (hValveSwitch[client])
	{
		KillTimer(hValveSwitch[client], false);
	}
	hTanked[client] = 0;
	hHealth[client] = 0;
	hSecondary[client] = 0;
	hValveSwitch[client] = 0;
	bCantSwitchHealth[client] = 0;
	bCantSwitchSecondary[client] = 0;
	bPreventValveSwitch[client] = 0;
	bTanked[client] = 0;
	iSwitchFlags[client] = -1;
	return 0;
}

HookValidClient(client, bool:Hook)
{
	if (IsValidClient(client))
	{
		if (Hook)
		{
			SDKHook(client, SDKHookType:2, OnTakeDamage);
			SDKHook(client, SDKHookType:13, WeaponCanSwitchTo);
			SDKHook(client, SDKHookType:16, WeaponEquip);
			SDKHook(client, SDKHookType:15, WeaponDrop);
		}
		SDKUnhook(client, SDKHookType:2, OnTakeDamage);
		SDKUnhook(client, SDKHookType:13, WeaponCanSwitchTo);
		SDKUnhook(client, SDKHookType:16, WeaponEquip);
		SDKUnhook(client, SDKHookType:15, WeaponDrop);
	}
	return 0;
}

public CVarChanged(Handle:cvar, String:oldValue[], String:newValue[])
{
	IncapFlags = GetConVarInt(hIncapPickupFlags);
	SwitchFlags = GetConVarInt(hSwitchFlags);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/20/2016",
	time = "07:34:55"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_cprefs =
{
	name = "Client Preferences",
	file = "clientprefs.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 0,
};
new bool:g_bLateLoad;
new bool:g_bFirstLoadDone;
new bool:g_bLoadSkipDone;
new bool:g_bLGOAvailable;
new bool:g_bReadyUpAvailable;
new bool:g_bPauseAvailable;
new bool:g_bSkillDetectLoaded;
new bool:g_bCMTActive;
new bool:g_bCMTSwapped;
new bool:g_bModeCampaign;
new bool:g_bModeScavenge;
new Handle:g_hCookiePrint;
new g_iCookieValue[66];
new Handle:g_hCvarDebug;
new Handle:g_hCvarMVPBrevityFlags;
new Handle:g_hCvarAutoPrintVs;
new Handle:g_hCvarAutoPrintCoop;
new Handle:g_hCvarShowBots;
new Handle:g_hCvarDetailPercent;
new Handle:g_hCvarWriteStats;
new Handle:g_hCvarSkipMap;
new bool:g_bGameStarted;
new bool:g_bInRound;
new bool:g_bTeamChanged;
new bool:g_bTankInGame;
new bool:g_bPlayersLeftStart;
new bool:g_bSecondHalf;
new bool:g_bFailedPrevious;
new g_iRound;
new g_iCurTeam;
new g_iTeamSize = 4;
new g_iLastRoundEndPrint;
new g_iSurvived[2];
new bool:g_bPaused;
new g_iPauseStart;
new g_iScores[2];
new g_iFirstScoresSet[3];
new g_iBoomedBy[66];
new g_iPlayerIndexSorted[4][64];
new g_iPlayerSortedUseTeam[4][64];
new g_iPlayerRoundTeam[3][64];
new g_iPlayerGameTeam[2][64];
new g_strGameData[2];
new g_strAllRoundData[2][19];
new g_strRoundData[48][2][19];
new g_strPlayerData[64][77];
new g_strRoundPlayerData[64][2][77];
new g_strPlayerInfData[64][77];
new g_strRoundPlayerInfData[64][2][77];
new Handle:g_hTriePlayers;
new Handle:g_hTrieWeapons;
new Handle:g_hTrieMaps;
new Handle:g_hTrieEntityCreated;
new Float:g_fHighestFlow[4];
new String:g_sPlayerName[64][64];
new String:g_sPlayerNameSafe[64][64];
new String:g_sPlayerId[64][32];
new String:g_sMapName[48][32];
new String:g_sConfigName[32];
new g_iPlayers;
new String:g_sConsoleBuf[10][4096];
new g_iConsoleBufChunks;
new String:g_sStatsFile[64];
new Handle:g_hStatsFile;
public Plugin:myinfo =
{
	name = "Player Statistics",
	description = "Tracks statistics, even when clients disconnect. MVP, Skills, Accuracy, etc.",
	author = "Tabun",
	version = "0.9.30",
	url = "https://github.com/Tabbernaut/L4D2-Plugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

StrCat(String:buffer[], maxlength, String:source[])
{
	new len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	return Format(buffer[len], maxlength - len, "%s", source);
}

ExplodeString(String:text[], String:split[], String:buffers[][], maxStrings, maxStringLength, bool:copyRemainder)
{
	new reloc_idx;
	new idx;
	new total;
	new var1;
	if (maxStrings < 1 || !split[0])
	{
		return 0;
	}
	while ((idx = SplitString(text[reloc_idx], split, buffers[total], maxStringLength)) != -1)
	{
		reloc_idx = idx + reloc_idx;
		total++;
		if (maxStrings == total)
		{
			if (copyRemainder)
			{
				strcopy(buffers[total + -1], maxStringLength, text[reloc_idx - idx]);
			}
			return total;
		}
	}
	total++;
	strcopy(buffers[total], maxStringLength, text[reloc_idx]);
	return total;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetTerrorNavMesh()
{
	static Address:TheNavMesh;
	if (!TheNavMesh)
	{
		TheNavMesh = GameConfGetAddress(L4D2Direct_GetGameConf(), "TerrorNavMesh");
	}
	return TheNavMesh;
}

Address:L4D2Direct_GetMapMaxFlowDistanceAddr()
{
	static Address:pMapMaxFlowDistance;
	if (!pMapMaxFlowDistance)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "TerrorNavMesh::m_fMapMaxFlowDistance");
		if (offs == -1)
		{
			return Address:0;
		}
		pMapMaxFlowDistance = L4D2Direct_GetTerrorNavMesh() + offs;
	}
	return pMapMaxFlowDistance;
}

Float:L4D2Direct_GetMapMaxFlowDistance()
{
	return LoadFromAddress(L4D2Direct_GetMapMaxFlowDistanceAddr(), NumberType:2);
}

Float:L4D2Direct_GetFlowDistance(client)
{
	static Handle:GetFlowDistanceSDKCall;
	if (!GetFlowDistanceSDKCall)
	{
		StartPrepSDKCall(SDKCallType:2);
		if (!PrepSDKCall_SetFromConf(L4D2Direct_GetGameConf(), SDKFuncConfSource:1, "CTerrorPlayer::GetFlowDistance"))
		{
			return 0.0;
		}
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		PrepSDKCall_SetReturnInfo(SDKType:5, SDKPassMethod:1, 0, 0);
		GetFlowDistanceSDKCall = EndPrepSDKCall();
		if (!GetFlowDistanceSDKCall)
		{
			return 0.0;
		}
	}
	return SDKCall(GetFlowDistanceSDKCall, client, 0);
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public __pl_lgofnoc_SetNTVOptional()
{
	MarkNativeAsOptional("LGO_BuildConfigPath");
	MarkNativeAsOptional("LGO_ExecuteConfigCfg");
	MarkNativeAsOptional("LGO_IsMapDataAvailable");
	MarkNativeAsOptional("LGO_GetMapValueInt");
	MarkNativeAsOptional("LGO_GetMapValueFloat");
	MarkNativeAsOptional("LGO_GetMapValueVector");
	MarkNativeAsOptional("LGO_GetMapValueString");
	MarkNativeAsOptional("LGO_CopyMapSubsection");
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	g_bLateLoad = late;
	return APLRes:0;
}

public OnAllPluginsLoaded()
{
	g_bLGOAvailable = LibraryExists("lgofnoc");
	g_bReadyUpAvailable = LibraryExists("readyup");
	g_bPauseAvailable = LibraryExists("pause");
	g_bSkillDetectLoaded = LibraryExists("skill_detect");
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "lgofnoc", true))
	{
		g_bLGOAvailable = false;
	}
	else
	{
		if (StrEqual(name, "readyup", true))
		{
			g_bReadyUpAvailable = false;
		}
		if (StrEqual(name, "pause", true))
		{
			g_bPauseAvailable = false;
		}
		if (StrEqual(name, "skill_detect", true))
		{
			g_bSkillDetectLoaded = false;
		}
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "lgofnoc", true))
	{
		g_bLGOAvailable = true;
	}
	else
	{
		if (StrEqual(name, "readyup", true))
		{
			g_bReadyUpAvailable = true;
		}
		if (StrEqual(name, "pause", true))
		{
			g_bPauseAvailable = true;
		}
		if (StrEqual(name, "skill_detect", true))
		{
			g_bSkillDetectLoaded = true;
		}
	}
	return 0;
}


/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "OnPluginStart" (number 18)
public LGO_OnMatchModeStart(String:sConfig[])
{
	g_bLoadSkipDone = false;
	return 0;
}

public OnConfigsExecuted()
{
	g_iTeamSize = GetConVarInt(FindConVar("survivor_limit"));
	new Handle:tmpHandle = FindConVar("l4d_ready_cfg_name");
	if (tmpHandle)
	{
		GetConVarString(tmpHandle, g_sConfigName, 32);
	}
	return 0;
}

public OnClientPostAdminCheck(client)
{
	GetPlayerIndexForClient(client);
	return 0;
}

public OnClientDisconnect(client)
{
	g_iCookieValue[client] = 0;
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(client);
	if (index == -1)
	{
		return 0;
	}
	new time = GetTime({0,0});
	if (g_bPaused)
	{
		time = g_iPauseStart;
	}
	if (g_iCurTeam == g_iPlayerRoundTeam[2][index])
	{
		g_strRoundPlayerData[index][g_iCurTeam][72] = time;
		if (!g_strRoundPlayerData[index][g_iCurTeam][74])
		{
			g_strRoundPlayerData[index][g_iCurTeam][74] = time;
		}
		if (!g_strRoundPlayerData[index][g_iCurTeam][76])
		{
			g_strRoundPlayerData[index][g_iCurTeam][76] = time;
		}
	}
	else
	{
		new var1;
		if (g_iCurTeam == g_iPlayerRoundTeam[2][index])
		{
			var1 = 0;
		}
		else
		{
			var1 = 1;
		}
		if (var1)
		{
			g_strRoundPlayerInfData[index][g_iCurTeam][24] = time;
		}
	}
	return 0;
}

public OnMapStart()
{
	g_bSecondHalf = false;
	CheckGameMode();
	new var2;
	if (!g_bLoadSkipDone && (g_bLGOAvailable || GetConVarBool(g_hCvarSkipMap)))
	{
		PrintDebug(2, "OnMapStart: Resetting all stats (resetnextmap setting)... ");
		ResetStats(false, -1, false);
		SetConVarInt(g_hCvarSkipMap, 0, false, false);
		g_bLoadSkipDone = true;
		g_iFirstScoresSet[0] = 0;
		g_iFirstScoresSet[1] = 0;
		g_iFirstScoresSet[2] = 1;
	}
	else
	{
		if (g_bFirstLoadDone)
		{
			PrintDebug(2, "OnMapStart: Reset stats for round (Timer_ResetStats)");
			CreateTimer(5.0, Timer_ResetStats, any:1, 2);
		}
	}
	g_bFirstLoadDone = true;
	CreateTimer(1.0, Timer_SaveFlows, any:0, 3);
	GetCurrentMap(g_sMapName[g_iRound], 32);
	return 0;
}

public OnMapEnd()
{
	g_bInRound = false;
	g_iRound += 1;
	new var1;
	if (!g_bCMTActive && !g_bModeCampaign && IsMissionFinalMap())
	{
		HandleGameEnd();
	}
	return 0;
}

public Event_MissionLostCampaign(Handle:hEvent, String:name[], bool:dontBroadcast)
{
	5684/* ERROR unknown load Constant */++;
	g_strRoundData[g_iRound][g_iCurTeam]++;
	HandleRoundEnd(true);
	return 0;
}

public Event_RoundStart(Handle:hEvent, String:name[], bool:dontBroadcast)
{
	HandleRoundStart(false);
	CreateTimer(5.5, Timer_RoundStart, any:0, 2);
	return 0;
}

HandleRoundStart(bool:bLeftStart)
{
	if (g_bInRound)
	{
		return 0;
	}
	g_bInRound = true;
	g_bPlayersLeftStart = bLeftStart;
	g_bTankInGame = false;
	g_bPaused = false;
	if (bLeftStart)
	{
		new var1;
		if (g_bModeCampaign)
		{
			var1 = 0;
		}
		else
		{
			var1 = GetCurrentTeamSurvivor();
		}
		g_iCurTeam = var1;
		ClearPlayerTeam(g_iCurTeam);
	}
	return 0;
}

public Action:Timer_RoundStart(Handle:timer)
{
	new var1;
	if (g_bModeCampaign)
	{
		var1 = 0;
	}
	else
	{
		var1 = GetCurrentTeamSurvivor();
	}
	g_iCurTeam = var1;
	ClearPlayerTeam(g_iCurTeam);
	return Action:0;
}

public Event_RoundEnd(Handle:hEvent, String:name[], bool:dontBroadcast)
{
	HandleRoundEnd(false);
	return 0;
}

HandleRoundEnd(bool:bFailed)
{
	PrintDebug(1, "HandleRoundEnd (failed: %i): inround: %i, current round: %i", bFailed, g_bInRound, g_iRound);
	if (!g_bInRound)
	{
		return 0;
	}
	g_iSurvived[g_iCurTeam] = GetUprightSurvivors();
	if (g_bTankInGame)
	{
		HandleTankTimeEnd();
	}
	SetRoundEndTimes();
	g_bInRound = false;
	new var1;
	if (!g_bModeCampaign || !bFailed)
	{
		if (GetConVarBool(g_hCvarWriteStats))
		{
			if (g_bSecondHalf)
			{
				CreateTimer(1.0, Timer_WriteStats, g_iCurTeam, 0);
			}
			WriteStatsToFile(g_iCurTeam, false);
		}
		HandleRoundAddition();
		new var2;
		if (g_iLastRoundEndPrint && GetTime({0,0}) - g_iLastRoundEndPrint > 15)
		{
			AutomaticRoundEndPrint(false);
		}
	}
	new var3;
	if ((g_bModeCampaign || g_bSecondHalf) && !AreClientsConnected())
	{
		PrintDebug(2, "HandleRoundEnd: Reset stats for entire game (no players on server)...");
		ResetStats(false, -1, false);
	}
	if (!g_bModeCampaign)
	{
		if (g_bSecondHalf)
		{
			g_iFirstScoresSet[2] = 0;
		}
		g_bSecondHalf = true;
	}
	else
	{
		g_bFailedPrevious = bFailed;
	}
	g_bPlayersLeftStart = false;
	return 0;
}

SetRoundEndTimes()
{
	new i;
	new j;
	new time = GetTime({0,0});
	i = 13;
	while (i < 18)
	{
		new var1;
		if (g_strRoundData[g_iRound][g_iCurTeam][i] && !g_strRoundData[g_iRound][g_iCurTeam][i + 1])
		{
			g_strRoundData[g_iRound][g_iCurTeam][i + 1] = time;
		}
		i += 2;
	}
	j = 0;
	while (j < g_iPlayers)
	{
		i = 71;
		while (i < 76)
		{
			new var2;
			if (g_strRoundPlayerData[j][g_iCurTeam][i] && !g_strRoundPlayerData[j][g_iCurTeam][i + 1])
			{
				g_strRoundPlayerData[j][g_iCurTeam][i + 1] = time;
			}
			i += 2;
		}
		i = 23;
		while (i < 24)
		{
			new var3;
			if (g_strRoundPlayerInfData[j][g_iCurTeam][i] && !g_strRoundPlayerInfData[j][g_iCurTeam][i + 1])
			{
				g_strRoundPlayerInfData[j][g_iCurTeam][i + 1] = time;
			}
			i += 2;
		}
		j++;
	}
	return 0;
}

HandleRoundAddition()
{
	new i;
	new j;
	new var1;
	if (g_iCurTeam)
	{
		var1 = 190424;
	}
	else
	{
		var1 = 190420;
	}
	PrintDebug(1, "Handling round addition for round %i, roundhalf %i (team %s).", g_iRound, g_bSecondHalf, var1);
	i = 0;
	while (i < 13)
	{
		new var5 = g_strAllRoundData[g_iCurTeam][i];
		var5 = g_strRoundData[g_iRound][g_iCurTeam][i][var5];
		i++;
	}
	i = 13;
	while (i < 18)
	{
		new var2;
		if (!g_strRoundData[g_iRound][g_iCurTeam][i] || !g_strRoundData[g_iRound][g_iCurTeam][i + 1])
		{
		}
		else
		{
			if (!g_strAllRoundData[g_iCurTeam][i])
			{
				g_strAllRoundData[g_iCurTeam][i] = g_strRoundData[g_iRound][g_iCurTeam][i];
				g_strAllRoundData[g_iCurTeam][i + 1] = g_strRoundData[g_iRound][g_iCurTeam][i + 1];
			}
			else
			{
				new var6 = g_strAllRoundData[g_iCurTeam][i + 1];
				var6 = var6[g_strRoundData[g_iRound][g_iCurTeam][i + 1] - g_strRoundData[g_iRound][g_iCurTeam][i]];
			}
		}
		i += 2;
	}
	j = 0;
	while (j < g_iPlayers)
	{
		i = 0;
		while (i < 71)
		{
			new var7 = g_strPlayerData[j][i];
			var7 = g_strRoundPlayerData[j][g_iCurTeam][i][var7];
			i++;
		}
		i = 71;
		while (i < 76)
		{
			new var3;
			if (!g_strRoundPlayerData[j][g_iCurTeam][i] || !g_strRoundPlayerData[j][g_iCurTeam][i + 1])
			{
			}
			else
			{
				if (!g_strPlayerData[j][i])
				{
					g_strPlayerData[j][i] = g_strRoundPlayerData[j][g_iCurTeam][i];
					g_strPlayerData[j][i + 1] = g_strRoundPlayerData[j][g_iCurTeam][i + 1];
				}
				else
				{
					new var8 = g_strPlayerData[j][i + 1];
					var8 = var8[g_strRoundPlayerData[j][g_iCurTeam][i + 1] - g_strRoundPlayerData[j][g_iCurTeam][i]];
				}
			}
			i += 2;
		}
		i = 0;
		while (i < 23)
		{
			new var9 = g_strPlayerInfData[j][i];
			var9 = g_strRoundPlayerInfData[j][g_iCurTeam][i][var9];
			i++;
		}
		i = 23;
		while (i < 24)
		{
			new var4;
			if (!g_strRoundPlayerInfData[j][g_iCurTeam][i] || !g_strRoundPlayerInfData[j][g_iCurTeam][i + 1])
			{
			}
			else
			{
				if (!g_strPlayerInfData[j][i])
				{
					g_strPlayerInfData[j][i] = g_strRoundPlayerInfData[j][g_iCurTeam][i];
					g_strPlayerInfData[j][i + 1] = g_strRoundPlayerInfData[j][g_iCurTeam][i + 1];
				}
				else
				{
					new var10 = g_strPlayerInfData[j][i + 1];
					var10 = var10[g_strRoundPlayerInfData[j][g_iCurTeam][i + 1] - g_strRoundPlayerInfData[j][g_iCurTeam][i]];
				}
			}
			i += 2;
		}
		j++;
	}
	return 0;
}

public Event_MapTransition(Handle:hEvent, String:name[], bool:dontBroadcast)
{
	if (g_bModeCampaign)
	{
		HandleRoundEnd(false);
	}
	return 0;
}

public Event_FinaleWin(Handle:hEvent, String:name[], bool:dontBroadcast)
{
	if (g_bModeCampaign)
	{
		HandleRoundEnd(false);
		if (!g_bCMTActive)
		{
			HandleGameEnd();
		}
	}
	return 0;
}

HandleGameEnd()
{
	PrintDebug(2, "HandleGameEnd...");
	ResetStats(false, -1, false);
	g_bLoadSkipDone = false;
	return 0;
}

public OnRoundIsLive()
{
	RoundReallyStarting();
	return 0;
}

public Action:L4D_OnFirstSurvivorLeftSafeArea(client)
{
	HandleRoundStart(true);
	if (!g_bReadyUpAvailable)
	{
		RoundReallyStarting();
	}
	return Action:0;
}

RoundReallyStarting()
{
	g_bPlayersLeftStart = true;
	new time = GetTime({0,0});
	new i = 1;
	while (i <= MaxClients)
	{
		g_iBoomedBy[i] = 0;
		i++;
	}
	i = 0;
	while (i < 4)
	{
		g_fHighestFlow[i] = 0;
		i++;
	}
	if (!g_bGameStarted)
	{
		g_bGameStarted = true;
		g_strGameData[1] = time;
		SetStartSurvivorTime(true, g_bFailedPrevious);
	}
	new var1;
	if (g_bFailedPrevious && g_strRoundData[g_iRound][g_iCurTeam][14])
	{
		g_strRoundData[g_iRound][g_iCurTeam][13] = time - g_strRoundData[g_iRound][g_iCurTeam][14] - g_strRoundData[g_iRound][g_iCurTeam][13];
		g_strRoundData[g_iRound][g_iCurTeam][14] = 0;
		g_bFailedPrevious = false;
	}
	else
	{
		g_strRoundData[g_iRound][g_iCurTeam][13] = time;
	}
	UpdatePlayerCurrentTeam();
	SetStartSurvivorTime(false, false);
	return 0;
}

public OnPause()
{
	if (g_bPaused)
	{
		return 0;
	}
	g_bPaused = true;
	new time = GetTime({0,0});
	g_iPauseStart = time;
	PrintDebug(1, "Pause (start time: %i -- stored time: %i -- round start time: %i).", g_iPauseStart, g_strRoundData[g_iRound][g_iCurTeam][15], g_strRoundData[g_iRound][g_iCurTeam][13]);
	return 0;
}


/* ERROR! null */
 function "OnUnpause" (number 40)
public Action:L4D_OnSetCampaignScores(&scoreA, &scoreB)
{
	if (g_bCMTSwapped)
	{
		g_iScores[1] = scoreA;
		g_iScores[0] = scoreB;
	}
	else
	{
		g_iScores[0] = scoreA;
		g_iScores[1] = scoreB;
	}
	if (!g_iFirstScoresSet[2])
	{
		g_iFirstScoresSet[0] = scoreA;
		g_iFirstScoresSet[1] = scoreB;
		g_iFirstScoresSet[2] = 1;
	}
	return Action:0;
}

public Action:Cmd_Say(client, args)
{
	if (!client)
	{
		return Action:0;
	}
	decl String:sMessage[64];
	GetCmdArg(1, sMessage, 64);
	new var1;
	if (StrEqual(sMessage, "!mvp", true) || StrEqual(sMessage, "!ff", true) || StrEqual(sMessage, "!stats", true))
	{
		return Action:3;
	}
	return Action:0;
}

public Action:Cmd_StatsDisplayGeneral(client, args)
{
	new iType;
	new String:sArg[24];
	GetCmdArg(0, sArg, 24);
	if (StrEqual(sArg, "sm_mvp", false))
	{
		iType = 1;
	}
	else
	{
		if (StrEqual(sArg, "sm_ff", false))
		{
			iType = 2;
		}
		if (StrEqual(sArg, "sm_skill", false))
		{
			iType = 3;
		}
		if (StrEqual(sArg, "sm_acc", false))
		{
			iType = 4;
		}
		if (StrEqual(sArg, "sm_inf", false))
		{
			iType = 5;
		}
	}
	new bool:bSetRound;
	new bool:bRound = 1;
	new bool:bSetGame;
	new bool:bGame;
	new bool:bSetAll;
	new bool:bAll;
	new bool:bOther;
	new bool:bTank;
	new bool:bMore;
	new bool:bMy;
	new iStart = 1;
	decl otherTeam;
	new var1;
	if (g_iCurTeam)
	{
		var1 = 0;
	}
	else
	{
		var1 = 1;
	}
	otherTeam = var1;
	if (args)
	{
		GetCmdArg(1, sArg, 24);
		new var2;
		if (StrEqual(sArg, "help", false) || StrEqual(sArg, "?", false))
		{
			new var3;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
			{
				PrintToChat(client, "\x01Use: /stats [<type>] [\x05round\x01/\x05game\x01/\x05team\x01/\x05all\x01/\x05other\x01]");
				PrintToChat(client, "\x01 or: /stats [<type>] [\x05r\x01/\x05g\x01/\x05t\x01/\x05a\x01/\x05o\x01]");
				PrintToChat(client, "\x01 where <type> is '\x04mvp\x01', '\x04skill\x01', '\x04ff\x01', '\x04acc\x01' or '\x04inf\x01'. (for more, see console)");
			}
			decl String:bufBasic[4096];
			Format(bufBasic, 4096, "|------------------------------------------------------------------------------|\n");
			Format(bufBasic, 4096, "%s| /stats command help      in chat:    '/stats <type> [argument [argument]]'   |\n", bufBasic);
			Format(bufBasic, 4096, "%s|                          in console: 'sm_stats <type> [arguments...]'        |\n", bufBasic);
			Format(bufBasic, 4096, "%s|------------------------------------------------------------------------------|\n", bufBasic);
			Format(bufBasic, 4096, "%s| stat type:   'general':  general statistics about the game, as in campaign   |\n", bufBasic);
			Format(bufBasic, 4096, "%s|              'mvp'    :  SI damage, common kills    (extra argument: 'tank') |\n", bufBasic);
			Format(bufBasic, 4096, "%s|              'skill'  :  skeets, levels, crowns, tongue cuts, etc            |\n", bufBasic);
			Format(bufBasic, 4096, "%s|              'ff'     :  friendly fire damage (per type of weapon)           |\n", bufBasic);
			Format(bufBasic, 4096, "%s|              'acc'    :  accuracy details           (extra argument: 'more') |\n", bufBasic);
			Format(bufBasic, 4096, "%s|              'inf'    :  special infected stats (dp's, damage done etc)      |", bufBasic);
			new var5;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
			{
				PrintToConsole(client, bufBasic);
			}
			else
			{
				PrintToServer(bufBasic);
			}
			Format(bufBasic, 4096, "|------------------------------------------------------------------------------|\n");
			Format(bufBasic, 4096, "%s| arguments:                                                                   |\n", bufBasic);
			Format(bufBasic, 4096, "%s|------------------------------------------------------------------------------|\n", bufBasic);
			Format(bufBasic, 4096, "%s|   'round' ('r') / 'game' ('g') : for this round; or for entire game so far   |\n", bufBasic);
			Format(bufBasic, 4096, "%s|   'team' ('t') / 'all' ('a')   : current survivor team only; or all players  |\n", bufBasic);
			Format(bufBasic, 4096, "%s|   'other' ('o') / 'my'         : team that is now infected; or your team NMW |\n", bufBasic);
			Format(bufBasic, 4096, "%s|   'tank'          [ MVP only ] : show stats for tank fight                   |\n", bufBasic);
			Format(bufBasic, 4096, "%s|   'more'    [ ACC & MVP only ] : show more stats ( MVP time / SI/tank hits ) |", bufBasic);
			new var7;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
			{
				PrintToConsole(client, bufBasic);
			}
			else
			{
				PrintToServer(bufBasic);
			}
			Format(bufBasic, 4096, "|------------------------------------------------------------------------------|\n");
			Format(bufBasic, 4096, "%s| examples:                                                                    |\n", bufBasic);
			Format(bufBasic, 4096, "%s|------------------------------------------------------------------------------|\n", bufBasic);
			Format(bufBasic, 4096, "%s|   '/stats skill round all' => shows skeets etc for all players, this round   |\n", bufBasic);
			Format(bufBasic, 4096, "%s|   '/stats ff team game'    => shows active team's friendly fire, this round  |\n", bufBasic);
			Format(bufBasic, 4096, "%s|   '/stats acc my'          => shows accuracy stats (your team, this round)   |\n", bufBasic);
			Format(bufBasic, 4096, "%s|   '/stats mvp tank'        => shows survivor action while tank is/was up     |\n", bufBasic);
			Format(bufBasic, 4096, "%s|------------------------------------------------------------------------------|", bufBasic);
			new var9;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
			{
				PrintToConsole(client, bufBasic);
			}
			else
			{
				PrintToServer(bufBasic);
			}
			return Action:3;
		}
		if (StrEqual(sArg, "mvp", false))
		{
			iType = 1;
			iStart++;
		}
		else
		{
			if (StrEqual(sArg, "ff", false))
			{
				iType = 2;
				iStart++;
			}
			new var11;
			if (StrEqual(sArg, "skill", false) || StrEqual(sArg, "special", false) || StrEqual(sArg, "s", false))
			{
				iType = 3;
				iStart++;
			}
			new var12;
			if (StrEqual(sArg, "acc", false) || StrEqual(sArg, "accuracy", false) || StrEqual(sArg, "ac", false))
			{
				iType = 4;
				iStart++;
			}
			new var13;
			if (StrEqual(sArg, "inf", false) || StrEqual(sArg, "i", false))
			{
				iType = 5;
				iStart++;
			}
			new var14;
			if (StrEqual(sArg, "fact", false) || StrEqual(sArg, "fun", false))
			{
				iType = 6;
				iStart++;
			}
			new var15;
			if (StrEqual(sArg, "general", false) || StrEqual(sArg, "gen", false))
			{
				iType = 0;
				iStart++;
			}
		}
		new i = iStart;
		while (i <= args)
		{
			GetCmdArg(i, sArg, 24);
			new var16;
			if (StrEqual(sArg, "round", false) || StrEqual(sArg, "r", false))
			{
				bSetRound = true;
				bRound = true;
			}
			else
			{
				new var17;
				if (StrEqual(sArg, "game", false) || StrEqual(sArg, "g", false))
				{
					bSetGame = true;
					bGame = true;
				}
				new var18;
				if (StrEqual(sArg, "all", false) || StrEqual(sArg, "a", false))
				{
					bSetAll = true;
					bAll = true;
				}
				new var19;
				if (StrEqual(sArg, "team", false) || StrEqual(sArg, "t", false))
				{
					if (bSetAll)
					{
						bSetAll = true;
						bAll = false;
					}
				}
				new var20;
				if (StrEqual(sArg, "other", false) || StrEqual(sArg, "o", false) || StrEqual(sArg, "otherteam", false))
				{
					bOther = true;
				}
				new var21;
				if (StrEqual(sArg, "more", false) || StrEqual(sArg, "m", false))
				{
					bMore = true;
				}
				if (StrEqual(sArg, "tank", false))
				{
					bTank = true;
				}
				if (StrEqual(sArg, "my", false))
				{
					bMy = true;
				}
				new var22;
				if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
				{
					PrintToChat(client, "Stats command: unknown argument: '%s'. Type '/stats help' for possible arguments.", sArg);
				}
				PrintToServer("Stats command: unknown argument: '%s'. Type '/stats help' for possible arguments.", sArg);
			}
			i++;
		}
	}
	decl iTeam;
	new var24;
	if (bOther)
	{
		var24 = otherTeam;
	}
	else
	{
		var24 = -1;
	}
	iTeam = var24;
	if (bMy)
	{
		new index = GetPlayerIndexForClient(client);
		new curteam = -1;
		if (index != -1)
		{
			curteam = g_iPlayerRoundTeam[2][index];
			if (curteam != -1)
			{
				bSetAll = true;
				bAll = false;
				iTeam = curteam;
			}
			iTeam = -1;
		}
	}
	switch (iType)
	{
		case 0:
		{
			new var54;
			if (bSetAll && bAll)
			{
				var55 = false;
			}
			else
			{
				var55 = true;
			}
			new var56;
			if (bSetRound && bRound)
			{
				var57 = true;
			}
			else
			{
				var57 = false;
			}
			DisplayStats(client, var57, -1, var55, iTeam);
		}
		case 1:
		{
			new var45;
			if (bSetAll && bAll)
			{
				var46 = false;
			}
			else
			{
				var46 = true;
			}
			new var47;
			if (bSetGame && bGame)
			{
				var48 = false;
			}
			else
			{
				var48 = true;
			}
			DisplayStatsMVP(client, bTank, bMore, var48, var46, iTeam);
			new var49;
			if (!bTank && !bMore)
			{
				new var50;
				if (bSetAll && bAll)
				{
					var51 = false;
				}
				else
				{
					var51 = true;
				}
				new var52;
				if (bSetGame && bGame)
				{
					var53 = false;
				}
				else
				{
					var53 = true;
				}
				DisplayStatsMVPChat(client, var53, var51, iTeam);
			}
		}
		case 2:
		{
			new var41;
			if (bSetAll && bAll)
			{
				var42 = false;
			}
			else
			{
				var42 = true;
			}
			new var43;
			if (bSetGame && bGame)
			{
				var44 = false;
			}
			else
			{
				var44 = true;
			}
			DisplayStatsFriendlyFire(client, var44, var42, false, iTeam);
		}
		case 3:
		{
			new var37;
			if (bSetAll && bAll)
			{
				var38 = false;
			}
			else
			{
				var38 = true;
			}
			new var39;
			if (bSetGame && bGame)
			{
				var40 = false;
			}
			else
			{
				var40 = true;
			}
			DisplayStatsSpecial(client, var40, var38, false, iTeam);
		}
		case 4:
		{
			new var33;
			if (bSetAll && bAll)
			{
				var34 = false;
			}
			else
			{
				var34 = true;
			}
			new var35;
			if (bSetGame && bGame)
			{
				var36 = false;
			}
			else
			{
				var36 = true;
			}
			DisplayStatsAccuracy(client, bMore, var36, var34, false, iTeam);
		}
		case 5:
		{
			new var29;
			if (bSetAll && bAll)
			{
				var30 = false;
			}
			else
			{
				var30 = true;
			}
			new var31;
			if (bSetGame && bGame)
			{
				var32 = false;
			}
			else
			{
				var32 = true;
			}
			DisplayStatsInfected(client, var32, var30, false, iTeam);
		}
		case 6:
		{
			new var25;
			if (bSetAll && bAll)
			{
				var26 = false;
			}
			else
			{
				var26 = true;
			}
			new var27;
			if (bSetGame && bGame)
			{
				var28 = false;
			}
			else
			{
				var28 = true;
			}
			DisplayStatsFunFactChat(client, var28, var26, iTeam);
		}
		default:
		{
		}
	}
	return Action:3;
}

public Action:Cmd_StatsReset(client, args)
{
	ResetStats(false, -1, false);
	PrintToChatAll("Player statistics reset.");
	return Action:3;
}

public Action:Cmd_Cookie_SetPrintFlags(client, args)
{
	new var1;
	if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
	{
		PrintToServer("This command can only be used by clients. Use the sm_stats_autoprint_* cvars to set server preferences.");
		return Action:3;
	}
	if (args)
	{
		decl String:sArg[24];
		GetCmdArg(1, sArg, 24);
		new iFlags = StringToInt(sArg, 10);
		new var3;
		if (StrEqual(sArg, "?", false) || StrEqual(sArg, "help", false))
		{
			PrintToChat(client, "\x01Use: \x04/stats_auto <flags>\x01. Flags is an integer that is the sum of all printouts to be displayed at round-end.");
			PrintToChat(client, "\x01Set flags to 0 to use server autoprint default; set to -1 to not display anything at all.");
			PrintToChat(client, "\x01See: \x05https://github.com/Tabbernaut/L4D2-Plugins/blob/master/stats/README.md\x01 for a list of flags.");
			return Action:3;
		}
		new var4;
		if (StrEqual(sArg, "test", false) || StrEqual(sArg, "preview", false))
		{
			if (g_iCookieValue[client] < 1)
			{
				PrintToChat(client, "\x01Stats Preview: No flags set. First set flags with \x04/stats_auto <flags>\x01. Type \x04/stats_auto help\x01 for more info.");
				return Action:3;
			}
			AutomaticPrintPerClient(g_iCookieValue[client], client, -1, false, false, false, false);
		}
		else
		{
			if (iFlags >= -1)
			{
				if (iFlags == -1)
				{
					PrintToChat(client, "\x01Stats Pref.: \x04no round end prints at all\x01.");
				}
				else
				{
					if (iFlags)
					{
						new var8 = 0;
						new String:tmpPrint[256] = "";
						new part;
						if (iFlags & 1)
						{
							Format(var8[part], 24, "mvp/chat(round)");
							part++;
						}
						if (iFlags & 2)
						{
							Format(var8[part], 24, "mvp/chat(game)");
							part++;
						}
						if (iFlags & 4)
						{
							Format(var8[part], 24, "mvp(round)");
							part++;
						}
						if (iFlags & 8)
						{
							Format(var8[part], 24, "mvp(game)");
							part++;
						}
						if (iFlags & 32768)
						{
							Format(var8[part], 24, "mvp/more(round)");
							part++;
						}
						if (iFlags & 65536)
						{
							Format(var8[part], 24, "mvp/more(game)");
							part++;
						}
						if (iFlags & 16)
						{
							Format(var8[part], 24, "mvp/tankfight");
							part++;
						}
						if (iFlags & 128)
						{
							Format(var8[part], 24, "skill/special(round)");
							part++;
						}
						if (iFlags & 256)
						{
							Format(var8[part], 24, "skill/special(game)");
							part++;
						}
						if (iFlags & 32)
						{
							Format(var8[part], 24, "ff(round)");
							part++;
						}
						if (iFlags & 64)
						{
							Format(var8[part], 24, "ff(game)");
							part++;
						}
						if (iFlags & 512)
						{
							Format(var8[part], 24, "accuracy(round)");
							part++;
						}
						if (iFlags & 1024)
						{
							Format(var8[part], 24, "accuracy(game)");
							part++;
						}
						if (iFlags & 2048)
						{
							Format(var8[part], 24, "acc/more(round)");
							part++;
						}
						if (iFlags & 4096)
						{
							Format(var8[part], 24, "acc/more(game)");
							part++;
						}
						PrintToChat(client, "\x01Stats Pref.: Flags set for:", var8);
						new tmpCnt;
						new i;
						while (i < part)
						{
							new var5;
							if (tmpCnt)
							{
								var5[0] = 194372;
							}
							else
							{
								var5[0] = 194376;
							}
							Format(tmpPrint, 256, "%s%s%s", tmpPrint, var5, var8[i]);
							tmpCnt++;
							new var6;
							if (tmpCnt >= 6 || part + -1 != i)
							{
								new var7;
								if (i < part + -1)
								{
									var7[0] = 194388;
								}
								else
								{
									var7[0] = 194392;
								}
								PrintToChat(client, "\x04%s%s\x01", tmpPrint, var7);
								tmpCnt = 0;
							}
							i++;
						}
						PrintToChat(client, "\x01Use \x04/stats_auto test\x01 to get a report preview.");
					}
					PrintToChat(client, "\x01Stats Pref.: \x04server default\x01.");
				}
				g_iCookieValue[client] = iFlags;
				if (AreClientCookiesCached(client))
				{
					decl String:sCookieValue[16];
					IntToString(iFlags, sCookieValue, 16);
					SetClientCookie(client, g_hCookiePrint, sCookieValue);
				}
				else
				{
					PrintToChat(client, "Stats Pref.: Error: cookie not cached yet (try again in a bit).");
				}
			}
			PrintToChat(client, "Stats Pref.: invalid value: '%s'. Type '/stats_auto help' for more info.", sArg);
		}
	}
	else
	{
		PrintToChat(client, "\x01Use: \x04/stats_auto <flags>\x01. Type \x04/stats_auto help\x01 for more info.");
	}
	return Action:3;
}

public OnClientCookiesCached(client)
{
	decl String:sCookieValue[16];
	GetClientCookie(client, g_hCookiePrint, sCookieValue, 16);
	g_iCookieValue[client] = StringToInt(sCookieValue, 10);
	return 0;
}

public OnCMTStart(rounds, String:mapname[])
{
	g_bCMTActive = true;
	PrintDebug(2, "CMT start. Rounds: %i. First map: %s", rounds, mapname);
	ResetStats(false, -1, false);
	return 0;
}

public OnCMTEnd()
{
	g_bCMTActive = false;
	PrintDebug(2, "CMT end.");
	HandleGameEnd();
	return 0;
}

public OnCMTTeamSwap()
{
	PrintDebug(2, "CMT TeamSwap.");
	g_bCMTSwapped = !g_bCMTSwapped;
	new iTmp = g_iScores[0];
	g_iScores[0] = g_iScores[1];
	g_iScores[1] = iTmp;
	iTmp = g_iFirstScoresSet[0];
	g_iFirstScoresSet[0] = g_iFirstScoresSet[1];
	g_iFirstScoresSet[1] = iTmp;
	return 0;
}

public Action:Event_PlayerTeam(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_bTeamChanged)
	{
		new newTeam = GetEventInt(event, "team");
		new oldTeam = GetEventInt(event, "oldteam");
		new var1;
		if (newTeam != 2 && oldTeam != 2)
		{
			return Action:0;
		}
		g_bTeamChanged = true;
		CreateTimer(0.5, Timer_TeamChanged, any:0, 2);
	}
	return Action:0;
}

public Action:Timer_TeamChanged(Handle:timer)
{
	g_bTeamChanged = false;
	UpdatePlayerCurrentTeam();
	return Action:0;
}


/* ERROR! null */
 function "Event_PlayerHurt" (number 52)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_InfectedHurt" (number 53)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_PlayerFallDamage" (number 54)
public Action:Event_WitchKilled(Handle:event, String:name[], bool:dontBroadcast)
{
	g_strRoundData[g_iRound][g_iCurTeam][8]++;
	return Action:0;
}


/* ERROR! null */
 function "Event_PlayerDeath" (number 56)
public Action:Timer_CheckTankDeath(Handle:hTimer, any:client_oldTank)
{
	if (!IsTankInGame())
	{
		g_strRoundData[g_iRound][g_iCurTeam][9]++;
		g_bTankInGame = false;
		if (g_bInRound)
		{
			HandleTankTimeEnd();
		}
	}
	return Action:0;
}

HandleTankTimeEnd()
{
	g_strRoundData[g_iRound][g_iCurTeam][18] = GetTime({0,0});
	return 0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_TankSpawned" (number 59)

/* ERROR! null */
 function "Event_PlayerIncapped" (number 60)

/* ERROR! null */
 function "Event_PlayerRevived" (number 61)
public Action:Event_SurvivorRescue(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new index = GetPlayerIndexForClient(client);
	if (index == -1)
	{
		return Action:0;
	}
	new time = GetTime({0,0});
	new var1;
	if (g_strRoundPlayerData[index][g_iCurTeam][74] && g_strRoundPlayerData[index][g_iCurTeam][73])
	{
		new var3 = g_strRoundPlayerData[index][g_iCurTeam][73];
		var3 = var3[time - g_strRoundPlayerData[index][g_iCurTeam][74]];
		g_strRoundPlayerData[index][g_iCurTeam][74] = 0;
	}
	new var2;
	if (g_strRoundPlayerData[index][g_iCurTeam][76] && g_strRoundPlayerData[index][g_iCurTeam][75])
	{
		new var4 = g_strRoundPlayerData[index][g_iCurTeam][75];
		var4 = var4[time - g_strRoundPlayerData[index][g_iCurTeam][76]];
		g_strRoundPlayerData[index][g_iCurTeam][76] = 0;
	}
	return Action:0;
}


/* ERROR! null */
 function "Event_PlayerLedged" (number 63)

/* ERROR! null */
 function "Event_PlayerLedgeRelease" (number 64)

/* ERROR! null */
 function "Event_DefibUsed" (number 65)
public Action:Event_HealSuccess(Handle:event, String:name[], bool:dontBroadcast)
{
	g_strRoundData[g_iRound][g_iCurTeam][2]++;
	return Action:0;
}

public Action:Event_PillsUsed(Handle:event, String:name[], bool:dontBroadcast)
{
	g_strRoundData[g_iRound][g_iCurTeam][1]++;
	return Action:0;
}

public Action:Event_AdrenUsed(Handle:event, String:name[], bool:dontBroadcast)
{
	g_strRoundData[g_iRound][g_iCurTeam][1]++;
	return Action:0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_WeaponFire" (number 69)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_PlayerSpawn" (number 70)

/* ERROR! null */
 function "Event_PlayerBoomed" (number 71)
public Action:Event_PlayerUnboomed(Handle:event, String:name[], bool:dontBroadcast)
{
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	g_iBoomedBy[victim] = 0;
	return Action:0;
}

public OnSpecialShoved(attacker, victim, zombieClass)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][38]++;
	return 0;
}

public OnHunterDeadstop(attacker, victim)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][39]++;
	return 0;
}

public OnSkeet(attacker, victim)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][30]++;
	return 0;
}

public OnSkeetGL(attacker, victim)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][30]++;
	return 0;
}

public OnSkeetHurt(attacker, victim, damage)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][31]++;
	return 0;
}

public OnSkeetMelee(attacker, victim)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][32]++;
	return 0;
}

public OnSkeetMeleeHurt(attacker, victim, damage)
{
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][31]++;
	return 0;
}

public OnSkeetSniper(attacker, victim)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][30]++;
	return 0;
}

public OnSkeetSniperHurt(attacker, victim, damage)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][31]++;
	return 0;
}

public OnBoomerPop(attacker, victim, shoveCount, Float:timeAlive)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][35]++;
	return 0;
}

public OnChargerLevel(attacker, victim)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][33]++;
	return 0;
}

public OnChargerLevelHurt(attacker, victim, damage)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][34]++;
	return 0;
}

public OnTongueCut(attacker, victim)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][40]++;
	return 0;
}

public OnSmokerSelfClear(attacker, victim, withShove)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][41]++;
	return 0;
}

public OnWitchCrown(attacker, damage)
{
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][36]++;
	return 0;
}

public OnWitchDrawCrown(attacker, damage, chipdamage)
{
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][37]++;
	return 0;
}

public OnTankRockEaten(attacker, victim)
{
	if (!g_bPlayersLeftStart)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(victim);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][51]++;
	return 0;
}

public OnTankRockSkeeted(attacker, victim)
{
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][50]++;
	return 0;
}

public OnHunterHighPounce(attacker, victim, actualDamage, Float:damage, Float:height, bool:bReportedHigh)
{
	if (!bReportedHigh)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerInfData[index][g_iCurTeam][8]++;
	new var1 = g_strRoundPlayerInfData[index][g_iCurTeam][9];
	var1 = var1[RoundToFloor(damage)];
	return 0;
}

public OnJockeyHighPounce(attacker, victim, Float:height, bool:bReportedHigh)
{
	if (!bReportedHigh)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerInfData[index][g_iCurTeam][10]++;
	return 0;
}

public OnDeathCharge(attacker, victim, Float:height, Float:distance, bool:bCarried)
{
	new index = GetPlayerIndexForClient(attacker);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerInfData[index][g_iCurTeam][11]++;
	return 0;
}

public OnSpecialClear(clearer, pinner, pinvictim, zombieClass, Float:timeA, Float:timeB, bool:withShove)
{
	new Float:fClearTime = timeA;
	new var1;
	if (zombieClass == 6 || zombieClass == 1)
	{
		fClearTime = timeB;
	}
	new var2;
	if (fClearTime < 0.0 || 0.0 == fClearTime || fClearTime > 60.0 || pinvictim != clearer)
	{
		return 0;
	}
	new index = GetPlayerIndexForClient(clearer);
	if (index == -1)
	{
		return 0;
	}
	g_strRoundPlayerData[index][g_iCurTeam][70] = RoundFloat(float(g_strRoundPlayerData[index][g_iCurTeam][69] * g_strRoundPlayerData[index][g_iCurTeam][70]) + fClearTime * 1000.0 / float(g_strRoundPlayerData[index][g_iCurTeam][69][0]));
	g_strRoundPlayerData[index][g_iCurTeam][69]++;
	return 0;
}

public Action:Timer_ResetStats(Handle:timer, any:roundOnly)
{
	ResetStats(roundOnly, -1, false);
	return Action:0;
}

ResetStats(bool:bCurrentRoundOnly, iTeam, bool:bFailedRound)
{
	new i;
	new j;
	new k;
	new var1;
	if (bCurrentRoundOnly)
	{
		var1 = 195264;
	}
	else
	{
		var1 = 195276;
	}
	PrintDebug(1, "Resetting stats [round %i]. (for: %s; for team: %i)", g_iRound, var1, iTeam);
	if (!bCurrentRoundOnly)
	{
		DisplayStats(-1, false, -1, true, -1);
		g_iRound = 0;
		g_bGameStarted = false;
		g_strGameData[0] = 0;
		i = 0;
		while (i < 48)
		{
			j = 0;
			while (j < 2)
			{
				k = 0;
				while (k <= 18)
				{
					g_strRoundData[i][j][k] = 0;
					k++;
				}
				j++;
			}
			i++;
		}
		j = 0;
		while (j < 2)
		{
			k = 0;
			while (k <= 18)
			{
				g_strAllRoundData[j][k] = 0;
				k++;
			}
			j++;
		}
		i = 0;
		while (i < 64)
		{
			j = 0;
			while (j <= 76)
			{
				g_strPlayerData[i][j] = 0;
				j++;
			}
			j = 0;
			while (j <= 24)
			{
				g_strPlayerInfData[i][j] = 0;
				j++;
			}
			j = 0;
			while (j < 2)
			{
				g_iPlayerGameTeam[j][i] = -1;
				j++;
			}
			i++;
		}
		j = 0;
		while (j < 2)
		{
			g_iScores[j] = 0;
			j++;
		}
	}
	else
	{
		if (iTeam == -1)
		{
			k = 0;
			while (k <= 18)
			{
				new var2;
				if (bFailedRound && k)
				{
				}
				else
				{
					g_strRoundData[g_iRound][0][k] = 0;
					g_strRoundData[g_iRound][1][k] = 0;
				}
				k++;
			}
		}
		k = 0;
		while (k <= 18)
		{
			new var3;
			if (bFailedRound && k)
			{
			}
			else
			{
				g_strRoundData[g_iRound][iTeam][k] = 0;
			}
			k++;
		}
	}
	if (iTeam == -1)
	{
		i = 0;
		while (i < 64)
		{
			j = 0;
			while (j < 2)
			{
				k = 0;
				while (k <= 76)
				{
					g_strRoundPlayerData[i][j][k] = 0;
					k++;
				}
				k = 0;
				while (k <= 76)
				{
					g_strRoundPlayerInfData[i][j][k] = 0;
					k++;
				}
				j++;
			}
			i++;
		}
	}
	else
	{
		i = 0;
		while (i < 64)
		{
			k = 0;
			while (k <= 76)
			{
				g_strRoundPlayerData[i][iTeam][k] = 0;
				k++;
			}
			k = 0;
			while (k <= 24)
			{
				g_strRoundPlayerInfData[i][iTeam][k] = 0;
				k++;
			}
			i++;
		}
	}
	return 0;
}


/* ERROR! null */
 function "UpdatePlayerCurrentTeam" (number 97)
ClearPlayerTeam(iTeam)
{
	new i;
	new j;
	if (iTeam == -1)
	{
		j = 0;
		while (j < 3)
		{
			i = 0;
			while (i < 64)
			{
				g_iPlayerRoundTeam[j][i] = -1;
				i++;
			}
			j++;
		}
	}
	else
	{
		i = 0;
		while (i < 64)
		{
			g_iPlayerRoundTeam[iTeam][i] = -1;
			i++;
		}
	}
	return 0;
}


/* ERROR! null */
 function "SetStartSurvivorTime" (number 99)

/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "DisplayStats" (number 100)
DisplayStatsMVPChat(client, bool:bRound, bool:bTeam, iTeam)
{
	new var59;
	new var60;
	new var61 = 0;
	new i;
	new j;
	new x;
	GetMVPChatString(bRound, bTeam, iTeam);
	if (client == -1)
	{
		PrintToServer("\x01%s", var59);
	}
	new intPieces = ExplodeString(var59, "\n", var61, 8, 192, false);
	if (0 < client)
	{
		i = 0;
		while (i < intPieces)
		{
			PrintToChat(client, "\x01%s", var61[i]);
			i++;
		}
	}
	else
	{
		if (client)
		{
			j = 1;
			while (j <= MaxClients)
			{
				i = 0;
				while (i < intPieces)
				{
					new var1;
					if ((j > 0 && j <= MaxClients) && IsClientInGame(j) && g_iCookieValue[j])
					{
					}
				}
				j++;
			}
		}
		i = 0;
		while (i < intPieces)
		{
			PrintToServer("\x01%s", var61[i]);
			i++;
		}
	}
	new iBrevityFlags = GetConVarInt(g_hCvarMVPBrevityFlags);
	new team = g_iCurTeam;
	if (iTeam != -1)
	{
		team = iTeam;
	}
	else
	{
		new var4;
		if (g_bSecondHalf && !g_bPlayersLeftStart)
		{
			new var5;
			if (team)
			{
				var5 = 0;
			}
			else
			{
				var5 = 1;
			}
			team = var5;
		}
	}
	new index = -1;
	new found = -1;
	new listNumber;
	new var6;
	if (((bRound && g_strRoundData[g_iRound][team][6] > 0) || (!bRound && g_strAllRoundData[team][6] > 0)) && (!iBrevityFlags & 8 && !iBrevityFlags & 1))
	{
		i = 1;
		while (i < g_iTeamSize && i < g_iPlayers)
		{
			new var62 = g_iPlayerIndexSorted;
			index = var62[0][var62][i];
			if (!(index == -1))
			{
				found = -1;
				x = 1;
				while (x <= MaxClients)
				{
					new var11;
					if ((x > 0 && x <= MaxClients) && IsClientInGame(x))
					{
						if (GetPlayerIndexForClient(x) == index)
						{
							found = x;
							if (!(found == -1))
							{
								new var13;
								if (!(bRound && bTeam && team != g_iPlayerRoundTeam[team][i]))
								{
									new var16;
									if (listNumber && (client == -1 || found != client) && (found > 0 && found <= MaxClients) && !IsFakeClient(found) && g_iCookieValue[found] != -1)
									{
										if (iBrevityFlags & 32)
										{
											new var17;
											if (bRound)
											{
												var17 = g_strRoundPlayerData[index][team][24];
											}
											else
											{
												var17 = g_strPlayerData[index][24];
											}
											new var18;
											if (bRound)
											{
												var18 = g_strRoundPlayerData[index][team][26];
											}
											else
											{
												var18 = g_strPlayerData[index][26];
											}
											new var19;
											if (bRound)
											{
												var19[0] = 196720;
											}
											else
											{
												var19[0] = 196724;
											}
											Format(var60, 512, "[MVP%s] Your rank - SI: #\x03%d \x01(\x05%d \x01dmg,\x05 %d \x01kills)", var19, i + 1, var18, var17);
										}
										else
										{
											if (iBrevityFlags & 64)
											{
												new var20;
												if (bRound)
												{
													var20 = float(g_strRoundPlayerData[index][team][24]) / float(g_strRoundData[g_iRound][team][5]) * 100;
												}
												else
												{
													var20 = float(g_strPlayerData[index][24]) / float(g_strAllRoundData[team][5]) * 100;
												}
												new var21;
												if (bRound)
												{
													var21 = float(g_strRoundPlayerData[index][team][26]) / float(g_strRoundData[g_iRound][team][6]) * 100;
												}
												else
												{
													var21 = float(g_strPlayerData[index][26]) / float(g_strAllRoundData[team][6]) * 100;
												}
												new var22;
												if (bRound)
												{
													var22[0] = 196792;
												}
												else
												{
													var22[0] = 196796;
												}
												Format(var60, 512, "[MVP%s] Your rank - SI: #\x03%d \x01(dmg \x04%i%%\x01, kills \x04%i%%\x01)", var22, i + 1, RoundFloat(var21), RoundFloat(var20));
											}
											new var23;
											if (bRound)
											{
												var23 = float(g_strRoundPlayerData[index][team][24]) / float(g_strRoundData[g_iRound][team][5]) * 100;
											}
											else
											{
												var23 = float(g_strPlayerData[index][24]) / float(g_strAllRoundData[team][5]) * 100;
											}
											new var24;
											if (bRound)
											{
												var24 = g_strRoundPlayerData[index][team][24];
											}
											else
											{
												var24 = g_strPlayerData[index][24];
											}
											new var25;
											if (bRound)
											{
												var25 = float(g_strRoundPlayerData[index][team][26]) / float(g_strRoundData[g_iRound][team][6]) * 100;
											}
											else
											{
												var25 = float(g_strPlayerData[index][26]) / float(g_strAllRoundData[team][6]) * 100;
											}
											new var26;
											if (bRound)
											{
												var26 = g_strRoundPlayerData[index][team][26];
											}
											else
											{
												var26 = g_strPlayerData[index][26];
											}
											new var27;
											if (bRound)
											{
												var27[0] = 196876;
											}
											else
											{
												var27[0] = 196880;
											}
											Format(var60, 512, "[MVP%s] Your rank - SI: #\x03%d \x01(\x05%d \x01dmg [\x04%i%%\x01],\x05 %d \x01kills [\x04%i%%\x01])", var27, i + 1, var26, RoundFloat(var25), var24, RoundFloat(var23));
										}
										PrintToChat(found, "\x01%s", var60);
									}
									listNumber++;
								}
							}
							i++;
						}
					}
					x++;
				}
				if (!(found == -1))
				{
					new var13;
					if (!(bRound && bTeam && team != g_iPlayerRoundTeam[team][i]))
					{
						new var16;
						if (listNumber && (client == -1 || found != client) && (found > 0 && found <= MaxClients) && !IsFakeClient(found) && g_iCookieValue[found] != -1)
						{
							if (iBrevityFlags & 32)
							{
								new var17;
								if (bRound)
								{
									var17 = g_strRoundPlayerData[index][team][24];
								}
								else
								{
									var17 = g_strPlayerData[index][24];
								}
								new var18;
								if (bRound)
								{
									var18 = g_strRoundPlayerData[index][team][26];
								}
								else
								{
									var18 = g_strPlayerData[index][26];
								}
								new var19;
								if (bRound)
								{
									var19[0] = 196720;
								}
								else
								{
									var19[0] = 196724;
								}
								Format(var60, 512, "[MVP%s] Your rank - SI: #\x03%d \x01(\x05%d \x01dmg,\x05 %d \x01kills)", var19, i + 1, var18, var17);
							}
							else
							{
								if (iBrevityFlags & 64)
								{
									new var20;
									if (bRound)
									{
										var20 = float(g_strRoundPlayerData[index][team][24]) / float(g_strRoundData[g_iRound][team][5]) * 100;
									}
									else
									{
										var20 = float(g_strPlayerData[index][24]) / float(g_strAllRoundData[team][5]) * 100;
									}
									new var21;
									if (bRound)
									{
										var21 = float(g_strRoundPlayerData[index][team][26]) / float(g_strRoundData[g_iRound][team][6]) * 100;
									}
									else
									{
										var21 = float(g_strPlayerData[index][26]) / float(g_strAllRoundData[team][6]) * 100;
									}
									new var22;
									if (bRound)
									{
										var22[0] = 196792;
									}
									else
									{
										var22[0] = 196796;
									}
									Format(var60, 512, "[MVP%s] Your rank - SI: #\x03%d \x01(dmg \x04%i%%\x01, kills \x04%i%%\x01)", var22, i + 1, RoundFloat(var21), RoundFloat(var20));
								}
								new var23;
								if (bRound)
								{
									var23 = float(g_strRoundPlayerData[index][team][24]) / float(g_strRoundData[g_iRound][team][5]) * 100;
								}
								else
								{
									var23 = float(g_strPlayerData[index][24]) / float(g_strAllRoundData[team][5]) * 100;
								}
								new var24;
								if (bRound)
								{
									var24 = g_strRoundPlayerData[index][team][24];
								}
								else
								{
									var24 = g_strPlayerData[index][24];
								}
								new var25;
								if (bRound)
								{
									var25 = float(g_strRoundPlayerData[index][team][26]) / float(g_strRoundData[g_iRound][team][6]) * 100;
								}
								else
								{
									var25 = float(g_strPlayerData[index][26]) / float(g_strAllRoundData[team][6]) * 100;
								}
								new var26;
								if (bRound)
								{
									var26 = g_strRoundPlayerData[index][team][26];
								}
								else
								{
									var26 = g_strPlayerData[index][26];
								}
								new var27;
								if (bRound)
								{
									var27[0] = 196876;
								}
								else
								{
									var27[0] = 196880;
								}
								Format(var60, 512, "[MVP%s] Your rank - SI: #\x03%d \x01(\x05%d \x01dmg [\x04%i%%\x01],\x05 %d \x01kills [\x04%i%%\x01])", var27, i + 1, var26, RoundFloat(var25), var24, RoundFloat(var23));
							}
							PrintToChat(found, "\x01%s", var60);
						}
						listNumber++;
					}
				}
				i++;
			}
		}
	}
	listNumber = 0;
	new var28;
	if (((bRound && g_strRoundData[g_iRound][team][4]) || (!bRound && g_strAllRoundData[team][4])) && (!iBrevityFlags & 8 && !iBrevityFlags & 2))
	{
		i = 1;
		while (i < g_iTeamSize && i < g_iPlayers)
		{
			index = g_iPlayerIndexSorted[1][i];
			if (!(index == -1))
			{
				found = -1;
				x = 1;
				while (x <= 65)
				{
					new var33;
					if ((x > 0 && x <= MaxClients) && IsClientInGame(x))
					{
						if (GetPlayerIndexForClient(x) == index)
						{
							found = x;
							if (!(found == -1))
							{
								new var35;
								if (!(bRound && bTeam && team != g_iPlayerRoundTeam[team][i]))
								{
									new var38;
									if (listNumber && (client == -1 || found != client) && (found > 0 && found <= MaxClients) && !IsFakeClient(found) && g_iCookieValue[found] != -1)
									{
										if (iBrevityFlags & 32)
										{
											new var39;
											if (bRound)
											{
												var39 = g_strRoundPlayerData[index][team][22];
											}
											else
											{
												var39 = g_strPlayerData[index][22];
											}
											new var40;
											if (bRound)
											{
												var40[0] = 196936;
											}
											else
											{
												var40[0] = 196940;
											}
											Format(var60, 512, "[MVP%s] Your rank - CI: #\x03%d \x01(\x05 %d \x01kills)", var40, i + 1, var39);
										}
										else
										{
											if (iBrevityFlags & 64)
											{
												new var41;
												if (bRound)
												{
													var41 = float(g_strRoundPlayerData[index][team][22]) / float(g_strRoundData[g_iRound][team][4]) * 100;
												}
												else
												{
													var41 = float(g_strPlayerData[index][22]) / float(g_strAllRoundData[team][4]) * 100;
												}
												new var42;
												if (bRound)
												{
													var42[0] = 196996;
												}
												else
												{
													var42[0] = 197000;
												}
												Format(var60, 512, "[MVP%s] Your rank - CI: #\x03%d \x01(kills \x04%i%%\x01)", var42, i + 1, RoundFloat(var41));
											}
											new var43;
											if (bRound)
											{
												var43 = float(g_strRoundPlayerData[index][team][22]) / float(g_strRoundData[g_iRound][team][4]) * 100;
											}
											else
											{
												var43 = float(g_strPlayerData[index][22]) / float(g_strAllRoundData[team][4]) * 100;
											}
											new var44;
											if (bRound)
											{
												var44 = g_strRoundPlayerData[index][team][22];
											}
											else
											{
												var44 = g_strPlayerData[index][22];
											}
											new var45;
											if (bRound)
											{
												var45[0] = 197064;
											}
											else
											{
												var45[0] = 197068;
											}
											Format(var60, 512, "[MVP%s] Your rank - CI: #\x03%d \x01(\x05 %d \x01kills [\x04%i%%\x01])", var45, i + 1, var44, RoundFloat(var43));
										}
										PrintToChat(found, "\x01%s", var60);
									}
									listNumber++;
								}
							}
							i++;
						}
					}
					x++;
				}
				if (!(found == -1))
				{
					new var35;
					if (!(bRound && bTeam && team != g_iPlayerRoundTeam[team][i]))
					{
						new var38;
						if (listNumber && (client == -1 || found != client) && (found > 0 && found <= MaxClients) && !IsFakeClient(found) && g_iCookieValue[found] != -1)
						{
							if (iBrevityFlags & 32)
							{
								new var39;
								if (bRound)
								{
									var39 = g_strRoundPlayerData[index][team][22];
								}
								else
								{
									var39 = g_strPlayerData[index][22];
								}
								new var40;
								if (bRound)
								{
									var40[0] = 196936;
								}
								else
								{
									var40[0] = 196940;
								}
								Format(var60, 512, "[MVP%s] Your rank - CI: #\x03%d \x01(\x05 %d \x01kills)", var40, i + 1, var39);
							}
							else
							{
								if (iBrevityFlags & 64)
								{
									new var41;
									if (bRound)
									{
										var41 = float(g_strRoundPlayerData[index][team][22]) / float(g_strRoundData[g_iRound][team][4]) * 100;
									}
									else
									{
										var41 = float(g_strPlayerData[index][22]) / float(g_strAllRoundData[team][4]) * 100;
									}
									new var42;
									if (bRound)
									{
										var42[0] = 196996;
									}
									else
									{
										var42[0] = 197000;
									}
									Format(var60, 512, "[MVP%s] Your rank - CI: #\x03%d \x01(kills \x04%i%%\x01)", var42, i + 1, RoundFloat(var41));
								}
								new var43;
								if (bRound)
								{
									var43 = float(g_strRoundPlayerData[index][team][22]) / float(g_strRoundData[g_iRound][team][4]) * 100;
								}
								else
								{
									var43 = float(g_strPlayerData[index][22]) / float(g_strAllRoundData[team][4]) * 100;
								}
								new var44;
								if (bRound)
								{
									var44 = g_strRoundPlayerData[index][team][22];
								}
								else
								{
									var44 = g_strPlayerData[index][22];
								}
								new var45;
								if (bRound)
								{
									var45[0] = 197064;
								}
								else
								{
									var45[0] = 197068;
								}
								Format(var60, 512, "[MVP%s] Your rank - CI: #\x03%d \x01(\x05 %d \x01kills [\x04%i%%\x01])", var45, i + 1, var44, RoundFloat(var43));
							}
							PrintToChat(found, "\x01%s", var60);
						}
						listNumber++;
					}
				}
				i++;
			}
		}
	}
	listNumber = 0;
	new var46;
	if (!iBrevityFlags & 8 && !iBrevityFlags & 4)
	{
		i = 1;
		while (i < g_iTeamSize && i < g_iPlayers)
		{
			index = g_iPlayerIndexSorted[2][i];
			if (!(index == -1))
			{
				found = -1;
				x = 1;
				while (x <= MaxClients)
				{
					new var48;
					if ((x > 0 && x <= MaxClients) && IsClientInGame(x))
					{
						if (GetPlayerIndexForClient(x) == index)
						{
							found = x;
							if (!(found == -1))
							{
								new var50;
								if (!(bRound && bTeam && team != g_iPlayerRoundTeam[team][i]))
								{
									new var51;
									if (!((bRound && !g_strRoundPlayerData[index][team][44]) || (!bRound && !g_strPlayerData[index][44])))
									{
										new var56;
										if (listNumber && (client == -1 || found != client) && (found > 0 && found <= MaxClients) && !IsFakeClient(found) && g_iCookieValue[found] != -1)
										{
											new var57;
											if (bRound)
											{
												var57 = g_strRoundPlayerData[index][team][44];
											}
											else
											{
												var57 = g_strPlayerData[index][44];
											}
											new var58;
											if (bRound)
											{
												var58[0] = 197124;
											}
											else
											{
												var58[0] = 197128;
											}
											Format(var60, 512, "[LVP%s] Your rank - FF: #\x03%d \x01(\x05%d \x01dmg)", var58, i + 1, var57);
											PrintToChat(found, "\x01%s", var60);
										}
										listNumber++;
									}
								}
							}
							i++;
						}
					}
					x++;
				}
				if (!(found == -1))
				{
					new var50;
					if (!(bRound && bTeam && team != g_iPlayerRoundTeam[team][i]))
					{
						new var51;
						if (!((bRound && !g_strRoundPlayerData[index][team][44]) || (!bRound && !g_strPlayerData[index][44])))
						{
							new var56;
							if (listNumber && (client == -1 || found != client) && (found > 0 && found <= MaxClients) && !IsFakeClient(found) && g_iCookieValue[found] != -1)
							{
								new var57;
								if (bRound)
								{
									var57 = g_strRoundPlayerData[index][team][44];
								}
								else
								{
									var57 = g_strPlayerData[index][44];
								}
								new var58;
								if (bRound)
								{
									var58[0] = 197124;
								}
								else
								{
									var58[0] = 197128;
								}
								Format(var60, 512, "[LVP%s] Your rank - FF: #\x03%d \x01(\x05%d \x01dmg)", var58, i + 1, var57);
								PrintToChat(found, "\x01%s", var60);
							}
							listNumber++;
						}
					}
				}
				i++;
			}
		}
	}
	return 0;
}

String:GetMVPChatString(bool:bRound, bool:bTeam, iTeam, _arg3)
{
	new String:printBuffer[1024] = "";
	decl String:tmpBuffer[512];
	SortPlayersMVP(bRound, 0, bTeam, iTeam);
	SortPlayersMVP(bRound, 1, bTeam, iTeam);
	SortPlayersMVP(bRound, 2, bTeam, iTeam);
	decl team;
	new var3;
	if (iTeam != -1)
	{
		var3 = iTeam;
	}
	else
	{
		new var1;
		if (g_bSecondHalf && !g_bPlayersLeftStart)
		{
			new var2;
			if (g_iCurTeam)
			{
				var2 = 0;
			}
			else
			{
				var2 = 1;
			}
			var3 = var2;
		}
		var3 = g_iCurTeam;
	}
	team = var3;
	decl mvp_SI;
	new var43 = g_iPlayerIndexSorted;
	mvp_SI = var43[0][var43];
	new mvp_Common = g_iPlayerIndexSorted[1];
	new mvp_FF = g_iPlayerIndexSorted[2];
	new var4;
	if (bTeam && !bRound)
	{
		new i;
		while (i < g_iPlayers)
		{
			if (team == g_iPlayerRoundTeam[team][i])
			{
				new var44 = i;
				mvp_FF = var44;
				mvp_Common = var44;
				mvp_SI = var44;
			}
			i++;
		}
	}
	new iBrevityFlags = GetConVarInt(g_hCvarMVPBrevityFlags);
	new var7;
	if (g_iPlayers < 1 || (bRound && !g_strRoundPlayerData[mvp_SI][team][26]) || (!bRound && !g_strPlayerData[mvp_SI][26]))
	{
		mvp_SI = -1;
	}
	new var10;
	if (g_iPlayers < 1 || (bRound && !g_strRoundPlayerData[mvp_Common][team][22]) || (!bRound && !g_strPlayerData[mvp_Common][22]))
	{
		mvp_Common = -1;
	}
	new var13;
	if (g_iPlayers < 1 || (bRound && !g_strRoundPlayerData[mvp_FF][team][44]) || (!bRound && !g_strPlayerData[mvp_FF][44]))
	{
		mvp_FF = -1;
	}
	new var15;
	if (mvp_SI == -1 && mvp_Common == -1 && (iBrevityFlags & 1 && iBrevityFlags & 2))
	{
		new var16;
		if (bRound)
		{
			var16[0] = 197180;
		}
		else
		{
			var16[0] = 197184;
		}
		Format(tmpBuffer, 512, "[MVP%s]: (not enough action yet)\n", var16);
		StrCat(printBuffer, 1024, tmpBuffer);
	}
	else
	{
		if (!iBrevityFlags & 1)
		{
			if (mvp_SI > -1)
			{
				if (iBrevityFlags & 32)
				{
					new var17;
					if (bRound)
					{
						var17 = g_strRoundPlayerData[mvp_SI][team][24];
					}
					else
					{
						var17 = g_strPlayerData[mvp_SI][24];
					}
					new var18;
					if (bRound)
					{
						var18 = g_strRoundPlayerData[mvp_SI][team][26];
					}
					else
					{
						var18 = g_strPlayerData[mvp_SI][26];
					}
					new var19;
					if (bRound)
					{
						var19[0] = 197236;
					}
					else
					{
						var19[0] = 197240;
					}
					Format(tmpBuffer, 512, "[MVP%s] SI:\x03 %s \x01(\x05%d \x01dmg,\x05 %d \x01kills)\n", var19, g_sPlayerName[mvp_SI], var18, var17);
				}
				else
				{
					if (iBrevityFlags & 64)
					{
						new var20;
						if (bRound)
						{
							var20 = float(g_strRoundPlayerData[mvp_SI][team][24]) / float(g_strRoundData[g_iRound][team][5]) * 100;
						}
						else
						{
							var20 = float(g_strPlayerData[mvp_SI][24]) / float(g_strAllRoundData[team][5]) * 100;
						}
						new var21;
						if (bRound)
						{
							var21 = float(g_strRoundPlayerData[mvp_SI][team][26]) / float(g_strRoundData[g_iRound][team][6]) * 100;
						}
						else
						{
							var21 = float(g_strPlayerData[mvp_SI][26]) / float(g_strAllRoundData[team][6]) * 100;
						}
						new var22;
						if (bRound)
						{
							var22[0] = 197296;
						}
						else
						{
							var22[0] = 197300;
						}
						Format(tmpBuffer, 512, "[MVP%s] SI:\x03 %s \x01(dmg \x04%i%%\x01, kills \x04%i%%\x01)\n", var22, g_sPlayerName[mvp_SI], RoundFloat(var21), RoundFloat(var20));
					}
					new var23;
					if (bRound)
					{
						var23 = float(g_strRoundPlayerData[mvp_SI][team][24]) / float(g_strRoundData[g_iRound][team][5]) * 100;
					}
					else
					{
						var23 = float(g_strPlayerData[mvp_SI][24]) / float(g_strAllRoundData[team][5]) * 100;
					}
					new var24;
					if (bRound)
					{
						var24 = g_strRoundPlayerData[mvp_SI][team][24];
					}
					else
					{
						var24 = g_strPlayerData[mvp_SI][24];
					}
					new var25;
					if (bRound)
					{
						var25 = float(g_strRoundPlayerData[mvp_SI][team][26]) / float(g_strRoundData[g_iRound][team][6]) * 100;
					}
					else
					{
						var25 = float(g_strPlayerData[mvp_SI][26]) / float(g_strAllRoundData[team][6]) * 100;
					}
					new var26;
					if (bRound)
					{
						var26 = g_strRoundPlayerData[mvp_SI][team][26];
					}
					else
					{
						var26 = g_strPlayerData[mvp_SI][26];
					}
					new var27;
					if (bRound)
					{
						var27[0] = 197368;
					}
					else
					{
						var27[0] = 197372;
					}
					Format(tmpBuffer, 512, "[MVP%s] SI:\x03 %s \x01(\x05%d \x01dmg[\x04%i%%\x01],\x05 %d \x01kills [\x04%i%%\x01])\n", var27, g_sPlayerName[mvp_SI], var26, RoundFloat(var25), var24, RoundFloat(var23));
				}
				StrCat(printBuffer, 1024, tmpBuffer);
			}
			new var28;
			if (bRound)
			{
				var28[0] = 197404;
			}
			else
			{
				var28[0] = 197408;
			}
			Format(tmpBuffer, 512, "[MVP%s] SI: \x03(nobody)\x01\n", var28);
			StrCat(printBuffer, 1024, tmpBuffer);
		}
		if (!iBrevityFlags & 2)
		{
			new var32;
			if (mvp_Common > -1 && ((bRound && g_strRoundData[g_iRound][team][4]) || (!bRound && g_strAllRoundData[team][4])))
			{
				if (iBrevityFlags & 32)
				{
					new var33;
					if (bRound)
					{
						var33 = g_strRoundPlayerData[mvp_Common][team][22];
					}
					else
					{
						var33 = g_strPlayerData[mvp_Common][22];
					}
					new var34;
					if (bRound)
					{
						var34[0] = 197448;
					}
					else
					{
						var34[0] = 197452;
					}
					Format(tmpBuffer, 512, "[MVP%s] CI:\x03 %s \x01(\x05%d \x01common)\n", var34, g_sPlayerName[mvp_Common], var33);
				}
				else
				{
					if (iBrevityFlags & 64)
					{
						new var35;
						if (bRound)
						{
							var35 = float(g_strRoundPlayerData[mvp_Common][team][22]) / float(g_strRoundData[g_iRound][team][4]) * 100;
						}
						else
						{
							var35 = float(g_strPlayerData[mvp_Common][22]) / float(g_strAllRoundData[team][4]) * 100;
						}
						new var36;
						if (bRound)
						{
							var36[0] = 197488;
						}
						else
						{
							var36[0] = 197492;
						}
						Format(tmpBuffer, 512, "[MVP%s] CI:\x03 %s \x01(\x04%i%%\x01)\n", var36, g_sPlayerName[mvp_Common], RoundFloat(var35));
					}
					new var37;
					if (bRound)
					{
						var37 = float(g_strRoundPlayerData[mvp_Common][team][22]) / float(g_strRoundData[g_iRound][team][4]) * 100;
					}
					else
					{
						var37 = float(g_strPlayerData[mvp_Common][22]) / float(g_strAllRoundData[team][4]) * 100;
					}
					new var38;
					if (bRound)
					{
						var38 = g_strRoundPlayerData[mvp_Common][team][22];
					}
					else
					{
						var38 = g_strPlayerData[mvp_Common][22];
					}
					new var39;
					if (bRound)
					{
						var39[0] = 197544;
					}
					else
					{
						var39[0] = 197548;
					}
					Format(tmpBuffer, 512, "[MVP%s] CI:\x03 %s \x01(\x05%d \x01common [\x04%i%%\x01])\n", var39, g_sPlayerName[mvp_Common], var38, RoundFloat(var37));
				}
				StrCat(printBuffer, 1024, tmpBuffer);
			}
		}
	}
	if (!iBrevityFlags & 4)
	{
		if (mvp_FF == -1)
		{
			new var40;
			if (bRound)
			{
				var40[0] = 197596;
			}
			else
			{
				var40[0] = 197600;
			}
			Format(tmpBuffer, 512, "[LVP%s] FF: no friendly fire at all!\n", var40);
			StrCat(printBuffer, 1024, tmpBuffer);
		}
		new var41;
		if (bRound)
		{
			var41 = g_strRoundPlayerData[mvp_FF][team][44];
		}
		else
		{
			var41 = g_strPlayerData[mvp_FF][44];
		}
		new var42;
		if (bRound)
		{
			var42[0] = 197640;
		}
		else
		{
			var42[0] = 197644;
		}
		Format(tmpBuffer, 512, "[LVP%s] FF:\x03 %s \x01(\x05%d \x01dmg)\n", var42, g_sPlayerName[mvp_FF], var41);
		StrCat(printBuffer, 1024, tmpBuffer);
	}
	return printBuffer;
}

DisplayStatsMVP(client, bool:bTank, bool:bMore, bool:bRound, bool:bTeam, iTeam)
{
	new i;
	new j;
	new bool:bFooter;
	SortPlayersMVP(bRound, 0, bTeam, iTeam);
	decl bool:bTankUp;
	new var1;
	bTankUp = !g_bModeCampaign && IsTankInGame() && g_bInRound;
	new var2;
	if (!bTank || !bTankUp)
	{
		BuildConsoleBufferMVP(bTank, bMore, bRound, bTeam, iTeam);
	}
	decl team;
	new var5;
	if (iTeam != -1)
	{
		var5 = iTeam;
	}
	else
	{
		new var3;
		if (g_bSecondHalf && !g_bPlayersLeftStart)
		{
			new var4;
			if (g_iCurTeam)
			{
				var4 = 0;
			}
			else
			{
				var4 = 1;
			}
			var5 = var4;
		}
		var5 = g_iCurTeam;
	}
	team = var5;
	decl String:bufBasicHeader[1024];
	decl String:bufBasicFooter[1024];
	if (bTank)
	{
		if (bTankUp)
		{
			Format(bufBasicHeader, 1024, "\n| Survivor MVP Stats -- Tank Fight (not showing table, tank is still up...)    |\n");
			Format(bufBasicHeader, 1024, "%s|------------------------------------------------------------------------------|", bufBasicHeader);
			g_iConsoleBufChunks = -1;
		}
		else
		{
			new var7;
			if (bTeam)
			{
				new var6;
				if (team)
				{
					var6 = 197928;
				}
				else
				{
					var6 = 197916;
				}
				var7 = var6;
			}
			else
			{
				var7 = 197940;
			}
			new var8;
			if (bRound)
			{
				var8 = 197892;
			}
			else
			{
				var8 = 197904;
			}
			Format(bufBasicHeader, 1024, "\n| Survivor MVP Stats -- Tank Fight -- %10s -- %11s                |\n", var8, var7);
			Format(bufBasicHeader, 1024, "%s|------------------------------------------------------------------------------|\n", bufBasicHeader);
			Format(bufBasicHeader, 1024, "%s| Name                 | SI during tank | CI d. tank | Melees | Rock skeet/eat |\n", bufBasicHeader);
			Format(bufBasicHeader, 1024, "%s|----------------------|----------------|------------|--------|----------------|", bufBasicHeader);
			if (!strlen(g_sConsoleBuf[g_iConsoleBufChunks]))
			{
				g_iConsoleBufChunks -= 1;
			}
			if (g_iConsoleBufChunks > -1)
			{
				Format(g_sConsoleBuf[g_iConsoleBufChunks], 4096, "%s\n|------------------------------------------------------------------------------|\n", g_sConsoleBuf[g_iConsoleBufChunks]);
			}
			Format(bufBasicHeader, 1024, "%s\n| (nothing to display)                                                         |%s", bufBasicHeader, "\n|------------------------------------------------------------------------------|");
		}
	}
	else
	{
		if (bMore)
		{
			new var10;
			if (bTeam)
			{
				new var9;
				if (team)
				{
					var9 = 198580;
				}
				else
				{
					var9 = 198568;
				}
				var10 = var9;
			}
			else
			{
				var10 = 198592;
			}
			new var11;
			if (bRound)
			{
				var11 = 198544;
			}
			else
			{
				var11 = 198556;
			}
			Format(bufBasicHeader, 1024, "\n| Survivor MVP Stats -- More Stats -- %10s -- %11s                         |\n", var11, var10);
			Format(bufBasicHeader, 1024, "%s|---------------------------------------------------------------------------------------|\n", bufBasicHeader);
			Format(bufBasicHeader, 1024, "%s| Name                 | Time Present  %%%% of rnd | Alive  | Upright |                    |\n", bufBasicHeader);
			Format(bufBasicHeader, 1024, "%s|----------------------|------------------------|--------|---------|--------------------|", bufBasicHeader);
			if (!strlen(g_sConsoleBuf[g_iConsoleBufChunks]))
			{
				g_iConsoleBufChunks -= 1;
			}
			if (g_iConsoleBufChunks > -1)
			{
				Format(g_sConsoleBuf[g_iConsoleBufChunks], 4096, "%s\n|---------------------------------------------------------------------------------------|\n", g_sConsoleBuf[g_iConsoleBufChunks]);
			}
			else
			{
				Format(bufBasicHeader, 1024, "%s\n| (nothing to display)                                                                  |%s", bufBasicHeader, "\n|---------------------------------------------------------------------------------------|");
			}
		}
		new var13;
		if (bTeam)
		{
			new var12;
			if (team)
			{
				var12 = 199304;
			}
			else
			{
				var12 = 199292;
			}
			var13 = var12;
		}
		else
		{
			var13 = 199316;
		}
		new var14;
		if (bRound)
		{
			var14 = 199268;
		}
		else
		{
			var14 = 199280;
		}
		Format(bufBasicHeader, 1024, "\n| Survivor MVP Stats -- %10s -- %11s                                                        |\n", var14, var13);
		Format(bufBasicHeader, 1024, "%s|--------------------------------------------------------------------------------------------------------|\n", bufBasicHeader);
		Format(bufBasicHeader, 1024, "%s| Name                 | Specials   kills/dmg  | Commons         | Tank   | Witch  | FF    | Rcvd | Time |\n", bufBasicHeader);
		Format(bufBasicHeader, 1024, "%s|----------------------|-----------------------|-----------------|--------|--------|-------|------|------|", bufBasicHeader);
		if (!strlen(g_sConsoleBuf[g_iConsoleBufChunks]))
		{
			g_iConsoleBufChunks -= 1;
		}
		if (g_iConsoleBufChunks > -1)
		{
			Format(g_sConsoleBuf[g_iConsoleBufChunks], 4096, "%s\n|--------------------------------------------------------------------------------------------------------|", g_sConsoleBuf[g_iConsoleBufChunks]);
		}
		else
		{
			Format(bufBasicHeader, 1024, "%s\n| (nothing to display)                                                                                   |%s", bufBasicHeader, "\n|--------------------------------------------------------------------------------------------------------|");
		}
		if (g_iConsoleBufChunks > -1)
		{
			new var23 = 24;

/* ERROR! null */
 function "DisplayStatsMVP" (number 103)
DisplayStatsFunFactChat(client, bool:bRound, bool:bTeam, iTeam)
{
	new var4;
	new var5 = 0;
	new i;
	new j;
	GetFunFactChatString(bRound, bTeam, iTeam);
	if (!strlen(var4))
	{
		return 0;
	}
	if (client == -1)
	{
		PrintToServer("\x01%s", var4);
	}
	new intPieces = ExplodeString(var4, "\n", var5, 8, 192, false);
	if (0 < client)
	{
		i = 0;
		while (i < intPieces)
		{
			PrintToChat(client, "\x01%s", var5[i]);
			i++;
		}
	}
	else
	{
		if (client)
		{
			j = 1;
			while (j <= MaxClients)
			{
				i = 0;
				while (i < intPieces)
				{
					new var1;
					if ((j > 0 && j <= MaxClients) && IsClientInGame(j) && g_iCookieValue[j])
					{
					}
				}
				j++;
			}
		}
		i = 0;
		while (i < intPieces)
		{
			PrintToServer("\x01%s", var5[i]);
			i++;
		}
	}
	return 0;
}

String:GetFunFactChatString(bool:bRound, bool:bTeam, iTeam, _arg3)
{
	new String:printBuffer[1024] = "";
	decl team;
	new var3;
	if (iTeam != -1)
	{
		var3 = iTeam;
	}
	else
	{
		new var1;
		if (g_bSecondHalf && !g_bPlayersLeftStart)
		{
			new var2;
			if (g_iCurTeam)
			{
				var2 = 0;
			}
			else
			{
				var2 = 1;
			}
			var3 = var2;
		}
		var3 = g_iCurTeam;
	}
	team = var3;
	new i;
	new j;
	new wTotal;
	new wPicks[256];
	new wTypeHighPly[17];
	new wTypeHighVal[17];
	new wTypeHighTeam[17];
	new wTmp;
	new highest;
	new value;
	new property;
	new minval;
	new maxval;
	new bool:bInf;
	i = 0;
	while (i <= 16)
	{
		wTmp = 0;
		wTypeHighPly[i] = -1;
		wTypeHighTeam[i] = team;
		bInf = false;
		switch (i)
		{
			case 1:
			{
				property = 36;
				minval = 1;
				maxval = 10;
			}
			case 2:
			{
				property = 37;
				minval = 1;
				maxval = 10;
			}
			case 3:
			{
				property = 30;
				minval = 2;
				maxval = 20;
			}
			case 4:
			{
				property = 32;
				minval = 1;
				maxval = 10;
			}
			case 5:
			{
				bInf = true;
				property = 8;
				minval = 2;
				maxval = 10;
			}
			case 6:
			{
				bInf = true;
				property = 10;
				minval = 2;
				maxval = 10;
			}
			case 7:
			{
				property = 38;
				minval = 15;
				maxval = 50;
			}
			case 8:
			{
				property = 49;
				minval = 4;
				maxval = 10;
			}
			case 9:
			{
				property = 40;
				minval = 4;
				maxval = 10;
			}
			case 10:
			{
				property = 35;
				minval = 4;
				maxval = 10;
			}
			case 11:
			{
				property = 39;
				minval = 7;
				maxval = 20;
			}
			case 12:
			{
				property = 33;
				minval = 3;
				maxval = 10;
			}
			case 13:
			{
				bInf = true;
				property = 4;
				minval = 50;
				maxval = 200;
			}
			case 14:
			{
				bInf = true;
				property = 11;
				minval = 1;
				maxval = 4;
			}
			case 15:
			{
				bInf = true;
				property = 6;
				minval = 40;
				maxval = 200;
			}
			case 16:
			{
				bInf = true;
				property = 5;
				minval = 60;
				maxval = 200;
			}
			default:
			{
			}
		}
		highest = GetPlayerWithHighestValue(property, bRound, bTeam, team, bInf);
		if (!(highest == -1))
		{
			if (bInf)
			{
				new var4;
				if (bRound && bTeam)
				{
					value = g_strRoundPlayerInfData[highest][team][property];
				}
				else
				{
					if (g_strRoundPlayerInfData[highest][1][property] < g_strRoundPlayerInfData[highest][0][property])
					{
						value = g_strRoundPlayerInfData[highest][0][property];
						wTypeHighTeam[i] = 0;
					}
					value = g_strRoundPlayerInfData[highest][1][property];
					wTypeHighTeam[i] = 1;
				}
			}
			else
			{
				new var5;
				if (bRound && bTeam)
				{
					value = g_strRoundPlayerData[highest][team][property];
				}
				if (g_strRoundPlayerData[highest][1][property] < g_strRoundPlayerData[highest][0][property])
				{
					value = g_strRoundPlayerData[highest][0][property];
					wTypeHighTeam[i] = 0;
				}
				value = g_strRoundPlayerData[highest][1][property];
				wTypeHighTeam[i] = 1;
			}
			if (value > minval)
			{
				wTypeHighPly[i] = highest;
				wTypeHighVal[i] = value;
				if (value >= maxval)
				{
					wTmp = 10;
				}
				wTmp = RoundFloat(float(value - minval) / float(maxval - minval) * float(10)) + 1;
			}
			if (wTmp)
			{
				j = 0;
				while (j < wTmp)
				{
					wPicks[j + wTotal] = i;
					j++;
				}
				wTotal = wTmp + wTotal;
			}
		}
		i++;
	}
	if (!wTotal)
	{
		return printBuffer;
	}
	new wPick = GetRandomInt(0, wTotal + -1);
	wPick = wPicks[wPick];
	switch (wPick)
	{
		case 1:
		{
			new var23;
			if (bRound)
			{
				var23[0] = 200436;
			}
			else
			{
				var23[0] = 200444;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01crowned \x05%d \x01witches.\n", var23, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 2:
		{
			new var22;
			if (bRound)
			{
				var22[0] = 200496;
			}
			else
			{
				var22[0] = 200504;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01draw-crowned \x05%d \x01witches.\n", var22, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 3:
		{
			new var21;
			if (bRound)
			{
				var21[0] = 200552;
			}
			else
			{
				var21[0] = 200560;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01skeeted \x05%d \x01hunters.\n", var21, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 4:
		{
			new var19;
			if (wTypeHighVal[wPick] == 1)
			{
				var19[0] = 200644;
			}
			else
			{
				var19[0] = 200648;
			}
			new var20;
			if (bRound)
			{
				var20[0] = 200628;
			}
			else
			{
				var20[0] = 200636;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01skeeted \x05%d \x01hunter%s with a melee weapon.\n", var20, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick], var19);
		}
		case 5:
		{
			new var18;
			if (bRound)
			{
				var18[0] = 201076;
			}
			else
			{
				var18[0] = 201084;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01landed \x05%d \x01highpounces with hunters.\n", var18, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 6:
		{
			new var17;
			if (bRound)
			{
				var17[0] = 201148;
			}
			else
			{
				var17[0] = 201156;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01landed \x05%d \x01highpounces with jockeys.\n", var17, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 7:
		{
			new var16;
			if (bRound)
			{
				var16[0] = 200700;
			}
			else
			{
				var16[0] = 200708;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01shoved \x05%d \x01special infected.\n", var16, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 8:
		{
			new var15;
			if (bRound)
			{
				var15[0] = 200768;
			}
			else
			{
				var15[0] = 200776;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01got \x05%d \x01melee swings on the tank.\n", var15, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 9:
		{
			new var14;
			if (bRound)
			{
				var14[0] = 200824;
			}
			else
			{
				var14[0] = 200832;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01cut \x05%d \x01tongue cuts.\n", var14, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 10:
		{
			new var13;
			if (bRound)
			{
				var13[0] = 200880;
			}
			else
			{
				var13[0] = 200888;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01popped \x05%d \x01boomers.\n", var13, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 11:
		{
			new var12;
			if (bRound)
			{
				var12[0] = 200940;
			}
			else
			{
				var12[0] = 200948;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01deadstopped \x05%d \x01hunters.\n", var12, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 12:
		{
			new var11;
			if (bRound)
			{
				var11[0] = 201004;
			}
			else
			{
				var11[0] = 201012;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01fully leveled \x05%d \x01chargers.\n", var11, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 13:
		{
			new var10;
			if (bRound)
			{
				var10[0] = 201316;
			}
			else
			{
				var10[0] = 201324;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01did a total of \x05%d \x01damage by scratching (standing) survivors.\n", var10, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 14:
		{
			new var8;
			if (wTypeHighVal[wPick] == 1)
			{
				var8[0] = 201228;
			}
			else
			{
				var8[0] = 201232;
			}
			new var9;
			if (bRound)
			{
				var9[0] = 201212;
			}
			else
			{
				var9[0] = 201220;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01death-charged \x05%d \x01 survivor%s.\n", var9, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick], var8);
		}
		case 15:
		{
			new var7;
			if (bRound)
			{
				var7[0] = 201424;
			}
			else
			{
				var7[0] = 201432;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01got a total of \x05%d \x01damage by common hits on boomed (standing) survivors.\n", var7, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		case 16:
		{
			new var6;
			if (bRound)
			{
				var6[0] = 201516;
			}
			else
			{
				var6[0] = 201524;
			}
			Format(printBuffer, 1024, "[%s fact] \x04%s \x01did a total of \x05%d \x01spit-damage on (standing) survivors.\n", var6, g_sPlayerName[wTypeHighPly[wPick]], wTypeHighVal[wPick]);
		}
		default:
		{
		}
	}
	return printBuffer;
}

DisplayStatsAccuracy(client, bool:bDetails, bool:bRound, bool:bTeam, bool:bSorted, iTeam)
{
	new i;
	new j;
	if (!bSorted)
	{
		SortPlayersMVP(bRound, 0, bTeam, iTeam);
	}
	BuildConsoleBufferAccuracy(bDetails, bRound, bTeam, iTeam);
	decl team;
	new var3;
	if (iTeam != -1)
	{
		var3 = iTeam;
	}
	else
	{
		new var1;
		if (g_bSecondHalf && !g_bPlayersLeftStart)
		{
			new var2;
			if (g_iCurTeam)
			{
				var2 = 0;
			}
			else
			{
				var2 = 1;
			}
			var3 = var2;
		}
		var3 = g_iCurTeam;
	}
	team = var3;
	decl String:bufBasicHeader[1024];
	if (bDetails)
	{
		new var5;
		if (bTeam)
		{
			new var4;
			if (team)
			{
				var4 = 201672;
			}
			else
			{
				var4 = 201660;
			}
			var5 = var4;
		}
		else
		{
			var5 = 201684;
		}
		new var6;
		if (bRound)
		{
			var6 = 201636;
		}
		else
		{
			var6 = 201648;
		}
		Format(bufBasicHeader, 1024, "\n| Accuracy -- Details -- %10s -- %11s                 hits on SI;  headshots on SI;  hits on tank |\n", var6, var5);
		Format(bufBasicHeader, 1024, "%s|--------------------------------------------------------------------------------------------------------------|\n", bufBasicHeader);
		Format(bufBasicHeader, 1024, "%s| Name                 | Shotgun             | SMG / Rifle         | Sniper              | Pistol              |\n", bufBasicHeader);
		Format(bufBasicHeader, 1024, "%s|----------------------|---------------------|---------------------|---------------------|---------------------|", bufBasicHeader);
		if (!strlen(g_sConsoleBuf[g_iConsoleBufChunks]))
		{
			g_iConsoleBufChunks -= 1;
		}
		if (g_iConsoleBufChunks > -1)
		{
			Format(g_sConsoleBuf[g_iConsoleBufChunks], 4096, "%s\n|--------------------------------------------------------------------------------------------------------------|", g_sConsoleBuf[g_iConsoleBufChunks]);
		}
		else
		{
			Format(bufBasicHeader, 1024, "%s\n| (nothing to display)                                                                                         |%s", bufBasicHeader, "\n|--------------------------------------------------------------------------------------------------------------|");
		}
	}
	else
	{
		new var8;
		if (bTeam)
		{
			new var7;
			if (team)
			{
				var7 = 202536;
			}
			else
			{
				var7 = 202524;
			}
			var8 = var7;
		}
		else
		{
			var8 = 202548;
		}
		new var9;
		if (bRound)
		{
			var9 = 202500;
		}
		else
		{
			var9 = 202512;
		}
		Format(bufBasicHeader, 1024, "\n| Accuracy Stats -- %10s -- %11s       hits (pellets/bullets);  acc prc;  headshots prc (of hits) |\n", var9, var8);
		Format(bufBasicHeader, 1024, "%s|--------------------------------------------------------------------------------------------------------------|\n", bufBasicHeader);
		Format(bufBasicHeader, 1024, "%s| Name                 | Shotgun buckshot    | SMG / Rifle  acc hs | Sniper       acc hs | Pistol       acc hs |\n", bufBasicHeader);
		Format(bufBasicHeader, 1024, "%s|----------------------|---------------------|---------------------|---------------------|---------------------|", bufBasicHeader);
		if (!strlen(g_sConsoleBuf[g_iConsoleBufChunks]))
		{
			g_iConsoleBufChunks -= 1;
		}
		if (g_iConsoleBufChunks > -1)
		{
			Format(g_sConsoleBuf[g_iConsoleBufChunks], 4096, "%s\n|--------------------------------------------------------------------------------------------------------------|", g_sConsoleBuf[g_iConsoleBufChunks]);
		}
		Format(bufBasicHeader, 1024, "%s\n| (nothing to display)                                                                                         |%s", bufBasicHeader, "\n|--------------------------------------------------------------------------------------------------------------|");
	}
	if (client == -2)
	{
		if (g_hStatsFile)
		{
			ReplaceString(bufBasicHeader, 1024, "%%", "%", true);
			WriteFileString(g_hStatsFile, bufBasicHeader, false);
			WriteFileString(g_hStatsFile, "\n", false);
			j = 0;
			while (j <= g_iConsoleBufChunks)
			{
				ReplaceString(g_sConsoleBuf[j], 4096, "%%", "%", true);
				WriteFileString(g_hStatsFile, g_sConsoleBuf[j], false);
				WriteFileString(g_hStatsFile, "\n", false);
				j++;
			}
			WriteFileString(g_hStatsFile, "\n", false);
		}
	}
	else
	{
		if (client == -1)
		{
			i = 1;
			while (i <= MaxClients)
			{
				new var10;
				if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && g_iCookieValue[i])
				{
					PrintToConsole(i, g_sConsoleBuf[j]);
					j++;
					while (j <= g_iConsoleBufChunks)
					{
						PrintToConsole(i, g_sConsoleBuf[j]);
						j++;
					}
				}
				i++;
			}
		}
		if (client)
		{
			new var13;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
			{
				PrintToConsole(client, bufBasicHeader);
				j = 0;
				while (j <= g_iConsoleBufChunks)
				{
					PrintToConsole(client, g_sConsoleBuf[j]);
					j++;
				}
			}
		}
		PrintToServer(bufBasicHeader);
		j = 0;
		while (j <= g_iConsoleBufChunks)
		{
			PrintToServer(g_sConsoleBuf[j]);
			j++;
		}
	}
	return 0;
}

DisplayStatsSpecial(client, bool:bRound, bool:bTeam, bool:bSorted, iTeam)
{
	new i;
	new j;
	if (!bSorted)
	{
		SortPlayersMVP(bRound, 0, bTeam, iTeam);
	}
	BuildConsoleBufferSpecial(bRound, bTeam, iTeam);
	decl team;
	new var3;
	if (iTeam != -1)
	{
		var3 = iTeam;
	}
	else
	{
		new var1;
		if (g_bSecondHalf && !g_bPlayersLeftStart)
		{
			new var2;
			if (g_iCurTeam)
			{
				var2 = 0;
			}
			else
			{
				var2 = 1;
			}
			var3 = var2;
		}
		var3 = g_iCurTeam;
	}
	team = var3;
	decl String:bufBasicHeader[1024];
	new var5;
	if (bTeam)
	{
		new var4;
		if (team)
		{
			var4 = 203416;
		}
		else
		{
			var4 = 203404;
		}
		var5 = var4;
	}
	else
	{
		var5 = 203428;
	}
	new var6;
	if (bRound)
	{
		var6 = 203380;
	}
	else
	{
		var6 = 203392;
	}
	Format(bufBasicHeader, 1024, "\n| Special -- %10s -- %11s       skts(full/hurt/melee); lvl(full/hurt); crwn(full/draw) |\n", var6, var5);
	if (!g_bSkillDetectLoaded)
	{
		Format(bufBasicHeader, 1024, "%s| ( skill_detect library not loaded: most of these stats won't be tracked )                         |\n", bufBasicHeader);
	}
	Format(bufBasicHeader, 1024, "%s|---------------------------------------------------------------------------------------------------|\n", bufBasicHeader);
	Format(bufBasicHeader, 1024, "%s| Name                 | Skeets  fl/ht/ml | Levels    | Crowns    | Pops | Cuts / Self | DSs / M2s  |\n", bufBasicHeader);
	Format(bufBasicHeader, 1024, "%s|----------------------|------------------|-----------|-----------|------|-------------|------------|", bufBasicHeader);
	if (!strlen(g_sConsoleBuf[g_iConsoleBufChunks]))
	{
		g_iConsoleBufChunks -= 1;
	}
	if (g_iConsoleBufChunks > -1)
	{
		Format(g_sConsoleBuf[g_iConsoleBufChunks], 4096, "%s\n|---------------------------------------------------------------------------------------------------|", g_sConsoleBuf[g_iConsoleBufChunks]);
	}
	else
	{
		Format(bufBasicHeader, 1024, "%s\n| (nothing to display)                                                                              |%s", bufBasicHeader, "\n|---------------------------------------------------------------------------------------------------|");
	}
	if (client == -2)
	{
		if (g_hStatsFile)
		{
			ReplaceString(bufBasicHeader, 1024, "%%", "%", true);
			WriteFileString(g_hStatsFile, bufBasicHeader, false);
			WriteFileString(g_hStatsFile, "\n", false);
			j = 0;
			while (j <= g_iConsoleBufChunks)
			{
				ReplaceString(g_sConsoleBuf[j], 4096, "%%", "%", true);
				WriteFileString(g_hStatsFile, g_sConsoleBuf[j], false);
				WriteFileString(g_hStatsFile, "\n", false);
				j++;
			}
			WriteFileString(g_hStatsFile, "\n", false);
		}
	}
	else
	{
		if (client == -1)
		{
			i = 1;
			while (i <= MaxClients)
			{
				new var7;
				if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && g_iCookieValue[i])
				{
					PrintToConsole(i, g_sConsoleBuf[j]);
					j++;
					while (j <= g_iConsoleBufChunks)
					{
						PrintToConsole(i, g_sConsoleBuf[j]);
						j++;
					}
				}
				i++;
			}
		}
		if (client)
		{
			new var10;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
			{
				PrintToConsole(client, bufBasicHeader);
				j = 0;
				while (j <= g_iConsoleBufChunks)
				{
					PrintToConsole(client, g_sConsoleBuf[j]);
					j++;
				}
			}
		}
		PrintToServer(bufBasicHeader);
		j = 0;
		while (j <= g_iConsoleBufChunks)
		{
			PrintToServer(g_sConsoleBuf[j]);
			j++;
		}
	}
	return 0;
}

DisplayStatsInfected(client, bool:bRound, bool:bTeam, bool:bSorted, iTeam)
{
	new i;
	new j;
	if (!bSorted)
	{
		SortPlayersMVP(bRound, 3, bTeam, iTeam);
	}
	BuildConsoleBufferInfected(bRound, bTeam, iTeam);
	decl team;
	new var3;
	if (iTeam != -1)
	{
		var3 = iTeam;
	}
	else
	{
		new var1;
		if (g_bSecondHalf && !g_bPlayersLeftStart)
		{
			new var2;
			if (g_iCurTeam)
			{
				var2 = 0;
			}
			else
			{
				var2 = 1;
			}
			var3 = var2;
		}
		var3 = g_iCurTeam;
	}
	team = var3;
	decl String:bufBasicHeader[1024];
	new var5;
	if (bTeam)
	{
		new var4;
		if (team)
		{
			var4 = 204336;
		}
		else
		{
			var4 = 204324;
		}
		var5 = var4;
	}
	else
	{
		var5 = 204348;
	}
	new var6;
	if (bRound)
	{
		var6 = 204300;
	}
	else
	{
		var6 = 204312;
	}
	Format(bufBasicHeader, 1024, "\n| Infected -- %10s -- %11s                                                     |\n", var6, var5);
	if (!g_bSkillDetectLoaded)
	{
		Format(bufBasicHeader, 1024, "%s| ( skill_detect library not loaded: most of these stats won't be tracked )                |\n", bufBasicHeader);
	}
	Format(bufBasicHeader, 1024, "%s|-------------------------------------------------------------------------------------------|\n", bufBasicHeader);
	Format(bufBasicHeader, 1024, "%s| Name                 | Dmg  up / tot | Commons | Hunt DPs / dmg | DCharge | Spawns | Time |\n", bufBasicHeader);
	Format(bufBasicHeader, 1024, "%s|----------------------|---------------|---------|----------------|---------|--------|------|", bufBasicHeader);
	if (!strlen(g_sConsoleBuf[g_iConsoleBufChunks]))
	{
		g_iConsoleBufChunks -= 1;
	}
	if (g_iConsoleBufChunks > -1)
	{
		Format(g_sConsoleBuf[g_iConsoleBufChunks], 4096, "%s\n|-------------------------------------------------------------------------------------------|", g_sConsoleBuf[g_iConsoleBufChunks]);
	}
	else
	{
		Format(bufBasicHeader, 1024, "%s\n| (nothing to display)                                                                      |%s", bufBasicHeader, "\n|-------------------------------------------------------------------------------------------|");
	}
	if (client == -2)
	{
		if (g_hStatsFile)
		{
			ReplaceString(bufBasicHeader, 1024, "%%", "%", true);
			WriteFileString(g_hStatsFile, bufBasicHeader, false);
			WriteFileString(g_hStatsFile, "\n", false);
			j = 0;
			while (j <= g_iConsoleBufChunks)
			{
				ReplaceString(g_sConsoleBuf[j], 4096, "%%", "%", true);
				WriteFileString(g_hStatsFile, g_sConsoleBuf[j], false);
				WriteFileString(g_hStatsFile, "\n", false);
				j++;
			}
			WriteFileString(g_hStatsFile, "\n", false);
		}
	}
	else
	{
		if (client == -1)
		{
			i = 1;
			while (i <= MaxClients)
			{
				new var7;
				if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && g_iCookieValue[i])
				{
					PrintToConsole(i, g_sConsoleBuf[j]);
					j++;
					while (j <= g_iConsoleBufChunks)
					{
						PrintToConsole(i, g_sConsoleBuf[j]);
						j++;
					}
				}
				i++;
			}
		}
		if (client)
		{
			new var10;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
			{
				PrintToConsole(client, bufBasicHeader);
				j = 0;
				while (j <= g_iConsoleBufChunks)
				{
					PrintToConsole(client, g_sConsoleBuf[j]);
					j++;
				}
			}
		}
		PrintToServer(bufBasicHeader);
		j = 0;
		while (j <= g_iConsoleBufChunks)
		{
			PrintToServer(g_sConsoleBuf[j]);
			j++;
		}
	}
	return 0;
}

DisplayStatsFriendlyFire(client, bool:bRound, bool:bTeam, bool:bSorted, iTeam)
{
	new i;
	new j;
	if (!bSorted)
	{
		SortPlayersMVP(true, 2, bTeam, iTeam);
	}
	decl team;
	new var3;
	if (iTeam != -1)
	{
		var3 = iTeam;
	}
	else
	{
		new var1;
		if (g_bSecondHalf && !g_bPlayersLeftStart)
		{
			new var2;
			if (g_iCurTeam)
			{
				var2 = 0;
			}
			else
			{
				var2 = 1;
			}
			var3 = var2;
		}
		var3 = g_iCurTeam;
	}
	team = var3;
	decl String:bufBasicHeader[1024];
	new bool:bNoStatsToShow = 1;
	if (bRound)
	{
		if (bTeam)
		{
			if (g_strRoundData[g_iRound][team][12])
			{
				bNoStatsToShow = false;
			}
		}
		else
		{
			new var4;
			if (g_strRoundData[g_iRound][0][12] || g_strRoundData[g_iRound][1][12])
			{
				bNoStatsToShow = false;
			}
		}
	}
	else
	{
		if (bTeam)
		{
			if (g_strAllRoundData[team][12])
			{
				bNoStatsToShow = false;
			}
		}
		new var22 = g_strAllRoundData;
		new var5;
		if (var22[0][var22][12] || g_strAllRoundData[1][12])
		{
			bNoStatsToShow = false;
		}
	}
	if (bNoStatsToShow)
	{
		Format(bufBasicHeader, 1024, "\nFF: No Friendly Fire done, not showing table.");
		g_iConsoleBufChunks = -1;
	}
	else
	{
		BuildConsoleBufferFriendlyFireGiven(bRound, bTeam, iTeam);
		new var7;
		if (bTeam)
		{
			new var6;
			if (team)
			{
				var6 = 205256;
			}
			else
			{
				var6 = 205244;
			}
			var7 = var6;
		}
		else
		{
			var7 = 205268;
		}
		new var8;
		if (bRound)
		{
			var8 = 205220;
		}
		else
		{
			var8 = 205232;
		}
		Format(bufBasicHeader, 1024, "\n| Friendly Fire -- Given / Offenders -- %10s -- %11s                                      |\n", var8, var7);
		Format(bufBasicHeader, 1024, "%s|--------------------------------||---------------------------------------------------------||---------|\n", bufBasicHeader);
		Format(bufBasicHeader, 1024, "%s| Name                 | Total   || Shotgun | Bullets | Melee  | Fire   | On Incap | Other  || to Self |\n", bufBasicHeader);
		Format(bufBasicHeader, 1024, "%s|----------------------|---------||---------|---------|--------|--------|----------|--------||---------|", bufBasicHeader);
		if (!strlen(g_sConsoleBuf[g_iConsoleBufChunks]))
		{
			g_iConsoleBufChunks -= 1;
		}
		if (g_iConsoleBufChunks > -1)
		{
			Format(g_sConsoleBuf[g_iConsoleBufChunks], 4096, "%s\n|--------------------------------||---------------------------------------------------------||---------|", g_sConsoleBuf[g_iConsoleBufChunks]);
		}
		Format(bufBasicHeader, 1024, "%s\n| (nothing to display)                                                                                 |%s", bufBasicHeader, "\n|------------------------------------------------------------------------------------------------------|");
	}
	if (client == -2)
	{
		if (g_hStatsFile)
		{
			ReplaceString(bufBasicHeader, 1024, "%%", "%", true);
			WriteFileString(g_hStatsFile, bufBasicHeader, false);
			WriteFileString(g_hStatsFile, "\n", false);
			j = 0;
			while (j <= g_iConsoleBufChunks)
			{
				ReplaceString(g_sConsoleBuf[j], 4096, "%%", "%", true);
				WriteFileString(g_hStatsFile, g_sConsoleBuf[j], false);
				WriteFileString(g_hStatsFile, "\n", false);
				j++;
			}
			WriteFileString(g_hStatsFile, "\n", false);
		}
	}
	else
	{
		if (client == -1)
		{
			i = 1;
			while (i <= MaxClients)
			{
				new var9;
				if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && g_iCookieValue[i])
				{
					PrintToConsole(i, g_sConsoleBuf[j]);
					j++;
					while (j <= g_iConsoleBufChunks)
					{
						PrintToConsole(i, g_sConsoleBuf[j]);
						j++;
					}
				}
				i++;
			}
		}
		if (client)
		{
			new var12;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
			{
				PrintToConsole(client, bufBasicHeader);
				j = 0;
				while (j <= g_iConsoleBufChunks)
				{
					PrintToConsole(client, g_sConsoleBuf[j]);
					j++;
				}
			}
		}
		PrintToServer(bufBasicHeader);
		j = 0;
		while (j <= g_iConsoleBufChunks)
		{
			PrintToServer(g_sConsoleBuf[j]);
			j++;
		}
	}
	if (bNoStatsToShow)
	{
		return 0;
	}
	BuildConsoleBufferFriendlyFireTaken(bRound, bTeam, iTeam);
	new var15;
	if (bTeam)
	{
		new var14;
		if (team)
		{
			var14 = 206092;
		}
		else
		{
			var14 = 206080;
		}
		var15 = var14;
	}
	else
	{
		var15 = 206104;
	}
	new var16;
	if (bRound)
	{
		var16 = 206056;
	}
	else
	{
		var16 = 206068;
	}
	Format(bufBasicHeader, 1024, "\n| Friendly Fire -- Received / Victims -- %10s -- %11s                                     |\n", var16, var15);
	Format(bufBasicHeader, 1024, "%s|--------------------------------||---------------------------------------------------------||---------|\n", bufBasicHeader);
	Format(bufBasicHeader, 1024, "%s| Name                 | Total   || Shotgun | Bullets | Melee  | Fire   | Incapped | Other  || Fall    |\n", bufBasicHeader);
	Format(bufBasicHeader, 1024, "%s|----------------------|---------||---------|---------|--------|--------|----------|--------||---------|", bufBasicHeader);
	if (!strlen(g_sConsoleBuf[g_iConsoleBufChunks]))
	{
		g_iConsoleBufChunks -= 1;
	}
	if (g_iConsoleBufChunks > -1)
	{
		Format(g_sConsoleBuf[g_iConsoleBufChunks], 4096, "%s\n|--------------------------------||---------------------------------------------------------||---------|\n", g_sConsoleBuf[g_iConsoleBufChunks]);
	}
	else
	{
		Format(bufBasicHeader, 1024, "%s\n| (nothing to display)                                                                                 |%s", bufBasicHeader, "\n|------------------------------------------------------------------------------------------------------|");
	}
	if (client == -2)
	{
		if (g_hStatsFile)
		{
			ReplaceString(bufBasicHeader, 1024, "%%", "%", true);
			WriteFileString(g_hStatsFile, bufBasicHeader, false);
			WriteFileString(g_hStatsFile, "\n", false);
			j = 0;
			while (j <= g_iConsoleBufChunks)
			{
				ReplaceString(g_sConsoleBuf[j], 4096, "%%", "%", true);
				WriteFileString(g_hStatsFile, g_sConsoleBuf[j], false);
				WriteFileString(g_hStatsFile, "\n", false);
				j++;
			}
			WriteFileString(g_hStatsFile, "\n", false);
		}
	}
	else
	{
		if (client == -1)
		{
			i = 1;
			while (i <= MaxClients)
			{
				new var17;
				if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && g_iCookieValue[i])
				{
					PrintToConsole(i, g_sConsoleBuf[j]);
					j++;
					while (j <= g_iConsoleBufChunks)
					{
						PrintToConsole(i, g_sConsoleBuf[j]);
						j++;
					}
				}
				i++;
			}
		}
		if (client)
		{
			new var20;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
			{
				PrintToConsole(client, bufBasicHeader);
				j = 0;
				while (j <= g_iConsoleBufChunks)
				{
					PrintToConsole(client, g_sConsoleBuf[j]);
					j++;
				}
			}
		}
		PrintToServer(bufBasicHeader);
		j = 0;
		while (j <= g_iConsoleBufChunks)
		{
			PrintToServer(g_sConsoleBuf[j]);
			j++;
		}
	}
	return 0;
}

BuildConsoleBufferGeneral(bool:bTeam, iTeam)
{
	g_iConsoleBufChunks = 0;
	new var6 = g_sConsoleBuf;
	new var7 = 24;

/* ERROR! null */
 function "BuildConsoleBufferGeneral" (number 110)
BuildConsoleBufferSpecial(bool:bRound, bool:bTeam, iTeam)
{
	g_iConsoleBufChunks = 0;
	new var47 = g_sConsoleBuf;
	new var48 = 24;

/* ERROR! null */
 function "BuildConsoleBufferSpecial" (number 111)
BuildConsoleBufferInfected(bool:bRound, bool:bTeam, iTeam)
{
	g_iConsoleBufChunks = 0;
	new var33 = g_sConsoleBuf;
	new var34 = 24;

/* ERROR! null */
 function "BuildConsoleBufferInfected" (number 112)
BuildConsoleBufferAccuracy(bool:details, bool:bRound, bool:bTeam, iTeam)
{
	g_iConsoleBufChunks = 0;
	new var46 = g_sConsoleBuf;
	new var47 = 24;

/* ERROR! null */
 function "BuildConsoleBufferAccuracy" (number 113)
BuildConsoleBufferMVP(bool:bTank, bool:bMore, bool:bRound, bool:bTeam, iTeam)
{
	g_iConsoleBufChunks = 0;
	new var84 = g_sConsoleBuf;
	new var85 = 24;

/* ERROR! null */
 function "BuildConsoleBufferMVP" (number 114)
BuildConsoleBufferFriendlyFireGiven(bool:bRound, bool:bTeam, iTeam)
{
	g_iConsoleBufChunks = 0;
	new var41 = g_sConsoleBuf;
	new var42 = 15;

/* ERROR! null */
 function "BuildConsoleBufferFriendlyFireGiven" (number 115)
BuildConsoleBufferFriendlyFireTaken(bool:bRound, bool:bTeam, iTeam)
{
	g_iConsoleBufChunks = 0;
	new var41 = g_sConsoleBuf;
	new var42 = 15;

/* ERROR! null */
 function "BuildConsoleBufferFriendlyFireTaken" (number 116)
SortPlayersMVP(bool:bRound, sortCol, bool:bTeam, iTeam)
{
	new iStored;
	new i;
	new j;
	new bool:found;
	new highest;
	new highTeam;
	new pickTeam;
	new var1;
	if (sortCol < 0 || sortCol > 3)
	{
		return 0;
	}
	decl team;
	new var4;
	if (iTeam != -1)
	{
		var4 = iTeam;
	}
	else
	{
		new var2;
		if (g_bSecondHalf && !g_bPlayersLeftStart)
		{
			new var3;
			if (g_iCurTeam)
			{
				var3 = 0;
			}
			else
			{
				var3 = 1;
			}
			var4 = var3;
		}
		var4 = g_iCurTeam;
	}
	team = var4;
	while (iStored < g_iPlayers)
	{
		highest = -1;
		i = 0;
		while (i < g_iPlayers)
		{
			found = false;
			j = 0;
			while (j < iStored)
			{
				if (i == g_iPlayerIndexSorted[sortCol][j])
				{
					found = true;
				}
				j++;
			}
			if (!found)
			{
				switch (sortCol)
				{
					case 0:
					{
						if (bRound)
						{
							if (bTeam)
							{
								new var29;
								if (highest == -1 || g_strRoundPlayerData[i][team][26] > g_strRoundPlayerData[highest][team][26] || (g_strRoundPlayerData[highest][team][26] == g_strRoundPlayerData[i][team][26] && (g_strRoundPlayerData[i][team][22] > g_strRoundPlayerData[highest][team][22] || (g_strRoundPlayerData[highest][team][22] == g_strRoundPlayerData[i][team][22] && highest < 4))))
								{
									highest = i;
								}
							}
							else
							{
								new var30;
								if (g_strRoundPlayerData[i][0][26] >= g_strRoundPlayerData[i][1][26])
								{
									var30 = 0;
								}
								else
								{
									var30 = 1;
								}
								pickTeam = var30;
								new var34;
								if (highest == -1 || g_strRoundPlayerData[i][pickTeam][26] > g_strRoundPlayerData[highest][highTeam][26] || (g_strRoundPlayerData[highest][highTeam][26] == g_strRoundPlayerData[i][pickTeam][26] && (g_strRoundPlayerData[i][pickTeam][22] > g_strRoundPlayerData[highest][highTeam][22] || (g_strRoundPlayerData[highest][highTeam][22] == g_strRoundPlayerData[i][pickTeam][22] && highest < 4))))
								{
									highest = i;
									g_iPlayerSortedUseTeam[sortCol][i] = pickTeam;
									highTeam = pickTeam;
								}
							}
						}
						else
						{
							new var38;
							if (highest == -1 || g_strPlayerData[i][26] > g_strPlayerData[highest][26] || (g_strPlayerData[highest][26] == g_strPlayerData[i][26] && (g_strPlayerData[i][22] > g_strPlayerData[highest][22] || (g_strPlayerData[highest][22] == g_strPlayerData[i][22] && highest < 4))))
							{
								highest = i;
							}
						}
					}
					case 1:
					{
						if (bRound)
						{
							if (bTeam)
							{
								new var16;
								if (highest == -1 || g_strRoundPlayerData[i][team][22] > g_strRoundPlayerData[highest][team][22] || (g_strRoundPlayerData[highest][team][22] == g_strRoundPlayerData[i][team][22] && (g_strRoundPlayerData[i][team][26] > g_strRoundPlayerData[highest][team][26] || (g_strRoundPlayerData[highest][team][26] == g_strRoundPlayerData[i][team][26] && highest < 4))))
								{
									highest = i;
								}
							}
							else
							{
								new var17;
								if (g_strRoundPlayerData[i][0][22] >= g_strRoundPlayerData[i][1][22])
								{
									var17 = 0;
								}
								else
								{
									var17 = 1;
								}
								pickTeam = var17;
								new var21;
								if (highest == -1 || g_strRoundPlayerData[i][pickTeam][22] > g_strRoundPlayerData[highest][highTeam][22] || (g_strRoundPlayerData[highest][highTeam][22] == g_strRoundPlayerData[i][pickTeam][22] && (g_strRoundPlayerData[i][pickTeam][26] > g_strRoundPlayerData[highest][highTeam][26] || (g_strRoundPlayerData[highest][highTeam][26] == g_strRoundPlayerData[i][pickTeam][26] && highest < 4))))
								{
									highest = i;
									g_iPlayerSortedUseTeam[sortCol][i] = pickTeam;
									highTeam = pickTeam;
								}
							}
						}
						else
						{
							new var25;
							if (highest == -1 || g_strPlayerData[i][22] > g_strPlayerData[highest][22] || (g_strPlayerData[highest][22] == g_strPlayerData[i][22] && (g_strPlayerData[i][26] > g_strPlayerData[highest][26] || (g_strPlayerData[highest][26] == g_strPlayerData[i][26] && highest < 4))))
							{
								highest = i;
							}
						}
					}
					case 2:
					{
						if (bRound)
						{
							if (bTeam)
							{
								new var9;
								if (highest == -1 || g_strRoundPlayerData[i][team][44] > g_strRoundPlayerData[highest][team][44])
								{
									highest = i;
								}
							}
							else
							{
								new var10;
								if (g_strRoundPlayerData[i][0][44] >= g_strRoundPlayerData[i][1][44])
								{
									var10 = 0;
								}
								else
								{
									var10 = 1;
								}
								pickTeam = var10;
								new var11;
								if (highest == -1 || g_strRoundPlayerData[i][pickTeam][44] > g_strRoundPlayerData[highest][highTeam][44])
								{
									highest = i;
									g_iPlayerSortedUseTeam[sortCol][i] = pickTeam;
									highTeam = pickTeam;
								}
							}
						}
						else
						{
							new var12;
							if (highest == -1 || g_strPlayerData[i][44] > g_strPlayerData[highest][44])
							{
								highest = i;
							}
						}
					}
					case 3:
					{
						if (bRound)
						{
							if (bTeam)
							{
								new var5;
								if (highest == -1 || g_strRoundPlayerInfData[i][team][1] > g_strRoundPlayerInfData[highest][team][1])
								{
									highest = i;
								}
							}
							else
							{
								new var6;
								if (g_strRoundPlayerInfData[i][0][1] >= g_strRoundPlayerInfData[i][1][1])
								{
									var6 = 0;
								}
								else
								{
									var6 = 1;
								}
								pickTeam = var6;
								new var7;
								if (highest == -1 || g_strRoundPlayerInfData[i][pickTeam][1] > g_strRoundPlayerInfData[highest][highTeam][1])
								{
									highest = i;
									g_iPlayerSortedUseTeam[sortCol][i] = pickTeam;
									highTeam = pickTeam;
								}
							}
						}
						else
						{
							new var8;
							if (highest == -1 || g_strPlayerInfData[i][1] > g_strPlayerInfData[highest][1])
							{
								highest = i;
							}
						}
					}
					default:
					{
					}
				}
			}
			i++;
		}
		g_iPlayerIndexSorted[sortCol][iStored] = highest;
		iStored++;
	}
	return 0;
}

GetPlayerWithHighestValue(property, bool:bRound, bool:bTeam, team, bool:bInfected)
{
	new i;
	new highest;
	new highTeam;
	new pickTeam;
	highest = -1;
	if (bInfected)
	{
		i = 4;
		while (i < g_iPlayers)
		{
			if (bRound)
			{
				if (bTeam)
				{
					new var1;
					if (highest == -1 || g_strRoundPlayerInfData[i][team][property] > g_strRoundPlayerInfData[highest][team][property])
					{
						highest = i;
					}
				}
				else
				{
					new var2;
					if (g_strRoundPlayerInfData[i][0][property] >= g_strRoundPlayerInfData[i][1][property])
					{
						var2 = 0;
					}
					else
					{
						var2 = 1;
					}
					pickTeam = var2;
					new var3;
					if (highest == -1 || g_strRoundPlayerInfData[i][pickTeam][property] > g_strRoundPlayerInfData[highest][highTeam][property])
					{
						highest = i;
						highTeam = pickTeam;
					}
				}
			}
			else
			{
				new var4;
				if (highest == -1 || g_strPlayerInfData[i][property] > g_strPlayerInfData[highest][property])
				{
					highest = i;
				}
			}
			i++;
		}
	}
	else
	{
		i = 4;
		while (i < g_iPlayers)
		{
			if (bRound)
			{
				if (bTeam)
				{
					new var5;
					if (highest == -1 || g_strRoundPlayerData[i][team][property] > g_strRoundPlayerData[highest][team][property])
					{
						highest = i;
					}
				}
				else
				{
					new var6;
					if (g_strRoundPlayerData[i][0][property] >= g_strRoundPlayerData[i][1][property])
					{
						var6 = 0;
					}
					else
					{
						var6 = 1;
					}
					pickTeam = var6;
					new var7;
					if (highest == -1 || g_strRoundPlayerData[i][pickTeam][property] > g_strRoundPlayerData[highest][highTeam][property])
					{
						highest = i;
						highTeam = pickTeam;
					}
				}
			}
			else
			{
				new var8;
				if (highest == -1 || g_strPlayerData[i][property] > g_strPlayerData[highest][property])
				{
					highest = i;
				}
			}
			i++;
		}
	}
	return highest;
}

TableIncludePlayer(index, team, bool:bRound, bool:bReverseTeam, statA, statB)
{
	if (bReverseTeam)
	{
		new var1;
		if (team)
		{
			var1 = 0;
		}
		else
		{
			var1 = 1;
		}
		if (var1 != g_iPlayerRoundTeam[team][index])
		{
			return 0;
		}
	}
	else
	{
		if (team != g_iPlayerRoundTeam[team][index])
		{
			return 0;
		}
	}
	if (g_bPlayersLeftStart)
	{
		if (bReverseTeam)
		{
			new var3;
			if ((g_strRoundPlayerInfData[index][team][23] && (g_strRoundPlayerInfData[index][team][15] || g_strRoundPlayerInfData[index][team][22])) && (g_iCurTeam == team && team && index >= 4))
			{
				return 1;
			}
		}
		else
		{
			new var6;
			if (g_iCurTeam == team && team == g_iPlayerRoundTeam[2][index])
			{
				return 1;
			}
		}
	}
	else
	{
		if (!bRound)
		{
			if (bReverseTeam)
			{
				new var8;
				if ((g_strPlayerInfData[index][23] && (g_strPlayerInfData[index][15] || g_strPlayerInfData[index][22])) || team || index < 4)
				{
					return 0;
				}
			}
			else
			{
				new var11;
				if ((g_strPlayerData[index][71] || g_strPlayerData[index][statA] || g_strPlayerData[index][statB]) || team == g_iPlayerGameTeam[team][index])
				{
					return 0;
				}
			}
		}
		if (index >= 4)
		{
			if (!IsIndexSurvivor(index, bReverseTeam))
			{
				if (g_iCurTeam == team)
				{
					return 0;
				}
			}
			if (g_iCurTeam != team)
			{
				return 0;
			}
		}
	}
	if (bReverseTeam)
	{
		if (bRound)
		{
			new var13;
			if (g_strRoundPlayerInfData[index][team][statA] || g_strRoundPlayerInfData[index][team][statB])
			{
				return 1;
			}
		}
		else
		{
			new var14;
			if (g_strPlayerInfData[index][statA] || g_strPlayerInfData[index][statB])
			{
				return 1;
			}
		}
	}
	else
	{
		if (bRound)
		{
			new var15;
			if (g_strRoundPlayerData[index][team][statA] || g_strRoundPlayerData[index][team][statB])
			{
				return 1;
			}
		}
		new var16;
		if (g_strPlayerData[index][statA] || g_strPlayerData[index][statB])
		{
			return 1;
		}
	}
	if (index < 4)
	{
		return 0;
	}
	new presTime;
	new time = GetTime({0,0});
	if (!bReverseTeam)
	{
		if (bRound)
		{
			new var17;
			if (g_strRoundPlayerData[index][team][72])
			{
				var17 = g_strRoundPlayerData[index][team][72];
			}
			else
			{
				var17 = time;
			}
			presTime = var17 - g_strRoundPlayerData[index][team][71];
		}
		else
		{
			new var18;
			if (g_strPlayerData[index][72])
			{
				var18 = g_strPlayerData[index][72];
			}
			else
			{
				var18 = time;
			}
			presTime = var18 - g_strPlayerData[index][71];
		}
	}
	else
	{
		if (bRound)
		{
			new var19;
			if (g_strRoundPlayerInfData[index][team][24])
			{
				var19 = g_strRoundPlayerInfData[index][team][24];
			}
			else
			{
				var19 = time;
			}
			presTime = var19 - g_strRoundPlayerInfData[index][team][23];
		}
		new var20;
		if (g_strPlayerInfData[index][24])
		{
			var20 = g_strPlayerInfData[index][24];
		}
		else
		{
			var20 = time;
		}
		presTime = var20 - g_strPlayerInfData[index][23];
	}
	if (presTime >= 30)
	{
		return 1;
	}
	return 0;
}

GetFullRoundTime(bRound, bTeam, team, bool:bTank)
{
	new start = 13;
	new stop = 14;
	if (bTank)
	{
		start = 17;
		stop = 18;
	}
	new fullTime;
	new time = GetTime({0,0});
	if (bRound)
	{
		if (bTeam)
		{
			if (g_strRoundData[g_iRound][team][start])
			{
				new var1;
				if (g_strRoundData[g_iRound][team][stop])
				{
					var1 = g_strRoundData[g_iRound][team][stop];
				}
				else
				{
					var1 = time;
				}
				fullTime = var1 - g_strRoundData[g_iRound][team][start];
				new var2;
				if (g_bPaused && g_iCurTeam == team)
				{
					new var3;
					if (!bTank || g_bTankInGame)
					{
						fullTime -= time - g_iPauseStart;
					}
				}
			}
		}
		else
		{
			if (g_strRoundData[g_iRound][0][start])
			{
				new var4;
				if (g_strRoundData[g_iRound][0][stop])
				{
					var4 = g_strRoundData[g_iRound][0][stop];
				}
				else
				{
					var4 = time;
				}
				fullTime = var4 - g_strRoundData[g_iRound][0][start];
				new var5;
				if (g_bPaused && g_iCurTeam)
				{
					new var6;
					if (!bTank || g_bTankInGame)
					{
						fullTime -= time - g_iPauseStart;
					}
				}
			}
			if (g_strRoundData[g_iRound][1][start])
			{
				new var7;
				if (g_strRoundData[g_iRound][1][stop])
				{
					var7 = g_strRoundData[g_iRound][1][stop];
				}
				else
				{
					var7 = time;
				}
				fullTime = var7 - g_strRoundData[g_iRound][1][start] + fullTime;
				new var8;
				if (g_bPaused && g_iCurTeam == 1)
				{
					new var9;
					if (!bTank || g_bTankInGame)
					{
						fullTime -= time - g_iPauseStart;
					}
				}
			}
		}
	}
	else
	{
		if (bTeam)
		{
			if (g_strAllRoundData[team][start])
			{
				new var10;
				if (g_strAllRoundData[team][stop])
				{
					var10 = g_strAllRoundData[team][stop];
				}
				else
				{
					var10 = time;
				}
				fullTime = var10 - g_strAllRoundData[team][start];
				new var11;
				if (g_bPaused && g_iCurTeam == team)
				{
					new var12;
					if (!bTank || g_bTankInGame)
					{
						fullTime -= time - g_iPauseStart;
					}
				}
			}
		}
		new var19 = g_strAllRoundData;
		if (var19[0][var19][start])
		{
			new var20 = g_strAllRoundData;
			new var13;
			if (var20[0][var20][stop])
			{
				new var21 = g_strAllRoundData;
				var13 = var21[0][var21][stop];
			}
			else
			{
				var13 = time;
			}
			new var22 = g_strAllRoundData;
			fullTime = var13 - var22[0][var22][start];
			new var14;
			if (g_bPaused && g_iCurTeam)
			{
				new var15;
				if (!bTank || g_bTankInGame)
				{
					fullTime -= time - g_iPauseStart;
				}
			}
		}
		if (g_strAllRoundData[1][start])
		{
			new var16;
			if (g_strAllRoundData[1][stop])
			{
				var16 = g_strAllRoundData[1][stop];
			}
			else
			{
				var16 = time;
			}
			fullTime = var16 - g_strAllRoundData[1][start] + fullTime;
			new var17;
			if (g_bPaused && g_iCurTeam == 1)
			{
				new var18;
				if (!bTank || g_bTankInGame)
				{
					fullTime -= time - g_iPauseStart;
				}
			}
		}
	}
	return fullTime;
}

GetPauseTime(bRound, bTeam, team, bool:bCurrentOnly)
{
	new start = 15;
	new stop = 16;
	new fullTime;
	new time = GetTime({0,0});
	if (bCurrentOnly)
	{
		if (bRound)
		{
			new var2;
			if (g_bPaused && (g_iCurTeam != team && !bTeam))
			{
				fullTime = time - g_iPauseStart + fullTime;
			}
		}
		return fullTime;
	}
	if (bRound)
	{
		if (bTeam)
		{
			new var3;
			if (g_strRoundData[g_iRound][team][start] && g_strRoundData[g_iRound][team][stop])
			{
				fullTime = g_strRoundData[g_iRound][team][stop] - g_strRoundData[g_iRound][team][start];
			}
			new var4;
			if (g_bPaused && g_iCurTeam == team)
			{
				fullTime = time - g_iPauseStart + fullTime;
			}
		}
		else
		{
			new var5;
			if (g_strRoundData[g_iRound][0][start] && g_strRoundData[g_iRound][0][stop])
			{
				fullTime = g_strRoundData[g_iRound][0][stop] - g_strRoundData[g_iRound][0][start];
			}
			new var6;
			if (g_strRoundData[g_iRound][1][start] && g_strRoundData[g_iRound][1][stop])
			{
				fullTime = g_strRoundData[g_iRound][1][stop] - g_strRoundData[g_iRound][1][start] + fullTime;
			}
			if (g_bPaused)
			{
				fullTime = time - g_iPauseStart + fullTime;
			}
		}
	}
	else
	{
		if (bTeam)
		{
			new var7;
			if (g_strAllRoundData[team][start] && g_strAllRoundData[team][stop])
			{
				fullTime = g_strAllRoundData[team][stop] - g_strAllRoundData[team][start];
			}
		}
		new var10 = g_strAllRoundData;
		new var8;
		if (var10[0][var10][start] && var11[0][var11][stop])
		{
			new var12 = g_strAllRoundData;
			new var13 = g_strAllRoundData;
			fullTime = var12[0][var12][stop] - var13[0][var13][start];
		}
		new var9;
		if (g_strAllRoundData[1][start] && g_strAllRoundData[1][stop])
		{
			fullTime = g_strAllRoundData[1][stop] - g_strAllRoundData[1][start] + fullTime;
		}
	}
	return fullTime;
}

SaveFurthestFlows()
{
	new chr;
	new Float:fTmp = 0.0;
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && (GetClientTeam(i) == 2 || !IsPlayerAlive(i)))
		{
		}
	}
	return 0;
}

public Action:Timer_SaveFlows(Handle:timer)
{
	new var1;
	if (!g_bPlayersLeftStart || !g_bInRound)
	{
		return Action:0;
	}
	SaveFurthestFlows();
	return Action:0;
}

AutomaticRoundEndPrint(bool:doDelay)
{
	g_iLastRoundEndPrint = GetTime({0,0});
	new Float:fDelay = 3.0;
	if (g_bModeScavenge)
	{
		fDelay = 2.0;
	}
	if (doDelay)
	{
		CreateTimer(fDelay, Timer_AutomaticRoundEndPrint, any:0, 2);
	}
	else
	{
		Timer_AutomaticRoundEndPrint(Handle:0);
	}
	return 0;
}

public Action:Timer_AutomaticRoundEndPrint(Handle:timer)
{
	decl iFlags;
	new var1;
	if (g_bModeCampaign)
	{
		var1 = g_hCvarAutoPrintCoop;
	}
	else
	{
		var1 = g_hCvarAutoPrintVs;
	}
	iFlags = GetConVarInt(var1);
	AutomaticPrintPerClient(iFlags, -1, -1, false, false, false, false);
	new client = 1;
	while (client <= MaxClients)
	{
		if (0 < g_iCookieValue[client])
		{
			AutomaticPrintPerClient(g_iCookieValue[client], client, -1, false, false, false, false);
		}
		client++;
	}
	return Action:0;
}


/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "AutomaticPrintPerClient" (number 126)
public Action:Timer_DelayedPrint(Handle:timer, Handle:pack)
{
	ResetPack(pack, false);
	new flags = ReadPackCell(pack);
	new client = ReadPackCell(pack);
	new team = ReadPackCell(pack);
	new bool:bSortedRound = ReadPackCell(pack);
	new bool:bSortedGame = ReadPackCell(pack);
	CloseHandle(pack);
	AutomaticPrintPerClient(flags, client, team, true, true, bSortedRound, bSortedGame);
	return Action:0;
}

GetCurrentTeamSurvivor()
{
	if (g_bCMTSwapped)
	{
		return !GameRules_GetProp("m_bAreTeamsFlipped", 4, 0);
	}
	return GameRules_GetProp("m_bAreTeamsFlipped", 4, 0);
}

GetWeaponTypeForClassname(String:classname[])
{
	new strWeaponType:weaponType;
	if (!GetTrieValue(g_hTrieWeapons, classname, weaponType))
	{
		return 0;
	}
	return weaponType;
}

GetPlayerIndexForClient(client)
{
	new var1;
	if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
	{
		return -1;
	}
	decl String:sSteamId[32];
	if (IsFakeClient(client))
	{
		Format(sSteamId, 32, "BOT_%i", GetPlayerCharacter(client));
	}
	else
	{
		GetClientAuthString(client, sSteamId, 32, true);
	}
	return GetPlayerIndexForSteamId(sSteamId, client);
}

GetPlayerIndexForSteamId(String:steamId[], client)
{
	new pIndex = -1;
	if (!GetTrieValue(g_hTriePlayers, steamId, pIndex))
	{
		pIndex = g_iPlayers;
		SetTrieValue(g_hTriePlayers, steamId, pIndex, true);
		strcopy(g_sPlayerId[pIndex], 32, steamId);
		if (client != -1)
		{
			GetClientName(client, g_sPlayerName[pIndex], 64);
			strcopy(g_sPlayerNameSafe[pIndex], 20, g_sPlayerName[pIndex]);
			stripUnicode(g_sPlayerNameSafe[pIndex], 20);
		}
		g_iPlayers += 1;
		if (g_iPlayers >= 64)
		{
			g_iPlayers = 4;
		}
	}
	return pIndex;
}

GetPlayerCharacter(client)
{
	new tmpChr = GetEntProp(client, PropType:0, "m_survivorCharacter", 4, 0);
	new var1;
	if (tmpChr < 0 || tmpChr >= 4)
	{
		decl String:model[256];
		GetEntPropString(client, PropType:1, "m_ModelName", model, 256, 0);
		if (StrContains(model, "gambler", true) != -1)
		{
			tmpChr = 0;
		}
		else
		{
			if (StrContains(model, "coach", true) != -1)
			{
				tmpChr = 2;
			}
			if (StrContains(model, "mechanic", true) != -1)
			{
				tmpChr = 3;
			}
			if (StrContains(model, "producer", true) != -1)
			{
				tmpChr = 1;
			}
			if (StrContains(model, "namvet", true) != -1)
			{
				tmpChr = 0;
			}
			if (StrContains(model, "teengirl", true) != -1)
			{
				tmpChr = 1;
			}
			if (StrContains(model, "biker", true) != -1)
			{
				tmpChr = 3;
			}
			if (StrContains(model, "manager", true) != -1)
			{
				tmpChr = 2;
			}
			tmpChr = 0;
		}
	}
	return tmpChr;
}

IsIndexSurvivor(index, bool:bInfectedInstead)
{
	if (index < 4)
	{
		return 1;
	}
	new tmpind;
	new client = 1;
	while (client <= MaxClients)
	{
		if (bInfectedInstead)
		{
			new var1;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client) && GetClientTeam(client) == 3)
			{
			}
		}
		else
		{
			new var4;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client) && GetClientTeam(client) == 2)
			{
			}
		}
		tmpind = GetPlayerIndexForClient(client);
		if (index == tmpind)
		{
			return 1;
		}
		client++;
	}
	return 0;
}

bool:IsWitch(iEntity)
{
	new var1;
	if (iEntity > 0 && IsValidEntity(iEntity) && IsValidEdict(iEntity))
	{
		decl String:strClassName[64];
		GetEdictClassname(iEntity, strClassName, 64);
		new strOEC:entType;
		if (!GetTrieValue(g_hTrieEntityCreated, strClassName, entType))
		{
			return false;
		}
		return entType == 1;
	}
	return false;
}

bool:IsCommon(iEntity)
{
	new var1;
	if (iEntity > 0 && IsValidEntity(iEntity) && IsValidEdict(iEntity))
	{
		decl String:strClassName[64];
		GetEdictClassname(iEntity, strClassName, 64);
		new strOEC:entType;
		if (!GetTrieValue(g_hTrieEntityCreated, strClassName, entType))
		{
			return false;
		}
		return entType == 0;
	}
	return false;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "IsTankInGame" (number 136)
bool:IsPlayerIncapacitated(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 1, 0);
}

bool:IsHangingFromLedge(client)
{
	new var1;
	return GetEntProp(client, PropType:0, "m_isHangingFromLedge", 4, 0) || GetEntProp(client, PropType:0, "m_isFallingFromLedge", 4, 0);
}

bool:IsPlayerIncapacitatedAtAll(client)
{
	new var1;
	return IsPlayerIncapacitated(client) || IsHangingFromLedge(client);
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "AreClientsConnected" (number 140)

/* ERROR! null */
 function "GetUprightSurvivors" (number 141)
public Action:Timer_WriteStats(Handle:timer, any:iTeam)
{
	WriteStatsToFile(iTeam, true);
	return Action:0;
}

WriteStatsToFile(iTeam, bool:bSecondHalf)
{
	if (g_bModeCampaign)
	{
		return 0;
	}
	new i;
	new j;
	new bool:bFirstWrite;
	new String:sStats[8192];
	new String:strTmpLine[512];
	decl String:sTmpTime[20];
	decl String:sTmpRoundNo[8];
	decl String:sTmpMap[64];
	new String:path[128];
	new var1;
	if (g_bModeCampaign || !bSecondHalf || !strlen(g_sStatsFile))
	{
		bFirstWrite = true;
		FormatTime(sTmpTime, 20, "%Y-%m-%d_%H-%M", -1);
		IntToString(g_iRound, sTmpRoundNo, 6);
		LeftPadString(sTmpRoundNo, 6, 4, true);
		GetCurrentMap(sTmpMap, 64);
		FormatEx(g_sStatsFile, 64, "%s_%s_%s.txt", sTmpTime, sTmpRoundNo, sTmpMap);
	}
	FormatEx(path, 128, "%s%s", "logs/", g_sStatsFile);
	BuildPath(PathType:0, path, 256, path);
	if (bFirstWrite)
	{
		FormatEx(strTmpLine, 512, "[Gameround:%i]\n", g_iRound);
		StrCat(sStats, 8192, strTmpLine);
		FormatTime(sTmpTime, 20, "%Y-%m-%d;%H:%M", -1);
		FormatEx(strTmpLine, 512, "%i;%s;%i;%s;%s;\n\n", g_iRound, sTmpTime, g_iTeamSize, g_sConfigName, sTmpMap);
		StrCat(sStats, 8192, strTmpLine);
	}
	FormatEx(strTmpLine, 512, "[RoundHalf:%i]\n", bSecondHalf);
	StrCat(sStats, 8192, strTmpLine);
	new var2;
	if (iTeam)
	{
		var2[0] = 210300;
	}
	else
	{
		var2[0] = 210296;
	}
	FormatEx(strTmpLine, 512, "%i;%s;", bSecondHalf, var2);
	i = 0;
	while (i <= 18)
	{
		Format(strTmpLine, 512, "%s%i;", strTmpLine, g_strRoundData[g_iRound][iTeam][i]);
		i++;
	}
	Format(strTmpLine, 512, "%s\n\n", strTmpLine);
	StrCat(sStats, 8192, strTmpLine);
	new Float:maxFlowDist = L4D2Direct_GetMapMaxFlowDistance();
	new Float:curFlowDist[66] = 0.0;
	new Float:farFlowDist[66] = 0.0;
	new clients;
	i = 1;
	while (i <= MaxClients)
	{
		new var3;
		if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && GetClientTeam(i) == 2)
		{
		}
	}
	new var6;
	if (iTeam)
	{
		var6[0] = 210340;
	}
	else
	{
		var6[0] = 210336;
	}
	FormatEx(strTmpLine, 512, "[Progress:%s]\n", var6);
	StrCat(sStats, 8192, strTmpLine);
	new var7;
	if (iTeam)
	{
		var7[0] = 210368;
	}
	else
	{
		var7[0] = 210364;
	}
	FormatEx(strTmpLine, 512, "%i;%s;%i;%i;%.2f;", g_bSecondHalf, var7, g_iSurvived[iTeam], L4D_GetVersusMaxCompletionScore(), maxFlowDist);
	i = 0;
	while (i < clients)
	{
		new var8;
		if (i < 4)
		{
			var8 = farFlowDist[i];
		}
		else
		{
			var8 = 0;
		}
		Format(strTmpLine, 512, "%s%.2f;%.2f;", strTmpLine, var8, curFlowDist[i]);
		i++;
	}
	Format(strTmpLine, 512, "%s\n\n", strTmpLine);
	StrCat(sStats, 8192, strTmpLine);
	new var9;
	if (iTeam)
	{
		var9[0] = 210416;
	}
	else
	{
		var9[0] = 210412;
	}
	FormatEx(strTmpLine, 512, "[Players:%s]:\n", var9);
	StrCat(sStats, 8192, strTmpLine);
	new iPlayerCount;
	j = 4;
	while (j < g_iPlayers)
	{
		if (!(iTeam != g_iPlayerRoundTeam[iTeam][j]))
		{
			iPlayerCount++;
			FormatEx(strTmpLine, 512, "%i;%i;%s;", iPlayerCount, j, g_sPlayerId[j]);
			i = 0;
			while (i <= 76)
			{
				Format(strTmpLine, 512, "%s%i;", strTmpLine, g_strRoundPlayerData[j][iTeam][i]);
				i++;
			}
			Format(strTmpLine, 512, "%s\n", strTmpLine);
			StrCat(sStats, 8192, strTmpLine);
		}
		j++;
	}
	StrCat(sStats, 8192, "\n");
	new var10;
	if (iTeam)
	{
		var10[0] = 210476;
	}
	else
	{
		var10[0] = 210472;
	}
	FormatEx(strTmpLine, 512, "[InfectedPlayers:%s]:\n", var10);
	StrCat(sStats, 8192, strTmpLine);
	iPlayerCount = 0;
	j = 4;
	while (j < g_iPlayers)
	{
		new var11;
		if (iTeam != g_iPlayerRoundTeam[iTeam][j])
		{
			var11 = 0;
		}
		else
		{
			var11 = 1;
		}
		if (!(var11))
		{
			new var12;
			if (!((g_strRoundPlayerInfData[j][iTeam][23] && g_strRoundPlayerInfData[j][iTeam][24]) || (g_strRoundPlayerInfData[j][iTeam][15] && g_strRoundPlayerInfData[j][iTeam][22])))
			{
				iPlayerCount++;
				FormatEx(strTmpLine, 512, "%i;%i;%s;", iPlayerCount, j, g_sPlayerId[j]);
				i = 0;
				while (i <= 24)
				{
					Format(strTmpLine, 512, "%s%i;", strTmpLine, g_strRoundPlayerInfData[j][iTeam][i]);
					i++;
				}
				Format(strTmpLine, 512, "%s\n", strTmpLine);
				StrCat(sStats, 8192, strTmpLine);
			}
		}
		j++;
	}
	StrCat(sStats, 8192, "\n");
	if (!bFirstWrite)
	{
		FormatEx(strTmpLine, 512, "[Scoring:]\n");
		StrCat(sStats, 8192, strTmpLine);
		new var15;
		if (g_bCMTSwapped)
		{
			var15 = 0;
		}
		else
		{
			var15 = 1;
		}
		new var16;
		if (g_bCMTSwapped)
		{
			var16 = 1;
		}
		else
		{
			var16 = 0;
		}
		FormatEx(strTmpLine, 512, "A;%i;%i;B;%i;%i;\n\n", g_iScores[0] - g_iFirstScoresSet[var16], g_iScores, g_iScores[1] - g_iFirstScoresSet[var15], 2020 + 4);
		StrCat(sStats, 8192, strTmpLine);
		FormatEx(strTmpLine, 512, "[PlayerNames:]:\n");
		StrCat(sStats, 8192, strTmpLine);
		iPlayerCount = 0;
		j = 4;
		while (j < g_iPlayers)
		{
			new var17;
			if (!strlen(g_sPlayerId[j]) || !strlen(g_sPlayerName[j]))
			{
			}
			else
			{
				iPlayerCount++;
				FormatEx(strTmpLine, 512, "%i;%s;%s\n", iPlayerCount, g_sPlayerId[j], g_sPlayerName[j]);
				StrCat(sStats, 8192, strTmpLine);
			}
			j++;
		}
		StrCat(sStats, 8192, "\n");
	}
	new Handle:fh = OpenFile(path, "a");
	if (fh)
	{
		WriteFileString(fh, sStats, false);
		CloseHandle(fh);
		if (GetConVarInt(g_hCvarWriteStats) > 1)
		{
			g_hStatsFile = OpenFile(path, "a");
			if (g_hStatsFile)
			{
				AutomaticPrintPerClient(164532, -2, iTeam, false, false, false, false);
				CloseHandle(g_hStatsFile);
			}
			PrintDebug(0, "Error [table printing]: could not write to file: '%s'.", path);
			return 0;
		}
		return 0;
	}
	PrintDebug(0, "Error: could not write to file: '%s'.", path);
	return 0;
}

InitTries()
{
	g_hTriePlayers = CreateTrie();
	SetTrieValue(g_hTriePlayers, "BOT_0", any:0, true);
	SetTrieValue(g_hTriePlayers, "BOT_1", any:1, true);
	SetTrieValue(g_hTriePlayers, "BOT_2", any:2, true);
	SetTrieValue(g_hTriePlayers, "BOT_3", any:3, true);
	new var1 = g_sPlayerName;
	new var2 = g_sPlayerId;
	g_iPlayers = g_iPlayers + 4;
	new i;
	while (i < 4)
	{
		i++;
	}
	g_hTrieWeapons = CreateTrie();
	SetTrieValue(g_hTrieWeapons, "weapon_pistol", any:4, true);
	SetTrieValue(g_hTrieWeapons, "weapon_pistol_magnum", any:4, true);
	SetTrieValue(g_hTrieWeapons, "weapon_pumpshotgun", any:1, true);
	SetTrieValue(g_hTrieWeapons, "weapon_shotgun_chrome", any:1, true);
	SetTrieValue(g_hTrieWeapons, "weapon_autoshotgun", any:1, true);
	SetTrieValue(g_hTrieWeapons, "weapon_shotgun_spas", any:1, true);
	SetTrieValue(g_hTrieWeapons, "weapon_hunting_rifle", any:3, true);
	SetTrieValue(g_hTrieWeapons, "weapon_sniper_military", any:3, true);
	SetTrieValue(g_hTrieWeapons, "weapon_sniper_awp", any:3, true);
	SetTrieValue(g_hTrieWeapons, "weapon_sniper_scout", any:3, true);
	SetTrieValue(g_hTrieWeapons, "weapon_smg", any:2, true);
	SetTrieValue(g_hTrieWeapons, "weapon_smg_silenced", any:2, true);
	SetTrieValue(g_hTrieWeapons, "weapon_smg_mp5", any:2, true);
	SetTrieValue(g_hTrieWeapons, "weapon_rifle", any:2, true);
	SetTrieValue(g_hTrieWeapons, "weapon_rifle_desert", any:2, true);
	SetTrieValue(g_hTrieWeapons, "weapon_rifle_ak47", any:2, true);
	SetTrieValue(g_hTrieWeapons, "weapon_rifle_sg552", any:2, true);
	SetTrieValue(g_hTrieWeapons, "weapon_rifle_m60", any:2, true);
	g_hTrieEntityCreated = CreateTrie();
	SetTrieValue(g_hTrieEntityCreated, "infected", any:0, true);
	SetTrieValue(g_hTrieEntityCreated, "witch", any:1, true);
	g_hTrieMaps = CreateTrie();
	SetTrieValue(g_hTrieMaps, "c1m4_atrium", any:0, true);
	SetTrieValue(g_hTrieMaps, "c2m5_concert", any:0, true);
	SetTrieValue(g_hTrieMaps, "c3m4_plantation", any:0, true);
	SetTrieValue(g_hTrieMaps, "c4m5_milltown_escape", any:0, true);
	SetTrieValue(g_hTrieMaps, "c5m5_bridge", any:0, true);
	SetTrieValue(g_hTrieMaps, "c6m3_port", any:0, true);
	SetTrieValue(g_hTrieMaps, "c7m3_port", any:0, true);
	SetTrieValue(g_hTrieMaps, "c8m5_rooftop", any:0, true);
	SetTrieValue(g_hTrieMaps, "c9m2_lots", any:0, true);
	SetTrieValue(g_hTrieMaps, "c10m5_houseboat", any:0, true);
	SetTrieValue(g_hTrieMaps, "c11m5_runway", any:0, true);
	SetTrieValue(g_hTrieMaps, "c12m5_cornfield", any:0, true);
	SetTrieValue(g_hTrieMaps, "c13m4_cutthroatcreek", any:0, true);
	return 0;
}

LeftPadString(String:text[], maxlength, cutOff, bool:bNumber)
{
	new tmp[maxlength];
	new safe;
	strcopy(tmp, maxlength, text);
	if (!bNumber)
	{
		while (strlen(tmp) < cutOff && safe < 1000)
		{
			Format(tmp, maxlength, " %s", tmp);
			safe++;
		}
	}
	strcopy(text, maxlength, tmp);
	return 0;
}

RightPadString(String:text[], maxlength, cutOff)
{
	new tmp[maxlength];
	new safe;
	strcopy(tmp, maxlength, text);
	while (strlen(tmp) < cutOff && safe < 1000)
	{
		Format(tmp, maxlength, "%s ", tmp);
		safe++;
	}
	strcopy(text, maxlength, tmp);
	return 0;
}

FormatTimeAsDuration(String:text[], maxlength, time, bool:bPad)
{
	new tmp[maxlength];
	if (time < 1)
	{
		Format(text, maxlength, "");
		return 0;
	}
	if (time > 3600)
	{
		new tmpHr = RoundToFloor(float(time) / 3600.0);
		Format(tmp, maxlength, "%ih", tmpHr);
		time -= tmpHr * 3600;
	}
	if (time > 60)
	{
		if (strlen(tmp))
		{
			Format(tmp, maxlength, "%s ", tmp);
		}
		new tmpMin = RoundToFloor(float(time) / 60.0);
		new var1;
		if (bPad && tmpMin < 10)
		{
			var2[0] = 211432;
		}
		else
		{
			var2[0] = 211436;
		}
		Format(tmp, maxlength, "%s%im", var2, tmpMin);
		time -= tmpMin * 60;
	}
	if (time)
	{
		new var3;
		if (bPad && time < 10)
		{
			var4[0] = 211460;
		}
		else
		{
			var4[0] = 211464;
		}
		new var5;
		if (strlen(tmp))
		{
			var5[0] = 211452;
		}
		else
		{
			var5[0] = 211456;
		}
		Format(tmp, maxlength, "%s%s%s%is", tmp, var5, var4, time);
	}
	strcopy(text, maxlength, tmp);
	return 0;
}

FormatPercentage(String:text[], maxlength, part, whole, bool:bDecimal)
{
	new strTmp[maxlength];
	new var1;
	if (!whole || !part)
	{
		FormatEx(strTmp, maxlength, "");
		strcopy(text, maxlength, strTmp);
		return 0;
	}
	if (bDecimal)
	{
		new Float:fValue = float(part) / float(whole) * 100.0;
		FormatEx(strTmp, maxlength, "%3.1f", fValue);
	}
	else
	{
		new iValue = RoundFloat(float(part) / float(whole) * 100.0);
		FormatEx(strTmp, maxlength, "%i", iValue);
	}
	strcopy(text, maxlength, strTmp);
	return 0;
}

CheckGameMode()
{
	new String:tmpStr[24];
	GetConVarString(FindConVar("mp_gamemode"), tmpStr, 24);
	new var1;
	if (StrEqual(tmpStr, "coop", false) || StrEqual(tmpStr, "mutation4", false) || StrEqual(tmpStr, "mutation14", false) || StrEqual(tmpStr, "mutation20", false) || StrEqual(tmpStr, "mutationrandomcoop", false))
	{
		g_bModeCampaign = true;
		g_bModeScavenge = false;
	}
	else
	{
		if (StrEqual(tmpStr, "scavenge", false))
		{
			g_bModeCampaign = false;
			g_bModeScavenge = true;
		}
		g_bModeCampaign = false;
		g_bModeScavenge = false;
	}
	return 0;
}

IsMissionFinalMap()
{
	new strMapType:mapType;
	if (!GetTrieValue(g_hTrieMaps, g_sMapName[g_iRound], mapType))
	{
		return 0;
	}
	return mapType == 0;
}

stripUnicode(String:testString[64], maxLength)
{
	if (maxLength < 1)
	{
		maxLength = 64;
	}
	decl tmpString[maxLength];
	strcopy(tmpString, maxLength, testString);
	new uni;
	new currentChar;
	new tmpCharLength;
	new i;
	while (i < maxLength && tmpString[i])
	{
		if (tmpString[i] & '')
		{
			new var2;
			if (i < maxLength + -1 && tmpString[i] & 224 == 192 && tmpString[i + 1] & 192 == 128)
			{
				i++;
				currentChar = tmpString[i] & 31;
				currentChar <<= 6;
				currentChar = tmpString[i] & 63 + currentChar;
				tmpCharLength = 1;
			}
			new var3;
			if (i < maxLength + -2 && tmpString[i] & 240 == 224 && tmpString[i + 1] & 192 == 128 && tmpString[i + 2] & 192 == 128)
			{
				i++;
				currentChar = tmpString[i] & 15;
				currentChar <<= 6;
				i++;
				currentChar = tmpString[i] & 63 + currentChar;
				currentChar <<= 6;
				currentChar = tmpString[i] & 63 + currentChar;
				tmpCharLength = 2;
			}
			new var4;
			if (i < maxLength + -3 && tmpString[i] & 248 == 240 && tmpString[i + 1] & 192 == 128 && tmpString[i + 2] & 192 == 128 && tmpString[i + 3] & 192 == 128)
			{
				i++;
				currentChar = tmpString[i] & 7;
				currentChar <<= 6;
				i++;
				currentChar = tmpString[i] & 63 + currentChar;
				currentChar <<= 6;
				i++;
				currentChar = tmpString[i] & 63 + currentChar;
				currentChar <<= 6;
				currentChar = tmpString[i] & 63 + currentChar;
				tmpCharLength = 3;
			}
			currentChar = 161;
			tmpCharLength = 0;
		}
		else
		{
			currentChar = tmpString[i];
			tmpCharLength = 0;
		}
		if (currentChar > 160)
		{
			uni++;
			new j = tmpCharLength;
			while (0 <= j)
			{
				tmpString[i - j] = MissingTAG:95;
				j--;
			}
		}
		i++;
	}
	if (strlen(tmpString) > maxLength)
	{
		tmpString[maxLength] = MissingTAG:0;
	}
	strcopy(testString, maxLength, tmpString);
	return 0;
}

PrintDebug(debugLevel, String:Message[])
{
	if (GetConVarInt(g_hCvarDebug) >= debugLevel)
	{
		decl String:DebugBuff[256];
		VFormat(DebugBuff, 256, Message, 3);
		LogMessage(DebugBuff);
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new lastHumanTank = -1;
public Plugin:myinfo =
{
	name = "L4D2 Profitless AI Tank",
	description = "Passing control to AI Tank will no longer be rewarded with an instant respawn",
	author = "Visor",
	version = "0.3",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	HookEvent("tank_frustrated", OnTankFrustrated, EventHookMode:1);
	return 0;
}

public OnTankFrustrated(Handle:event, String:name[], bool:dontBroadcast)
{
	new tank = GetClientOfUserId(GetEventInt(event, "userid"));
	if (!IsFakeClient(tank))
	{
		lastHumanTank = tank;
		CreateTimer(0.1, CheckForAITank, any:0, 2);
	}
	return 0;
}

public Action:CheckForAITank(Handle:timer)
{
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsTank(i) && IsFakeClient(i))
		{
			if (IsInfected(lastHumanTank))
			{
				ForcePlayerSuicide(lastHumanTank);
			}
			return Action:3;
		}
		i++;
	}
	return Action:3;
}

bool:IsTank(client)
{
	new var1;
	return IsInfected(client) && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:21"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:MeleeWeaponModels[15][];
new String:MeleeWeaponNames[15][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1414218835, 1936486255, 0, 1953195123, 1936486255, 1954047278, 0, 1208, 1220, 1, 1, 1699176301, 1919247470, 0, 0, 843330636, 1869173280, 1866670196, 29552, 2053661002, 1444949093, 1919906665, 0, 3288625, 1869376577, 1769087095, 1663071343, 544436335, 1646292852, 1768628325, 1684368492, 544825888, 1701322849, 1752392801, 29807, 0, 1268, 1304, 1284, 1300, 1348, 7157091, 1701211753, 1684370531, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new bool:bPluginActive;
new Handle:hMeleeWeaponModelsTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hSurvivorModelsTrie;
new Handle:hWeaponNamesTrie;
public Plugin:myinfo =
{
	name = "L4D2 Riot Cops",
	description = "Allow riot cops to be killed by a headshot",
	author = "Jahze, Visor",
	version = "1.2",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

L4D2_Gender:GetGender(entity)
{
	return GetEntProp(entity, PropType:0, L4D2_InfectedTimerEntities, 4, 0);
}

public OnMapStart()
{
	decl String:sMap[128];
	GetCurrentMap(sMap, 128);
	new var1;
	if (StrContains(sMap, "c5m", false) > -1)
	{
		var1 = 1;
	}
	else
	{
		var1 = 0;
	}
	bPluginActive = var1;
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	if (!bPluginActive)
	{
		return 0;
	}
	new var1;
	if (entity <= 0 || entity > 2048)
	{
		return 0;
	}
	if (StrEqual("infected", classname, true))
	{
		SDKHook(entity, SDKHookType:24, RiotCopSpawn);
	}
	return 0;
}

public RiotCopSpawn(entity)
{
	if (GetGender(entity) == 15)
	{
		SDKHook(entity, SDKHookType:11, RiotCopTraceAttack);
	}
	return 0;
}

public Action:RiotCopTraceAttack(victim, &attacker, &inflictor, &Float:damage, &damageType, &ammotype, hitbox, hitgroup)
{
	if (!attacker)
	{
		return Action:0;
	}
	if (hitgroup == 1)
	{
		SDKHooks_TakeDamage(victim, 0, attacker, damage, 0, -1, NULL_VECTOR, NULL_VECTOR);
		return Action:3;
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4181",
	date = "03/11/2014",
	time = "23:40:54"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_lgofnoc =
{
	name = "lgofnoc",
	file = "lgofnoc.smx",
	required = 0,
};
new String:MAPINFO_PATH[28] = "configs/saferoominfo.txt";
public Plugin:myinfo =
{
	name = "Precise saferoom detection",
	description = "Allows checks whether a coordinate/entity/player is in start or end saferoom (uses saferoominfo.txt).",
	author = "Tabun",
	version = "0.0.7",
	url = ""
};
new bool:g_bLGOIsAvailable;
new Handle:g_kSIData;
new g_iMode;
new String:g_sMapname[64];
new bool:g_bHasStart;
new bool:g_bHasStartExtra;
new Float:g_fStartLocA[3];
new Float:g_fStartLocB[3];
new Float:g_fStartLocC[3];
new Float:g_fStartLocD[3];
new Float:g_fStartRotate;
new bool:g_bHasEnd;
new bool:g_bHasEndExtra;
new Float:g_fEndLocA[3];
new Float:g_fEndLocB[3];
new Float:g_fEndLocC[3];
new Float:g_fEndLocD[3];
new Float:g_fEndRotate;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator!=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) != 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator>=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) >= 0;
}

bool:operator<(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) < 0;
}

bool:operator<=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) <= 0;
}

bool:operator!(Float:)(Float:oper)
{
	return oper & -1 == 0;
}

GetEntSendPropOffs(ent, String:prop[], bool:actual)
{
	decl String:cls[64];
	if (!GetEntityNetClass(ent, cls, 64))
	{
		return -1;
	}
	if (actual)
	{
		return FindSendPropInfo(cls, prop, 0, 0, 0);
	}
	return FindSendPropOffs(cls, prop);
}

public __pl_lgofnoc_SetNTVOptional()
{
	MarkNativeAsOptional("LGO_BuildConfigPath");
	MarkNativeAsOptional("LGO_ExecuteConfigCfg");
	MarkNativeAsOptional("LGO_IsMapDataAvailable");
	MarkNativeAsOptional("LGO_GetMapValueInt");
	MarkNativeAsOptional("LGO_GetMapValueFloat");
	MarkNativeAsOptional("LGO__GetMapValueVector");
	MarkNativeAsOptional("LGO_GetMapValueString");
	MarkNativeAsOptional("LGO_CopyMapSubsection");
	MarkNativeAsOptional("LGO_IsMatchModeLoaded");
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	CreateNative("SAFEDETECT_IsEntityInStartSaferoom", Native_IsEntityInStartSaferoom);
	CreateNative("SAFEDETECT_IsPlayerInStartSaferoom", Native_IsPlayerInStartSaferoom);
	CreateNative("SAFEDETECT_IsEntityInEndSaferoom", Native_IsEntityInEndSaferoom);
	CreateNative("SAFEDETECT_IsPlayerInEndSaferoom", Native_IsPlayerInEndSaferoom);
	RegPluginLibrary("saferoom_detect");
	MarkNativeAsOptional("LGO_IsMapDataAvailable");
	MarkNativeAsOptional("LGO_GetMapValueVector");
	MarkNativeAsOptional("LGO_GetMapValueFloat");
	return APLRes:0;
}

public OnAllPluginsLoaded()
{
	g_bLGOIsAvailable = LibraryExists("lgofnoc");
	return 0;
}

public Native_IsEntityInStartSaferoom(Handle:plugin, numParams)
{
	new entity = GetNativeCell(1);
	return IsEntityInStartSaferoom(entity);
}

public Native_IsEntityInEndSaferoom(Handle:plugin, numParams)
{
	new entity = GetNativeCell(1);
	return IsEntityInEndSaferoom(entity);
}

public Native_IsPlayerInStartSaferoom(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	return IsPlayerInStartSaferoom(client);
}

public Native_IsPlayerInEndSaferoom(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	return IsPlayerInEndSaferoom(client);
}

public OnPluginStart()
{
	SI_KV_Load();
	return 0;
}

public OnPluginEnd()
{
	SI_KV_Close();
	return 0;
}

public OnMapStart()
{
	GetCurrentMap(g_sMapname, 64);
	new var1;
	if (SI_KV_UpdateSaferoomInfo())
	{
		var1 = 1;
	}
	else
	{
		var1 = 0;
	}
	g_iMode = var1;
	return 0;
}

public OnMapEnd()
{
	KvRewind(g_kSIData);
	return 0;
}

public IsEntityInStartSaferoom(entity)
{
	new var1;
	if (!IsValidEntity(entity) || GetEntSendPropOffs(entity, "m_vecOrigin", true) == -1)
	{
		return 0;
	}
	new Float:location[3] = 0.0;
	GetEntPropVector(entity, PropType:0, "m_vecOrigin", location, 0);
	return IsPointInStartSaferoom(location, -1);
}

public IsEntityInEndSaferoom(entity)
{
	new var1;
	if (!IsValidEntity(entity) || GetEntSendPropOffs(entity, "m_vecOrigin", true) == -1)
	{
		return 0;
	}
	new Float:location[3] = 0.0;
	GetEntPropVector(entity, PropType:0, "m_vecOrigin", location, 0);
	return IsPointInEndSaferoom(location, -1);
}

public IsPlayerInStartSaferoom(client)
{
	new var1;
	if (client < 1 || client > MaxClients || !IsClientInGame(client))
	{
		return 0;
	}
	new Float:locationA[3] = 0.0;
	new Float:locationB[3] = 0.0;
	GetClientAbsOrigin(client, locationA);
	GetClientEyePosition(client, locationB);
	new var2;
	return IsPointInStartSaferoom(locationA, -1) || IsPointInStartSaferoom(locationB, -1);
}

public IsPlayerInEndSaferoom(client)
{
	new var1;
	if (client < 1 || client > MaxClients || !IsClientInGame(client))
	{
		return 0;
	}
	new Float:locationA[3] = 0.0;
	new Float:locationB[3] = 0.0;
	GetClientAbsOrigin(client, locationA);
	GetClientEyePosition(client, locationB);
	new var2;
	return IsPointInEndSaferoom(locationA, -1) || IsPointInEndSaferoom(locationB, -1);
}

IsPointInStartSaferoom(Float:location[3], entity)
{
	if (g_iMode == 1)
	{
		if (!g_bHasStart)
		{
			return 0;
		}
		new bool:inSaferoom;
		if (g_fStartRotate)
		{
			RotatePoint(g_fStartLocA, location, location[1], g_fStartRotate);
		}
		new Float:xMin = 0.0;
		new Float:xMax = 0.0;
		new Float:yMin = 0.0;
		new Float:yMax = 0.0;
		new Float:zMin = 0.0;
		new Float:zMax = 0.0;
		if (g_fStartLocA[0] < g_fStartLocB[0])
		{
			xMin = g_fStartLocA[0];
			xMax = g_fStartLocB[0];
		}
		else
		{
			xMin = g_fStartLocB[0];
			xMax = g_fStartLocA[0];
		}
		if (g_fStartLocA[1] < g_fStartLocB[1])
		{
			yMin = g_fStartLocA[1];
			yMax = g_fStartLocB[1];
		}
		else
		{
			yMin = g_fStartLocB[1];
			yMax = g_fStartLocA[1];
		}
		if (g_fStartLocA[2] < g_fStartLocB[2])
		{
			zMin = g_fStartLocA[2];
			zMax = g_fStartLocB[2];
		}
		else
		{
			zMin = g_fStartLocB[2];
			zMax = g_fStartLocA[2];
		}
		PrintDebug("dimensions checked: %f - %f (%f) -- %f - %f (%f) -- %f - %f (%f)", xMin, xMax, location, yMin, yMax, location[1], zMin, zMax, location[2]);
		new var1;
		inSaferoom = location[0] >= xMin && location[0] <= xMax && location[1] >= yMin && location[1] <= yMax && location[2] >= zMin && location[2] <= zMax;
		new var2;
		if (!inSaferoom && g_bHasStartExtra)
		{
			if (g_fStartLocC[0] < g_fStartLocD[0])
			{
				xMin = g_fStartLocC[0];
				xMax = g_fStartLocD[0];
			}
			else
			{
				xMin = g_fStartLocD[0];
				xMax = g_fStartLocC[0];
			}
			if (g_fStartLocC[1] < g_fStartLocD[1])
			{
				yMin = g_fStartLocC[1];
				yMax = g_fStartLocD[1];
			}
			else
			{
				yMin = g_fStartLocD[1];
				yMax = g_fStartLocC[1];
			}
			if (g_fStartLocC[2] < g_fStartLocD[2])
			{
				zMin = g_fStartLocC[2];
				zMax = g_fStartLocD[2];
			}
			else
			{
				zMin = g_fStartLocD[2];
				zMax = g_fStartLocC[2];
			}
			PrintDebug("extra dimensions checked: %f - %f (%f) -- %f - %f (%f) -- %f - %f (%f)", xMin, xMax, location, yMin, yMax, location[1], zMin, zMax, location[2]);
			new var3;
			if (location[0] >= xMin && location[0] <= xMax && location[1] >= yMin && location[1] <= yMax && location[2] >= zMin && location[2] <= zMax)
			{
			}
		}
		return inSaferoom;
	}
	if (g_bLGOIsAvailable)
	{
		new Float:saferoom_distance = LGO_GetMapValueFloat("start_dist", 200.0);
		new Float:saferoom_distance_extra = LGO_GetMapValueFloat("start_extra_dist", 0.0);
		new Float:saferoom[3] = 0.0;
		LGO_GetMapValueVector("start_point", saferoom, NULL_VECTOR);
		new var4;
		if (entity != -1 && IsValidEntity(entity) && GetEntSendPropOffs(entity, "m_vecOrigin", true) != -1)
		{
			GetEntPropVector(entity, PropType:0, "m_vecOrigin", location, 0);
		}
		new var5;
		if (saferoom_distance_extra > saferoom_distance)
		{
			var5 = saferoom_distance_extra;
		}
		else
		{
			var5 = saferoom_distance;
		}
		return GetVectorDistance(location, saferoom, false) <= var5;
	}
	return 0;
}

IsPointInEndSaferoom(Float:location[3], entity)
{
	if (g_iMode == 1)
	{
		if (!g_bHasEnd)
		{
			return 0;
		}
		new bool:inSaferoom;
		if (g_fEndRotate)
		{
			RotatePoint(g_fEndLocA, location, location[1], g_fEndRotate);
		}
		new Float:xMin = 0.0;
		new Float:xMax = 0.0;
		new Float:yMin = 0.0;
		new Float:yMax = 0.0;
		new Float:zMin = 0.0;
		new Float:zMax = 0.0;
		if (g_fEndLocA[0] < g_fEndLocB[0])
		{
			xMin = g_fEndLocA[0];
			xMax = g_fEndLocB[0];
		}
		else
		{
			xMin = g_fEndLocB[0];
			xMax = g_fEndLocA[0];
		}
		if (g_fEndLocA[1] < g_fEndLocB[1])
		{
			yMin = g_fEndLocA[1];
			yMax = g_fEndLocB[1];
		}
		else
		{
			yMin = g_fEndLocB[1];
			yMax = g_fEndLocA[1];
		}
		if (g_fEndLocA[2] < g_fEndLocB[2])
		{
			zMin = g_fEndLocA[2];
			zMax = g_fEndLocB[2];
		}
		else
		{
			zMin = g_fEndLocB[2];
			zMax = g_fEndLocA[2];
		}
		PrintDebug("dimensions checked: %f - %f (%f) -- %f - %f (%f) -- %f - %f (%f)", xMin, xMax, location, yMin, yMax, location[1], zMin, zMax, location[2]);
		new var1;
		inSaferoom = location[0] >= xMin && location[0] <= xMax && location[1] >= yMin && location[1] <= yMax && location[2] >= zMin && location[2] <= zMax;
		new var2;
		if (!inSaferoom && g_bHasEndExtra)
		{
			if (g_fEndLocC[0] < g_fEndLocD[0])
			{
				xMin = g_fEndLocC[0];
				xMax = g_fEndLocD[0];
			}
			else
			{
				xMin = g_fEndLocD[0];
				xMax = g_fEndLocC[0];
			}
			if (g_fEndLocC[1] < g_fEndLocD[1])
			{
				yMin = g_fEndLocC[1];
				yMax = g_fEndLocD[1];
			}
			else
			{
				yMin = g_fEndLocD[1];
				yMax = g_fEndLocC[1];
			}
			if (g_fEndLocC[2] < g_fEndLocD[2])
			{
				zMin = g_fEndLocC[2];
				zMax = g_fEndLocD[2];
			}
			else
			{
				zMin = g_fEndLocD[2];
				zMax = g_fEndLocC[2];
			}
			PrintDebug("extra dimensions checked: %f - %f (%f) -- %f - %f (%f) -- %f - %f (%f)", xMin, xMax, location, yMin, yMax, location[1], zMin, zMax, location[2]);
			new var3;
			if (location[0] >= xMin && location[0] <= xMax && location[1] >= yMin && location[1] <= yMax && location[2] >= zMin && location[2] <= zMax)
			{
			}
		}
		return inSaferoom;
	}
	if (g_bLGOIsAvailable)
	{
		new Float:saferoom_distance = LGO_GetMapValueFloat("end_dist", 200.0);
		new Float:saferoom[3] = 0.0;
		LGO_GetMapValueVector("end_point", saferoom, NULL_VECTOR);
		new var4;
		if (entity != -1 && IsValidEntity(entity) && GetEntSendPropOffs(entity, "m_vecOrigin", true) != -1)
		{
			GetEntPropVector(entity, PropType:0, "m_vecOrigin", location, 0);
		}
		return GetVectorDistance(location, saferoom, false) <= saferoom_distance;
	}
	return 0;
}

SI_KV_Close()
{
	if (g_kSIData)
	{
		CloseHandle(g_kSIData);
		g_kSIData = MissingTAG:0;
		return 0;
	}
	return 0;
}

SI_KV_Load()
{
	decl String:sNameBuff[256];
	g_kSIData = CreateKeyValues("SaferoomInfo", "", "");
	BuildPath(PathType:0, sNameBuff, 256, MAPINFO_PATH);
	if (!FileToKeyValues(g_kSIData, sNameBuff))
	{
		LogError("[SI] Couldn't load SaferoomInfo data!");
		SI_KV_Close();
		return 0;
	}
	return 0;
}

bool:SI_KV_UpdateSaferoomInfo()
{
	if (g_kSIData)
	{
		g_bHasStart = false;
		g_bHasStartExtra = false;
		g_bHasEnd = false;
		g_bHasEndExtra = false;
		g_fStartRotate = 0.0;
		g_fEndRotate = 0.0;
		if (KvJumpToKey(g_kSIData, g_sMapname, false))
		{
			KvGetVector(g_kSIData, "start_loc_a", g_fStartLocA, 2640);
			KvGetVector(g_kSIData, "start_loc_b", g_fStartLocB, 2640);
			KvGetVector(g_kSIData, "start_loc_c", g_fStartLocC, 2640);
			KvGetVector(g_kSIData, "start_loc_d", g_fStartLocD, 2640);
			g_fStartRotate = KvGetFloat(g_kSIData, "start_rotate", g_fStartRotate);
			KvGetVector(g_kSIData, "end_loc_a", g_fEndLocA, 2640);
			KvGetVector(g_kSIData, "end_loc_b", g_fEndLocB, 2640);
			KvGetVector(g_kSIData, "end_loc_c", g_fEndLocC, 2640);
			KvGetVector(g_kSIData, "end_loc_d", g_fEndLocD, 2640);
			g_fEndRotate = KvGetFloat(g_kSIData, "end_rotate", g_fEndRotate);
			new var1;
			if (0.0 != g_fStartLocA[0] && 0.0 != g_fStartLocA[1] && 0.0 != g_fStartLocA[2] && 0.0 != g_fStartLocB[0] && 0.0 != g_fStartLocB[1] && 0.0 != g_fStartLocB[2])
			{
				g_bHasStart = true;
			}
			new var2;
			if (0.0 != g_fStartLocC[0] && 0.0 != g_fStartLocC[1] && 0.0 != g_fStartLocC[2] && 0.0 != g_fStartLocD[0] && 0.0 != g_fStartLocD[1] && 0.0 != g_fStartLocD[2])
			{
				g_bHasStartExtra = true;
			}
			new var3;
			if (0.0 != g_fEndLocA[0] && 0.0 != g_fEndLocA[1] && 0.0 != g_fEndLocA[2] && 0.0 != g_fEndLocB[0] && 0.0 != g_fEndLocB[1] && 0.0 != g_fEndLocB[2])
			{
				g_bHasEnd = true;
			}
			new var4;
			if (0.0 != g_fEndLocC[0] && 0.0 != g_fEndLocC[1] && 0.0 != g_fEndLocC[2] && 0.0 != g_fEndLocD[0] && 0.0 != g_fEndLocD[1] && 0.0 != g_fEndLocD[2])
			{
				g_bHasEndExtra = true;
			}
			if (0.0 != g_fStartRotate)
			{
				RotatePoint(g_fStartLocA, g_fStartLocB, 1744 + 4, g_fStartRotate);
				if (g_bHasStartExtra)
				{
					RotatePoint(g_fStartLocA, g_fStartLocC, 1756 + 4, g_fStartRotate);
					RotatePoint(g_fStartLocA, g_fStartLocD, 1768 + 4, g_fStartRotate);
				}
			}
			if (0.0 != g_fEndRotate)
			{
				RotatePoint(g_fEndLocA, g_fEndLocB, 1804 + 4, g_fEndRotate);
				if (g_bHasEndExtra)
				{
					RotatePoint(g_fEndLocA, g_fEndLocC, 1816 + 4, g_fEndRotate);
					RotatePoint(g_fEndLocA, g_fEndLocD, 1828 + 4, g_fEndRotate);
				}
			}
			return true;
		}
		LogMessage("[SI] SaferoomInfo for %s is missing.", g_sMapname);
		return false;
	}
	LogError("[SI] No saferoom keyvalues loaded!");
	return false;
}

RotatePoint(Float:origin[3], &Float:pointX, &Float:pointY, Float:angle)
{
	new Float:newPoint[2] = 0.0;
	angle /= 57.29578;
	newPoint[0] = Cosine(angle) * pointX - origin[0] - Sine(angle) * pointY - origin[1] + origin[0];
	newPoint[1] = Sine(angle) * pointX - origin[0] + Cosine(angle) * pointY - origin[1] + origin[1];
	pointX = newPoint[0];
	pointY = newPoint[1];
	return 0;
}

public PrintDebug(String:Message[])
{
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2",
	date = "09/06/2015",
	time = "21:04:47"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced"
};
new String:WeaponNames[56][] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced",
	"weapon_shotgun_chrome",
	"weapon_rifle_desert",
	"weapon_sniper_military",
	"weapon_shotgun_spas",
	"weapon_first_aid_kit",
	"weapon_molotov",
	"weapon_pipe_bomb",
	"weapon_pain_pills",
	"weapon_gascan",
	"weapon_propanetank",
	"weapon_oxygentank",
	"weapon_melee",
	"weapon_chainsaw",
	"weapon_grenade_launcher",
	"weapon_ammo_pack",
	"weapon_adrenaline",
	"weapon_defibrillator",
	"weapon_vomitjar",
	"weapon_rifle_ak47",
	"weapon_gnome",
	"weapon_cola_bottles",
	"weapon_fireworkcrate",
	"weapon_upgradepack_incendiary",
	"weapon_upgradepack_explosive",
	"weapon_pistol_magnum",
	"weapon_smg_mp5",
	"weapon_rifle_sg552",
	"weapon_sniper_awp",
	"weapon_sniper_scout",
	"weapon_rifle_m60",
	"weapon_tank_claw",
	"weapon_hunter_claw",
	"weapon_charger_claw",
	"weapon_boomer_claw",
	"weapon_smoker_claw",
	"weapon_spitter_claw",
	"weapon_jockey_claw",
	"weapon_machinegun",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:MeleeWeaponNames[15][] =
{
	"",
	"knife",
	"baseball_bat",
	"chainsaw",
	"cricket_bat",
	"crowbar",
	"didgeridoo",
	"electric_guitar",
	"fireaxe",
	"frying_pan",
	"golfclub",
	"katana",
	"machete",
	"riotshield",
	"tonfa"
};
new String:WeaponModels[56][] =
{
	"",
	"/w_models/weapons/w_pistol_B.mdl",
	"/w_models/weapons/w_smg_uzi.mdl",
	"/w_models/weapons/w_shotgun.mdl",
	"/w_models/weapons/w_autoshot_m4super.mdl",
	"/w_models/weapons/w_rifle_m16a2.mdl",
	"/w_models/weapons/w_sniper_mini14.mdl",
	"/w_models/weapons/w_smg_a.mdl",
	"/w_models/weapons/w_pumpshotgun_a.mdl",
	"/w_models/weapons/w_desert_rifle.mdl",
	"/w_models/weapons/w_sniper_military.mdl",
	"/w_models/weapons/w_shotgun_spas.mdl",
	"/w_models/weapons/w_eq_medkit.mdl",
	"/w_models/weapons/w_eq_molotov.mdl",
	"/w_models/weapons/w_eq_pipebomb.mdl",
	"/w_models/weapons/w_eq_painpills.mdl",
	"/props_junk/gascan001a.mdl",
	"/props_junk/propanecanister001.mdl",
	"/props_equipment/oxygentank01.mdl",
	"",
	"/weapons/melee/w_chainsaw.mdl",
	"/w_models/weapons/w_grenade_launcher.mdl",
	"",
	"/w_models/weapons/w_eq_adrenaline.mdl",
	"/w_models/weapons/w_eq_defibrillator.mdl",
	"/w_models/weapons/w_eq_bile_flask.mdl",
	"/w_models/weapons/w_rifle_ak47.mdl",
	"/props_junk/gnome.mdl",
	"/w_models/weapons/w_cola.mdl",
	"/props_junk/explosive_box001.mdl",
	"/w_models/weapons/w_eq_incendiary_ammopack.mdl",
	"/w_models/weapons/w_eq_explosive_ammopack.mdl",
	"/w_models/weapons/w_desert_eagle.mdl",
	"/w_models/weapons/w_smg_mp5.mdl",
	"/w_models/weapons/w_rifle_sg552.mdl",
	"/w_models/weapons/w_sniper_awp.mdl",
	"/w_models/weapons/w_sniper_scout.mdl",
	"/w_models/weapons/w_m60.mdl",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	""
};
new String:MeleeWeaponModels[15][] =
{
	"",
	"/w_models/weapons/w_knife_t.mdl",
	"/weapons/melee/w_bat.mdl",
	"/weapons/melee/w_chainsaw.mdl",
	"/weapons/melee/w_cricket_bat.mdl",
	"/weapons/melee/w_crowbar.mdl",
	"/weapons/melee/w_didgeridoo.mdl",
	"/weapons/melee/w_electric_guitar.mdl",
	"/weapons/melee/w_fireaxe.mdl",
	"/weapons/melee/w_frying_pan.mdl",
	"/weapons/melee/w_golfclub.mdl",
	"/weapons/melee/w_katana.mdl",
	"/weapons/melee/w_machete.mdl",
	"/weapons/melee/w_riotshield.mdl",
	"/weapons/melee/w_tonfa.mdl"
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new WeaponSlots[56] =
{
	0, 0, 0, 0, 0, 1702256493, 1769099107, 7235943, 1851875181, 1953452647, 1869182049, 110, 1819044203, 0, 1885431159, 1935634031, 1853317488, 0, 1702322029, 1852797025, 17481, 1853189987, 116, 845427820, 1818850421, 0, 845427820, 1818850421, 2020438830, 0, 4840, 4852, 1, 0, 0, 0, 0, 0, 1701208403, 1836019570, 1853179680, 1852785440, 1819243124, 0, 1751607624, 1869562656, 543517035, 543452769, 1851880531, 1869373796, 25966, 1702130753, 1937010797, 544175136, 1819305330, 543515489
};
new Handle:hSurvivorModelsTrie;
new Handle:hWeaponNamesTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hMeleeWeaponModelsTrie;
public SharedPlugin:__pl_l4d2util =
{
	name = "l4d2util",
	file = "l4d2util.smx",
	required = 1,
};
new Handle:g_hKVData;
new Handle:g_hCvarKVPath;
new Handle:g_hSafeAllowedWeapons;
new Handle:g_hWeaponSpawns;
new Handle:g_hSafeSpawnEnts;
public Plugin:myinfo =
{
	name = "Saferoom Gun Control",
	description = "Attempts to replace existing weapon spawn entities with new weapon spawns specified in the config/saferoom_gun_control.txt",
	author = "High Cookie and Standalone",
	version = "1",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

SetEntityMoveType(entity, MoveType:mt)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_MoveType", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_MoveType");
		}
		gotconfig = true;
	}
	SetEntProp(entity, PropType:1, datamap, mt, 4, 0);
	return 0;
}

InitWeaponNamesTrie()
{
	L4D2_InfectedTimerEntities[0] = CreateTrie();
	new i;
	while (i < 56)
	{
		SetTrieValue(L4D2_InfectedTimerEntities[0], L4D2_InfectedNames[i], i, true);
		i++;
	}
	hMeleeWeaponNamesTrie = CreateTrie();
	hMeleeWeaponModelsTrie = CreateTrie();
	new i;
	while (i < 15)
	{
		SetTrieValue(hMeleeWeaponNamesTrie, MeleeWeaponNames[i], i, true);
		SetTrieString(hMeleeWeaponModelsTrie, MeleeWeaponModels[i], MeleeWeaponNames[i], true);
		i++;
	}
	return 0;
}

bool:IsValidWeaponId(WeaponId:wepid, tagType)
{
	if (tagType == -1073741714)
	{
		new var1;
		return wepid >= WeaponId:0 && wepid < WeaponId:15;
	}
	new var2;
	return wepid >= WeaponId:0 && wepid < WeaponId:56;
}

bool:HasValidWeaponModel(WeaponId:wepid, tagType)
{
	if (tagType == -1073741714)
	{
		new var1;
		return IsValidWeaponId(wepid, -1073741714) && MeleeWeaponModels[wepid][0];
	}
	new var2;
	return IsValidWeaponId(wepid, -1073741715) && WeaponModels[wepid][0];
}

WeaponId:WeaponNameToId(String:weaponName[])
{
	new WeaponID:id;
	if (!L4D2_InfectedTimerEntities[0])
	{
		InitWeaponNamesTrie();
	}
	if (GetTrieValue(L4D2_InfectedTimerEntities[0], weaponName, id))
	{
		return id;
	}
	return WeaponId:0;
}

GetWeaponModel(WeaponId:wepid, String:modelBuffer[], length, tagType)
{
	if (tagType == -1073741714)
	{
		new var1;
		if (HasValidWeaponModel(wepid, -1073741714))
		{
			var1[0] = MeleeWeaponModels[wepid];
		}
		else
		{
			var1[0] = 4760;
		}
		strcopy(modelBuffer, length, var1);
	}
	else
	{
		new var2;
		if (HasValidWeaponModel(wepid, -1073741715))
		{
			var2[0] = WeaponModels[wepid];
		}
		else
		{
			var2[0] = 4764;
		}
		strcopy(modelBuffer, length, var2);
	}
	return 0;
}

ConvertWeaponSpawn(entity, WeaponId:wepid, count, String:model[])
{
	if (!IsValidEntity(entity))
	{
		return -1;
	}
	if (!IsValidWeaponId(wepid, -1073741715))
	{
		return -1;
	}
	new var1;
	if (model[0] && !HasValidWeaponModel(wepid, -1073741715))
	{
		return -1;
	}
	new Float:origins[3] = 0.0;
	new Float:angles[3] = 0.0;
	GetEntPropVector(entity, PropType:0, "m_vecOrigin", origins, 0);
	GetEntPropVector(entity, PropType:0, "m_angRotation", angles, 0);
	AcceptEntityInput(entity, "kill", -1, -1, 0);
	entity = CreateEntityByName("weapon_spawn", -1);
	if (!IsValidEntity(entity))
	{
		return -1;
	}
	SetEntProp(entity, PropType:0, "m_weaponID", wepid, 4, 0);
	decl String:buf[64];
	if (model[0])
	{
		GetWeaponModel(wepid, buf, 64, -1073741715);
		SetEntityModel(entity, buf);
	}
	else
	{
		SetEntityModel(entity, model);
	}
	IntToString(count, buf, 64);
	DispatchKeyValue(entity, "count", buf);
	TeleportEntity(entity, origins, angles, NULL_VECTOR);
	DispatchSpawn(entity);
	SetEntityMoveType(entity, MoveType:0);
	return entity;
}

public __pl_l4d2util_SetNTVOptional()
{
	return 0;
}

public OnPluginStart()
{
	g_hCvarKVPath = CreateConVar("sm_guncontrol_configpath", "configs/saferoom_gun_control.txt", "The path to the saferoom_gun_control.txt, default is the sourcemod configs folder.", 262144, false, 0.0, false, 0.0);
	PrepareWeaponSpawnArray();
	return 0;
}

public OnPluginEnd()
{
	CloseHandles();
	if (g_hWeaponSpawns)
	{
		CloseHandle(g_hWeaponSpawns);
		g_hWeaponSpawns = MissingTAG:0;
	}
	if (g_hCvarKVPath)
	{
		CloseHandle(g_hCvarKVPath);
		g_hCvarKVPath = MissingTAG:0;
	}
	return 0;
}

public OnRoundStart()
{
	CreateTimer(1.1, Timer_DelayedOnRoundStart, any:0, 2);
	return 0;
}

public Action:Timer_DelayedOnRoundStart(Handle:timer)
{
	if (KV_Load())
	{
		KV_SwapGuns();
		CloseHandles();
	}
	return Action:0;
}

bool:KV_Load()
{
	decl String:filePath[256];
	GetConVarString(g_hCvarKVPath, filePath, 256);
	BuildPath(PathType:0, filePath, 256, filePath);
	g_hKVData = CreateKeyValues("SaferoomGunControl", "", "");
	if (!FileToKeyValues(g_hKVData, filePath))
	{
		LogError("[GUN CONTROL] Couldn't load Gun Control data! (file: %s)", filePath);
		CloseHandles();
		return false;
	}
	return true;
}

public KV_SwapGuns()
{
	if (g_hKVData)
	{
		new String:mapname[64];
		GetCurrentMap(mapname, 64);
		PrintToServer("%s", mapname);
		if (!KvJumpToKey(g_hKVData, mapname, false))
		{
			if (!KvJumpToKey(g_hKVData, "default", false))
			{
				LogError("[GUN CONTROL] No map section found for %s and no default section found in KV file", mapname);
				return 0;
			}
		}
		if (KvGotoFirstSubKey(g_hKVData, false))
		{
			decl String:valuebuffer[64];
			new count;
			new safeSpawnsCount;
			new weaponId;
			BuildSafeWeaponSpawnEnts();
			safeSpawnsCount = GetArraySize(g_hSafeSpawnEnts);
			KvGetString(g_hKVData, NULL_STRING, valuebuffer, 64, "");
			while (count < safeSpawnsCount)
			{
				weaponId = WeaponNameToId(valuebuffer);
				ConvertWeaponSpawn(GetArrayCell(g_hSafeSpawnEnts, count, 0, false), weaponId, 5, "");
				count++;
				if (KvGotoNextKey(g_hKVData, false))
				{
				}
				while (count < safeSpawnsCount)
				{
					AcceptEntityInput(GetArrayCell(g_hSafeSpawnEnts, count, 0, false), "Kill", -1, -1, 0);
					count++;
				}
			}
			while (count < safeSpawnsCount)
			{
				AcceptEntityInput(GetArrayCell(g_hSafeSpawnEnts, count, 0, false), "Kill", -1, -1, 0);
				count++;
			}
		}
		return 0;
	}
	return 0;
}

CloseHandles()
{
	if (g_hKVData)
	{
		CloseHandle(g_hKVData);
		g_hKVData = MissingTAG:0;
	}
	if (g_hSafeAllowedWeapons)
	{
		CloseHandle(g_hSafeAllowedWeapons);
		g_hSafeAllowedWeapons = MissingTAG:0;
	}
	return 0;
}

BuildSafeWeaponSpawnEnts()
{
	decl String:classname[64];
	if (g_hSafeSpawnEnts)
	{
		ClearArray(g_hSafeSpawnEnts);
	}
	else
	{
		g_hSafeSpawnEnts = CreateArray(1, 0);
	}
	new i = 1;
	while (GetEntityCount() > i)
	{
		if (IsValidEntity(i))
		{
			if (SAFEDETECT_IsEntityInStartSaferoom(i))
			{
				GetEdictClassname(i, classname, 64);
				if (FindStringInArray(g_hWeaponSpawns, classname) != -1)
				{
					PushArrayCell(g_hSafeSpawnEnts, i);
				}
			}
		}
		i++;
	}
	return 0;
}

PrepareWeaponSpawnArray()
{
	g_hWeaponSpawns = CreateArray(32, 0);
	PushArrayString(g_hWeaponSpawns, "weapon_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_smg_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_smg_silenced_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_pumpshotgun_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_shotgun_chrome_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_hunting_rifle_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_sniper_military_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_rifle_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_rifle_ak47_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_rifle_desert_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_autoshotgun_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_shotgun_spas_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_rifle_m60_spawn");
	PushArrayString(g_hWeaponSpawns, "weapon_grenade_launcher_spawn");
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "11/24/2017",
	time = "15:54:59"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	845427820, 1818850421, 0, 845427820, 1818850421, 2020438830, 0, 1064, 1076, 1, 1701208403, 1836019570, 1702119712, 1699881069, 1702260589, 114, 1969381716, 1394617454, 29289, 1869440338, 544433526, 544829025, 1701208435, 1836019570, 1702127904, 1932009581, 1953653108, 544370464, 694447717, 46, 774909488, 54, 0, 1104, 1140, 1128, 1184, 1192, 0, 0, 0, 0, 1935633779, 1768253025, 1802331508, 1600941161, 1650552421, 25964, 49, 1952802903, 544367976, 543452773, 1701208435, 1836019570, 1702127904, 1931506541
};
new Handle:hSurvivorModelsTrie = 845427820;
new Handle:hWeaponNamesTrie = 845427820;
public SharedPlugin:__pl_l4d2util =
{
	name = "l4d2util",
	file = "l4d2util.smx",
	required = 1,
};
public Plugin:myinfo =
{
	name = "Saferoom Item Remover",
	description = "Removes any saferoom item (start or end).",
	author = "Tabun, Sir",
	version = "0.0.6",
	url = ""
};
new Handle:g_hCvarEnabled;
new Handle:g_hCvarSaferoom;
new Handle:g_hCvarItems;
new Handle:g_hTrieItems;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public __pl_l4d2util_SetNTVOptional()
{
	return 0;
}

public OnPluginStart()
{
	g_hCvarEnabled = CreateConVar("sm_safeitemkill_enable", "1", "Whether end saferoom items should be removed.", 262144, true, 0.0, true, 1.0);
	g_hCvarSaferoom = CreateConVar("sm_safeitemkill_saferooms", "1", "Saferooms to empty. Flags: 1 = end saferoom, 2 = start saferoom (3 = kill items from both).", 262144, true, 0.0, false, 0.0);
	g_hCvarItems = CreateConVar("sm_safeitemkill_items", "7", "Types to rmove. Flags: 1 = health items, 2 = guns, 4 = melees, 8 = all other usable items", 262144, true, 0.0, false, 0.0);
	PrepareTrie();
	return 0;
}

public OnRoundStart()
{
	if (GetConVarBool(g_hCvarEnabled))
	{
		CreateTimer(1.0, Timer_DelayedOnRoundStart, any:0, 2);
	}
	return 0;
}

public Action:Timer_DelayedOnRoundStart(Handle:timer)
{
	RemoveEndSaferoomItems();
	return Action:0;
}

RemoveEndSaferoomItems()
{
	new String:classname[128];
	new eTrieItemKillable:checkItem;
	new entityCount = GetEntityCount();
	new iCountEnd;
	new iCountStart;
	new i = 1;
	while (i < entityCount)
	{
		if (IsValidEntity(i))
		{
			GetEdictClassname(i, classname, 128);
			if (GetTrieValue(g_hTrieItems, classname, checkItem))
			{
				new var1;
				if (checkItem && checkItem & GetConVarInt(g_hCvarItems))
				{
					if (GetConVarInt(g_hCvarSaferoom) & 1)
					{
						if (SAFEDETECT_IsEntityInEndSaferoom(i))
						{
							AcceptEntityInput(i, "Kill", -1, -1, 0);
							iCountEnd++;
						}
					}
					if (GetConVarInt(g_hCvarSaferoom) & 2)
					{
						if (SAFEDETECT_IsEntityInStartSaferoom(i))
						{
							AcceptEntityInput(i, "Kill", -1, -1, 0);
							iCountStart++;
						}
					}
				}
			}
		}
		i++;
	}
	LogMessage("Removed %i saferoom item(s) (start: %i; end: %i).", iCountEnd + iCountStart, iCountStart, iCountEnd);
	return 0;
}

PrepareTrie()
{
	g_hTrieItems = CreateTrie();
	SetTrieValue(g_hTrieItems, "weapon_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_ammo_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_pistol_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_pistol_magnum_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_smg_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_smg_silenced_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_pumpshotgun_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_shotgun_chrome_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_hunting_rifle_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_sniper_military_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_rifle_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_rifle_ak47_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_rifle_desert_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_autoshotgun_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_shotgun_spas_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_rifle_m60_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_grenade_launcher_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_chainsaw_spawn", any:2, true);
	SetTrieValue(g_hTrieItems, "weapon_melee_spawn", any:4, true);
	SetTrieValue(g_hTrieItems, "weapon_item_spawn", any:1, true);
	SetTrieValue(g_hTrieItems, "weapon_first_aid_kit_spawn", any:1, true);
	SetTrieValue(g_hTrieItems, "weapon_defibrillator_spawn", any:1, true);
	SetTrieValue(g_hTrieItems, "weapon_pain_pills_spawn", any:1, true);
	SetTrieValue(g_hTrieItems, "weapon_adrenaline_spawn", any:1, true);
	SetTrieValue(g_hTrieItems, "weapon_pipe_bomb_spawn", any:8, true);
	SetTrieValue(g_hTrieItems, "weapon_molotov_spawn", any:8, true);
	SetTrieValue(g_hTrieItems, "weapon_vomitjar_spawn", any:8, true);
	SetTrieValue(g_hTrieItems, "weapon_gascan_spawn", any:8, true);
	SetTrieValue(g_hTrieItems, "upgrade_spawn", any:8, true);
	SetTrieValue(g_hTrieItems, "upgrade_laser_sight", any:8, true);
	SetTrieValue(g_hTrieItems, "weapon_upgradepack_explosive_spawn", any:8, true);
	SetTrieValue(g_hTrieItems, "weapon_upgradepack_incendiary_spawn", any:8, true);
	SetTrieValue(g_hTrieItems, "upgrade_ammo_incendiary", any:8, true);
	SetTrieValue(g_hTrieItems, "upgrade_ammo_explosive", any:8, true);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "03/24/2014",
	time = "01:39:01"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public SharedPlugin:__pl_l4d2lib =
{
	name = "l4d2lib",
	file = "l4d2lib.smx",
	required = 0,
};
public Plugin:myinfo =
{
	name = "L4D2 Scoremod",
	description = "L4D2 Custom Scoring System (Health Bonus)",
	author = "CanadaRox, ProdigySim",
	version = "1.1b",
	url = "https://bitbucket.org/CanadaRox/random-sourcemod-stuff"
};
new bool:l4d2lib_available;
new SM_iDefaultSurvivalBonus;
new SM_iDefaultTieBreaker;
new SM_iPillPercent;
new SM_iAdrenPercent;
new Float:SM_fHealPercent;
new Float:SM_fMapMulti;
new Float:SM_fHBRatio;
new Float:SM_fSurvivalBonusRatio;
new Float:SM_fTempMulti[3];
new bool:SM_bModuleIsEnabled;
new bool:SM_bHooked;
new bool:SM_bIsFirstRoundOver;
new bool:SM_bIsSecondRoundStarted;
new bool:SM_bIsSecondRoundOver;
new SM_iFirstScore;
new Handle:SM_hEnable;
new Handle:SM_hHBRatio;
new Handle:SM_hSurvivalBonusRatio;
new Handle:SM_hMapMulti;
new Handle:SM_hCustomMaxDistance;
new Handle:SM_hShowMaxDist;
new Handle:SM_hSurvivalBonus;
new Handle:SM_hTieBreaker;
new Handle:SM_hHealPercent;
new Handle:SM_hPillPercent;
new Handle:SM_hAdrenPercent;
new Handle:SM_hTempMulti0;
new Handle:SM_hTempMulti1;
new Handle:SM_hTempMulti2;
new iDifference;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator/(Float:,_:)(Float:oper1, oper2)
{
	return oper1 / float(oper2);
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return oper1 + float(oper2);
}

bool:operator!=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) != 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public __pl_l4d2lib_SetNTVOptional()
{
	MarkNativeAsOptional("L4D2_GetCurrentRound");
	MarkNativeAsOptional("L4D2_CurrentlyInRound");
	MarkNativeAsOptional("L4D2_GetSurvivorCount");
	MarkNativeAsOptional("L4D2_GetSurvivorOfIndex");
	MarkNativeAsOptional("L4D2_IsMapDataAvailable");
	MarkNativeAsOptional("L4D2_IsEntityInSaferoom");
	MarkNativeAsOptional("L4D2_GetMapStartOrigin");
	MarkNativeAsOptional("L4D2_GetMapEndOrigin");
	MarkNativeAsOptional("L4D2_GetMapStartDistance");
	MarkNativeAsOptional("L4D2_GetMapStartExtraDistance");
	MarkNativeAsOptional("L4D2_GetMapEndDistance");
	MarkNativeAsOptional("L4D2_GetMapValueInt");
	MarkNativeAsOptional("L4D2_GetMapValueFloat");
	MarkNativeAsOptional("L4D2_GetMapValueVector");
	MarkNativeAsOptional("L4D2_GetMapValueString");
	MarkNativeAsOptional("L4D2_CopyMapSubsection");
	return 0;
}

public OnPluginStart()
{
	SM_hEnable = CreateConVar("SM_enable", "1", "L4D2 Custom Scoring - Enable/Disable", 262144, false, 0.0, false, 0.0);
	HookConVarChange(SM_hEnable, SM_ConVarChanged_Enable);
	SM_hHBRatio = CreateConVar("SM_healthbonusratio", "2.0", "L4D2 Custom Scoring - Healthbonus Multiplier", 262144, true, 0.25, true, 10.0);
	HookConVarChange(SM_hHBRatio, SM_CVChanged_HealthBonusRatio);
	SM_hSurvivalBonusRatio = CreateConVar("SM_survivalbonusratio", "0.0", "Ratio to be used for a static survival bonus against Map distance. 25% == 100 points maximum health bonus on a 400 distance map", 262144, false, 0.0, false, 0.0);
	HookConVarChange(SM_hSurvivalBonusRatio, SM_CVChanged_SurvivalBonusRatio);
	SM_hTempMulti0 = CreateConVar("SM_tempmulti_incap_0", "0.30625", "L4D2 Custom Scoring - How important temp health is on survivors who have had no incaps", 262144, true, 0.0, true, 1.0);
	HookConVarChange(SM_hTempMulti0, SM_ConVarChanged_TempMulti0);
	SM_hTempMulti1 = CreateConVar("SM_tempmulti_incap_1", "0.17500", "L4D2 Custom Scoring - How important temp health is on survivors who have had one incap", 262144, true, 0.0, true, 1.0);
	HookConVarChange(SM_hTempMulti1, SM_ConVarChanged_TempMulti1);
	SM_hTempMulti2 = CreateConVar("SM_tempmulti_incap_2", "0.10000", "L4D2 Custom Scoring - How important temp health is on survivors who have had two incaps (black and white)", 262144, true, 0.0, true, 1.0);
	HookConVarChange(SM_hTempMulti2, SM_ConVarChanged_TempMulti2);
	SM_hShowMaxDist = CreateConVar("SM_showmaxdist", "1", "Print custom max distances.", 262144, false, 0.0, false, 0.0);
	SM_fTempMulti[0] = GetConVarFloat(SM_hTempMulti0);
	SM_fTempMulti[1] = GetConVarFloat(SM_hTempMulti1);
	SM_fTempMulti[2] = GetConVarFloat(SM_hTempMulti2);
	decl String:buf[32];
	FloatToString(GetConVarFloat(FindConVar("first_aid_heal_percent")), buf, 32);
	SM_hHealPercent = CreateConVar("SM_first_aid_heal_percent", buf, "L4D2 Custom Scoring: What percent of health is healed by medkits?", 0, false, 0.0, false, 0.0);
	IntToString(GetConVarInt(FindConVar("pain_pills_health_value")), buf, 32);
	SM_hPillPercent = CreateConVar("SM_pain_pills_health_value", buf, "L4D2 Custom Scoring: How much health is added by pills?", 0, false, 0.0, false, 0.0);
	IntToString(GetConVarInt(FindConVar("adrenaline_health_buffer")), buf, 32);
	SM_hAdrenPercent = CreateConVar("SM_adrenaline_health_buffer", buf, "L4D2 Custom Scoring: How much health is added by adrenaline?", 0, false, 0.0, false, 0.0);
	SM_hMapMulti = CreateConVar("SM_mapmulti", "1", "L4D2 Custom Scoring - Increases Healthbonus Max to Distance Max", 262144, false, 0.0, false, 0.0);
	SM_hCustomMaxDistance = CreateConVar("SM_custommaxdistance", "0", "L4D2 Custom Scoring - Custom max distance from config", 262144, false, 0.0, false, 0.0);
	SM_hSurvivalBonus = FindConVar("vs_survival_bonus");
	SM_hTieBreaker = FindConVar("vs_tiebreak_bonus");
	HookConVarChange(SM_hHealPercent, SM_ConVarChanged_Health);
	HookConVarChange(SM_hPillPercent, SM_ConVarChanged_Health);
	HookConVarChange(SM_hAdrenPercent, SM_ConVarChanged_Health);
	SM_iDefaultSurvivalBonus = GetConVarInt(SM_hSurvivalBonus);
	SM_iDefaultTieBreaker = GetConVarInt(SM_hTieBreaker);
	SM_fHealPercent = GetConVarFloat(SM_hHealPercent);
	SM_iPillPercent = GetConVarInt(SM_hPillPercent);
	SM_iAdrenPercent = GetConVarInt(SM_hAdrenPercent);
	RegConsoleCmd("sm_health", SM_Cmd_Health, "", 0);
	return 0;
}

public OnAllPluginsLoaded()
{
	l4d2lib_available = LibraryExists("l4d2lib");
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "l4d2lib", true))
	{
		l4d2lib_available = false;
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "l4d2lib", true))
	{
		l4d2lib_available = true;
	}
	return 0;
}

public OnPluginEnd()
{
	PluginDisable();
	return 0;
}

public OnMapStart()
{
	if (!GetConVarBool(SM_hMapMulti))
	{
		SM_fMapMulti = 1.0;
	}
	else
	{
		SM_fMapMulti = float(GetMapMaxScore()) / 400.0;
	}
	SM_bModuleIsEnabled = GetConVarBool(SM_hEnable);
	new var1;
	if (SM_bModuleIsEnabled && !SM_bHooked)
	{
		PluginEnable();
	}
	if (SM_bModuleIsEnabled)
	{
		SetConVarInt(SM_hTieBreaker, 0, false, false);
	}
	new var2;
	if (SM_bModuleIsEnabled && GetConVarBool(SM_hCustomMaxDistance) && GetCustomMapMaxScore() > -1)
	{
		SetMapMaxScore(GetCustomMapMaxScore());
		if (0 < GetCustomMapMaxScore())
		{
			SM_fMapMulti = float(GetCustomMapMaxScore()) / 400.0;
		}
	}
	SM_bIsFirstRoundOver = false;
	SM_bIsSecondRoundStarted = false;
	SM_bIsSecondRoundOver = false;
	SM_iFirstScore = 0;
	SM_fTempMulti[0] = GetConVarFloat(SM_hTempMulti0);
	SM_fTempMulti[1] = GetConVarFloat(SM_hTempMulti1);
	SM_fTempMulti[2] = GetConVarFloat(SM_hTempMulti2);
	return 0;
}

public SM_ConVarChanged_Enable(Handle:convar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10))
	{
		PluginEnable();
		SM_bModuleIsEnabled = true;
	}
	else
	{
		PluginDisable();
		SM_bModuleIsEnabled = false;
	}
	return 0;
}

public SM_ConVarChanged_TempMulti0(Handle:convar, String:oldValue[], String:newValue[])
{
	SM_fTempMulti[0] = StringToFloat(newValue);
	return 0;
}

public SM_ConVarChanged_TempMulti1(Handle:convar, String:oldValue[], String:newValue[])
{
	SM_fTempMulti[1] = StringToFloat(newValue);
	return 0;
}

public SM_ConVarChanged_TempMulti2(Handle:convar, String:oldValue[], String:newValue[])
{
	SM_fTempMulti[2] = StringToFloat(newValue);
	return 0;
}

public SM_CVChanged_HealthBonusRatio(Handle:convar, String:oldValue[], String:newValue[])
{
	SM_fHBRatio = StringToFloat(newValue);
	return 0;
}

public SM_CVChanged_SurvivalBonusRatio(Handle:convar, String:oldValue[], String:newValue[])
{
	SM_fSurvivalBonusRatio = StringToFloat(newValue);
	return 0;
}

public SM_ConVarChanged_Health(Handle:convar, String:oldValue[], String:newValue[])
{
	SM_fHealPercent = GetConVarFloat(SM_hHealPercent);
	SM_iPillPercent = GetConVarInt(SM_hPillPercent);
	SM_iAdrenPercent = GetConVarInt(SM_hAdrenPercent);
	return 0;
}

PluginEnable()
{
	HookEvent("door_close", SM_DoorClose_Event, EventHookMode:1);
	HookEvent("player_death", SM_PlayerDeath_Event, EventHookMode:1);
	HookEvent("round_end", SM_RoundEnd_Event, EventHookMode:1);
	HookEvent("round_start", SM_RoundStart_Event, EventHookMode:1);
	HookEvent("finale_vehicle_leaving", SM_FinaleVehicleLeaving_Event, EventHookMode:2);
	RegConsoleCmd("say", SM_Command_Say, "", 0);
	RegConsoleCmd("say_team", SM_Command_Say, "", 0);
	SM_fHBRatio = GetConVarFloat(SM_hHBRatio);
	SM_fSurvivalBonusRatio = GetConVarFloat(SM_hSurvivalBonusRatio);
	SM_iDefaultSurvivalBonus = GetConVarInt(SM_hSurvivalBonus);
	SM_iDefaultTieBreaker = GetConVarInt(SM_hTieBreaker);
	SetConVarInt(SM_hTieBreaker, 0, false, false);
	SM_fHealPercent = GetConVarFloat(SM_hHealPercent);
	SM_iPillPercent = GetConVarInt(SM_hPillPercent);
	SM_iAdrenPercent = GetConVarInt(SM_hAdrenPercent);
	SM_bHooked = true;
	return 0;
}

PluginDisable()
{
	SetConVarInt(SM_hSurvivalBonus, SM_iDefaultSurvivalBonus, false, false);
	SetConVarInt(SM_hTieBreaker, SM_iDefaultTieBreaker, false, false);
	SM_bHooked = false;
	return 0;
}

public Action:SM_DoorClose_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!SM_bModuleIsEnabled)
	{
		return Action:0;
	}
	if (GetEventBool(event, "checkpoint"))
	{
		SetConVarInt(SM_hSurvivalBonus, SM_CalculateSurvivalBonus(), false, false);
	}
	return Action:0;
}

public Action:SM_PlayerDeath_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!SM_bModuleIsEnabled)
	{
		return Action:0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client && GetClientTeam(client) == 2)
	{
		SetConVarInt(SM_hSurvivalBonus, SM_CalculateSurvivalBonus(), false, false);
	}
	return Action:0;
}

public Action:SM_RoundEnd_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!SM_bModuleIsEnabled)
	{
		return Action:0;
	}
	if (!SM_bIsFirstRoundOver)
	{
		SM_bIsFirstRoundOver = true;
		decl iAliveCount;
		SM_iFirstScore = RoundToFloor(SM_CalculateAvgHealth(iAliveCount) * SM_fMapMulti * SM_fHBRatio + SM_fMapMulti * 400 * SM_fSurvivalBonusRatio);
		new var1;
		if (SM_iFirstScore)
		{
			var1 = iAliveCount * GetConVarInt(SM_hSurvivalBonus);
		}
		else
		{
			var1 = 0;
		}
		SM_iFirstScore = var1;
		CPrintToChatAll("{default}Round {olive}1 {default}Bonus: {lightgreen}%d{default}", SM_iFirstScore);
	}
	else
	{
		new var2;
		if (SM_bIsSecondRoundStarted && !SM_bIsSecondRoundOver)
		{
			SM_bIsSecondRoundOver = true;
			decl iAliveCount;
			new iScore = RoundToFloor(SM_CalculateAvgHealth(iAliveCount) * SM_fMapMulti * SM_fHBRatio + SM_fMapMulti * 400 * SM_fSurvivalBonusRatio);
			new var3;
			if (iScore)
			{
				var3 = iAliveCount * GetConVarInt(SM_hSurvivalBonus);
			}
			else
			{
				var3 = 0;
			}
			iScore = var3;
			CPrintToChatAll("{default}Round {olive}1 {default}Bonus: {lightgreen}%d", SM_iFirstScore);
			CPrintToChatAll("{default}Round {olive}2 {default}Bonus: {lightgreen}%d", iScore);
			iDifference = SM_iFirstScore - iScore;
			if (iScore > SM_iFirstScore)
			{
				iDifference = ~iDifference + 1;
			}
			CPrintToChatAll("{default}Difference: {green}%d", iDifference);
		}
	}
	return Action:0;
}

public Action:SM_RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!SM_bModuleIsEnabled)
	{
		return Action:0;
	}
	if (SM_bIsFirstRoundOver)
	{
		SM_bIsSecondRoundStarted = true;
	}
	return Action:0;
}

public Action:SM_FinaleVehicleLeaving_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!SM_bModuleIsEnabled)
	{
		return Action:0;
	}
	SetConVarInt(SM_hSurvivalBonus, SM_CalculateSurvivalBonus(), false, false);
	return Action:0;
}

SM_IsPlayerIncap(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

public Action:SM_Cmd_Health(client, args)
{
	if (!SM_bModuleIsEnabled)
	{
		return Action:0;
	}
	decl iAliveCount;
	new Float:fAvgHealth = SM_CalculateAvgHealth(iAliveCount);
	new iScore = iAliveCount * RoundToFloor(fAvgHealth * SM_fMapMulti * SM_fHBRatio);
	if (SM_bIsSecondRoundStarted)
	{
		iDifference = SM_iFirstScore - iScore;
		if (iScore > SM_iFirstScore)
		{
			iDifference = ~iDifference + 1;
		}
		CPrintToChat(client, "{default}Round {olive}1 {default}Bonus: {lightgreen}%d{default} {olive}({default}Difference: {green}%d{olive})", SM_iFirstScore, iDifference);
	}
	if (client)
	{
		CPrintToChat(client, "{default}Average Health: {lightgreen}%.02f", fAvgHealth);
	}
	else
	{
		PrintToServer("[ScoreMod] Average Health: %.02f", fAvgHealth);
	}
	if (client)
	{
		CPrintToChat(client, "{default}Health Bonus: {lightgreen}%d{default}", iScore);
		if (0.0 != SM_fSurvivalBonusRatio)
		{
			CPrintToChat(client, "{default}Static Survival Bonus Per Survivor: {olive}%d{default}", RoundToFloor(SM_fMapMulti * 400 * SM_fSurvivalBonusRatio));
		}
	}
	else
	{
		PrintToServer("[ScoreMod] Health Bonus: %d", iScore);
		if (0.0 != SM_fSurvivalBonusRatio)
		{
			PrintToServer("[ScoreMod] Static Survival Bonus Per Survivor: %d", RoundToFloor(SM_fMapMulti * 400 * SM_fSurvivalBonusRatio));
		}
	}
	if (GetConVarBool(SM_hShowMaxDist))
	{
		new var1;
		if (GetConVarBool(SM_hCustomMaxDistance) && GetCustomMapMaxScore() > -1)
		{
			if (client)
			{
				CPrintToChat(client, "{default}Custom Max Distance: {olive}%d{default}", GetCustomMapMaxScore());
			}
			PrintToServer("[ScoreMod] Custom Max Distance: %d", GetCustomMapMaxScore());
		}
	}
	return Action:0;
}

SM_CalculateSurvivalBonus()
{
	return RoundToFloor(SM_CalculateAvgHealth(0) * SM_fMapMulti * SM_fHBRatio + SM_fMapMulti * 400 * SM_fSurvivalBonusRatio);
}

Float:SM_CalculateAvgHealth(&iAliveCount)
{
	new iTotalHealth;
	new iTotalTempHealth[3];
	new Float:fTotalAdjustedTempHealth = 0.0;
	new bool:IsFinale = L4D_IsMissionFinalMap();
	new iTemp;
	new iCurrHealth;
	new iCurrTemp;
	new iIncapCount;
	decl String:strTemp[52];
	new iSurvCount;
	iAliveCount = 0;
	new index = 1;
	while (index < MaxClients)
	{
		if (IsSurvivor(index))
		{
			iSurvCount++;
			if (IsPlayerAlive(index))
			{
				if (!SM_IsPlayerIncap(index))
				{
					iCurrHealth = GetSurvivorPermanentHealth(index);
					iCurrTemp = GetSurvivorTempHealth(index);
					iIncapCount = GetSurvivorIncapCount(index);
					iTemp = GetPlayerWeaponSlot(index, 3);
					if (iTemp > -1)
					{
						GetEdictClassname(iTemp, strTemp, 50);
						if (StrEqual(strTemp, "weapon_first_aid_kit", true))
						{
							iCurrHealth = RoundToFloor(SM_fHealPercent * 100 - iCurrHealth + iCurrHealth);
							iCurrTemp = 0;
							iIncapCount = 0;
						}
					}
					iTemp = GetPlayerWeaponSlot(index, 4);
					if (iTemp > -1)
					{
						GetEdictClassname(iTemp, strTemp, 50);
						if (StrEqual(strTemp, "weapon_pain_pills", true))
						{
							iCurrTemp = SM_iPillPercent + iCurrTemp;
						}
						if (StrEqual(strTemp, "weapon_adrenaline", true))
						{
							iCurrTemp = SM_iAdrenPercent + iCurrTemp;
						}
					}
					if (iCurrHealth + iCurrTemp > 100)
					{
						iCurrTemp = 100 - iCurrHealth;
					}
					new var1 = iAliveCount;
					var1++;
					iAliveCount = var1;
					iTotalHealth = iCurrHealth + iTotalHealth;
					new var2 = iTotalTempHealth[iIncapCount];
					var2 = var2[iCurrTemp];
				}
				if (!IsFinale)
				{
					new var3 = iAliveCount;
					var3++;
					iAliveCount = var3;
				}
			}
		}
		index++;
	}
	new i;
	while (i < 3)
	{
		fTotalAdjustedTempHealth += SM_fTempMulti[i] * iTotalTempHealth[i];
		i++;
	}
	new Float:fAvgHealth = fTotalAdjustedTempHealth + iTotalHealth / iSurvCount;
	return fAvgHealth;
}

public Action:SM_Command_Say(client, args)
{
	if (!SM_bModuleIsEnabled)
	{
		return Action:0;
	}
	decl String:sMessage[32];
	GetCmdArg(1, sMessage, 32);
	if (StrEqual(sMessage, "!health", true))
	{
		return Action:3;
	}
	return Action:0;
}

bool:IsSurvivor(client)
{
	new var1;
	return IsClientInGame(client) && GetClientTeam(client) == 2;
}

GetSurvivorPermanentHealth(client)
{
	return GetEntProp(client, PropType:0, "m_iHealth", 4, 0);
}

GetSurvivorTempHealth(client)
{
	new temphp = RoundToCeil(GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0) - GetGameTime() - GetEntPropFloat(client, PropType:0, "m_healthBufferTime", 0) * GetConVarFloat(FindConVar("pain_pills_decay_rate"))) + -1;
	new var1;
	if (temphp > 0)
	{
		var1 = temphp;
	}
	else
	{
		var1 = 0;
	}
	return var1;
}

GetSurvivorIncapCount(client)
{
	return GetEntProp(client, PropType:0, "m_currentReviveCount", 4, 0);
}

GetCustomMapMaxScore()
{
	new var1;
	if (l4d2lib_available)
	{
		var1 = L4D2_GetMapValueInt("max_distance", -1);
	}
	else
	{
		var1 = -1;
	}
	return var1;
}

GetMapMaxScore()
{
	return L4D_GetVersusMaxCompletionScore();
}

SetMapMaxScore(score)
{
	L4D_SetVersusMaxCompletionScore(score);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.5.3",
	date = "04/04/2014",
	time = "14:55:08"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new _pl_scp = 1444;
public Plugin:myinfo =
{
	name = "L4D2 Self Mute",
	description = "Allows a player to local mute another client's text and voice chat.",
	author = "Blade & Chdata",
	version = "0.4",
	url = "https://github.com/thebladeee/l4d2_selfmute"
};
new Target[163];
new bool:IgnoreMatrix[66][66][2];
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

ReplyToTargetError(client, reason)
{
	switch (reason)
	{
		case -7:
		{
			ReplyToCommand(client, "[SM] %t", "More than one client matched");
		}
		case -6:
		{
			ReplyToCommand(client, "[SM] %t", "Cannot target bot");
		}
		case -5:
		{
			ReplyToCommand(client, "[SM] %t", "No matching clients");
		}
		case -4:
		{
			ReplyToCommand(client, "[SM] %t", "Unable to target");
		}
		case -3:
		{
			ReplyToCommand(client, "[SM] %t", "Target is not in game");
		}
		case -2:
		{
			ReplyToCommand(client, "[SM] %t", "Target must be dead");
		}
		case -1:
		{
			ReplyToCommand(client, "[SM] %t", "Target must be alive");
		}
		case 0:
		{
			ReplyToCommand(client, "[SM] %t", "No matching client");
		}
		default:
		{
		}
	}
	return 0;
}

public OnPluginStart()
{
	CreateConVar("sm_l4d2sgag_version", "0.4", "L4D2 Self Gag Version", 401728, false, 0.0, false, 0.0);
	LoadTranslations("common.phrases");
	RegConsoleCmd("sm_smute", Command_Ignore, "Usage: sm_smute <#userid|name>\nSet target's chat and voice to be ignored.", 0);
	RegConsoleCmd("sm_sunmute", Command_UnIgnore, "Usage: sm_sunmute <#userid|name>\nUnmutes target.", 0);
	return 0;
}

public OnAllPluginsLoaded()
{
	if (!LibraryExists("scp"))
	{
		SetFailState("Simple Chat Processor is not loaded. It is required for this plugin to work.");
	}
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "scp", true))
	{
		SetFailState("Simple Chat Processor Unloaded. Plugin Disabled.");
	}
	return 0;
}

public OnClientDisconnect(client)
{
	new i;
	while (i <= 65)
	{
		IgnoreMatrix[client][i][0] = false;
		IgnoreMatrix[client][i][1] = false;
		i++;
	}
	return 0;
}

public Action:OnChatMessage(&author, Handle:recipients, String:name[], String:message[])
{
	new var1;
	if (author < 0 || author > MaxClients)
	{
		LogError("[Ignore list] Warning: author is out of bounds: %d", author);
		return Action:0;
	}
	new i;
	new client;
	while (GetArraySize(recipients) > i)
	{
		client = GetArrayCell(recipients, i, 0, false);
		new var2;
		if (client < 0 || client > MaxClients)
		{
			LogError("[L4D2 Self Mute] Warning: client is out of bounds: %d, Try updating SCP", client);
			i++;
		}
		if (IgnoreMatrix[client][author][0])
		{
			RemoveFromArray(recipients, i);
		}
		else
		{
			i++;
		}
	}
	return Action:1;
}

public Action:Command_Ignore(client, args)
{
	if (args)
	{
		ProcessIgnore(client, true, true, 3);
		return Action:3;
	}
	ReplyToCommand(client, "Usage: sm_smute <#userid|name>");
	return Action:3;
}

ProcessIgnore(client, bool:chat, bool:voice, which)
{
	GetCmdArg(1, Target, 32);
	new bool:bTargetAll;
	if (!(strcmp(Target, "@all", false)))
	{
		bTargetAll = true;
	}
	Target[97] = ProcessTargetString(Target, client, 1656 + 128, 65, 12, 1656 + 392, 64, 1656 + 648);
	if (0 >= Target[97])
	{
		ReplyToTargetError(client, Target[97]);
		return 0;
	}
	new i;
	while (Target[97] > i)
	{
		ToggleIgnoreStatus(client, Target[32][i][0], chat, voice, which, bTargetAll);
		i++;
	}
	if (bTargetAll)
	{
		decl String:s[256];
		new var1;
		if (!which & 2)
		{
			var1[0] = 55424;
		}
		else
		{
			if (voice)
			{
				var1[0] = 55436;
			}
			var1[0] = 55440;
		}
		new var2;
		if (!which & 1)
		{
			var2[0] = 55404;
		}
		else
		{
			if (chat)
			{
				var2[0] = 55416;
			}
			var2[0] = 55420;
		}
		Format(s, 256, "[SM] All Players - Chat: %s | Voice: %s", var2, var1);
		ReplyToCommand(client, s);
	}
	return 0;
}

ToggleIgnoreStatus(client, target, bool:chat, bool:voice, which, bool:bTargetAll)
{
	if (which & 1)
	{
		IgnoreMatrix[client][target][0] = chat;
	}
	if (which & 2)
	{
		IgnoreMatrix[client][target][1] = voice;
		if (IgnoreMatrix[client][target][1])
		{
			SetListenOverride(client, target, ListenOverride:1);
		}
		SetListenOverride(client, target, ListenOverride:0);
	}
	if (bTargetAll)
	{
		return 0;
	}
	decl String:s[256];
	new var1;
	if (IgnoreMatrix[client][target][1])
	{
		var1[0] = 55484;
	}
	else
	{
		var1[0] = 55488;
	}
	new var2;
	if (IgnoreMatrix[client][target][0])
	{
		var2[0] = 55476;
	}
	else
	{
		var2[0] = 55480;
	}
	Format(s, 256, "[SM] %N - Chat: %s | Voice: %s", target, var2, var1);
	ReplyToCommand(client, s);
	return 0;
}

public Action:Command_UnIgnore(client, args)
{
	if (args)
	{
		ProcessIgnore(client, false, false, 3);
		return Action:3;
	}
	ReplyToCommand(client, "Usage: sm_sunmute <#userid|name>");
	return Action:3;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	CreateNative("GetIgnoreMatrix", Native_GetIgnoreMatrix);
	RegPluginLibrary("ignorematrix");
	return APLRes:0;
}

public Native_GetIgnoreMatrix(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	new target = GetNativeCell(2);
	return IgnoreMatrix[client][target][0];
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.2-dev",
	date = "02/21/2013",
	time = "20:56:03"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_builtinvotes =
{
	name = "BuiltinVotes",
	file = "builtinvotes.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new Handle:minimumPlayersForVote;
new Handle:allowPlayersToVote;
new Handle:forceAdminsToVote;
new Handle:voteHandler;
new survivorScore;
new infectedScore;
new initiatingClient;
new bool:adminInitiated;
new bool:inFirstReadyUpOfRound;
new Handle:gConf;
new Handle:fSetCampaignScores;
public Plugin:myinfo =
{
	name = "SetScores",
	description = "Changes team scores.",
	author = "vintik",
	version = "1.2",
	url = "https://bitbucket.org/vintik/various-plugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetCDirector()
{
	static Address:TheDirector;
	if (!TheDirector)
	{
		TheDirector = GameConfGetAddress(L4D2Direct_GetGameConf(), "CDirector");
	}
	return TheDirector;
}

Address:L4D2Direct_GetCDirectorVersusMode()
{
	static Address:pVersusModeDirector;
	if (!pVersusModeDirector)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode");
		if (offs == -1)
		{
			return Address:0;
		}
		pVersusModeDirector = L4D2Direct_GetCDirector() + offs;
		pVersusModeDirector = LoadFromAddress(pVersusModeDirector, NumberType:2);
	}
	return pVersusModeDirector;
}

Address:L4D2Direct_GetVSCampaignScoresAddr()
{
	static Address:pCampaignScores;
	if (!pCampaignScores)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_iCampaignScores");
		if (offs == -1)
		{
			return Address:0;
		}
		pCampaignScores = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pCampaignScores;
}

L4D2Direct_SetVSCampaignScore(teamNumber, score)
{
	new var1;
	if (teamNumber < 0 || teamNumber > 1)
	{
		return 0;
	}
	StoreToAddress(teamNumber * 4 + L4D2Direct_GetVSCampaignScoresAddr(), score, NumberType:2);
	return 0;
}

bool:IsNewBuiltinVoteAllowed()
{
	new var1;
	if (IsBuiltinVoteInProgress() || CheckBuiltinVoteDelay())
	{
		return false;
	}
	return true;
}

public __ext_builtinvotes_SetNTVOptional()
{
	MarkNativeAsOptional("CreateBuiltinVote");
	MarkNativeAsOptional("DisplayBuiltinVote");
	MarkNativeAsOptional("AddBuiltinVoteItem");
	MarkNativeAsOptional("InsertBuiltinVoteItem");
	MarkNativeAsOptional("RemoveBuiltinVoteItem");
	MarkNativeAsOptional("RemoveAllBuiltinVoteItems");
	MarkNativeAsOptional("GetBuiltinVoteItem");
	MarkNativeAsOptional("GetBuiltinVoteItemCount");
	MarkNativeAsOptional("SetBuiltinVoteArgument");
	MarkNativeAsOptional("GetBuiltinVoteArgument");
	MarkNativeAsOptional("IsBuiltinVoteInProgress");
	MarkNativeAsOptional("GetBuiltinVoteMaxItems");
	MarkNativeAsOptional("SetBuiltinVoteOptionFlags");
	MarkNativeAsOptional("GetBuiltinVoteOptionFlags");
	MarkNativeAsOptional("SetBuiltinVoteResultCallback");
	MarkNativeAsOptional("CheckBuiltinVoteDelay");
	MarkNativeAsOptional("IsClientInBuiltinVotePool");
	MarkNativeAsOptional("RedrawClientBuiltinVote");
	MarkNativeAsOptional("GetBuiltinVoteType");
	MarkNativeAsOptional("SetBuiltinVoteTeam");
	MarkNativeAsOptional("GetBuiltinVoteTeam");
	MarkNativeAsOptional("SetBuiltinVoteInitiator");
	MarkNativeAsOptional("GetBuiltinVoteInitiator");
	MarkNativeAsOptional("DisplayBuiltinVotePass");
	MarkNativeAsOptional("DisplayBuiltinVotePass2");
	MarkNativeAsOptional("DisplayBuiltinVoteFail");
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	BfWriteByte(hBuffer, author);
	BfWriteByte(hBuffer, 1);
	BfWriteString(hBuffer, szMessage);
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	decl String:sGame[256];
	GetGameFolderName(sGame, 256);
	if (!StrEqual(sGame, "left4dead2", false))
	{
		SetFailState("Plugin 'SetScores' supports Left 4 Dead 2 only!");
	}
	gConf = LoadGameConfigFile("left4downtown.l4d2");
	if (!gConf)
	{
		LogError("Could not load gamedata/left4downtown.l4d2.txt");
	}
	StartPrepSDKCall(SDKCallType:3);
	if (PrepSDKCall_SetFromConf(gConf, SDKFuncConfSource:1, "SetCampaignScores"))
	{
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		fSetCampaignScores = EndPrepSDKCall();
		if (fSetCampaignScores)
		{
		}
		else
		{
			LogError("Function 'SetCampaignScores' found, but something went wrong.");
		}
	}
	else
	{
		LogError("Function 'SetCampaignScores' not found.");
	}
	minimumPlayersForVote = CreateConVar("setscore_player_limit", "2", "Minimum # of players in game to start the vote", 262144, false, 0.0, false, 0.0);
	allowPlayersToVote = CreateConVar("setscore_allow_player_vote", "1", "Whether player initiated votes are allowed, 1 to allow (default), 0 to disallow.", 262144, false, 0.0, false, 0.0);
	forceAdminsToVote = CreateConVar("setscore_force_admin_vote", "0", "Whether admin score changes require a vote, 1 vote required, 0 vote not required (default).", 262144, false, 0.0, false, 0.0);
	RegConsoleCmd("sm_setscores", Command_SetScores, "sm_setscores <survivor score> <infected score>", 0);
	return 0;
}

public Action:Command_SetScores(client, args)
{
	if (!inFirstReadyUpOfRound)
	{
		ReplyToCommand(client, "Scores can only be changed during readyup before the round starts.");
		return Action:3;
	}
	if (args < 2)
	{
		ReplyToCommand(client, "Usage: sm_setscores <survivor score> <infected score>");
		return Action:3;
	}
	initiatingClient = client;
	new String:buffer[32];
	GetCmdArg(1, buffer, 32);
	survivorScore = StringToInt(buffer, 10);
	GetCmdArg(2, buffer, 32);
	infectedScore = StringToInt(buffer, 10);
	new AdminId:id = GetUserAdmin(client);
	if (id != AdminId:-1)
	{
		adminInitiated = true;
		if (GetConVarInt(forceAdminsToVote) == 1)
		{
			StartScoreVote();
		}
		else
		{
			SetScores();
		}
	}
	else
	{
		if (GetConVarInt(allowPlayersToVote) == 1)
		{
			adminInitiated = false;
			StartScoreVote();
		}
	}
	return Action:3;
}

StartScoreVote()
{
	if (GetClientTeam(initiatingClient) == 1)
	{
		PrintToChat(initiatingClient, "Score voting isn't allowed for spectators.");
		return 0;
	}
	if (IsNewBuiltinVoteAllowed())
	{
		new iNumPlayers;
		decl iPlayers[MaxClients];
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (!IsClientInGame(i) || IsFakeClient(i) || GetClientTeam(i) == 1)
			{
			}
			else
			{
				iNumPlayers++;
				iPlayers[iNumPlayers] = i;
			}
			i++;
		}
		if (GetConVarInt(minimumPlayersForVote) > iNumPlayers)
		{
			PrintToChat(initiatingClient, "Score vote cannot be started. Not enough players.");
			return 0;
		}
		voteHandler = CreateBuiltinVote(BuiltinVoteActionHandler:13, BuiltinVoteType:3, BuiltinVoteAction:26);
		new String:sBuffer[64];
		Format(sBuffer, 64, "Change scores to %d - %d?", survivorScore, infectedScore);
		SetBuiltinVoteArgument(voteHandler, sBuffer);
		SetBuiltinVoteInitiator(voteHandler, initiatingClient);
		SetBuiltinVoteResultCallback(voteHandler, BuiltinVoteHandler:11);
		DisplayBuiltinVote(voteHandler, iPlayers, iNumPlayers, 20);
		FakeClientCommand(initiatingClient, "Vote Yes");
		return 0;
	}
	PrintToChat(initiatingClient, "Score vote cannot be started now.");
	return 0;
}

SetScores()
{
	decl SurvivorTeamIndex;
	new var1;
	if (GameRules_GetProp("m_bAreTeamsFlipped", 4, 0))
	{
		var1 = 1;
	}
	else
	{
		var1 = 0;
	}
	SurvivorTeamIndex = var1;
	decl InfectedTeamIndex;
	new var2;
	if (GameRules_GetProp("m_bAreTeamsFlipped", 4, 0))
	{
		var2 = 0;
	}
	else
	{
		var2 = 1;
	}
	InfectedTeamIndex = var2;
	SDKCall(fSetCampaignScores, survivorScore, infectedScore);
	L4D2Direct_SetVSCampaignScore(SurvivorTeamIndex, survivorScore);
	L4D2Direct_SetVSCampaignScore(InfectedTeamIndex, infectedScore);
	if (!adminInitiated)
	{
		CPrintToChatAll("Scores set to {olive}%d {default} ({green}Sur{default}) - {olive}%d {default} ({green}Inf{default}) by vote.", survivorScore, infectedScore);
	}
	else
	{
		new String:client_name[32];
		GetClientName(initiatingClient, client_name, 32);
		CPrintToChatAll("Scores set to {olive}%d {default} ({green}Sur{default}) - {olive}%d {default} ({green}Inf{default}) by {lightgreen}%s{default}.", survivorScore, infectedScore, client_name);
	}
	return 0;
}

public VoteActionHandler(Handle:vote, BuiltinVoteAction:action, param1, param2)
{
	switch (action)
	{
		case 2:
		{
			voteHandler = MissingTAG:0;
			CloseHandle(vote);
		}
		case 8:
		{
			DisplayBuiltinVoteFail(vote, param1);
		}
		default:
		{
		}
	}
	return 0;
}

public ScoreVoteResultHandler(Handle:vote, num_votes, num_clients, client_info[][2], num_items, item_info[][2])
{
	new i;
	while (i < num_items)
	{
		if (item_info[i][0] == 1)
		{
			if (num_clients / 2 < item_info[i][1])
			{
				DisplayBuiltinVotePass(vote, "Changing scores...");
				SetScores();
				return 0;
			}
		}
		i++;
	}
	DisplayBuiltinVoteFail(vote, BuiltinVoteFailReason:3);
	return 0;
}

public OnRoundIsLive()
{
	inFirstReadyUpOfRound = false;
	return 0;
}

public OnMapStart()
{
	inFirstReadyUpOfRound = true;
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "06/07/2018",
	time = "03:00:59"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Shadow Removal",
	description = "A plugin that removes Shadows so that Survivors can't see Infected Player's their shadows through walls and the like.",
	author = "Sir",
	version = "1.0",
	url = "Nope"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

public void:OnMapStart()
{
	CreateEntityByName("shadow_control", -1);
	new ent = -1;
	while ((ent = FindEntityByClassname(ent, "shadow_control")) != -1)
	{
		SetVariantInt(1);
		AcceptEntityInput(ent, "SetShadowsDisabled", -1, -1, 0);
	}
	return void:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:21"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Infected Friendly Fire Disable",
	description = "Disables friendly fire between infected players.",
	author = "ProdigySim, Don, Visor",
	version = "1.3",
	url = ""
};
new Handle:cvar_ffblock;
new Handle:cvar_allow_tank_ff;
new Handle:cvar_block_witch_ff;
new bool:bIsWitch;
new bool:lateLoad;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	cvar_ffblock = CreateConVar("l4d2_block_infected_ff", "1", "Disable SI->SI friendly fire", 0, false, 0.0, false, 0.0);
	cvar_allow_tank_ff = CreateConVar("l4d2_infected_ff_allow_tank", "0", "Do not disable friendly fire for tanks on other SI", 0, false, 0.0, false, 0.0);
	cvar_block_witch_ff = CreateConVar("l4d2_infected_ff_block_witch", "0", "Disable FF towards witches", 0, false, 0.0, false, 0.0);
	if (lateLoad)
	{
		new cl = 1;
		while (cl <= MaxClients)
		{
			if (IsClientInGame(cl))
			{
				SDKHook(cl, SDKHookType:2, OnTakeDamage);
			}
			cl++;
		}
	}
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	lateLoad = late;
	return APLRes:0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (GetConVarBool(cvar_ffblock) && IsClientAndInGame(victim) && IsClientAndInGame(attacker) && GetClientTeam(attacker) == 3)
	{
		decl String:victimClass[64];
		GetEdictClassname(victim, victimClass, 64);
		if (StrEqual(victimClass, "witch", true))
		{
			bIsWitch = true;
		}
		new var2;
		if (!GetConVarBool(cvar_allow_tank_ff) || GetEntProp(attacker, PropType:0, "m_zombieClass", 4, 0) == 8)
		{
			new var3;
			if (!bIsWitch && GetClientTeam(victim) == 3)
			{
				return Action:3;
			}
			new var4;
			if (bIsWitch && GetConVarBool(cvar_block_witch_ff))
			{
				damage = 0;
				return Action:1;
			}
		}
	}
	return Action:0;
}

bool:IsClientAndInGame(index)
{
	new var1;
	return index > 0 && index <= MaxClients && IsClientInGame(index);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:40"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new LINUX_SI_DOMINATION_OFFSETS[4] =
{
	13284, 16008, 16128, 15976
};
new FLAGS[3] =
{
	1, 2, 4
};
new Handle:hCvarInfectedFlags;
new iActiveFlags;
public Plugin:myinfo =
{
	name = "L4D2 No SI Friendly Staggers",
	description = "Removes SI staggers caused by other SI(Boomer, Charger, Witch)",
	author = "Visor",
	version = "1.1",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	hCvarInfectedFlags = CreateConVar("l4d2_disable_si_friendly_staggers", "0", "Remove SI staggers caused by other SI(bitmask: 1-Boomer/2-Charger/4-Witch)", 262144, false, 0.0, false, 0.0);
	iActiveFlags = GetConVarInt(hCvarInfectedFlags);
	HookConVarChange(hCvarInfectedFlags, PluginActivityChanged);
	return 0;
}

public PluginActivityChanged(Handle:cvar, String:oldValue[], String:newValue[])
{
	iActiveFlags = GetConVarInt(hCvarInfectedFlags);
	return 0;
}

public Action:L4D2_OnStagger(target, source)
{
	if (!iActiveFlags)
	{
		return Action:0;
	}
	new var1;
	if (GetInfectedClass(source) == 2 && !FLAGS[0] & iActiveFlags)
	{
		return Action:0;
	}
	new var2;
	if (!source && !FLAGS[1] & iActiveFlags)
	{
		return Action:0;
	}
	new var3;
	if (GetClientTeam(target) == 2 && IsBeingAttacked(target))
	{
		return Action:3;
	}
	if (GetClientTeam(target) != 3)
	{
		return Action:0;
	}
	new var4;
	if (!source && GetInfectedClass(target) != 6)
	{
		return Action:3;
	}
	new var5;
	if (source <= MaxClients && GetInfectedClass(source) == 2)
	{
		return Action:3;
	}
	decl String:classname[64];
	GetEdictClassname(source, classname, 64);
	new var6;
	if (FLAGS[2] & iActiveFlags && StrEqual(classname, "witch", true))
	{
		return Action:3;
	}
	return Action:0;
}

bool:IsBeingAttacked(survivor)
{
	new Address:pEntity = GetEntityAddress(survivor);
	if (pEntity)
	{
		new survivorState;
		new i;
		while (i < 4)
		{
			survivorState = LoadFromAddress(LINUX_SI_DOMINATION_OFFSETS[i][pEntity], NumberType:2) + survivorState;
			i++;
		}
		new var1;
		if (survivorState > 0)
		{
			var1 = true;
		}
		else
		{
			var1 = false;
		}
		return var1;
	}
	return false;
}

GetInfectedClass(client)
{
	new var1;
	if (client > 0 && client <= MaxClients && IsClientInGame(client))
	{
		return GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	}
	return -1;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:40"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new infectedProps[4] =
{
	13280, 16004, 16124, 15972
};
new String:L4D2SI_Names[9][32] =
{
	"None",
	"Smoker",
	"Boomer",
	"Hunter",
	"Spitter",
	"Jockey",
	"Charger",
	"Witch",
	"Tank"
};
public Plugin:myinfo =
{
	name = "L4D2 SI Suicide",
	description = "Allows the SI to commit a suicide under certain circumstances",
	author = "Visor",
	version = "1.2",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator>=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) >= 0;
}

MakeVectorFromPoints(Float:pt1[3], Float:pt2[3], Float:output[3])
{
	output[0] = pt2[0] - pt1[0];
	output[1] = pt2[1] - pt1[1];
	output[2] = pt2[2] - pt1[2];
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 2);
	new index = CFormat(szCMessage, 250, -1);
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			if (index == -1)
			{
				PrintToChat(i, szCMessage);
			}
			CSayText2(i, index, szCMessage);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	BfWriteByte(hBuffer, author);
	BfWriteByte(hBuffer, 1);
	BfWriteString(hBuffer, szMessage);
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	RegConsoleCmd("sm_kill", CommitSuicideCmd, "", 0);
	RegConsoleCmd("sm_suicide", CommitSuicideCmd, "", 0);
	return 0;
}

public Action:CommitSuicideCmd(client, args)
{
	new String:error[256] = "You want to commit suicide as a Tank? Really?";
	new var1;
	if (!IsInfected(client) || !IsPlayerAlive(client) || IsGhost(client))
	{
	}
	else
	{
		if (!(IsVisibleToSurvivors(client)))
		{
			if (!(IsAttacking(client)))
			{
				if (GetInfectedClass(client) == 8)
				{
				}
			}
		}
	}
	if (error[0])
	{
		CPrintToChat(client, "<{olive}ZombieSuicide{default}> %s", error);
		return Action:3;
	}
	ForcePlayerSuicide(client);
	CPrintToChatAll("<{olive}ZombieSuicide{default}> {red}%N{default}[{green}%s{default}] has committed suicide!", client, L4D2SI_Names[GetInfectedClass(client) + -1]);
	return Action:0;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

bool:IsGhost(client)
{
	return GetEntProp(client, PropType:0, "m_isGhost", 4, 0);
}

GetInfectedClass(client)
{
	return GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
}

bool:IsAttacking(infected)
{
	new client;
	new i;
	while (i < 4)
	{
		client = GetEntDataEnt2(infected, infectedProps[i]);
		new var1;
		if (IsSurvivor(client) && IsPlayerAlive(client))
		{
			return true;
		}
		i++;
	}
	return false;
}

bool:IsVisibleToSurvivors(entity)
{
	new iSurv;
	new i = 1;
	while (i < MaxClients && iSurv < 4)
	{
		if (IsSurvivor(i))
		{
			iSurv++;
			new var2;
			if (IsPlayerAlive(i) && IsVisibleTo(i, entity))
			{
				return true;
			}
		}
		i++;
	}
	return false;
}

bool:IsVisibleTo(client, entity)
{
	decl Float:vAngles[3];
	decl Float:vOrigin[3];
	decl Float:vEnt[3];
	decl Float:vLookAt[3];
	GetClientEyePosition(client, vOrigin);
	GetEntPropVector(entity, PropType:0, "m_vecOrigin", vEnt, 0);
	MakeVectorFromPoints(vOrigin, vEnt, vLookAt);
	GetVectorAngles(vLookAt, vAngles);
	new Handle:trace = TR_TraceRayFilterEx(vOrigin, vAngles, 1174421507, RayType:1, TraceFilter, any:0);
	new bool:isVisible;
	if (TR_DidHit(trace))
	{
		decl Float:vStart[3];
		TR_GetEndPosition(vStart, trace);
		if (GetVectorDistance(vOrigin, vStart, false) + 75.0 >= GetVectorDistance(vOrigin, vEnt, false))
		{
			isVisible = true;
		}
	}
	else
	{
		isVisible = true;
	}
	CloseHandle(trace);
	return isVisible;
}

public bool:TraceFilter(entity, contentsMask)
{
	new var1;
	if (entity <= MaxClients || !IsValidEntity(entity))
	{
		return false;
	}
	decl String:class[128];
	GetEdictClassname(entity, class, 128);
	return !StrEqual(class, "prop_physics", false);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/19/2016",
	time = "13:16:52"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new String:g_csSIClassName[9][] =
{
	"",
	"smoker",
	"boomer",
	"hunter",
	"spitter",
	"jockey",
	"charger",
	"witch",
	"tank"
};
new bool:g_bLateLoad;
new Handle:g_hForwardSkeet;
new Handle:g_hForwardSkeetHurt;
new Handle:g_hForwardSkeetMelee;
new Handle:g_hForwardSkeetMeleeHurt;
new Handle:g_hForwardSkeetSniper;
new Handle:g_hForwardSkeetSniperHurt;
new Handle:g_hForwardSkeetGL;
new Handle:g_hForwardHunterDeadstop;
new Handle:g_hForwardSIShove;
new Handle:g_hForwardBoomerPop;
new Handle:g_hForwardLevel;
new Handle:g_hForwardLevelHurt;
new Handle:g_hForwardCrown;
new Handle:g_hForwardDrawCrown;
new Handle:g_hForwardTongueCut;
new Handle:g_hForwardSmokerSelfClear;
new Handle:g_hForwardRockSkeeted;
new Handle:g_hForwardRockEaten;
new Handle:g_hForwardHunterDP;
new Handle:g_hForwardJockeyDP;
new Handle:g_hForwardDeathCharge;
new Handle:g_hForwardClear;
new Handle:g_hForwardVomitLanded;
new Handle:g_hForwardBHopStreak;
new Handle:g_hForwardAlarmTriggered;
new Handle:g_hTrieWeapons;
new Handle:g_hTrieEntityCreated;
new Handle:g_hTrieAbility;
new Handle:g_hWitchTrie;
new Handle:g_hRockTrie;
new Handle:g_hCarTrie;
new Float:g_fSpawnTime[66];
new Float:g_fPinTime[66][2];
new g_iSpecialVictim[66];
new g_iHunterShotDmgTeam[66];
new g_iHunterShotDmg[66][66];
new Float:g_fHunterShotStart[66][66];
new Float:g_fHunterTracePouncing[66];
new Float:g_fHunterLastShot[66];
new g_iHunterLastHealth[66];
new g_iHunterOverkill[66];
new bool:g_bHunterKilledPouncing[66];
new g_iPounceDamage[66];
new Float:g_fPouncePosition[66][3];
new Float:g_fVictimLastShove[66][66];
new g_iChargerHealth[66];
new Float:g_fChargeTime[66];
new g_iChargeVictim[66];
new Float:g_fChargeVictimPos[66][3];
new g_iVictimCharger[66];
new g_iVictimFlags[66];
new g_iVictimMapDmg[66];
new bool:g_bBoomerHitSomebody[66];
new g_iBoomerGotShoved[66];
new g_iBoomerVomitHits[66];
new Float:g_fWitchShotStart[66];
new bool:g_bSmokerClearCheck[66];
new g_iSmokerVictim[66];
new g_iSmokerVictimDamage[66];
new bool:g_bSmokerShoved[66];
new g_iTankRock[66];
new g_iRocksBeingThrown[10];
new g_iRocksBeingThrownCount;
new bool:g_bIsHopping[66];
new bool:g_bHopCheck[66];
new g_iHops[66];
new Float:g_fLastHop[66][3];
new Float:g_fHopTopVelocity[66];
new Float:g_fLastCarAlarm;
new g_iLastCarAlarmReason[66];
new g_iLastCarAlarmBoomer;
new Handle:g_hCvarReport;
new Handle:g_hCvarAllowMelee;
new Handle:g_hCvarAllowSniper;
new Handle:g_hCvarAllowGLSkeet;
new Handle:g_hCvarDrawCrownThresh;
new Handle:g_hCvarSelfClearThresh;
new Handle:g_hCvarHunterDPThresh;
new Handle:g_hCvarJockeyDPThresh;
new Handle:g_hCvarHideFakeDamage;
new Handle:g_hCvarDeathChargeHeight;
new Handle:g_hCvarInstaTime;
new Handle:g_hCvarBHopMinStreak;
new Handle:g_hCvarBHopMinInitSpeed;
new Handle:g_hCvarBHopContSpeed;
new Handle:g_hCvarPounceInterrupt;
new g_iPounceInterrupt = 150;
new Handle:g_hCvarChargerHealth;
new Handle:g_hCvarWitchHealth;
new Handle:g_hCvarMaxPounceDistance;
new Handle:g_hCvarMinPounceDistance;
new Handle:g_hCvarMaxPounceDamage;
public Plugin:myinfo =
{
	name = "Skill Detection (skeets, crowns, levels)",
	description = "Detects and reports skeets, crowns, levels, highpounces, etc.",
	author = "Tabun",
	version = "0.9.19",
	url = "https://github.com/Tabbernaut/L4D2-Plugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

bool:operator>(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) > oper2;
}

bool:operator<(Float:,_:)(Float:oper1, oper2)
{
	return oper1 < float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Float:L4D2Direct_GetFlowDistance(client)
{
	static Handle:GetFlowDistanceSDKCall;
	if (!GetFlowDistanceSDKCall)
	{
		StartPrepSDKCall(SDKCallType:2);
		if (!PrepSDKCall_SetFromConf(L4D2Direct_GetGameConf(), SDKFuncConfSource:1, "CTerrorPlayer::GetFlowDistance"))
		{
			return 0.0;
		}
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		PrepSDKCall_SetReturnInfo(SDKType:5, SDKPassMethod:1, 0, 0);
		GetFlowDistanceSDKCall = EndPrepSDKCall();
		if (!GetFlowDistanceSDKCall)
		{
			return 0.0;
		}
	}
	return SDKCall(GetFlowDistanceSDKCall, client, 0);
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	RegPluginLibrary("skill_detect");
	g_hForwardSkeet = CreateGlobalForward("OnSkeet", ExecType:0, 2, 2);
	g_hForwardSkeetHurt = CreateGlobalForward("OnSkeetHurt", ExecType:0, 2, 2, 2, 2);
	g_hForwardSkeetMelee = CreateGlobalForward("OnSkeetMelee", ExecType:0, 2, 2);
	g_hForwardSkeetMeleeHurt = CreateGlobalForward("OnSkeetMeleeHurt", ExecType:0, 2, 2, 2, 2);
	g_hForwardSkeetSniper = CreateGlobalForward("OnSkeetSniper", ExecType:0, 2, 2);
	g_hForwardSkeetSniperHurt = CreateGlobalForward("OnSkeetSniperHurt", ExecType:0, 2, 2, 2, 2);
	g_hForwardSkeetGL = CreateGlobalForward("OnSkeetGL", ExecType:0, 2, 2);
	g_hForwardSIShove = CreateGlobalForward("OnSpecialShoved", ExecType:0, 2, 2, 2);
	g_hForwardHunterDeadstop = CreateGlobalForward("OnHunterDeadstop", ExecType:0, 2, 2);
	g_hForwardBoomerPop = CreateGlobalForward("OnBoomerPop", ExecType:0, 2, 2, 2, 4);
	g_hForwardLevel = CreateGlobalForward("OnChargerLevel", ExecType:0, 2, 2);
	g_hForwardLevelHurt = CreateGlobalForward("OnChargerLevelHurt", ExecType:0, 2, 2, 2);
	g_hForwardCrown = CreateGlobalForward("OnWitchCrown", ExecType:0, 2, 2);
	g_hForwardDrawCrown = CreateGlobalForward("OnWitchDrawCrown", ExecType:0, 2, 2, 2);
	g_hForwardTongueCut = CreateGlobalForward("OnTongueCut", ExecType:0, 2, 2);
	g_hForwardSmokerSelfClear = CreateGlobalForward("OnSmokerSelfClear", ExecType:0, 2, 2, 2);
	g_hForwardRockSkeeted = CreateGlobalForward("OnTankRockSkeeted", ExecType:0, 2, 2);
	g_hForwardRockEaten = CreateGlobalForward("OnTankRockEaten", ExecType:0, 2, 2);
	g_hForwardHunterDP = CreateGlobalForward("OnHunterHighPounce", ExecType:0, 2, 2, 2, 4, 4, 2, 2);
	g_hForwardJockeyDP = CreateGlobalForward("OnJockeyHighPounce", ExecType:0, 2, 2, 4, 2);
	g_hForwardDeathCharge = CreateGlobalForward("OnDeathCharge", ExecType:0, 2, 2, 4, 4, 2);
	g_hForwardClear = CreateGlobalForward("OnSpecialClear", ExecType:0, 2, 2, 2, 2, 4, 4, 2);
	g_hForwardVomitLanded = CreateGlobalForward("OnBoomerVomitLanded", ExecType:0, 2, 2);
	g_hForwardBHopStreak = CreateGlobalForward("OnBunnyHopStreak", ExecType:0, 2, 2, 4);
	g_hForwardAlarmTriggered = CreateGlobalForward("OnCarAlarmTriggered", ExecType:0, 2, 2, 2);
	g_bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	HookEvent("round_start", Event_RoundStart, EventHookMode:2);
	HookEvent("scavenge_round_start", Event_RoundStart, EventHookMode:2);
	HookEvent("round_end", Event_RoundEnd, EventHookMode:2);
	HookEvent("player_spawn", Event_PlayerSpawn, EventHookMode:1);
	HookEvent("player_hurt", Event_PlayerHurt, EventHookMode:0);
	HookEvent("player_death", Event_PlayerDeath, EventHookMode:0);
	HookEvent("ability_use", Event_AbilityUse, EventHookMode:1);
	HookEvent("lunge_pounce", Event_LungePounce, EventHookMode:1);
	HookEvent("player_shoved", Event_PlayerShoved, EventHookMode:1);
	HookEvent("player_jump", Event_PlayerJumped, EventHookMode:1);
	HookEvent("player_jump_apex", Event_PlayerJumpApex, EventHookMode:1);
	HookEvent("player_now_it", Event_PlayerBoomed, EventHookMode:1);
	HookEvent("boomer_exploded", Event_BoomerExploded, EventHookMode:1);
	HookEvent("witch_spawn", Event_WitchSpawned, EventHookMode:1);
	HookEvent("witch_killed", Event_WitchKilled, EventHookMode:1);
	HookEvent("witch_harasser_set", Event_WitchHarasserSet, EventHookMode:1);
	HookEvent("tongue_grab", Event_TongueGrab, EventHookMode:1);
	HookEvent("tongue_pull_stopped", Event_TonguePullStopped, EventHookMode:1);
	HookEvent("choke_start", Event_ChokeStart, EventHookMode:1);
	HookEvent("choke_stopped", Event_ChokeStop, EventHookMode:1);
	HookEvent("jockey_ride", Event_JockeyRide, EventHookMode:1);
	HookEvent("charger_carry_start", Event_ChargeCarryStart, EventHookMode:1);
	HookEvent("charger_carry_end", Event_ChargeCarryEnd, EventHookMode:1);
	HookEvent("charger_impact", Event_ChargeImpact, EventHookMode:1);
	HookEvent("charger_pummel_start", Event_ChargePummelStart, EventHookMode:1);
	HookEvent("player_incapacitated_start", Event_IncapStart, EventHookMode:1);
	HookEvent("triggered_car_alarm", Event_CarAlarmGoesOff, EventHookMode:1);
	CreateConVar("sm_skill_detect_version", "0.9.19", "Skill detect plugin version.", 401664, false, 0.0, false, 0.0);
	g_hCvarReport = CreateConVar("sm_skill_report_enable", "0", "Whether to report in chat (see sm_skill_report_flags).", 262144, true, 0.0, true, 1.0);
	g_hCvarAllowMelee = CreateConVar("sm_skill_skeet_allowmelee", "1", "Whether to count/forward melee skeets.", 262144, true, 0.0, true, 1.0);
	g_hCvarAllowSniper = CreateConVar("sm_skill_skeet_allowsniper", "1", "Whether to count/forward sniper/magnum headshots as skeets.", 262144, true, 0.0, true, 1.0);
	g_hCvarAllowGLSkeet = CreateConVar("sm_skill_skeet_allowgl", "1", "Whether to count/forward direct GL hits as skeets.", 262144, true, 0.0, true, 1.0);
	g_hCvarDrawCrownThresh = CreateConVar("sm_skill_drawcrown_damage", "500", "How much damage a survivor must at least do in the final shot for it to count as a drawcrown.", 262144, true, 0.0, false, 0.0);
	g_hCvarSelfClearThresh = CreateConVar("sm_skill_selfclear_damage", "200", "How much damage a survivor must at least do to a smoker for him to count as self-clearing.", 262144, true, 0.0, false, 0.0);
	g_hCvarHunterDPThresh = CreateConVar("sm_skill_hunterdp_height", "400", "Minimum height of hunter pounce for it to count as a DP.", 262144, true, 0.0, false, 0.0);
	g_hCvarJockeyDPThresh = CreateConVar("sm_skill_jockeydp_height", "300", "How much height distance a jockey must make for his 'DP' to count as a reportable highpounce.", 262144, true, 0.0, false, 0.0);
	g_hCvarHideFakeDamage = CreateConVar("sm_skill_hidefakedamage", "0", "If set, any damage done that exceeds the health of a victim is hidden in reports.", 262144, true, 0.0, true, 1.0);
	g_hCvarDeathChargeHeight = CreateConVar("sm_skill_deathcharge_height", "400", "How much height distance a charger must take its victim for a deathcharge to be reported.", 262144, true, 0.0, false, 0.0);
	g_hCvarInstaTime = CreateConVar("sm_skill_instaclear_time", "0.75", "A clear within this time (in seconds) counts as an insta-clear.", 262144, true, 0.0, false, 0.0);
	g_hCvarBHopMinStreak = CreateConVar("sm_skill_bhopstreak", "3", "The lowest bunnyhop streak that will be reported.", 262144, true, 0.0, false, 0.0);
	g_hCvarBHopMinInitSpeed = CreateConVar("sm_skill_bhopinitspeed", "150", "The minimal speed of the first jump of a bunnyhopstreak (0 to allow 'hops' from standstill).", 262144, true, 0.0, false, 0.0);
	g_hCvarBHopContSpeed = CreateConVar("sm_skill_bhopkeepspeed", "300", "The minimal speed at which hops are considered succesful even if not speed increase is made.", 262144, true, 0.0, false, 0.0);
	g_hCvarPounceInterrupt = FindConVar("z_pounce_damage_interrupt");
	HookConVarChange(g_hCvarPounceInterrupt, CvarChange_PounceInterrupt);
	g_iPounceInterrupt = GetConVarInt(g_hCvarPounceInterrupt);
	g_hCvarChargerHealth = FindConVar("z_charger_health");
	g_hCvarWitchHealth = FindConVar("z_witch_health");
	g_hCvarMaxPounceDistance = FindConVar("z_pounce_damage_range_max");
	g_hCvarMinPounceDistance = FindConVar("z_pounce_damage_range_min");
	g_hCvarMaxPounceDamage = FindConVar("z_hunter_max_pounce_bonus_damage");
	if (!g_hCvarMaxPounceDistance)
	{
		g_hCvarMaxPounceDistance = CreateConVar("z_pounce_damage_range_max", "1000.0", "Not available on this server, added by l4d2_skill_detect.", 262144, true, 0.0, false, 0.0);
	}
	if (!g_hCvarMinPounceDistance)
	{
		g_hCvarMinPounceDistance = CreateConVar("z_pounce_damage_range_min", "300.0", "Not available on this server, added by l4d2_skill_detect.", 262144, true, 0.0, false, 0.0);
	}
	if (!g_hCvarMaxPounceDamage)
	{
		g_hCvarMaxPounceDamage = CreateConVar("z_hunter_max_pounce_bonus_damage", "49", "Not available on this server, added by l4d2_skill_detect.", 262144, true, 0.0, false, 0.0);
	}
	g_hTrieWeapons = CreateTrie();
	SetTrieValue(g_hTrieWeapons, "hunting_rifle", any:0, true);
	SetTrieValue(g_hTrieWeapons, "sniper_military", any:0, true);
	SetTrieValue(g_hTrieWeapons, "sniper_awp", any:0, true);
	SetTrieValue(g_hTrieWeapons, "sniper_scout", any:0, true);
	SetTrieValue(g_hTrieWeapons, "pistol_magnum", any:1, true);
	SetTrieValue(g_hTrieWeapons, "grenade_launcher_projectile", any:2, true);
	g_hTrieEntityCreated = CreateTrie();
	SetTrieValue(g_hTrieEntityCreated, "tank_rock", any:1, true);
	SetTrieValue(g_hTrieEntityCreated, "witch", any:0, true);
	SetTrieValue(g_hTrieEntityCreated, "trigger_hurt", any:2, true);
	SetTrieValue(g_hTrieEntityCreated, "prop_car_alarm", any:3, true);
	SetTrieValue(g_hTrieEntityCreated, "prop_car_glass", any:4, true);
	g_hTrieAbility = CreateTrie();
	SetTrieValue(g_hTrieAbility, "ability_lunge", any:0, true);
	SetTrieValue(g_hTrieAbility, "ability_throw", any:1, true);
	g_hWitchTrie = CreateTrie();
	g_hRockTrie = CreateTrie();
	g_hCarTrie = CreateTrie();
	if (g_bLateLoad)
	{
		new client = 1;
		while (client <= MaxClients)
		{
			new var1;
			if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
			{
				SDKHook(client, SDKHookType:2, OnTakeDamageByWitch);
			}
			client++;
		}
	}
	return 0;
}

public CvarChange_PounceInterrupt(Handle:convar, String:oldValue[], String:newValue[])
{
	g_iPounceInterrupt = GetConVarInt(convar);
	return 0;
}

public OnClientPostAdminCheck(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamageByWitch);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamageByWitch);
	return 0;
}

public Action:Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	g_iRocksBeingThrownCount = 0;
	new i = 1;
	while (i <= MaxClients)
	{
		g_bIsHopping[i] = 0;
		new j = 1;
		while (j <= MaxClients)
		{
			g_fVictimLastShove[i][j] = 0.0;
			j++;
		}
		i++;
	}
	return Action:0;
}

public Action:Event_RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	ClearTrie(g_hCarTrie);
	return Action:0;
}


/* ERROR! null */
 function "Event_PlayerHurt" (number 23)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_PlayerSpawn" (number 24)
public Action:Event_IncapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new attackent = GetEventInt(event, "attackerentid");
	new dmgtype = GetEventInt(event, "type");
	new String:classname[24];
	new strOEC:classnameOEC;
	if (IsValidEntity(attackent))
	{
		GetEdictClassname(attackent, classname, 24);
		if (GetTrieValue(g_hTrieEntityCreated, classname, classnameOEC))
		{
			g_iVictimFlags[client] = g_iVictimFlags[client] | 16;
		}
	}
	new Float:flow = GetSurvivorDistance(client);
	if (dmgtype & 16384)
	{
		g_iVictimFlags[client] = g_iVictimFlags[client] | 4;
	}
	if (flow < 900.0)
	{
		g_iVictimFlags[client] = g_iVictimFlags[client] | 128;
	}
	return Action:0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "TraceAttack_Hunter" (number 26)
public Action:TraceAttack_Charger(victim, &attacker, &inflictor, &Float:damage, &damagetype, &ammotype, hitbox, hitgroup)
{
	new victimA = GetEntPropEnt(victim, PropType:0, "m_carryVictim", 0);
	if (victimA != -1)
	{
		g_iSpecialVictim[victim] = victimA;
	}
	else
	{
		g_iSpecialVictim[victim] = GetEntPropEnt(victim, PropType:0, "m_pummelVictim", 0);
	}
	return Action:0;
}

public Action:TraceAttack_Jockey(victim, &attacker, &inflictor, &Float:damage, &damagetype, &ammotype, hitbox, hitgroup)
{
	g_iSpecialVictim[victim] = GetEntPropEnt(victim, PropType:0, "m_jockeyVictim", 0);
	return Action:0;
}


/* ERROR! lysis.nodes.types.DSwitch incompatible with lysis.nodes.types.DJump */
 function "Event_PlayerDeath" (number 29)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_PlayerShoved" (number 30)
public Action:Event_LungePounce(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	g_fPinTime[client][0] = GetGameTime();
	ResetHunter(client);
	new var1;
	if (0.0 == g_fPouncePosition[client][0] && 0.0 == g_fPouncePosition[client][1] && 0.0 == g_fPouncePosition[client][2])
	{
		return Action:0;
	}
	new Float:endPos[3] = 0.0;
	GetClientAbsOrigin(client, endPos);
	new Float:fHeight = g_fPouncePosition[client][2] - endPos[2];
	new Float:fMin = GetConVarFloat(g_hCvarMinPounceDistance);
	new Float:fMax = GetConVarFloat(g_hCvarMaxPounceDistance);
	new Float:fMaxDmg = GetConVarFloat(g_hCvarMaxPounceDamage);
	new distance = RoundToNearest(GetVectorDistance(g_fPouncePosition[client], endPos, false));
	new Float:fDamage = float(distance) - fMin / fMax - fMin * fMaxDmg + 1.0;
	if (fDamage < 0.0)
	{
		fDamage = 0.0;
	}
	else
	{
		if (fDamage > fMaxDmg + 1.0)
		{
			fDamage = fMaxDmg + 1.0;
		}
	}
	new Handle:pack = CreateDataPack();
	WritePackCell(pack, client);
	WritePackCell(pack, victim);
	WritePackFloat(pack, fDamage);
	WritePackFloat(pack, fHeight);
	CreateTimer(0.05, Timer_HunterDP, pack, 0);
	return Action:0;
}

public Action:Timer_HunterDP(Handle:timer, Handle:pack)
{
	ResetPack(pack, false);
	new client = ReadPackCell(pack);
	new victim = ReadPackCell(pack);
	new Float:fDamage = ReadPackFloat(pack);
	new Float:fHeight = ReadPackFloat(pack);
	CloseHandle(pack);
	HandleHunterDP(client, victim, g_iPounceDamage[client], fDamage, fHeight, false);
	return Action:0;
}


/* ERROR! null */
 function "Event_PlayerJumped" (number 33)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Timer_CheckHop" (number 34)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Timer_CheckHopStreak" (number 35)
public Action:Event_PlayerJumpApex(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (g_bIsHopping[client])
	{
		new Float:fVel[3] = 0.0;
		GetEntPropVector(client, PropType:1, "m_vecVelocity", fVel, 0);
		fVel[2] = 0.0;
		new Float:fLength = GetVectorLength(fVel, false);
		if (fLength > g_fHopTopVelocity[client])
		{
			g_fHopTopVelocity[client] = fLength;
		}
	}
	return Action:0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_JockeyRide" (number 37)
public Action:Event_AbilityUse(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new String:abilityName[64];
	GetEventString(event, "ability", abilityName, 64);
	new var1;
	if ((client > 0 && client <= MaxClients) && IsClientInGame(client))
	{
		return Action:0;
	}
	new strAbility:ability;
	if (!GetTrieValue(g_hTrieAbility, abilityName, ability))
	{
		return Action:0;
	}
	switch (ability)
	{
		case 0:
		{
			ResetHunter(client);
			GetClientAbsOrigin(client, g_fPouncePosition[client]);
		}
		case 1:
		{
			g_iRocksBeingThrown[g_iRocksBeingThrownCount] = client;
			if (g_iRocksBeingThrownCount < 9)
			{
				g_iRocksBeingThrownCount += 1;
			}
		}
		default:
		{
		}
	}
	return Action:0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_ChargeCarryStart" (number 39)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_ChargeImpact" (number 40)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_ChargePummelStart" (number 41)
public Action:Event_ChargeCarryEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return Action:0;
	}
	g_fPinTime[client][1] = GetGameTime();
	CreateTimer(0.1, Timer_ChargeCarryEnd, client, 2);
	return Action:0;
}

public Action:Timer_ChargeCarryEnd(Handle:timer, any:client)
{
	g_iChargeVictim[client] = 0;
	return Action:0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Timer_ChargeCheck" (number 44)
public Action:Timer_DeathChargeCheck(Handle:timer, any:client)
{
	new var1;
	if ((client > any:0 && client <= MaxClients) && IsClientInGame(client))
	{
		return Action:0;
	}
	PrintDebug(3, "Checking charge victim: %i - %i - flags: %i (alive? %i)", g_iVictimCharger[client], client, g_iVictimFlags[client], IsPlayerAlive(client));
	new flags = g_iVictimFlags[client];
	if (!IsPlayerAlive(client))
	{
		new Float:pos[3] = 0.0;
		GetClientAbsOrigin(client, pos);
		new Float:fHeight = g_fChargeVictimPos[client][2] - pos[2];
		new var3;
		if ((((flags & 4 || flags & 2) && (flags & 8 || flags & 32)) || (flags & 128 && fHeight >= 350.0) || g_iVictimMapDmg[client] >= 300) && !flags & 64)
		{
			HandleDeathCharge(g_iVictimCharger[client], client, fHeight, GetVectorDistance(g_fChargeVictimPos[client], pos, false), flags & 1);
		}
	}
	else
	{
		new var9;
		if ((flags & 128 || g_iVictimMapDmg[client] >= 100) && !flags & 256)
		{
			g_iVictimFlags[client] = g_iVictimFlags[client] | 256;
			CreateTimer(3.0, Timer_DeathChargeCheck, client, 2);
		}
	}
	return Action:0;
}

ResetHunter(client)
{
	g_iHunterShotDmgTeam[client] = 0;
	new i = 1;
	while (i <= MaxClients)
	{
		g_iHunterShotDmg[client][i] = 0;
		g_fHunterShotStart[client][i] = 0.0;
		i++;
	}
	g_iHunterOverkill[client] = 0;
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	new var1;
	if (entity < 1 || !IsValidEntity(entity) || !IsValidEdict(entity))
	{
		return 0;
	}
	new strOEC:classnameOEC;
	if (!GetTrieValue(g_hTrieEntityCreated, classname, classnameOEC))
	{
		return 0;
	}
	switch (classnameOEC)
	{
		case 1:
		{
			decl String:rock_key[12];
			FormatEx(rock_key, 10, "%x", entity);
			new rock_array[3];
			new tank = ShiftTankThrower();
			new var2;
			if ((tank > 0 && tank <= MaxClients) && IsClientInGame(tank))
			{
				g_iTankRock[tank] = entity;
				rock_array[1] = tank;
			}
			SetTrieArray(g_hRockTrie, rock_key, rock_array, 3, true);
			SDKHook(entity, SDKHookType:11, TraceAttack_Rock);
			SDKHook(entity, SDKHookType:10, OnTouch_Rock);
		}
		case 3:
		{
			decl String:car_key[12];
			FormatEx(car_key, 10, "%x", entity);
			SDKHook(entity, SDKHookType:2, OnTakeDamage_Car);
			SDKHook(entity, SDKHookType:10, OnTouch_Car);
			SDKHook(entity, SDKHookType:7, OnEntitySpawned_CarAlarm);
		}
		case 4:
		{
			SDKHook(entity, SDKHookType:2, OnTakeDamage_CarGlass);
			SDKHook(entity, SDKHookType:10, OnTouch_CarGlass);
			SDKHook(entity, SDKHookType:7, OnEntitySpawned_CarAlarmGlass);
		}
		default:
		{
		}
	}
	return 0;
}

public OnEntitySpawned_CarAlarm(entity)
{
	if (!IsValidEntity(entity))
	{
		return 0;
	}
	decl String:car_key[12];
	FormatEx(car_key, 10, "%x", entity);
	decl String:target[48];
	GetEntPropString(entity, PropType:1, "m_iName", target, 48, 0);
	SetTrieValue(g_hCarTrie, target, entity, true);
	SetTrieValue(g_hCarTrie, car_key, any:0, true);
	HookSingleEntityOutput(entity, "OnCarAlarmStart", Hook_CarAlarmStart, false);
	return 0;
}

public OnEntitySpawned_CarAlarmGlass(entity)
{
	if (!IsValidEntity(entity))
	{
		return 0;
	}
	decl String:car_key[12];
	FormatEx(car_key, 10, "%x", entity);
	decl String:parent[48];
	GetEntPropString(entity, PropType:1, "m_iParent", parent, 48, 0);
	new parentEntity;
	if (GetTrieValue(g_hCarTrie, parent, parentEntity))
	{
		if (IsValidEntity(parentEntity))
		{
			SetTrieValue(g_hCarTrie, car_key, parentEntity, true);
			decl String:car_key_p[12];
			FormatEx(car_key_p, 10, "%x_A", parentEntity);
			new testEntity;
			if (GetTrieValue(g_hCarTrie, car_key_p, testEntity))
			{
				FormatEx(car_key_p, 10, "%x_B", parentEntity);
			}
			SetTrieValue(g_hCarTrie, car_key_p, entity, true);
		}
	}
	return 0;
}

public OnEntityDestroyed(entity)
{
	decl String:witch_key[12];
	FormatEx(witch_key, 10, "%x", entity);
	decl rock_array[3];
	if (GetTrieArray(g_hRockTrie, witch_key, rock_array, 3, 0))
	{
		CreateTimer(0.34, Timer_CheckRockSkeet, entity, 0);
		SDKUnhook(entity, SDKHookType:11, TraceAttack_Rock);
		return 0;
	}
	decl witch_array[72];
	if (GetTrieArray(g_hWitchTrie, witch_key, witch_array, 72, 0))
	{
		CreateTimer(0.15, Timer_WitchKeyDelete, entity, 0);
		SDKUnhook(entity, SDKHookType:3, OnTakeDamagePost_Witch);
		return 0;
	}
	return 0;
}

public Action:Timer_WitchKeyDelete(Handle:timer, any:witch)
{
	decl String:witch_key[12];
	FormatEx(witch_key, 10, "%x", witch);
	RemoveFromTrie(g_hWitchTrie, witch_key);
	return Action:0;
}

public Action:Timer_CheckRockSkeet(Handle:timer, any:rock)
{
	decl rock_array[3];
	decl String:rock_key[12];
	FormatEx(rock_key, 10, "%x", rock);
	if (!GetTrieArray(g_hRockTrie, rock_key, rock_array, 3, 0))
	{
		return Action:0;
	}
	RemoveFromTrie(g_hRockTrie, rock_key);
	if (0 < rock_array[0])
	{
		HandleRockSkeeted(rock_array[2], rock_array[1]);
	}
	return Action:0;
}


/* ERROR! null */
 function "Event_PlayerBoomed" (number 53)
public Action:Timer_BoomVomitCheck(Handle:timer, any:client)
{
	HandleVomitLanded(client, g_iBoomerVomitHits[client]);
	g_iBoomerVomitHits[client] = 0;
	return Action:0;
}


/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "Event_BoomerExploded" (number 55)
public Action:Event_WitchSpawned(Handle:event, String:name[], bool:dontBroadcast)
{
	new witch = GetEventInt(event, "witchid");
	SDKHook(witch, SDKHookType:3, OnTakeDamagePost_Witch);
	new witch_dmg_array[72];
	decl String:witch_key[12];
	FormatEx(witch_key, 10, "%x", witch);
	witch_dmg_array[66] = GetConVarInt(g_hCvarWitchHealth);
	SetTrieArray(g_hWitchTrie, witch_key, witch_dmg_array, 72, false);
	return Action:0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_WitchKilled" (number 57)
public Action:Event_WitchHarasserSet(Handle:event, String:name[], bool:dontBroadcast)
{
	new witch = GetEventInt(event, "witchid");
	decl String:witch_key[12];
	FormatEx(witch_key, 10, "%x", witch);
	decl witch_dmg_array[72];
	if (!GetTrieArray(g_hWitchTrie, witch_key, witch_dmg_array, 72, 0))
	{
		new i;
		while (i <= 65)
		{
			witch_dmg_array[i] = 0;
			i++;
		}
		witch_dmg_array[66] = GetConVarInt(g_hCvarWitchHealth);
		witch_dmg_array[68] = 1;
		SetTrieArray(g_hWitchTrie, witch_key, witch_dmg_array, 72, false);
	}
	else
	{
		witch_dmg_array[68] = 1;
		SetTrieArray(g_hWitchTrie, witch_key, witch_dmg_array, 72, true);
	}
	return Action:0;
}


/* ERROR! null */
 function "OnTakeDamageByWitch" (number 59)

/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "OnTakeDamagePost_Witch" (number 60)
public Action:Timer_CheckWitchCrown(Handle:timer, Handle:pack)
{
	ResetPack(pack, false);
	new attacker = ReadPackCell(pack);
	new witch = ReadPackCell(pack);
	new bool:bOneShot = ReadPackCell(pack);
	CloseHandle(pack);
	CheckWitchCrown(witch, attacker, bOneShot);
	return Action:0;
}

CheckWitchCrown(witch, attacker, bool:bOneShot)
{
	decl String:witch_key[12];
	FormatEx(witch_key, 10, "%x", witch);
	decl witch_dmg_array[72];
	if (!GetTrieArray(g_hWitchTrie, witch_key, witch_dmg_array, 72, 0))
	{
		PrintDebug(0, "Witch Crown Check: Error: Trie entry missing (entity: %i, oneshot: %i)", witch, bOneShot);
		return 0;
	}
	new chipDamage;
	new iWitchHealth = GetConVarInt(g_hCvarWitchHealth);
	if (bOneShot)
	{
		witch_dmg_array[71] = 1;
	}
	new var1;
	if (witch_dmg_array[67] || !witch_dmg_array[71])
	{
		PrintDebug(0, "Witch Crown Check: Failed: bungled: %i / crowntype: %i (entity: %i)", witch_dmg_array[67], witch_dmg_array[71], witch);
		PrintDebug(1, "Witch Crown Check: Further details: attacker: %N, attacker dmg: %i, teamless dmg: %i", attacker, witch_dmg_array[attacker], witch_dmg_array);
		return 0;
	}
	PrintDebug(0, "Witch Crown Check: crown shot: %i, harrassed: %i (full health: %i / drawthresh: %i / oneshot %i)", witch_dmg_array[70], witch_dmg_array[68], iWitchHealth, GetConVarInt(g_hCvarDrawCrownThresh), bOneShot);
	new var3;
	if (!witch_dmg_array[68] && (bOneShot || witch_dmg_array[70] >= iWitchHealth))
	{
		if (GetConVarBool(g_hCvarHideFakeDamage))
		{
			chipDamage = 0;
			new i;
			while (i <= 65)
			{
				if (!(attacker == i))
				{
					chipDamage = witch_dmg_array[i][chipDamage];
				}
				i++;
			}
			witch_dmg_array[attacker] = iWitchHealth - chipDamage;
		}
		HandleCrown(attacker, witch_dmg_array[attacker]);
	}
	else
	{
		if (GetConVarInt(g_hCvarDrawCrownThresh) <= witch_dmg_array[70])
		{
			new i;
			while (i <= 65)
			{
				if (attacker == i)
				{
					chipDamage = witch_dmg_array[i] - witch_dmg_array[70] + chipDamage;
				}
				else
				{
					chipDamage = witch_dmg_array[i][chipDamage];
				}
				i++;
			}
			if (GetConVarBool(g_hCvarHideFakeDamage))
			{
				if (chipDamage >= iWitchHealth)
				{
					chipDamage = iWitchHealth + -1;
					witch_dmg_array[70] = 1;
				}
				else
				{
					witch_dmg_array[70] = iWitchHealth - chipDamage;
				}
				if (GetConVarInt(g_hCvarDrawCrownThresh) > witch_dmg_array[70])
				{
					return 0;
				}
			}
			HandleDrawCrown(attacker, witch_dmg_array[70], chipDamage);
		}
	}
	return 0;
}

public Action:TraceAttack_Rock(victim, &attacker, &inflictor, &Float:damage, &damagetype, &ammotype, hitbox, hitgroup)
{
	new var1;
	return (attacker > 0 && attacker <= MaxClients) && IsClientInGame(attacker) && GetClientTeam(attacker) == 2;
}

public OnTouch_Rock(entity)
{
	decl String:rock_key[12];
	FormatEx(rock_key, 10, "%x", entity);
	new rock_array[3];
	rock_array[0] = -1;
	SetTrieArray(g_hRockTrie, rock_key, rock_array, 3, true);
	SDKUnhook(entity, SDKHookType:10, OnTouch_Rock);
	return 0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_TonguePullStopped" (number 65)
public Action:Event_TongueGrab(Handle:event, String:name[], bool:dontBroadcast)
{
	new attacker = GetClientOfUserId(GetEventInt(event, "userid"));
	new victim = GetClientOfUserId(GetEventInt(event, "victim"));
	new var1;
	return (attacker > 0 && attacker <= MaxClients) && IsClientInGame(attacker) && (GetClientTeam(attacker) == 3 && ((victim > 0 && victim <= MaxClients) && IsClientInGame(victim) && GetClientTeam(victim) == 2));
}

public Action:Event_ChokeStart(Handle:event, String:name[], bool:dontBroadcast)
{
	new attacker = GetClientOfUserId(GetEventInt(event, "userid"));
	if (0.0 == g_fPinTime[attacker][0])
	{
		g_fPinTime[attacker][0] = GetGameTime();
	}
	g_fPinTime[attacker][1] = GetGameTime();
	return Action:0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "Event_ChokeStop" (number 68)
public Hook_CarAlarmStart(String:output[], caller, activator, Float:delay)
{
	PrintDebug(0, "calarm trigger: caller %i / activator %i / delay: %.2f", caller, activator, delay);
	return 0;
}

public Action:Event_CarAlarmGoesOff(Handle:event, String:name[], bool:dontBroadcast)
{
	g_fLastCarAlarm = GetGameTime();
	return Action:0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "OnTakeDamage_Car" (number 71)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "OnTouch_Car" (number 72)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "OnTakeDamage_CarGlass" (number 73)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "OnTouch_CarGlass" (number 74)

/* ERROR! null */
 function "Timer_CheckAlarm" (number 75)
HandlePop(attacker, victim, shoveCount, Float:timeAlive)
{
	Call_StartForward(g_hForwardBoomerPop);
	Call_PushCell(attacker);
	Call_PushCell(victim);
	Call_PushCell(shoveCount);
	Call_PushFloat(timeAlive);
	Call_Finish(0);
	return 0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJumpCondition */
 function "HandleLevel" (number 77)

/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJumpCondition */
 function "HandleLevelHurt" (number 78)
HandleDeadstop(attacker, victim)
{
	Call_StartForward(g_hForwardHunterDeadstop);
	Call_PushCell(attacker);
	Call_PushCell(victim);
	Call_Finish(0);
	return 0;
}

HandleShove(attacker, victim, zombieClass)
{
	Call_StartForward(g_hForwardSIShove);
	Call_PushCell(attacker);
	Call_PushCell(victim);
	Call_PushCell(zombieClass);
	Call_Finish(0);
	return 0;
}

HandleSkeet(attacker, victim, bool:bMelee, bool:bSniper, bool:bGL)
{
	if (bSniper)
	{
		Call_StartForward(g_hForwardSkeetSniper);
		Call_PushCell(attacker);
		Call_PushCell(victim);
		Call_Finish(0);
	}
	else
	{
		if (bGL)
		{
			Call_StartForward(g_hForwardSkeetGL);
			Call_PushCell(attacker);
			Call_PushCell(victim);
			Call_Finish(0);
		}
		if (bMelee)
		{
			Call_StartForward(g_hForwardSkeetMelee);
			Call_PushCell(attacker);
			Call_PushCell(victim);
			Call_Finish(0);
		}
		Call_StartForward(g_hForwardSkeet);
		Call_PushCell(attacker);
		Call_PushCell(victim);
		Call_Finish(0);
	}
	return 0;
}

HandleNonSkeet(attacker, victim, damage, bool:bOverKill, bool:bMelee, bool:bSniper)
{
	if (bSniper)
	{
		Call_StartForward(g_hForwardSkeetSniperHurt);
		Call_PushCell(attacker);
		Call_PushCell(victim);
		Call_PushCell(damage);
		Call_PushCell(bOverKill);
		Call_Finish(0);
	}
	else
	{
		if (bMelee)
		{
			Call_StartForward(g_hForwardSkeetMeleeHurt);
			Call_PushCell(attacker);
			Call_PushCell(victim);
			Call_PushCell(damage);
			Call_PushCell(bOverKill);
			Call_Finish(0);
		}
		Call_StartForward(g_hForwardSkeetHurt);
		Call_PushCell(attacker);
		Call_PushCell(victim);
		Call_PushCell(damage);
		Call_PushCell(bOverKill);
		Call_Finish(0);
	}
	return 0;
}

HandleCrown(attacker, damage)
{
	Call_StartForward(g_hForwardCrown);
	Call_PushCell(attacker);
	Call_PushCell(damage);
	Call_Finish(0);
	return 0;
}

HandleDrawCrown(attacker, damage, chipdamage)
{
	Call_StartForward(g_hForwardDrawCrown);
	Call_PushCell(attacker);
	Call_PushCell(damage);
	Call_PushCell(chipdamage);
	Call_Finish(0);
	return 0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJumpCondition */
 function "HandleTongueCut" (number 85)

/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "HandleSmokerSelfClear" (number 86)
HandleRockEaten(attacker, victim)
{
	Call_StartForward(g_hForwardRockEaten);
	Call_PushCell(attacker);
	Call_PushCell(victim);
	Call_Finish(0);
	return 0;
}

HandleRockSkeeted(attacker, victim)
{
	if (GetConVarBool(g_hCvarReport))
	{
		CPrintToChatAll("{green}? {olive}%N {blue}skeeted {default}a tank rock", attacker);
	}
	Call_StartForward(g_hForwardRockSkeeted);
	Call_PushCell(attacker);
	Call_PushCell(victim);
	Call_Finish(0);
	return 0;
}

HandleHunterDP(attacker, victim, actualDamage, Float:calculatedDamage, Float:height, bool:playerIncapped)
{
	new var1;
	if (GetConVarBool(g_hCvarReport) && height >= GetConVarFloat(g_hCvarHunterDPThresh) && !playerIncapped)
	{
		new var2;
		if ((attacker > 0 && attacker <= MaxClients) && IsClientInGame(attacker) && ((victim > 0 && victim <= MaxClients) && IsClientInGame(victim) && !IsFakeClient(attacker)))
		{
			var10 = MissingTAG:1;
		}
		else
		{
			var10 = MissingTAG:0;
		}
		Call_PushCell(var10);
		Call_Finish(0);
		return 0;
	}
	Call_StartForward(g_hForwardHunterDP);
	Call_PushCell(attacker);
	Call_PushCell(victim);
	Call_PushCell(actualDamage);
	Call_PushFloat(calculatedDamage);
	Call_PushFloat(height);
	new var9;
	if (height >= GetConVarFloat(g_hCvarHunterDPThresh))
	{
		var9 = MissingTAG:1;
	}
	else
	{
		var9 = MissingTAG:0;
	}
	Call_PushCell(var9);
	new var10;
	if (playerIncapped)
	{
		var10 = MissingTAG:1;
	}
	else
	{
		var10 = MissingTAG:0;
	}
	Call_PushCell(var10);
	Call_Finish(0);
	return 0;
}

HandleJockeyDP(attacker, victim, Float:height)
{
	new var1;
	if (GetConVarBool(g_hCvarReport) && height >= GetConVarFloat(g_hCvarJockeyDPThresh))
	{
		new var2;
		return (attacker > 0 && attacker <= MaxClients) && IsClientInGame(attacker) && ((victim > 0 && victim <= MaxClients) && IsClientInGame(victim) && !IsFakeClient(attacker));
	}
	Call_StartForward(g_hForwardJockeyDP);
	Call_PushCell(attacker);
	Call_PushCell(victim);
	Call_PushFloat(height);
	new var9;
	if (height >= GetConVarFloat(g_hCvarJockeyDPThresh))
	{
		var9 = MissingTAG:1;
	}
	else
	{
		var9 = MissingTAG:0;
	}
	Call_PushCell(var9);
	Call_Finish(0);
	return 0;
}


/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "HandleDeathCharge" (number 91)

/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "HandleClear" (number 92)
HandleVomitLanded(attacker, boomCount)
{
	Call_StartForward(g_hForwardVomitLanded);
	Call_PushCell(attacker);
	Call_PushCell(boomCount);
	Call_Finish(0);
	return 0;
}


/* ERROR! lysis.nodes.types.DJump incompatible with lysis.nodes.types.DJumpCondition */
 function "HandleBHopStreak" (number 94)
HandleCarAlarmTriggered(survivor, infected, reason)
{
	Call_StartForward(g_hForwardAlarmTriggered);
	Call_PushCell(survivor);
	Call_PushCell(infected);
	Call_PushCell(reason);
	Call_Finish(0);
	return 0;
}

Float:GetSurvivorDistance(client)
{
	return L4D2Direct_GetFlowDistance(client);
}

ShiftTankThrower()
{
	new tank = -1;
	if (!g_iRocksBeingThrownCount)
	{
		return -1;
	}
	tank = g_iRocksBeingThrown[0];
	if (g_iRocksBeingThrownCount > 1)
	{
		new x = 1;
		while (x <= g_iRocksBeingThrownCount)
		{
			g_iRocksBeingThrown[x + -1] = g_iRocksBeingThrown[x];
			x++;
		}
	}
	g_iRocksBeingThrownCount -= 1;
	return tank;
}

PrintDebug(debuglevel, String:Message[])
{
	decl String:DebugBuff[256];
	VFormat(DebugBuff, 256, Message, 3);
	LogMessage(DebugBuff);
	return 0;
}

bool:IsWitch(entity)
{
	if (!IsValidEntity(entity))
	{
		return false;
	}
	decl String:classname[24];
	new strOEC:classnameOEC;
	GetEdictClassname(entity, classname, 24);
	new var1;
	if (!GetTrieValue(g_hTrieEntityCreated, classname, classnameOEC) || classnameOEC)
	{
		return false;
	}
	return true;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "03/19/2016",
	time = "19:25:35"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCvarSdGunfireSi;
new Handle:hCvarSdGunfireTank;
new Handle:hCvarSdInwaterTank;
new Handle:hCvarSdInwaterSurvivor;
new Handle:hCvarFindLimpspeed;
new Float:fGunfireSi;
new Float:fGunfireTank;
new Float:fInWaterTank;
new Float:fInWaterSurvivor;
new iLimp;
public Plugin:myinfo =
{
	name = "L4D2 Slowdown Control",
	description = "Manages the water/gunfire slowdown for both teams",
	author = "Visor, Sir",
	version = "3.0",
	url = "https://github.com/ConfoglTeam/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return oper1 + float(oper2);
}

bool:operator==(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) == 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator<(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) < 0;
}

bool:operator<=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) <= 0;
}

public OnPluginStart()
{
	hCvarSdGunfireSi = CreateConVar("l4d2_slowdown_gunfire_si", "-1", "Slowdown from gunfire for SI(-1: native slowdown; 0: no slowdown; 0.01-2.0: velocity multiplier)", 262144, false, 0.0, false, 0.0);
	hCvarSdGunfireTank = CreateConVar("l4d2_slowdown_gunfire_tank", "-1", "Slowdown from gunfire for the Tank(-1: native slowdown; 0: no slowdown; 0.01-2.0: velocity multiplier)", 262144, false, 0.0, false, 0.0);
	hCvarSdInwaterTank = CreateConVar("l4d2_slowdown_water_tank", "-1", "Slowdown in the water for the Tank(-1: native slowdown; 0: no slowdown; 0.01-2.0: velocity multiplier)", 262144, false, 0.0, false, 0.0);
	hCvarSdInwaterSurvivor = CreateConVar("l4d2_slowdown_water_survivors", "-1", "Slowdown in the water for the Survivors(-1: native slowdown; 0: no slowdown; 0.0-2.0: velocity multiplier)", 262144, false, 0.0, false, 0.0);
	hCvarFindLimpspeed = FindConVar("survivor_limp_health");
	HookConVarChange(hCvarSdGunfireSi, OnCvarChanged);
	HookConVarChange(hCvarSdGunfireTank, OnCvarChanged);
	HookConVarChange(hCvarSdInwaterTank, OnCvarChanged);
	HookConVarChange(hCvarSdInwaterSurvivor, OnCvarChanged);
	HookConVarChange(hCvarFindLimpspeed, OnCvarChanged);
	return 0;
}

public OnCvarChanged(Handle:cvar, String:oldValue[], String:newValue[])
{
	OnConfigsExecuted();
	return 0;
}

public OnConfigsExecuted()
{
	fGunfireSi = ProcessConVar(hCvarSdGunfireSi);
	fGunfireTank = ProcessConVar(hCvarSdGunfireTank);
	fInWaterTank = ProcessConVar(hCvarSdInwaterTank);
	fInWaterSurvivor = ProcessConVar(hCvarSdInwaterSurvivor);
	iLimp = GetConVarInt(hCvarFindLimpspeed);
	return 0;
}

Float:ProcessConVar(Handle:cvar)
{
	new Float:value = GetConVarFloat(cvar);
	if (-1.0 == value)
	{
		return -1.0;
	}
	if (0.0 == value)
	{
		return 1.0;
	}
	new var1;
	if (value > 2.0)
	{
		var1 = 2.0;
	}
	else
	{
		if (value < 0.01)
		{
			var1 = 0.01;
		}
		var1 = value;
	}
	return var1;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:3, OnTakeDamagePost);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:3, OnTakeDamagePost);
	return 0;
}

public L4D2_OnWaterMove(client)
{
	if (GetEntityFlags(client) & 512)
	{
		new var1;
		if (IsInfected(client) && IsTank(client))
		{
			ApplySlowdown(client, fInWaterTank, false);
		}
		new var2;
		if (IsSurvivor(client) && !IsLimping(client))
		{
			if (fInWaterSurvivor > -1.0)
			{
				ApplySlowdown(client, fInWaterSurvivor, true);
				CreateTimer(0.1, ResetSpeed, client, 2);
			}
		}
	}
	return 0;
}

public Action:ResetSpeed(Handle:timer, any:client)
{
	ApplySlowdown(client, 1.0, true);
	return Action:3;
}

public Action:OnTakeDamagePost(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	if (IsInfected(victim))
	{
		new var1;
		if (IsTank(victim))
		{
			var1 = fGunfireTank;
		}
		else
		{
			var1 = fGunfireSi;
		}
		ApplySlowdown(victim, var1, false);
	}
	return Action:0;
}

ApplySlowdown(client, Float:value, bool:laggedMovementProp)
{
	if (-1.0 == value)
	{
		return 0;
	}
	new var1;
	if (laggedMovementProp)
	{
		var1[0] = 2028;
	}
	else
	{
		var1[0] = 2052;
	}
	SetEntPropFloat(client, PropType:0, var1, value, 0);
	return 0;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

bool:IsTank(client)
{
	return GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8;
}

bool:IsLimping(client)
{
	new Float:buffer = GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0);
	new Float:TempHealth = 0.0;
	new PermHealth = GetClientHealth(client);
	if (buffer <= 0.0)
	{
		TempHealth = 0.0;
	}
	else
	{
		new Float:difference = GetGameTime() - GetEntPropFloat(client, PropType:0, "m_healthBufferTime", 0);
		new Float:decay = GetConVarFloat(FindConVar("pain_pills_decay_rate"));
		new Float:constant = 1.0 / decay;
		TempHealth = buffer - difference / constant;
	}
	if (TempHealth < 0.0)
	{
		TempHealth = 0.0;
	}
	if (RoundToFloor(TempHealth + PermHealth) < iLimp)
	{
		return true;
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:24"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCvarSdPistolMod;
new Handle:hCvarSdDeagleMod;
new Handle:hCvarSdUziMod;
new Handle:hCvarSdMacMod;
new Handle:hCvarSdAkMod;
new Handle:hCvarSdM4Mod;
new Handle:hCvarSdScarMod;
new Handle:hCvarSdPumpMod;
new Handle:hCvarSdChromeMod;
new Handle:hCvarSdAutoMod;
new Handle:hCvarSdRifleMod;
new Handle:hCvarSdScoutMod;
new Handle:hCvarSdMilitaryMod;
new Handle:hCvarSdGunfireSi;
new Handle:hCvarSdGunfireTank;
new Handle:hCvarSdInwaterTank;
new Handle:hCvarSdInwaterSurvivor;
new Handle:hCvarSdInwaterDuringTank;
new Handle:hCvarSurvivorLimpspeed;
new bool:tankInPlay;
public Plugin:myinfo =
{
	name = "L4D2 Slowdown Control",
	description = "Manages the water/gunfire slowdown for both teams",
	author = "Visor, Sir, darkid",
	version = "2.5",
	url = "https://github.com/ConfoglTeam/ProMod"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return oper1 + float(oper2);
}

Float:operator-(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) - oper2;
}

bool:operator==(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) == 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator<(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) < 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public OnPluginStart()
{
	hCvarSdGunfireSi = CreateConVar("l4d2_slowdown_gunfire_si", "0.0", "Maximum slowdown from gunfire for SI (-1: native slowdown; 0.0: No slowdown, 0.01-1.0: 1%%-100%% slowdown)", 262144, true, -1.0, true, 1.0);
	hCvarSdGunfireTank = CreateConVar("l4d2_slowdown_gunfire_tank", "0.2", "Maximum slowdown from gunfire for the Tank (-1: native slowdown; 0.0: No slowdown, 0.01-1.0: 1%%-100%% slowdown)", 262144, true, -1.0, true, 1.0);
	hCvarSdInwaterTank = CreateConVar("l4d2_slowdown_water_tank", "-1", "Maximum slowdown in the water for the Tank (-1: native slowdown; 0.0: No slowdown, 0.01-1.0: 1%%-100%% slowdown)", 262144, true, -1.0, true, 1.0);
	hCvarSdInwaterSurvivor = CreateConVar("l4d2_slowdown_water_survivors", "-1", "Maximum slowdown in the water for the Survivors outside of Tank fights (-1: native slowdown; 0.0: No slowdown, 0.01-2.0: 1%%-200%% slowdown)", 262144, true, -1.0, true, 2.0);
	hCvarSdInwaterDuringTank = CreateConVar("l4d2_slowdown_water_survivors_during_tank", "0", "Maximum slowdown in the water for the Survivors during Tank fights (0: ignore setting; 0.01-2.0: 1%%-200%% slowdown)", 262144, true, 0.0, true, 2.0);
	hCvarSdPistolMod = CreateConVar("l4d2_slowdown_pistol_percent", "0.0", "Pistols cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdDeagleMod = CreateConVar("l4d2_slowdown_deagle_percent", "0.1", "Deagles cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdUziMod = CreateConVar("l4d2_slowdown_uzi_percent", "0.8", "Unsilenced uzis cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdMacMod = CreateConVar("l4d2_slowdown_mac_percent", "0.8", "Silenced Uzis cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdAkMod = CreateConVar("l4d2_slowdown_ak_percent", "0.8", "AKs cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdM4Mod = CreateConVar("l4d2_slowdown_m4_percent", "0.8", "M4s cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdScarMod = CreateConVar("l4d2_slowdown_scar_percent", "0.8", "Scars cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdPumpMod = CreateConVar("l4d2_slowdown_pump_percent", "0.5", "Pump Shotguns cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdChromeMod = CreateConVar("l4d2_slowdown_chrome_percent", "0.5", "Chrome Shotguns cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdAutoMod = CreateConVar("l4d2_slowdown_auto_percent", "0.5", "Auto Shotguns cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdRifleMod = CreateConVar("l4d2_slowdown_rifle_percent", "0.1", "Hunting Rifles cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdScoutMod = CreateConVar("l4d2_slowdown_scout_percent", "0.1", "Scouts cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSdMilitaryMod = CreateConVar("l4d2_slowdown_military_percent", "0.1", "Military Rifles cause this much slowdown * l4d2_slowdown_gunfire at maximum damage.", 0, false, 0.0, false, 0.0);
	hCvarSurvivorLimpspeed = FindConVar("survivor_limp_health");
	HookEvent("player_hurt", PlayerHurt, EventHookMode:1);
	HookEvent("tank_spawn", TankSpawn, EventHookMode:1);
	HookEvent("player_death", TankDeath, EventHookMode:1);
	HookEvent("round_end", RoundEnd, EventHookMode:1);
	return 0;
}

public TankSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	if (tankInPlay)
	{
		return 0;
	}
	tankInPlay = true;
	if (GetConVarFloat(hCvarSdInwaterDuringTank) > 0)
	{
		PrintToChatAll("\x05Water Slowdown\x01 has been reduced while Tank is in play.");
	}
	return 0;
}

public TankDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (IsInfected(client) && IsTank(client))
	{
		tankInPlay = false;
		if (GetConVarFloat(hCvarSdInwaterDuringTank) > 0)
		{
			PrintToChatAll("\x05Water Slowdown\x01 has been restored to normal.");
		}
	}
	return 0;
}

public RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	tankInPlay = false;
	return 0;
}

public PlayerHurt(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (!IsInfected(client))
	{
		return 0;
	}
	decl Float:slowdown;
	new var1;
	if (IsTank(client))
	{
		var1 = GetActualValue(hCvarSdGunfireTank);
	}
	else
	{
		var1 = GetActualValue(hCvarSdGunfireSi);
	}
	slowdown = var1;
	if (1.0 == slowdown)
	{
		ApplySlowdown(client, slowdown);
	}
	else
	{
		if (slowdown > 0.0)
		{
			new damage = GetEventInt(event, "dmg_health");
			decl String:weapon[64];
			GetEventString(event, "weapon", weapon, 64);
			decl Float:scale;
			decl Float:modifier;
			GetScaleAndModifier(scale, modifier, weapon, damage);
			ApplySlowdown(client, 1 - modifier * scale * slowdown);
		}
	}
	return 0;
}

public L4D2_OnWaterMove(client)
{
	if (!GetEntityFlags(client) & 512)
	{
		return 0;
	}
	new var1;
	if (IsSurvivor(client) && !IsLimping(client))
	{
		new var2;
		if (GetConVarFloat(hCvarSdInwaterDuringTank) > 0 && tankInPlay)
		{
			ApplySlowdown(client, GetConVarFloat(hCvarSdInwaterDuringTank));
		}
		else
		{
			ApplySlowdown(client, GetActualValue(hCvarSdInwaterSurvivor));
		}
	}
	else
	{
		new var3;
		if (IsInfected(client) && IsTank(client))
		{
			ApplySlowdown(client, GetActualValue(hCvarSdInwaterTank));
		}
	}
	return 0;
}

Float:GetActualValue(Handle:cvar)
{
	new Float:value = GetConVarFloat(cvar);
	if (-1.0 == value)
	{
		return -1.0;
	}
	if (0.0 == value)
	{
		return 1.0;
	}
	new var1;
	if (value > 2.0)
	{
		var1 = 2.0;
	}
	else
	{
		if (value < 0.01)
		{
			var1 = 0.01;
		}
		var1 = value;
	}
	return var1;
}

ApplySlowdown(client, Float:value)
{
	if (-1.0 == value)
	{
		return 0;
	}
	SetEntPropFloat(client, PropType:0, "m_flVelocityModifier", value, 0);
	return 0;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

bool:IsTank(client)
{
	return GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8;
}

bool:IsLimping(client)
{
	new PermHealth = GetClientHealth(client);
	new Float:buffer = GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0);
	new Float:bleedTime = GetGameTime() - GetEntPropFloat(client, PropType:0, "m_healthBufferTime", 0);
	new Float:decay = GetConVarFloat(FindConVar("pain_pills_decay_rate"));
	decl Float:TempHealth;
	new var1;
	if (buffer - bleedTime * decay > 1120403456)
	{
		var1 = 1120403456;
	}
	else
	{
		if (buffer - bleedTime * decay < 0)
		{
			var1 = 0;
		}
		var1 = buffer - bleedTime * decay;
	}
	TempHealth = var1;
	return RoundToFloor(TempHealth + PermHealth) < GetConVarInt(hCvarSurvivorLimpspeed);
}

GetScaleAndModifier(&Float:scale, &Float:modifier, String:weapon[], damage)
{
	if (strcmp(weapon, "melee", true))
	{
		if (strcmp(weapon, "pistol", true))
		{
			if (strcmp(weapon, "pistol_magnum", true))
			{
				if (strcmp(weapon, "smg", true))
				{
					if (strcmp(weapon, "smg_silenced", true))
					{
						if (strcmp(weapon, "rifle_ak47", true))
						{
							if (strcmp(weapon, "rifle", true))
							{
								if (strcmp(weapon, "rifle_desert", true))
								{
									if (strcmp(weapon, "pumpshotgun", true))
									{
										if (strcmp(weapon, "shotgun_chrome", true))
										{
											if (strcmp(weapon, "autoshotgun", true))
											{
												if (strcmp(weapon, "shotgun_spas", true))
												{
													if (strcmp(weapon, "hunting_rifle", true))
													{
														if (strcmp(weapon, "sniper_scout", true))
														{
															if (strcmp(weapon, "sniper_military", true))
															{
																scale = 1065353216;
																modifier = 0;
															}
															new var14;
															if (damage - 1119092736 / 90.0 - 90.0 > 1065353216)
															{
																var14 = 1065353216;
															}
															else
															{
																if (damage - 1119092736 / 90.0 - 90.0 < 0)
																{
																	var14 = 0;
																}
																var14 = damage - 1119092736 / 90.0 - 90.0;
															}
															scale = var14;
															modifier = GetConVarFloat(hCvarSdMilitaryMod);
														}
														new var13;
														if (damage - 1119092736 / 90.0 - 90.0 > 1065353216)
														{
															var13 = 1065353216;
														}
														else
														{
															if (damage - 1119092736 / 90.0 - 90.0 < 0)
															{
																var13 = 0;
															}
															var13 = damage - 1119092736 / 90.0 - 90.0;
														}
														scale = var13;
														modifier = GetConVarFloat(hCvarSdScoutMod);
													}
													new var12;
													if (damage - 1119092736 / 90.0 - 90.0 > 1065353216)
													{
														var12 = 1065353216;
													}
													else
													{
														if (damage - 1119092736 / 90.0 - 90.0 < 0)
														{
															var12 = 0;
														}
														var12 = damage - 1119092736 / 90.0 - 90.0;
													}
													scale = var12;
													modifier = GetConVarFloat(hCvarSdRifleMod);
												}
												new var11;
												if (damage * damage - 3.0 * 3.0 / 23.0 * 23.0 - 3.0 * 3.0 > 1065353216)
												{
													var11 = 1065353216;
												}
												else
												{
													if (damage * damage - 3.0 * 3.0 / 23.0 * 23.0 - 3.0 * 3.0 < 0)
													{
														var11 = 0;
													}
													var11 = damage * damage - 3.0 * 3.0 / 23.0 * 23.0 - 3.0 * 3.0;
												}
												scale = var11;
												modifier = GetConVarFloat(hCvarSdAutoMod);
											}
											new var10;
											if (damage * damage - 2.0 * 2.0 / 19.0 * 19.0 - 2.0 * 2.0 > 1065353216)
											{
												var10 = 1065353216;
											}
											else
											{
												if (damage * damage - 2.0 * 2.0 / 19.0 * 19.0 - 2.0 * 2.0 < 0)
												{
													var10 = 0;
												}
												var10 = damage * damage - 2.0 * 2.0 / 19.0 * 19.0 - 2.0 * 2.0;
											}
											scale = var10;
											modifier = GetConVarFloat(hCvarSdAutoMod);
										}
										new var9;
										if (damage * damage - 2.0 * 2.0 / 15.0 * 15.0 - 2.0 * 2.0 > 1065353216)
										{
											var9 = 1065353216;
										}
										else
										{
											if (damage * damage - 2.0 * 2.0 / 15.0 * 15.0 - 2.0 * 2.0 < 0)
											{
												var9 = 0;
											}
											var9 = damage * damage - 2.0 * 2.0 / 15.0 * 15.0 - 2.0 * 2.0;
										}
										scale = var9;
										modifier = GetConVarFloat(hCvarSdChromeMod);
									}
									new var8;
									if (damage * damage - 2.0 * 2.0 / 13.0 * 13.0 - 2.0 * 2.0 > 1065353216)
									{
										var8 = 1065353216;
									}
									else
									{
										if (damage * damage - 2.0 * 2.0 / 13.0 * 13.0 - 2.0 * 2.0 < 0)
										{
											var8 = 0;
										}
										var8 = damage * damage - 2.0 * 2.0 / 13.0 * 13.0 - 2.0 * 2.0;
									}
									scale = var8;
									modifier = GetConVarFloat(hCvarSdPumpMod);
								}
								new var7;
								if (damage * damage - 1.0 * 1.0 / 43.0 * 43.0 - 1.0 * 1.0 > 1065353216)
								{
									var7 = 1065353216;
								}
								else
								{
									if (damage * damage - 1.0 * 1.0 / 43.0 * 43.0 - 1.0 * 1.0 < 0)
									{
										var7 = 0;
									}
									var7 = damage * damage - 1.0 * 1.0 / 43.0 * 43.0 - 1.0 * 1.0;
								}
								scale = var7;
								modifier = GetConVarFloat(hCvarSdScarMod);
							}
							new var6;
							if (damage * damage - 0.0 * 0.0 / 32.0 * 32.0 - 0.0 * 0.0 > 1065353216)
							{
								var6 = 1065353216;
							}
							else
							{
								if (damage * damage - 0.0 * 0.0 / 32.0 * 32.0 - 0.0 * 0.0 < 0)
								{
									var6 = 0;
								}
								var6 = damage * damage - 0.0 * 0.0 / 32.0 * 32.0 - 0.0 * 0.0;
							}
							scale = var6;
							modifier = GetConVarFloat(hCvarSdM4Mod);
						}
						new var5;
						if (damage * damage - 0.0 * 0.0 / 57.0 * 57.0 - 0.0 * 0.0 > 1065353216)
						{
							var5 = 1065353216;
						}
						else
						{
							if (damage * damage - 0.0 * 0.0 / 57.0 * 57.0 - 0.0 * 0.0 < 0)
							{
								var5 = 0;
							}
							var5 = damage * damage - 0.0 * 0.0 / 57.0 * 57.0 - 0.0 * 0.0;
						}
						scale = var5;
						modifier = GetConVarFloat(hCvarSdAkMod);
					}
					new var4;
					if (damage * damage - 0.0 * 0.0 / 24.0 * 24.0 - 0.0 * 0.0 > 1065353216)
					{
						var4 = 1065353216;
					}
					else
					{
						if (damage * damage - 0.0 * 0.0 / 24.0 * 24.0 - 0.0 * 0.0 < 0)
						{
							var4 = 0;
						}
						var4 = damage * damage - 0.0 * 0.0 / 24.0 * 24.0 - 0.0 * 0.0;
					}
					scale = var4;
					modifier = GetConVarFloat(hCvarSdMacMod);
				}
				new var3;
				if (damage * damage - 9.0 * 9.0 / 19.0 * 19.0 - 9.0 * 9.0 > 1065353216)
				{
					var3 = 1065353216;
				}
				else
				{
					if (damage * damage - 9.0 * 9.0 / 19.0 * 19.0 - 9.0 * 9.0 < 0)
					{
						var3 = 0;
					}
					var3 = damage * damage - 9.0 * 9.0 / 19.0 * 19.0 - 9.0 * 9.0;
				}
				scale = var3;
				modifier = GetConVarFloat(hCvarSdUziMod);
			}
			new var2;
			if (damage - 1100480512 / 78.0 - 19.0 > 1065353216)
			{
				var2 = 1065353216;
			}
			else
			{
				if (damage - 1100480512 / 78.0 - 19.0 < 0)
				{
					var2 = 0;
				}
				var2 = damage - 1100480512 / 78.0 - 19.0;
			}
			scale = var2;
			modifier = GetConVarFloat(hCvarSdDeagleMod);
		}
		new var1;
		if (damage - 1091567616 / 32.0 - 9.0 > 1065353216)
		{
			var1 = 1065353216;
		}
		else
		{
			if (damage - 1091567616 / 32.0 - 9.0 < 0)
			{
				var1 = 0;
			}
			var1 = damage - 1091567616 / 32.0 - 9.0;
		}
		scale = var1;
		modifier = GetConVarFloat(hCvarSdPistolMod);
	}
	else
	{
		scale = 1065353216;
		modifier = 0;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/13/2016",
	time = "20:48:44"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:WeaponNames[56][] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced",
	"weapon_shotgun_chrome",
	"weapon_rifle_desert",
	"weapon_sniper_military",
	"weapon_shotgun_spas",
	"weapon_first_aid_kit",
	"weapon_molotov",
	"weapon_pipe_bomb",
	"weapon_pain_pills",
	"weapon_gascan",
	"weapon_propanetank",
	"weapon_oxygentank",
	"weapon_melee",
	"weapon_chainsaw",
	"weapon_grenade_launcher",
	"weapon_ammo_pack",
	"weapon_adrenaline",
	"weapon_defibrillator",
	"weapon_vomitjar",
	"weapon_rifle_ak47",
	"weapon_gnome",
	"weapon_cola_bottles",
	"weapon_fireworkcrate",
	"weapon_upgradepack_incendiary",
	"weapon_upgradepack_explosive",
	"weapon_pistol_magnum",
	"weapon_smg_mp5",
	"weapon_rifle_sg552",
	"weapon_sniper_awp",
	"weapon_sniper_scout",
	"weapon_rifle_m60",
	"weapon_tank_claw",
	"weapon_hunter_claw",
	"weapon_charger_claw",
	"weapon_boomer_claw",
	"weapon_smoker_claw",
	"weapon_spitter_claw",
	"weapon_jockey_claw",
	"weapon_machinegun",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:LongWeaponNames[56][];
new String:MeleeWeaponNames[15][] =
{
	"",
	"knife",
	"baseball_bat",
	"chainsaw",
	"cricket_bat",
	"crowbar",
	"didgeridoo",
	"electric_guitar",
	"fireaxe",
	"frying_pan",
	"golfclub",
	"katana",
	"machete",
	"riotshield",
	"tonfa"
};
new String:LongMeleeWeaponNames[15][] =
{
	"",
	"/w_models/weapons/w_knife_t.mdl",
	"/weapons/melee/w_bat.mdl",
	"/weapons/melee/w_chainsaw.mdl",
	"/weapons/melee/w_cricket_bat.mdl",
	"/weapons/melee/w_crowbar.mdl",
	"/weapons/melee/w_didgeridoo.mdl",
	"/weapons/melee/w_electric_guitar.mdl",
	"/weapons/melee/w_fireaxe.mdl",
	"/weapons/melee/w_frying_pan.mdl",
	"/weapons/melee/w_golfclub.mdl",
	"/weapons/melee/w_katana.mdl",
	"/weapons/melee/w_machete.mdl",
	"/weapons/melee/w_riotshield.mdl",
	"/weapons/melee/w_tonfa.mdl"
};
new String:MeleeWeaponModels[15][] =
{
	"",
	"/w_models/weapons/w_knife_t.mdl",
	"/weapons/melee/w_bat.mdl",
	"/weapons/melee/w_chainsaw.mdl",
	"/weapons/melee/w_cricket_bat.mdl",
	"/weapons/melee/w_crowbar.mdl",
	"/weapons/melee/w_didgeridoo.mdl",
	"/weapons/melee/w_electric_guitar.mdl",
	"/weapons/melee/w_fireaxe.mdl",
	"/weapons/melee/w_frying_pan.mdl",
	"/weapons/melee/w_golfclub.mdl",
	"/weapons/melee/w_katana.mdl",
	"/weapons/melee/w_machete.mdl",
	"/weapons/melee/w_riotshield.mdl",
	"/weapons/melee/w_tonfa.mdl"
};
new String:WeaponModels[56][];
new WeaponSlots[56] =
{
	0, 0, 0, 1885431159, 1935634031, 1853317488, 0, 1702322029, 1852797025, 17481, 1634759519, 28279, 0, 0, 843330636, 1196249888, 1818579488, 543449455, 1701146707, 2002002020, 1701536101, 114, 1869834582, 114, 1869376577, 1663071095, 661807478, 1868767332, 1869771886, 1986994284, 1948283493, 1914725736, 1634692197, 1969496164, 1769234802, 544435823, 544370534, 1752461154, 1887007776, 1864397669, 1297293414, 71, 3223089, 1886680168, 791624307, 1752459623, 1663984245, 1093627247, 1851880564, 877408111, 1127035460, 1701866863, 1769236852, 1177380214, 1701667186, 1802661751
};
new Handle:hWeaponNamesTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hMeleeWeaponModelsTrie;
new Handle:hCvarReloadSpeedUzi;
new Handle:hCvarReloadSpeedSilencedSmg;
public Plugin:myinfo =
{
	name = "L4D2 SMG Reload Speed Tweaker",
	description = "Allows cvar'd control over the reload durations for both types of SMG",
	author = "Visor",
	version = "1.1",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator<=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) <= 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

InitWeaponNamesTrie()
{
	WeaponSlots[0] = CreateTrie();
	new i;
	while (i < 56)
	{
		SetTrieValue(WeaponSlots[0], WeaponNames[i], i, true);
		i++;
	}
	hMeleeWeaponNamesTrie = CreateTrie();
	hMeleeWeaponModelsTrie = CreateTrie();
	new i;
	while (i < 15)
	{
		SetTrieValue(hMeleeWeaponNamesTrie, LongWeaponNames[i], i, true);
		SetTrieString(hMeleeWeaponModelsTrie, LongMeleeWeaponNames[i], LongWeaponNames[i], true);
		i++;
	}
	return 0;
}

WeaponId:WeaponNameToId(String:weaponName[])
{
	new WeaponID:id;
	if (!WeaponSlots[0])
	{
		InitWeaponNamesTrie();
	}
	if (GetTrieValue(WeaponSlots[0], weaponName, id))
	{
		return id;
	}
	return WeaponId:0;
}

WeaponId:IdentifyWeapon(entity)
{
	new var1;
	if (!entity || !IsValidEntity(entity) || !IsValidEdict(entity))
	{
		return WeaponId:0;
	}
	decl String:class[64];
	if (!GetEdictClassname(entity, class, 64))
	{
		return WeaponId:0;
	}
	if (StrEqual(class, "weapon_spawn", true))
	{
		return GetEntProp(entity, PropType:0, "m_weaponID", 4, 0);
	}
	new len = strlen(class);
	new var2;
	if (len + -6 > 0 && StrEqual(class[len + -6], "_spawn", true))
	{
		class[len + -6] = MissingTAG:0;
		return WeaponNameToId(class);
	}
	return WeaponNameToId(class);
}

public OnPluginStart()
{
	hCvarReloadSpeedUzi = CreateConVar("l4d2_reload_speed_uzi", "0", "Reload duration of Uzi(normal SMG)", 16640, true, 0.0, true, 10.0);
	hCvarReloadSpeedSilencedSmg = CreateConVar("l4d2_reload_speed_silenced_smg", "0", "Reload duration of Silenced SMG", 16640, true, 0.0, true, 10.0);
	HookEvent("weapon_reload", OnWeaponReload, EventHookMode:1);
	return 0;
}

public OnWeaponReload(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (!IsSurvivor(client) || !IsPlayerAlive(client) || IsFakeClient(client))
	{
		return 0;
	}
	new Float:originalReloadDuration = 0.0;
	new Float:alteredReloadDuration = 0.0;
	new weapon = GetPlayerWeaponSlot(client, 0);
	new WeaponId:weaponId = IdentifyWeapon(weapon);
	if (weaponId == WeaponId:2)
	{
		originalReloadDuration = 2.235352;
		alteredReloadDuration = GetConVarFloat(hCvarReloadSpeedUzi);
	}
	else
	{
		if (weaponId == WeaponId:7)
		{
			originalReloadDuration = 2.235291;
			alteredReloadDuration = GetConVarFloat(hCvarReloadSpeedSilencedSmg);
		}
		return 0;
	}
	if (alteredReloadDuration <= 0.0)
	{
		return 0;
	}
	new Float:oldNextAttack = GetEntPropFloat(weapon, PropType:0, "m_flNextPrimaryAttack", 0);
	new Float:newNextAttack = oldNextAttack - originalReloadDuration + alteredReloadDuration;
	new Float:playbackRate = originalReloadDuration / alteredReloadDuration;
	SetEntPropFloat(weapon, PropType:0, "m_flNextPrimaryAttack", newNextAttack, 0);
	SetEntPropFloat(client, PropType:0, "m_flNextAttack", newNextAttack, 0);
	SetEntPropFloat(weapon, PropType:0, "m_flPlaybackRate", playbackRate, 0);
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons)
{
	if (!buttons & 2048)
	{
		return Action:0;
	}
	new var1;
	if (!IsSurvivor(client) || !IsPlayerAlive(client) || IsFakeClient(client))
	{
		return Action:0;
	}
	new Float:originalReloadDuration = 0.0;
	new Float:alteredReloadDuration = 0.0;
	new weapon = GetPlayerWeaponSlot(client, 0);
	new WeaponId:weaponId = IdentifyWeapon(weapon);
	if (weaponId == WeaponId:2)
	{
		originalReloadDuration = 2.235352;
		alteredReloadDuration = GetConVarFloat(hCvarReloadSpeedUzi);
	}
	else
	{
		if (weaponId == WeaponId:7)
		{
			originalReloadDuration = 2.235291;
			alteredReloadDuration = GetConVarFloat(hCvarReloadSpeedSilencedSmg);
		}
		return Action:0;
	}
	new Float:playbackRate = originalReloadDuration / alteredReloadDuration;
	SetEntPropFloat(weapon, PropType:0, "m_flPlaybackRate", playbackRate, 0);
	return Action:0;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "01/04/2018",
	time = "22:44:41"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new String:CTag[6][] =
{
	"",
	"",
	"",
	"",
	"",
	""
};
new String:CTagCode[6][16];
new bool:CTagReqSayText2[6];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new Handle:tongue_drag_damage_interval;
new Handle:tongue_drag_first_damage_interval;
new Handle:tongue_drag_first_damage;
public Plugin:myinfo =
{
	name = "L4D2 Smoker Drag Damage Interval",
	description = "Implements a native-like cvar that should've been there out of the box",
	author = "Visor, Sir",
	version = "0.7",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CEventIsHooked[i] = false;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	HookEvent("tongue_grab", OnTongueGrab, EventHookMode:1);
	new String:value[32];
	GetConVarString(FindConVar("tongue_choke_damage_interval"), value, 32);
	tongue_drag_damage_interval = CreateConVar("tongue_drag_damage_interval", value, "How often the drag does damage.", 0, false, 0.0, false, 0.0);
	tongue_drag_first_damage_interval = CreateConVar("tongue_drag_first_damage_interval", "0.0", "After how many seconds do we apply our first tick of damage? | 0.0 to Disable.", 0, false, 0.0, false, 0.0);
	tongue_drag_first_damage = CreateConVar("tongue_drag_first_damage", "3.0", "How much damage do we apply on the first tongue hit? | Only applies when first_damage_interval is used", 0, false, 0.0, false, 0.0);
	HookConVarChange(FindConVar("tongue_choke_damage_amount"), tongue_choke_damage_amount_ValueChanged);
	return 0;
}

public tongue_choke_damage_amount_ValueChanged(Handle:convar, String:oldValue[], String:newValue[])
{
	SetConVarInt(convar, 1, false, false);
	return 0;
}

public OnTongueGrab(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new Float:fFirst = GetConVarFloat(tongue_drag_first_damage_interval);
	if (fFirst > 0.0)
	{
		UpdateDragDamageInterval(client, tongue_drag_first_damage_interval);
		CreateTimer(fFirst, FirstDamage, client, 0);
	}
	else
	{
		UpdateDragDamageInterval(client, tongue_drag_damage_interval);
		CreateTimer(GetConVarFloat(tongue_drag_damage_interval) + 0.1, FixDragInterval, client, 3);
	}
	return 0;
}

public Action:FirstDamage(Handle:timer, any:client)
{
	new var1;
	if (!IsSurvivor(client) || !IsSurvivorBeingDragged(client))
	{
		return Action:4;
	}
	new i = 1;
	while (MaxClients + 1 > i)
	{
		if (IsTongue(i))
		{
			SDKHooks_TakeDamage(client, i, i, GetConVarFloat(tongue_drag_first_damage) - 1.0, 0, -1, NULL_VECTOR, NULL_VECTOR);
			UpdateDragDamageInterval(client, tongue_drag_damage_interval);
			return Action:0;
		}
		i++;
	}
	UpdateDragDamageInterval(client, tongue_drag_damage_interval);
	return Action:0;
}

public Action:FixDragInterval(Handle:timer, any:client)
{
	new var1;
	if (!IsSurvivor(client) || !IsSurvivorBeingDragged(client))
	{
		return Action:4;
	}
	UpdateDragDamageInterval(client, tongue_drag_damage_interval);
	return Action:0;
}

UpdateDragDamageInterval(client, Handle:convar)
{
	SetEntDataFloat(client, 13352, GetGameTime() + GetConVarFloat(convar), false);
	return 0;
}

bool:IsSurvivorBeingDragged(client)
{
	new var1;
	return GetEntData(client, 13284, 4) > 0 && !IsSurvivorBeingChoked(client);
}

bool:IsSurvivorBeingChoked(client)
{
	return GetEntData(client, 13308, 4) > 0;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsTongue(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetEntPropEnt(client, PropType:0, "m_tongueVictim", 0) > 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new bool:bLateLoad;
public Plugin:myinfo =
{
	name = "L4D2 Sniper Hunter Bodyshot",
	description = "Remove sniper weapons' stomach hitgroup damage multiplier against hunters",
	author = "Visor",
	version = "1.1",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator/(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) / oper2;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	if (bLateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientConnected(i) && IsClientInGame(i))
			{
				OnClientPutInServer(i);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:11, TraceAttack);
	return 0;
}

public Action:TraceAttack(victim, &attacker, &inflictor, &Float:damage, &damagetype, &ammotype, hitbox, hitgroup)
{
	new var1;
	if (!IsHunter(victim) || !IsSurvivor(attacker) || IsFakeClient(attacker))
	{
		return Action:0;
	}
	new weapon = GetClientActiveWeapon(attacker);
	if (!IsValidSniper(weapon))
	{
		return Action:0;
	}
	if (hitgroup == 3)
	{
		damage = GetWeaponDamage(weapon) / 1067450368;
		return Action:1;
	}
	return Action:0;
}

GetClientActiveWeapon(client)
{
	return GetEntPropEnt(client, PropType:0, "m_hActiveWeapon", 0);
}

GetWeaponDamage(weapon)
{
	decl String:classname[64];
	GetEdictClassname(weapon, classname, 64);
	return L4D2_GetIntWeaponAttribute(classname, L4D2IntWeaponAttributes:0);
}

bool:IsValidSniper(weapon)
{
	decl String:classname[64];
	GetEdictClassname(weapon, classname, 64);
	new var1;
	return StrEqual(classname, "weapon_sniper_scout", true) || StrEqual(classname, "weapon_sniper_awp", true);
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsHunter(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 3 && GetEntProp(client, PropType:0, "m_isGhost", 4, 0) != 1;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:WeaponNames[56][] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced",
	"weapon_shotgun_chrome",
	"weapon_rifle_desert",
	"weapon_sniper_military",
	"weapon_shotgun_spas",
	"weapon_first_aid_kit",
	"weapon_molotov",
	"weapon_pipe_bomb",
	"weapon_pain_pills",
	"weapon_gascan",
	"weapon_propanetank",
	"weapon_oxygentank",
	"weapon_melee",
	"weapon_chainsaw",
	"weapon_grenade_launcher",
	"weapon_ammo_pack",
	"weapon_adrenaline",
	"weapon_defibrillator",
	"weapon_vomitjar",
	"weapon_rifle_ak47",
	"weapon_gnome",
	"weapon_cola_bottles",
	"weapon_fireworkcrate",
	"weapon_upgradepack_incendiary",
	"weapon_upgradepack_explosive",
	"weapon_pistol_magnum",
	"weapon_smg_mp5",
	"weapon_rifle_sg552",
	"weapon_sniper_awp",
	"weapon_sniper_scout",
	"weapon_rifle_m60",
	"weapon_tank_claw",
	"weapon_hunter_claw",
	"weapon_charger_claw",
	"weapon_boomer_claw",
	"weapon_smoker_claw",
	"weapon_spitter_claw",
	"weapon_jockey_claw",
	"weapon_machinegun",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:LongWeaponNames[56][];
new String:MeleeWeaponNames[15][] =
{
	"",
	"knife",
	"baseball_bat",
	"chainsaw",
	"cricket_bat",
	"crowbar",
	"didgeridoo",
	"electric_guitar",
	"fireaxe",
	"frying_pan",
	"golfclub",
	"katana",
	"machete",
	"riotshield",
	"tonfa"
};
new String:LongMeleeWeaponNames[15][] =
{
	"",
	"/w_models/weapons/w_pistol_B.mdl",
	"/w_models/weapons/w_smg_uzi.mdl",
	"/w_models/weapons/w_shotgun.mdl",
	"/w_models/weapons/w_autoshot_m4super.mdl",
	"/w_models/weapons/w_rifle_m16a2.mdl",
	"/w_models/weapons/w_sniper_mini14.mdl",
	"/w_models/weapons/w_smg_a.mdl",
	"/w_models/weapons/w_pumpshotgun_a.mdl",
	"/w_models/weapons/w_desert_rifle.mdl",
	"/w_models/weapons/w_sniper_military.mdl",
	"/w_models/weapons/w_shotgun_spas.mdl",
	"/w_models/weapons/w_eq_medkit.mdl",
	"/w_models/weapons/w_eq_molotov.mdl",
	"/w_models/weapons/w_eq_pipebomb.mdl"
};
new String:WeaponModels[56][] =
{
	"",
	"/w_models/weapons/w_pistol_B.mdl",
	"/w_models/weapons/w_smg_uzi.mdl",
	"/w_models/weapons/w_shotgun.mdl",
	"/w_models/weapons/w_autoshot_m4super.mdl",
	"/w_models/weapons/w_rifle_m16a2.mdl",
	"/w_models/weapons/w_sniper_mini14.mdl",
	"/w_models/weapons/w_smg_a.mdl",
	"/w_models/weapons/w_pumpshotgun_a.mdl",
	"/w_models/weapons/w_desert_rifle.mdl",
	"/w_models/weapons/w_sniper_military.mdl",
	"/w_models/weapons/w_shotgun_spas.mdl",
	"/w_models/weapons/w_eq_medkit.mdl",
	"/w_models/weapons/w_eq_molotov.mdl",
	"/w_models/weapons/w_eq_pipebomb.mdl",
	"/w_models/weapons/w_eq_painpills.mdl",
	"/props_junk/gascan001a.mdl",
	"/props_junk/propanecanister001.mdl",
	"/props_equipment/oxygentank01.mdl",
	"",
	"/weapons/melee/w_chainsaw.mdl",
	"/w_models/weapons/w_grenade_launcher.mdl",
	"",
	"/w_models/weapons/w_eq_adrenaline.mdl",
	"/w_models/weapons/w_eq_defibrillator.mdl",
	"/w_models/weapons/w_eq_bile_flask.mdl",
	"/w_models/weapons/w_rifle_ak47.mdl",
	"/props_junk/gnome.mdl",
	"/w_models/weapons/w_cola.mdl",
	"/props_junk/explosive_box001.mdl",
	"/w_models/weapons/w_eq_incendiary_ammopack.mdl",
	"/w_models/weapons/w_eq_explosive_ammopack.mdl",
	"/w_models/weapons/w_desert_eagle.mdl",
	"/w_models/weapons/w_smg_mp5.mdl",
	"/w_models/weapons/w_rifle_sg552.mdl",
	"/w_models/weapons/w_sniper_awp.mdl",
	"/w_models/weapons/w_sniper_scout.mdl",
	"/w_models/weapons/w_m60.mdl",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	""
};
new String:MeleeWeaponModels[15][];
new WeaponSlots[56] =
{
	0, 0, 35, 36, 843330636, 1768837920, 544367984, 1667592784, 1701340001, 0, 1869834582, 114, 3157554, 1869377109, 544435043, 1836213575, 1931505249, 1701865838, 1702305906, 1852797025, 115, 1886680168, 791624307, 1752459623, 1663984245, 1093627247, 1851880564, 1900359535, 1768712565, 1969844834, 109, 4280, 4316, 4304, 4312, 4348, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
new Handle:hMeleeWeaponModelsTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hWeaponNamesTrie;
new snipers[2] =
{
	35, 36
};
public Plugin:myinfo =
{
	name = "L4D2 Sniper Precache",
	description = "Unlocks German sniper weapons",
	author = "Visor",
	version = "2.0",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:IsValidWeaponId(WeaponId:wepid, tagType)
{
	if (tagType == -1073741727)
	{
		new var1;
		return wepid >= WeaponId:0 && wepid < WeaponId:15;
	}
	new var2;
	return wepid >= WeaponId:0 && wepid < WeaponId:56;
}

GetWeaponName(WeaponId:wepid, String:nameBuffer[], length, tagType)
{
	if (tagType == -1073741727)
	{
		new var1;
		if (IsValidWeaponId(wepid, -1073741727))
		{
			var1[0] = LongWeaponNames[wepid];
		}
		else
		{
			var1[0] = 4264;
		}
		strcopy(nameBuffer, length, var1);
	}
	else
	{
		new var2;
		if (IsValidWeaponId(wepid, -1073741728))
		{
			var2[0] = WeaponNames[wepid];
		}
		else
		{
			var2[0] = 4268;
		}
		strcopy(nameBuffer, length, var2);
	}
	return 0;
}

public OnMapStart()
{
	new WeaponId:wepid;
	decl String:buffer[64];
	new i;
	while (i < 2)
	{
		wepid = snipers[i];
		PrecacheModel(LongMeleeWeaponNames[wepid], false);
		GetWeaponName(wepid, buffer, 64, -1073741728);
		new index = CreateEntityByName(buffer, -1);
		DispatchSpawn(index);
		RemoveEdict(index);
		i++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "07/05/2018",
	time = "19:40:20"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_sceneproces =
{
	name = "sceneprocessor",
	file = "sceneprocessor.smx",
	required = 1,
};
new Handle:cBlockHB;
new Handle:cBlock4Competitive;
public Plugin:myinfo =
{
	name = "Sound Manipulation",
	description = "Allows control over certain sounds",
	author = "Sir",
	version = "1.4",
	url = "https://github.com/SirPlease/SirCoding"
};
new String:sCoachSound[19][192] =
{
	"player/survivor/voice/coach/meleeswing01.wav",
	"player/survivor/voice/coach/meleeswing02.wav",
	"player/survivor/voice/coach/meleeswing03.wav",
	"player/survivor/voice/coach/meleeswing04.wav",
	"player/survivor/voice/coach/meleeswing05.wav",
	"player/survivor/voice/coach/meleeswing06.wav",
	"player/survivor/voice/coach/meleeswing07.wav",
	"player/survivor/voice/coach/meleeswing08.wav",
	"player/survivor/voice/coach/meleeswing09.wav",
	"player/survivor/voice/coach/meleeswing10.wav",
	"player/survivor/voice/coach/meleeswing11.wav",
	"player/survivor/voice/coach/meleeswing12.wav",
	"player/survivor/voice/coach/meleeswing13.wav",
	"player/survivor/voice/coach/meleeswing14.wav",
	"player/survivor/voice/coach/meleeswing15.wav",
	"player/survivor/voice/coach/meleeswing16.wav",
	"player/survivor/voice/coach/meleeswing17.wav",
	"player/survivor/voice/coach/meleeswing18.wav",
	"player/survivor/voice/coach/meleeswing19.wav"
};
new String:sRochelleSound[9][192] =
{
	"player/survivor/voice/producer/meleeswing01.wav",
	"player/survivor/voice/producer/meleeswing02.wav",
	"player/survivor/voice/producer/meleeswing03.wav",
	"player/survivor/voice/producer/meleeswing04.wav",
	"player/survivor/voice/producer/meleeswing05.wav",
	"player/survivor/voice/producer/meleeswing06.wav",
	"player/survivor/voice/producer/meleeswing07.wav",
	"player/survivor/voice/producer/meleeswing08.wav",
	"player/survivor/voice/producer/meleeswing09.wav"
};
new String:sEllisSound[7][192] =
{
	"player/survivor/voice/mechanic/meleeswing01.wav",
	"player/survivor/voice/mechanic/meleeswing02.wav",
	"player/survivor/voice/mechanic/meleeswing03.wav",
	"player/survivor/voice/mechanic/meleeswing04.wav",
	"player/survivor/voice/mechanic/meleeswing05.wav",
	"player/survivor/voice/mechanic/meleeswing06.wav",
	"player/survivor/voice/mechanic/meleeswing07.wav"
};
new String:sNickSound[15][192] =
{
	"player/survivor/voice/gambler/meleeswing01.wav",
	"player/survivor/voice/gambler/meleeswing02.wav",
	"player/survivor/voice/gambler/meleeswing03.wav",
	"player/survivor/voice/gambler/meleeswing04.wav",
	"player/survivor/voice/gambler/meleeswing05.wav",
	"player/survivor/voice/gambler/meleeswing06.wav",
	"player/survivor/voice/gambler/meleeswing07.wav",
	"player/survivor/voice/gambler/meleeswing08.wav",
	"player/survivor/voice/gambler/meleeswing09.wav",
	"player/survivor/voice/gambler/meleeswing10.wav",
	"player/survivor/voice/gambler/meleeswing11.wav",
	"player/survivor/voice/gambler/meleeswing12.wav",
	"player/survivor/voice/gambler/meleeswing13.wav",
	"player/survivor/voice/gambler/meleeswing14.wav",
	"player/survivor/voice/gambler/meleeswing15.wav"
};
new String:sFrancisSound[12][] =
{
	"player/survivor/voice/biker/hurtminor02.wav",
	"player/survivor/voice/biker/hurtminor04.wav",
	"player/survivor/voice/biker/hurtminor07.wav",
	"player/survivor/voice/biker/hurtminor08.wav",
	"player/survivor/voice/biker/positivenoise02.wav",
	"player/survivor/voice/biker/shoved01.wav",
	"player/survivor/voice/biker/shoved02.wav",
	"player/survivor/voice/biker/shoved03.wav",
	"player/survivor/voice/biker/shoved04.wav",
	"player/survivor/voice/biker/shoved05.wav",
	"player/survivor/voice/biker/shoved06.wav",
	"player/survivor/voice/biker/shoved07.wav"
};
new String:sZoeySound[10][] =
{
	"player/survivor/voice/teengirl/hordeatttack10.wav",
	"player/survivor/voice/teengirl/hordeattack29.wav",
	"player/survivor/voice/teengirl/hurtminor03.wav",
	"player/survivor/voice/teengirl/shoved01.wav",
	"player/survivor/voice/teengirl/shoved02.wav",
	"player/survivor/voice/teengirl/shoved03.wav",
	"player/survivor/voice/teengirl/shoved04.wav",
	"player/survivor/voice/teengirl/shoved05.wav",
	"player/survivor/voice/teengirl/shoved06.wav",
	"player/survivor/voice/teengirl/shoved14.wav"
};
new String:sLouisSound[8][] =
{
	"player/survivor/voice/manager/hurtminor02.wav",
	"player/survivor/voice/manager/hurtminor05.wav",
	"player/survivor/voice/manager/hurtminor06.wav",
	"player/survivor/voice/manager/shoved01.wav",
	"player/survivor/voice/manager/shoved02.wav",
	"player/survivor/voice/manager/shoved03.wav",
	"player/survivor/voice/manager/shoved04.wav",
	"player/survivor/voice/manager/shoved05.wav"
};
new String:sBillSound[11][] =
{
	"player/survivor/voice/namvet/hurtminor02.wav",
	"player/survivor/voice/namvet/hurtminor05.wav",
	"player/survivor/voice/namvet/hurtminor07.wav",
	"player/survivor/voice/namvet/hurtminor08.wav",
	"player/survivor/voice/namvet/shoved01.wav",
	"player/survivor/voice/namvet/shoved02.wav",
	"player/survivor/voice/namvet/shoved03.wav",
	"player/survivor/voice/namvet/shoved04.wav",
	"player/survivor/voice/namvet/shoved05.wav",
	"player/survivor/voice/namvet/positivenoise03.wav",
	"player/survivor/voice/namvet/reactionstartled01.wav"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

bool:IsActorBusy(actor)
{
	return GetSceneFromActor(actor) != -1;
}

bool:IsValidClient(client, bool:filterbots)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	if (!IsClientInGame(client))
	{
		return false;
	}
	new var2;
	if (filterbots && IsFakeClient(client))
	{
		return false;
	}
	return true;
}

bool:IsInfected(client, bool:filterbots)
{
	if (IsValidClient(client, filterbots))
	{
		return GetClientTeam(client) == 3;
	}
	return false;
}

public void:OnPluginStart()
{
	cBlockHB = CreateConVar("sound_block_hb", "0", "Block the Heartbeat Sound, very useful for 1v1 matchmodes", 0, false, 0.0, false, 0.0);
	cBlock4Competitive = CreateConVar("sound_block_for_comp", "0", "Block a lot of Random noises and voice lines", 0, false, 0.0, false, 0.0);
	HookEvent("player_death", Event_PlayerDeath, EventHookMode:1);
	AddNormalSoundHook(SoundHook);
	return void:0;
}

public void:OnMapStart()
{
	new i;
	while (i <= 8)
	{
		PrefetchSound(sRochelleSound[i]);
		PrecacheSound(sRochelleSound[i], true);
		i++;
	}
	new i;
	while (i <= 14)
	{
		PrefetchSound(sNickSound[i]);
		PrecacheSound(sNickSound[i], true);
		i++;
	}
	new i;
	while (i <= 6)
	{
		PrefetchSound(sEllisSound[i]);
		PrecacheSound(sEllisSound[i], true);
		i++;
	}
	new i;
	while (i <= 18)
	{
		PrefetchSound(sCoachSound[i]);
		PrecacheSound(sCoachSound[i], true);
		i++;
	}
	new i;
	while (i <= 11)
	{
		PrefetchSound(sFrancisSound[i]);
		PrecacheSound(sFrancisSound[i], true);
		i++;
	}
	new i;
	while (i <= 7)
	{
		PrefetchSound(sLouisSound[i]);
		PrecacheSound(sLouisSound[i], true);
		i++;
	}
	new i;
	while (i <= 9)
	{
		PrefetchSound(sZoeySound[i]);
		PrecacheSound(sZoeySound[i], true);
		i++;
	}
	new i;
	while (i <= 10)
	{
		PrefetchSound(sBillSound[i]);
		PrecacheSound(sBillSound[i], true);
		i++;
	}
	return void:0;
}

public Event_PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new String:weapon[64];
	GetEventString(event, "weapon", weapon, 64, "");
	new Dead = GetClientOfUserId(GetEventInt(event, "userid", 0));
	new client = GetClientOfUserId(GetEventInt(event, "attacker", 0));
	if (!IsSi(Dead))
	{
		return 0;
	}
	new var1;
	if (StrEqual(weapon, "melee", true) && GetClientTeam(client) == 2)
	{
		new String:clientModel[44];
		GetClientModel(client, clientModel, 42);
		if (IsActorBusy(client))
		{
			return 0;
		}
		if (StrEqual(clientModel, "models/survivors/survivor_coach.mdl", true))
		{
			new rndPick = GetRandomInt(0, 18);
			EmitSoundToAll(sCoachSound[rndPick], client, 2, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
		}
		else
		{
			if (StrEqual(clientModel, "models/survivors/survivor_gambler.mdl", true))
			{
				new rndPick = GetRandomInt(0, 14);
				EmitSoundToAll(sNickSound[rndPick], client, 2, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
			}
			if (StrEqual(clientModel, "models/survivors/survivor_producer.mdl", true))
			{
				new rndPick = GetRandomInt(0, 8);
				EmitSoundToAll(sRochelleSound[rndPick], client, 2, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
			}
			if (StrEqual(clientModel, "models/survivors/survivor_mechanic.mdl", true))
			{
				new rndPick = GetRandomInt(0, 6);
				EmitSoundToAll(sEllisSound[rndPick], client, 2, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
			}
			if (StrEqual(clientModel, "models/survivors/survivor_manager.mdl", true))
			{
				new rndPick = GetRandomInt(0, 7);
				EmitSoundToAll(sLouisSound[rndPick], client, 2, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
			}
			if (StrEqual(clientModel, "models/survivors/survivor_teenangst.mdl", true))
			{
				new rndPick = GetRandomInt(0, 9);
				EmitSoundToAll(sZoeySound[rndPick], client, 2, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
			}
			if (StrEqual(clientModel, "models/survivors/survivor_namvet.mdl", true))
			{
				new rndPick = GetRandomInt(0, 10);
				EmitSoundToAll(sBillSound[rndPick], client, 2, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
			}
			if (StrEqual(clientModel, "models/survivors/survivor_biker.mdl", true))
			{
				new rndPick = GetRandomInt(0, 11);
				EmitSoundToAll(sFrancisSound[rndPick], client, 2, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
			}
			return 0;
		}
	}
	return 0;
}

public Action:SoundHook(clients[64], &numClients, String:sample[256], &entity)
{
	new var1;
	if (GetConVarBool(cBlockHB) && StrEqual(sample, "player/heartbeatloop.wav", false))
	{
		return Action:4;
	}
	if (GetConVarBool(cBlock4Competitive))
	{
		new var2;
		if (StrContains(sample, "World", true) == -1 && StrContains(sample, "look", false) == -1 && StrContains(sample, "ask", false) == -1 && StrContains(sample, "followme", false) == -1 && StrContains(sample, "gettingrevived", false) == -1 && StrContains(sample, "alertgiveitem", false) == -1 && StrContains(sample, "imwithyou", false) == -1 && StrContains(sample, "laughter", false) == -1 && StrContains(sample, "name", false) == -1 && StrContains(sample, "leadon", false) == -1 && StrContains(sample, "moveon", false) == -1 && StrContains(sample, "friendlyfire", false) == -1 && StrContains(sample, "splat", false) == -1)
		{
			return Action:4;
		}
	}
	return Action:0;
}

bool:IsSi(client)
{
	if (IsInfected(client, false))
	{
		return true;
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "08/30/2016",
	time = "15:46:02"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new Handle:g_hMaxSurvivors;
new Handle:g_hMaxInfected;
public Plugin:myinfo =
{
	name = "Spectator stays spectator",
	description = "Spectator will stay as spectators on mapchange.",
	author = "Die Teetasse",
	version = "1.0",
	url = ""
};
new lastTimestamp;
new spectatorCount;
new Handle:spectatorTimer[24];
new String:spectatorSteamIds[24][32];
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	decl String:gameFolder[12];
	GetGameFolderName(gameFolder, 12);
	if (StrContains(gameFolder, "left4dead", true) == -1)
	{
		SetFailState("Spec stays spec work with Left 4 Dead 1 or 2 only!");
	}
	HookEvent("round_start", Event_Round_Start, EventHookMode:1);
	g_hMaxSurvivors = FindConVar("survivor_limit");
	g_hMaxInfected = FindConVar("z_max_player_zombies");
	return 0;
}

public OnMapStart()
{
	HookEvent("round_end", Event_Round_End, EventHookMode:1);
	return 0;
}

public Action:Event_Round_Start(Handle:event, String:name[], bool:dontBroadcast)
{
	CreateTimer(15.0, Check4Spec, any:0, 1);
	return Action:0;
}

public Action:Check4Spec(Handle:timer)
{
	if (GetConVarInt(g_hMaxInfected) + GetConVarInt(g_hMaxSurvivors) != GetRealClientCount())
	{
		return Action:0;
	}
	new i = 1;
	while (GetMaxClients() >= i)
	{
		new var1;
		if (IsClientInGame(i) && IsClientConnected(i) && GetClientTeam(i) == 1)
		{
			FakeClientCommand(i, "say /spectate");
		}
		i++;
	}
	return Action:4;
}

public Action:Event_Round_End(Handle:event, String:name[], bool:dontBroadcast)
{
	spectatorCount = 0;
	new i;
	while (i < 24)
	{
		if (spectatorTimer[i])
		{
			KillTimer(spectatorTimer[i], false);
			spectatorTimer[i] = 0;
		}
		i++;
	}
	new i = 1;
	while (i < MaxClients)
	{
		if (IsClientInGame(i))
		{
			if (!(GetClientTeam(i) != 1))
			{
				GetClientAuthId(i, AuthIdType:1, spectatorSteamIds[spectatorCount], 32, true);
				spectatorCount += 1;
			}
		}
		i++;
	}
	lastTimestamp = GetTime({0,0});
	return Action:0;
}

public OnClientAuthorized(client, String:auth[])
{
	new currentTimestamp = GetTime({0,0});
	if (currentTimestamp - lastTimestamp > 120)
	{
		return 0;
	}
	new index = Function_GetIndex(auth);
	if (index == -1)
	{
		return 0;
	}
	spectatorTimer[index] = CreateTimer(1.0, Timer_MoveToSpec, client, 1);
	return 0;
}

public Action:Timer_MoveToSpec(Handle:timer, any:client)
{
	if (!IsClientInGame(client))
	{
		return Action:0;
	}
	new String:auth[32];
	GetClientAuthId(client, AuthIdType:1, auth, 32, true);
	new index = Function_GetIndex(auth);
	if (index == -1)
	{
		return Action:4;
	}
	spectatorTimer[index] = 0;
	new team = GetClientTeam(client);
	if (team == 1)
	{
		CreateTimer(2.0, ReSpec, client, 0);
		return Action:4;
	}
	decl String:name[32];
	GetClientName(client, name, 32);
	ChangeClientTeam(client, 1);
	CreateTimer(2.0, ReSpec, client, 0);
	return Action:4;
}

public Action:ReSpec(Handle:timer, any:client)
{
	new var1;
	if (IsValidClient(client) && IsClientInGame(client) && GetClientTeam(client) == 1)
	{
		FakeClientCommand(client, "say /spectate");
	}
	return Action:0;
}

public OnClientDisconnect(client)
{
	new String:clientSteamId[32];
	GetClientAuthId(client, AuthIdType:1, clientSteamId, 32, true);
	new index = Function_GetIndex(clientSteamId);
	if (index == -1)
	{
		return 0;
	}
	if (spectatorTimer[index])
	{
		KillTimer(spectatorTimer[index], false);
		spectatorTimer[index] = 0;
		return 0;
	}
	return 0;
}

Function_GetIndex(String:clientSteamId[])
{
	new i;
	while (i < spectatorCount)
	{
		if (StrEqual(spectatorSteamIds[i], clientSteamId, true))
		{
			return i;
		}
		i++;
	}
	return -1;
}

GetRealClientCount()
{
	new clients;
	new i = 1;
	while (GetMaxClients() >= i)
	{
		new var1;
		if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i) && GetClientTeam(i) != 1)
		{
			clients++;
		}
		i++;
	}
	return clients;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return false;
	}
	return true;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "05/05/2014",
	time = "02:12:06"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new Float:block_square[4];
new Handle:hSpitBlockSquares;
new bool:lateLoad;
public Plugin:myinfo =
{
	name = "L4D2 Spit Blocker",
	description = "Blocks spit damage on various maps",
	author = "ProdigySim + Estoopi + Jacob, Visor (:D)",
	version = "2.0",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator>=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) >= 0;
}

bool:operator<=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) <= 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	lateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	RegServerCmd("spit_block_square", AddSpitBlockSquare, "", 0);
	hSpitBlockSquares = CreateTrie();
	if (lateLoad)
	{
		new cl = 1;
		while (cl <= MaxClients)
		{
			if (IsClientInGame(cl))
			{
				SDKHook(cl, SDKHookType:2, stop_spit_dmg);
			}
			cl++;
		}
	}
	return 0;
}

public Action:AddSpitBlockSquare(args)
{
	decl String:mapname[64];
	GetCmdArg(1, mapname, 64);
	new Float:square[4] = 0.0;
	decl String:buf[32];
	new i;
	while (i < 4)
	{
		GetCmdArg(i + 2, buf, 32);
		square[i] = StringToFloat(buf);
		i++;
	}
	SetTrieArray(hSpitBlockSquares, mapname, square, 4, true);
	OnMapStart();
	return Action:0;
}

public OnMapStart()
{
	decl String:mapname[64];
	GetCurrentMap(mapname, 64);
	if (!GetTrieArray(hSpitBlockSquares, mapname, block_square, 4, 0))
	{
		block_square[0] = 0;
		block_square[1] = 0;
		block_square[2] = 0;
		block_square[3] = 0;
	}
	return 0;
}

public OnClientPostAdminCheck(client)
{
	SDKHook(client, SDKHookType:2, stop_spit_dmg);
	return 0;
}

public Action:stop_spit_dmg(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	new var1;
	if (victim <= 0 || victim > MaxClients)
	{
		return Action:0;
	}
	if (!IsValidEdict(inflictor))
	{
		return Action:0;
	}
	decl String:sInflictor[64];
	GetEdictClassname(inflictor, sInflictor, 64);
	if (StrEqual(sInflictor, "insect_swarm", true))
	{
		decl Float:origin[3];
		GetClientAbsOrigin(victim, origin);
		if (isPointIn2DBox(origin[0], origin[1], block_square[0], block_square[1], block_square[2], block_square[3]))
		{
			return Action:3;
		}
	}
	return Action:0;
}

bool:isPointIn2DBox(Float:x0, Float:y0, Float:x1, Float:y1, Float:x2, Float:y2)
{
	if (x1 > x2)
	{
		if (y1 > y2)
		{
			new var1;
			return x0 <= x1 && x0 >= x2 && y0 <= y1 && y0 >= y2;
		}
		new var2;
		return x0 <= x1 && x0 >= x2 && y0 >= y1 && y0 <= y2;
	}
	if (y1 > y2)
	{
		new var3;
		return x0 >= x1 && x0 <= x2 && y0 <= y1 && y0 >= y2;
	}
	new var4;
	return x0 >= x1 && x0 <= x2 && y0 >= y1 && y0 <= y2;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "11/24/2014",
	time = "19:20:01"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public SharedPlugin:__pl_l4d2util =
{
	name = "code_patcher",
	file = "code_patcher.smx",
	required = 1,
};
new Handle:hRing1BulletsCvar;
new Handle:hRing1FactorCvar;
new Handle:hCenterPelletCvar;
new g_BulletOffsets[4] =
{
	17, 28, 41, 61
};
new g_FactorOffset = 46;
new g_CenterPelletOffset = -49;
public Plugin:myinfo =
{
	name = "L4D2 Static Shotgun Spread",
	description = "^",
	author = "Jahze, Visor",
	version = "1.1",
	url = "https://github.com/Attano"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public __pl_lgofnoc_SetNTVOptional()
{
	MarkNativeAsOptional("IsPatchApplied");
	MarkNativeAsOptional("GetPatchAddress");
	MarkNativeAsOptional("IsPlatformWindows");
	return 0;
}

public OnPluginStart()
{
	hRing1BulletsCvar = CreateConVar("sgspread_ring1_bullets", "3", "", 0, false, 0.0, false, 0.0);
	hRing1FactorCvar = CreateConVar("sgspread_ring1_factor", "2", "", 0, false, 0.0, false, 0.0);
	hCenterPelletCvar = CreateConVar("sgspread_center_pellet", "1", "0 : center pellet off; 1 : on", 262144, true, 0.0, true, 1.0);
	HookConVarChange(hRing1BulletsCvar, OnRing1BulletsChange);
	HookConVarChange(hRing1FactorCvar, OnRing1FactorChange);
	HookConVarChange(hCenterPelletCvar, OnCenterPelletChange);
	return 0;
}

HotPatchCenterPellet(newValue)
{
	if (IsPlatformWindows())
	{
		LogMessage("Static shotgun spread not supported on windows");
		return 0;
	}
	new Address:addr = GetPatchAddress("sgspread");
	new currentValue = LoadFromAddress(g_CenterPelletOffset + addr, NumberType:0);
	if (newValue == currentValue)
	{
		return 0;
	}
	StoreToAddress(g_CenterPelletOffset + addr, newValue, NumberType:0);
	return 0;
}

HotPatchBullets(nBullets)
{
	if (IsPlatformWindows())
	{
		LogMessage("Static shotgun spread not supported on windows");
		return 0;
	}
	new Address:addr = GetPatchAddress("sgspread");
	StoreToAddress(g_BulletOffsets[0] + addr, nBullets + 1, NumberType:0);
	StoreToAddress(g_BulletOffsets[1] + addr, nBullets + 2, NumberType:0);
	StoreToAddress(g_BulletOffsets[2] + addr, nBullets + 2, NumberType:0);
	new Float:degree = 360.0 / float(nBullets) * 2.0;
	StoreToAddress(g_BulletOffsets[3] + addr, degree, NumberType:2);
	return 0;
}

HotPatchFactor(factor)
{
	if (IsPlatformWindows())
	{
		LogMessage("Static shotgun spread not supported on windows");
		return 0;
	}
	new Address:addr = GetPatchAddress("sgspread");
	StoreToAddress(g_FactorOffset + addr, factor, NumberType:2);
	return 0;
}

public OnRing1BulletsChange(Handle:cvar, String:oldVal[], String:newVal[])
{
	new nBullets = StringToInt(newVal, 10);
	if (IsPatchApplied("sgspread"))
	{
		HotPatchBullets(nBullets);
	}
	return 0;
}

public OnRing1FactorChange(Handle:cvar, String:oldVal[], String:newVal[])
{
	new factor = StringToInt(newVal, 10);
	if (IsPatchApplied("sgspread"))
	{
		HotPatchFactor(factor);
	}
	return 0;
}

public OnCenterPelletChange(Handle:cvar, String:oldVal[], String:newVal[])
{
	new value = StringToInt(newVal, 10);
	if (IsPatchApplied("sgspread"))
	{
		HotPatchCenterPellet(value);
	}
	return 0;
}

public OnPatchApplied(String:name[])
{
	if (StrEqual("sgspread", name, true))
	{
		HotPatchBullets(GetConVarInt(hRing1BulletsCvar));
		HotPatchFactor(GetConVarInt(hRing1FactorCvar));
		HotPatchCenterPellet(GetConVarInt(hCenterPelletCvar));
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/31/2016",
	time = "17:54:25"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new g_iAlarmCarClient;
public Plugin:myinfo =
{
	name = "L4D2 Realtime Stats",
	description = "Display Skeets/Etc to Chat to clients",
	author = "Griffin, Philogl, Sir",
	version = "1.0",
	url = "<- URL ->"
};
new g_iSurvivorLimit = 4;
new Handle:g_hCvarSurvivorLimit;
new bool:g_bHasRoundEnded;
new g_iBoomerClient;
new g_iBoomerKiller;
new g_iBoomerShover;
new g_iLastHealth[66];
new bool:g_bHasBoomLanded;
new bool:g_bIsPouncing[66];
new Handle:g_hBoomerShoveTimer;
new Handle:g_hBoomerKillTimer;
new Float:BoomerKillTime;
new String:Boomer[32];
new g_iDamageDealt[66][66];
new g_iShotsDealt[66][66];
new bool:g_bShotCounted[66][66];
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

StrCat(String:buffer[], maxlength, String:source[])
{
	new len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	return Format(buffer[len], maxlength - len, "%s", source);
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	HookEvent("round_start", Event_RoundStart, EventHookMode:1);
	HookEvent("round_end", Event_RoundEnd, EventHookMode:1);
	HookEvent("player_hurt", Event_PlayerHurt, EventHookMode:1);
	HookEvent("player_death", Event_PlayerDeath, EventHookMode:1);
	HookEvent("player_spawn", Event_PlayerSpawn, EventHookMode:1);
	HookEvent("ability_use", Event_AbilityUse, EventHookMode:1);
	HookEvent("lunge_pounce", Event_LungePounce, EventHookMode:1);
	HookEvent("weapon_fire", Event_WeaponFire, EventHookMode:1);
	HookEvent("player_shoved", Event_PlayerShoved, EventHookMode:1);
	HookEvent("player_now_it", Event_PlayerBoomed, EventHookMode:1);
	HookEvent("create_panic_event", Event_Panic, EventHookMode:1);
	HookEvent("triggered_car_alarm", Event_AlarmCar, EventHookMode:1);
	g_hCvarSurvivorLimit = FindConVar("survivor_limit");
	HookConVarChange(g_hCvarSurvivorLimit, Cvar_SurvivorLimit);
	g_iSurvivorLimit = GetConVarInt(g_hCvarSurvivorLimit);
	return 0;
}

public Event_PlayerSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client && !IsClientInGame(client))
	{
		return 0;
	}
	if (GetClientTeam(client) == 3)
	{
		new zombieclass = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
		if (zombieclass == 8)
		{
			return 0;
		}
		if (zombieclass == 2)
		{
			new var2;
			if (!IsFakeClient(client) || !g_iBoomerClient)
			{
				g_bHasBoomLanded = false;
				g_iBoomerClient = client;
				g_iBoomerShover = 0;
				g_iBoomerKiller = 0;
			}
			if (g_hBoomerShoveTimer)
			{
				KillTimer(g_hBoomerShoveTimer, false);
				g_hBoomerShoveTimer = MissingTAG:0;
			}
			BoomerKillTime = 0.0;
			g_hBoomerKillTimer = CreateTimer(0.1, Timer_KillBoomer, any:0, 1);
		}
		g_iLastHealth[client] = GetClientHealth(client);
	}
	return 0;
}

public Event_WeaponFire(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new i = 1;
	while (i <= MaxClients)
	{
		g_bShotCounted[i][client] = false;
		i++;
	}
	return 0;
}

public OnMapStart()
{
	g_bHasRoundEnded = false;
	ClearMapStats();
	return 0;
}

public Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	g_bHasRoundEnded = false;
	if (g_hBoomerKillTimer)
	{
		KillTimer(g_hBoomerKillTimer, false);
		g_hBoomerKillTimer = MissingTAG:0;
		BoomerKillTime = 0.0;
	}
	g_iAlarmCarClient = 0;
	return 0;
}

public Event_RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bHasRoundEnded)
	{
		return 0;
	}
	g_bHasRoundEnded = true;
	new i = 1;
	while (i <= MaxClients)
	{
		ClearDamage(i);
		i++;
	}
	return 0;
}

public Event_AbilityUse(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bHasRoundEnded)
	{
		return 0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (!IsClientInGame(client) || !GetClientTeam(client) == 3)
	{
		return 0;
	}
	new zombieclass = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	if (zombieclass == 3)
	{
		g_bIsPouncing[client] = 1;
		CreateTimer(0.5, Timer_GroundedCheck, client, 1);
	}
	return 0;
}

public Event_LungePounce(Handle:event, String:name[], bool:dontBroadcast)
{
	new attacker = GetClientOfUserId(GetEventInt(event, "userid"));
	new zombieclass = GetEntProp(attacker, PropType:0, "m_zombieClass", 4, 0);
	if (zombieclass == 3)
	{
		g_bIsPouncing[attacker] = 0;
	}
	return 0;
}

public Action:Timer_GroundedCheck(Handle:timer, any:client)
{
	new var1;
	if (!IsClientInGame(client) || IsGrounded(client))
	{
		g_bIsPouncing[client] = 0;
		KillTimer(timer, false);
	}
	return Action:0;
}

public Action:Timer_KillBoomer(Handle:timer)
{
	BoomerKillTime = BoomerKillTime + 0.1;
	return Action:0;
}

bool:IsGrounded(client)
{
	return GetEntProp(client, PropType:1, "m_fFlags", 4, 0) & 1 > 0;
}

public Event_PlayerHurt(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bHasRoundEnded)
	{
		return 0;
	}
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var1;
	if (victim && !IsClientInGame(victim))
	{
		return 0;
	}
	new var2;
	if (!attacker || !IsClientInGame(attacker))
	{
		return 0;
	}
	new damage = GetEventInt(event, "dmg_health");
	new var3;
	if (GetClientTeam(attacker) == 2 && GetClientTeam(victim) == 3)
	{
		new zombieclass = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
		if (zombieclass == 8)
		{
			return 0;
		}
		if (!g_bShotCounted[victim][attacker])
		{
			g_iShotsDealt[victim][attacker]++;
			g_bShotCounted[victim][attacker] = true;
		}
		new remaining_health = GetEventInt(event, "health");
		if (0 >= remaining_health)
		{
			return 0;
		}
		g_iLastHealth[victim] = remaining_health;
		new var4 = g_iDamageDealt[victim][attacker];
		var4 = var4[damage];
		if (zombieclass == 2)
		{
		}
		else
		{
			if (!(zombieclass == 3))
			{
				if (!(zombieclass == 1))
				{
					if (!(zombieclass == 5))
					{
						if (zombieclass == 6)
						{
						}
					}
				}
			}
		}
	}
	return 0;
}

public Event_PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bHasRoundEnded)
	{
		return 0;
	}
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var1;
	if (victim && !IsClientInGame(victim))
	{
		return 0;
	}
	if (attacker)
	{
		if (!IsClientInGame(attacker))
		{
			if (GetClientTeam(victim) == 3)
			{
				ClearDamage(victim);
			}
			return 0;
		}
		new var2;
		if (GetClientTeam(attacker) == 2 && GetClientTeam(victim) == 3)
		{
			new String:weapon[64];
			GetClientWeapon(attacker, weapon, 64);
			new zombieclass = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
			if (zombieclass == 8)
			{
				return 0;
			}
			new lasthealth = g_iLastHealth[victim];
			new var8 = g_iDamageDealt[victim][attacker];
			var8 = var8[lasthealth];
			if (zombieclass == 2)
			{
				if (!g_iBoomerClient)
				{
					g_iBoomerClient = victim;
				}
				if (IsClientConnected(g_iBoomerClient))
				{
					if (!IsFakeClient(g_iBoomerClient))
					{
						GetClientName(g_iBoomerClient, Boomer, 32);
					}
				}
				else
				{
					if (!IsFakeClient(victim))
					{
						GetClientName(victim, Boomer, 32);
					}
				}
				CreateTimer(0.2, Timer_BoomerKilledCheck, victim, 0);
				g_iBoomerKiller = attacker;
				if (g_hBoomerKillTimer)
				{
					KillTimer(g_hBoomerKillTimer, false);
					g_hBoomerKillTimer = MissingTAG:0;
				}
			}
			else
			{
				new var3;
				if (zombieclass == 3 && g_bIsPouncing[victim])
				{

/* ERROR! null */
 function "Event_PlayerDeath" (number 23)
public Action:Timer_BoomerKilledCheck(Handle:timer)
{
	BoomerKillTime = BoomerKillTime - 0.2;
	new var1;
	if (g_bHasBoomLanded || BoomerKillTime > 2.0)
	{
		g_iBoomerClient = 0;
		BoomerKillTime = 0.0;
		return Action:0;
	}
	if (BoomerKillTime < 0.1)
	{
		BoomerKillTime = 0.1;
	}
	if (IsValidClient(g_iBoomerKiller))
	{
		if (IsValidClient(g_iBoomerClient))
		{
			if (BoomerKillTime < 0.5)
			{
				CPrintToChatAll("{green}? {olive}%N {default}has shutdown {olive}%s{default}'s Boomer in {blue}%0.1fs", g_iBoomerKiller, Boomer, BoomerKillTime);
			}
			if (BoomerKillTime < 1.4)
			{
				CPrintToChatAll("{green}? {olive}%N {default}has shutdown {olive}%s{default}'s Boomer in {blue}%0.1fs", g_iBoomerKiller, Boomer, BoomerKillTime);
			}
			CPrintToChatAll("{green}? {olive}%N {default}has shutdown {olive}%s{default}'s Boomer in {blue}%0.1fs", g_iBoomerKiller, Boomer, BoomerKillTime);
		}
	}
	g_iBoomerClient = 0;
	BoomerKillTime = 0.0;
	return Action:0;
}

public Event_PlayerShoved(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bHasRoundEnded)
	{
		return 0;
	}
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (victim && !IsClientInGame(victim) && !GetClientTeam(victim) == 3)
	{
		return 0;
	}
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var2;
	if (attacker && !IsClientInGame(attacker) && !GetClientTeam(attacker) == 2)
	{
		return 0;
	}
	new zombieclass = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
	if (zombieclass == 2)
	{
		if (g_hBoomerShoveTimer)
		{
			KillTimer(g_hBoomerShoveTimer, false);
			new var3;
			if (!g_iBoomerShover || !IsClientInGame(g_iBoomerShover))
			{
				g_iBoomerShover = attacker;
			}
		}
		else
		{
			g_iBoomerShover = attacker;
		}
		g_hBoomerShoveTimer = CreateTimer(4.0, Timer_BoomerShove, any:0, 0);
	}
	return 0;
}

public Action:Timer_BoomerShove(Handle:timer)
{
	g_hBoomerShoveTimer = MissingTAG:0;
	g_iBoomerShover = 0;
	return Action:0;
}

public Event_PlayerBoomed(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bHasBoomLanded)
	{
		return 0;
	}
	g_bHasBoomLanded = true;
	if (!(GetEventBool(event, "exploded")))
	{
	}
	return 0;
}

public Event_Panic(Handle:event, String:name[], bool:dontBroadcast)
{
	g_iAlarmCarClient = GetClientOfUserId(GetEventInt(event, "userid"));
	CreateTimer(0.5, Clear, g_iAlarmCarClient, 0);
	return 0;
}

public Action:Clear(Handle:timer)
{
	g_iAlarmCarClient = 0;
	return Action:0;
}

public Action:Event_AlarmCar(Handle:event, String:name[], bool:dontBroadcast)
{
	new var1;
	if (g_iAlarmCarClient && IsClientInGame(g_iAlarmCarClient) && GetClientTeam(g_iAlarmCarClient) == 2)
	{
		CPrintToChatAll("{green}? {olive}%N {default}triggered an {red}Alarmed {default}Car", g_iAlarmCarClient);
		g_iAlarmCarClient = 0;
	}
	return Action:0;
}

public Cvar_SurvivorLimit(Handle:convar, String:oldValue[], String:newValue[])
{
	g_iSurvivorLimit = StringToInt(newValue, 10);
	return 0;
}

ClearMapStats()
{
	new i = 1;
	while (i <= MaxClients)
	{
		ClearDamage(i);
		i++;
	}
	g_iAlarmCarClient = 0;
	return 0;
}

ClearDamage(client)
{
	g_iLastHealth[client] = 0;
	new i = 1;
	while (i <= MaxClients)
	{
		g_iDamageDealt[client][i] = 0;
		g_iShotsDealt[client][i] = 0;
		i++;
	}
	return 0;
}

public ClientValue2DSortDesc(x[], y[], array[][], Handle:data)
{
	if (y[1] < x[1])
	{
		return -1;
	}
	if (y[1] > x[1])
	{
		return 1;
	}
	return 0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "12/10/2015",
	time = "12:51:25"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "No Spitter During Tank",
	description = "Prevents the director from giving the infected team a spitter while the tank is alive",
	author = "Don, epilimic, XBetaAlpha, darkid",
	version = "1.8",
	url = "https://bitbucket.org/DonSanchez/random-sourcemod-stuff"
};
new bool:g_bIsTankAlive;
new Handle:g_hSpitterLimit;
new Handle:g_hBoomerLimit;
new Handle:g_hSetClass;
new Handle:g_hCreateAbility;
new g_oAbility;
new bool:in_attack2[65];
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	decl String:sGame[12];
	GetGameFolderName(sGame, 12);
	if (StrEqual(sGame, "left4dead2", true))
	{
		return APLRes:0;
	}
	strcopy(error, err_max, "Plugin only supports L4D2");
	return APLRes:1;
}

public OnPluginStart()
{
	HookEvent("tank_spawn", Event_tank_spawn_Callback, EventHookMode:1);
	HookEvent("player_death", PlayerDeath, EventHookMode:0);
	HookEvent("player_disconnect", PlayerDisconnect, EventHookMode:0);
	HookEvent("round_end", RoundEnd, EventHookMode:1);
	g_hSpitterLimit = FindConVar("z_versus_spitter_limit");
	g_hBoomerLimit = FindConVar("z_versus_boomer_limit");
	HookEvent("ghost_spawn_time", PlayerGhostTimer, EventHookMode:1);
	Sub_HookGameData();
	return 0;
}

bool:teamHasBoomerOrSpitter(client)
{
	new i = 1;
	while (i < MaxClients)
	{
		if (!(i == client))
		{
			if (IsClientInGame(i))
			{
				if (!(GetClientTeam(i) != 3))
				{
					new class = GetEntProp(i, PropType:0, "m_zombieClass", 4, 0);
					new var1;
					if (class == 2 || class == 4)
					{
						return true;
					}
				}
			}
		}
		i++;
	}
	return false;
}

public Event_tank_spawn_Callback(Handle:event, String:name[], bool:dontBroadcast)
{
	SetConVarInt(g_hSpitterLimit, 0, false, false);
	g_bIsTankAlive = true;
	return 0;
}

public PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return 0;
	}
	new class = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	new var3;
	if (g_bIsTankAlive && (class == 4 || class == 2))
	{
		SetConVarInt(g_hBoomerLimit, 1, false, false);
	}
	else
	{
		if (class == 8)
		{
			g_bIsTankAlive = false;
			SetConVarInt(g_hSpitterLimit, 1, false, false);
			SetConVarInt(g_hBoomerLimit, 1, false, false);
		}
	}
	return 0;
}

public PlayerDisconnect(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_bIsTankAlive)
	{
		return 0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return 0;
	}
	if (GetClientTeam(client) != 3)
	{
		return 0;
	}
	new class = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	new var2;
	if (class == 2 || class == 4)
	{
		SetConVarInt(g_hBoomerLimit, 1, false, false);
	}
	CreateTimer(1.0, TankDisconnect, any:0, 0);
	return 0;
}

public Action:TankDisconnect(Handle:timer)
{
	g_bIsTankAlive = false;
	new i = 1;
	while (i < MaxClients)
	{
		if (IsClientInGame(i))
		{
			if (!(GetClientTeam(i) != 3))
			{
				if (!(GetEntProp(i, PropType:0, "m_zombieClass", 4, 0) != 8))
				{
					g_bIsTankAlive = true;
				}
			}
		}
		i++;
	}
	if (!g_bIsTankAlive)
	{
		SetConVarInt(g_hSpitterLimit, 1, false, false);
		SetConVarInt(g_hBoomerLimit, 1, false, false);
	}
	return Action:0;
}

public RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	g_bIsTankAlive = false;
	SetConVarInt(g_hSpitterLimit, 1, false, false);
	SetConVarInt(g_hBoomerLimit, 1, false, false);
	return 0;
}

public OnMapChange()
{
	g_bIsTankAlive = false;
	SetConVarInt(g_hSpitterLimit, 1, false, false);
	SetConVarInt(g_hBoomerLimit, 1, false, false);
	return 0;
}

public OnPluginEnd()
{
	SetConVarInt(g_hSpitterLimit, 1, false, false);
	SetConVarInt(g_hBoomerLimit, 1, false, false);
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	if (!g_bIsTankAlive)
	{
		return Action:0;
	}
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return Action:0;
	}
	if (!IsClientInGame(client))
	{
		return Action:0;
	}
	if (IsFakeClient(client))
	{
		return Action:0;
	}
	if (GetClientTeam(client) != 3)
	{
		return Action:0;
	}
	if (!GetEntProp(client, PropType:0, "m_isGhost", 4, 0))
	{
		return Action:0;
	}
	if (teamHasBoomerOrSpitter(client))
	{
		return Action:0;
	}
	new var2;
	if (buttons & 2048 != 2048 && in_attack2[client])
	{
		in_attack2[client] = 0;
	}
	new var3;
	if (buttons & 2048 == 2048 && !in_attack2[client])
	{
		in_attack2[client] = 1;
		new class = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
		if (class == 4)
		{
			Sub_DetermineClass(client, any:2);
			PrintHintText(client, "Press <Mouse2> to change back to spitter.");
		}
		else
		{
			if (class == 2)
			{
				Sub_DetermineClass(client, any:4);
				PrintHintText(client, "Press <Mouse2> to change back to boomer.");
			}
		}
	}
	return Action:0;
}

public PlayerGhostTimer(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_bIsTankAlive)
	{
		return 0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return 0;
	}
	if (!IsClientInGame(client))
	{
		return 0;
	}
	if (IsFakeClient(client))
	{
		return 0;
	}
	if (GetClientTeam(client) != 3)
	{
		return 0;
	}
	new Float:spawntime = 1065353216 * GetEventInt(event, "spawntime") + 0.1;
	CreateTimer(spawntime, PlayerBecameGhost, client, 0);
	return 0;
}

public Action:PlayerBecameGhost(Handle:timer, any:client)
{
	if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) != 2)
	{
		return Action:0;
	}
	if (teamHasBoomerOrSpitter(client))
	{
		return Action:0;
	}
	SetConVarInt(g_hBoomerLimit, 0, false, false);
	PrintHintText(client, "Press <Mouse2> to change to spitter.");
	return Action:0;
}

public Sub_HookGameData()
{
	new Handle:g_hGameConf = LoadGameConfigFile("l4d2_zcs");
	if (g_hGameConf)
	{
		StartPrepSDKCall(SDKCallType:2);
		PrepSDKCall_SetFromConf(g_hGameConf, SDKFuncConfSource:1, "SetClass");
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		g_hSetClass = EndPrepSDKCall();
		if (!g_hSetClass)
		{
			SetFailState("Unable to find SetClass signature.");
		}
		StartPrepSDKCall(SDKCallType:0);
		PrepSDKCall_SetFromConf(g_hGameConf, SDKFuncConfSource:1, "CreateAbility");
		PrepSDKCall_AddParameter(SDKType:1, SDKPassMethod:0, 0, 0);
		PrepSDKCall_SetReturnInfo(SDKType:0, SDKPassMethod:0, 0, 0);
		g_hCreateAbility = EndPrepSDKCall();
		if (!g_hCreateAbility)
		{
			SetFailState("Unable to find CreateAbility signature.");
		}
		g_oAbility = GameConfGetOffset(g_hGameConf, "oAbility");
		CloseHandle(g_hGameConf);
	}
	else
	{
		SetFailState("Unable to load l4d2_zcs.txt");
	}
	return 0;
}

public Sub_DetermineClass(any:Client, any:ZClass)
{
	new WeaponIndex;
	while ((WeaponIndex = GetPlayerWeaponSlot(Client, 0)) != -1)
	{
		RemovePlayerItem(Client, WeaponIndex);
		RemoveEdict(WeaponIndex);
	}
	SDKCall(g_hSetClass, Client, ZClass);
	AcceptEntityInput(MakeCompatEntRef(GetEntProp(Client, PropType:0, "m_customAbility", 4, 0)), "Kill", -1, -1, 0);
	SetEntProp(Client, PropType:0, "m_customAbility", GetEntData(SDKCall(g_hCreateAbility, Client), g_oAbility, 4), 4, 0);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5292",
	date = "03/15/2016",
	time = "17:41:55"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new bool:g_bIsTankAlive;
public Plugin:myinfo =
{
	name = "L4D2 Tank Announcer",
	description = "Announce in chat and via a sound when a Tank has spawned",
	author = "Visor",
	version = "1.0",
	url = "https://github.com/Attano"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public void:OnMapStart()
{
	PrecacheSound("ui/pickup_secret01.wav", false);
	return void:0;
}

public void:OnPluginStart()
{
	HookEvent("tank_spawn", OnTankSpawn, EventHookMode:2);
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	return void:0;
}

public OnRoundStart()
{
	g_bIsTankAlive = false;
	return 0;
}

public OnTankSpawn()
{
	if (!g_bIsTankAlive)
	{
		g_bIsTankAlive = true;
		CPrintToChatAll("{red}[{default}!{red}] {olive}Tank {default}has spawned!");
		EmitSoundToAll("ui/pickup_secret01.wav", -2, 0, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/28/2016",
	time = "15:52:58"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new g_iQueuedThrow[66];
new Handle:g_hBlockPunchRock;
new Handle:g_hBlockJumpRock;
new Handle:hOverhandOnly;
new Float:throwQueuedAt[66];
public Plugin:myinfo =
{
	name = "Tank Attack Control",
	description = "",
	author = "vintik, CanadaRox, Jacob, Visor",
	version = "0.7",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

GetClientButtons(client)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_nButtons", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_nButtons");
		}
		gotconfig = true;
	}
	return GetEntProp(client, PropType:1, datamap, 4, 0);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	decl String:sGame[256];
	GetGameFolderName(sGame, 256);
	if (!StrEqual(sGame, "left4dead2", false))
	{
		SetFailState("Plugin supports Left 4 dead 2 only!");
	}
	g_hBlockPunchRock = CreateConVar("l4d2_block_punch_rock", "1", "Block tanks from punching and throwing a rock at the same time", 0, false, 0.0, false, 0.0);
	g_hBlockJumpRock = CreateConVar("l4d2_block_jump_rock", "0", "Block tanks from jumping and throwing a rock at the same time", 0, false, 0.0, false, 0.0);
	hOverhandOnly = CreateConVar("tank_overhand_only", "0", "Force tank to only throw overhand rocks.", 262144, false, 0.0, false, 0.0);
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	HookEvent("tank_spawn", TankSpawn_Event, EventHookMode:1);
	return 0;
}

public OnRoundStart()
{
	new i = 1;
	while (i <= MaxClients)
	{
		throwQueuedAt[i] = 0;
		i++;
	}
	return 0;
}

public TankSpawn_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new tank = GetClientOfUserId(GetEventInt(event, "userid"));
	if (IsFakeClient(tank))
	{
		return 0;
	}
	new bool:hidemessage;
	decl String:buffer[4];
	if (GetClientInfo(tank, "rs_hidemessage", buffer, 3))
	{
		hidemessage = StringToInt(buffer, 10);
	}
	new var1;
	if (!hidemessage && GetConVarBool(hOverhandOnly))
	{
		CPrintToChat(tank, "{blue}[{default}Tank Rock Selector{blue}]");
		CPrintToChat(tank, "{olive}Reload {default}= {blue}2 Handed Overhand");
		CPrintToChat(tank, "{olive}Use {default}= {blue}Underhand");
		CPrintToChat(tank, "{olive}M2 {default}= {blue}1 Handed Overhand");
	}
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	new var1;
	if (!IsClientInGame(client) || IsFakeClient(client) || GetClientTeam(client) == 3 || GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8)
	{
		return Action:0;
	}
	new var2;
	if (buttons & 2 && ShouldCancelJump(client))
	{
		buttons = buttons & -3;
	}
	if (GetConVarBool(hOverhandOnly))
	{
		g_iQueuedThrow[client] = 3;
	}
	else
	{
		if (buttons & 8192)
		{
			g_iQueuedThrow[client] = 3;
			buttons = buttons | 2048;
		}
		else
		{
			if (buttons & 32)
			{
				g_iQueuedThrow[client] = 2;
				buttons = buttons | 2048;
			}
			g_iQueuedThrow[client] = 1;
		}
	}
	return Action:0;
}

public Action:L4D_OnCThrowActivate(ability)
{
	if (!IsValidEntity(ability))
	{
		LogMessage("Invalid 'ability_throw' index: %d. Continuing throwing.", ability);
		return Action:0;
	}
	new client = GetEntPropEnt(ability, PropType:1, "m_hOwnerEntity", 0);
	if (GetClientButtons(client) & 1)
	{
		if (GetConVarBool(g_hBlockPunchRock))
		{
			return Action:3;
		}
	}
	throwQueuedAt[client] = GetGameTime();
	return Action:0;
}

public Action:L4D2_OnSelectTankAttack(client, &sequence)
{
	new var1;
	if (sequence > 48 && g_iQueuedThrow[client])
	{
		sequence = g_iQueuedThrow[client] + 48;
		return Action:3;
	}
	return Action:0;
}

bool:ShouldCancelJump(client)
{
	if (!GetConVarBool(g_hBlockJumpRock))
	{
		return false;
	}
	return 1.5 > GetGameTime() - throwQueuedAt[client];
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "05/09/2017",
	time = "17:24:41"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new g_iQueuedThrow[66];
new Handle:g_hBlockPunchRock;
new Handle:g_hBlockJumpRock;
new Handle:hOverhandOnly;
new Float:throwQueuedAt[66];
public Plugin:myinfo =
{
	name = "Tank Attack Control",
	description = "",
	author = "vintik, CanadaRox, Jacob, Visor",
	version = "0.7",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

GetClientButtons(client)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_nButtons", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_nButtons");
		}
		gotconfig = true;
	}
	return GetEntProp(client, PropType:1, datamap, 4, 0);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	decl String:sGame[256];
	GetGameFolderName(sGame, 256);
	if (!StrEqual(sGame, "left4dead2", false))
	{
		SetFailState("Plugin supports Left 4 dead 2 only!");
	}
	g_hBlockPunchRock = CreateConVar("l4d2_block_punch_rock", "1", "Block tanks from punching and throwing a rock at the same time", 0, false, 0.0, false, 0.0);
	g_hBlockJumpRock = CreateConVar("l4d2_block_jump_rock", "0", "Block tanks from jumping and throwing a rock at the same time", 0, false, 0.0, false, 0.0);
	hOverhandOnly = CreateConVar("tank_overhand_only", "0", "Force tank to only throw overhand rocks.", 262144, false, 0.0, false, 0.0);
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	HookEvent("tank_spawn", TankSpawn_Event, EventHookMode:1);
	return 0;
}

public OnRoundStart()
{
	new i = 1;
	while (i <= MaxClients)
	{
		throwQueuedAt[i] = 0;
		i++;
	}
	return 0;
}

public TankSpawn_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new tank = GetClientOfUserId(GetEventInt(event, "userid"));
	if (IsFakeClient(tank))
	{
		return 0;
	}
	new bool:hidemessage;
	decl String:buffer[4];
	if (GetClientInfo(tank, "rs_hidemessage", buffer, 3))
	{
		hidemessage = StringToInt(buffer, 10);
	}
	new var1;
	if (!hidemessage && GetConVarBool(hOverhandOnly))
	{
		CPrintToChat(tank, "{blue}[{default}Tank Rock Selector{blue}]");
		CPrintToChat(tank, "{olive}Reload {default}= {blue}2 Handed Overhand");
		CPrintToChat(tank, "{olive}Use {default}= {blue}Underhand");
		CPrintToChat(tank, "{olive}M2 {default}= {blue}1 Handed Overhand");
	}
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	new var1;
	if (!IsClientInGame(client) || IsFakeClient(client) || GetClientTeam(client) == 3 || GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8)
	{
		return Action:0;
	}
	new var2;
	if (buttons & 2 && ShouldCancelJump(client))
	{
		buttons = buttons & -3;
	}
	if (GetConVarBool(hOverhandOnly))
	{
		g_iQueuedThrow[client] = 3;
	}
	else
	{
		if (buttons & 8192)
		{
			g_iQueuedThrow[client] = 3;
			buttons = buttons | 2048;
		}
		else
		{
			if (buttons & 32)
			{
				g_iQueuedThrow[client] = 2;
				buttons = buttons | 2048;
			}
			g_iQueuedThrow[client] = 1;
		}
	}
	return Action:0;
}

public Action:L4D_OnCThrowActivate(ability)
{
	if (!IsValidEntity(ability))
	{
		LogMessage("Invalid 'ability_throw' index: %d. Continuing throwing.", ability);
		return Action:0;
	}
	new client = GetEntPropEnt(ability, PropType:1, "m_hOwnerEntity", 0);
	if (GetClientButtons(client) & 1)
	{
		if (GetConVarBool(g_hBlockPunchRock))
		{
			return Action:3;
		}
	}
	throwQueuedAt[client] = GetGameTime();
	return Action:0;
}

public Action:L4D2_OnSelectTankAttack(client, &sequence)
{
	new var1;
	if (sequence > 48 && g_iQueuedThrow[client])
	{
		sequence = g_iQueuedThrow[client] + 48;
		return Action:3;
	}
	return Action:0;
}

bool:ShouldCancelJump(client)
{
	if (!GetConVarBool(g_hBlockJumpRock))
	{
		return false;
	}
	return 1.5 > GetGameTime() - throwQueuedAt[client];
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Tank & Charger M2 Fix",
	description = "Stops Shoves slowing the Tank and Charger Down",
	author = "Sir, Visor",
	version = "1.0",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public Action:L4D_OnShovedBySurvivor(shover, shovee, Float:vector[3])
{
	new var1;
	if (!IsSurvivor(shover) || !IsInfected(shovee))
	{
		return Action:0;
	}
	if (IsTankOrCharger(shovee))
	{
		return Action:3;
	}
	return Action:0;
}

public Action:L4D2_OnEntityShoved(shover, shovee_ent, weapon, Float:vector[3], bool:bIsHunterDeadstop)
{
	new var1;
	if (!IsSurvivor(shover) || !IsInfected(shovee_ent))
	{
		return Action:0;
	}
	if (IsTankOrCharger(shovee_ent))
	{
		return Action:3;
	}
	return Action:0;
}

bool:IsTankOrCharger(client)
{
	if (!IsPlayerAlive(client))
	{
		return false;
	}
	new zombieclass = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	new var1;
	return zombieclass == 6 || zombieclass == 8;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "01/09/2016",
	time = "19:42:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new Handle:vs_tank_pound_damage;
new Handle:vs_tank_rock_damage;
new bool:lateLoad;
public Plugin:myinfo =
{
	name = "L4D2 Tank Damage Cvars",
	description = "Toggle Tank attack damage per type",
	author = "Visor",
	version = "1.1",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	lateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	vs_tank_pound_damage = CreateConVar("vs_tank_pound_damage", "24", "Amount of damage done by a vs tank's melee attack on incapped survivors", 0, false, 0.0, false, 0.0);
	vs_tank_rock_damage = CreateConVar("vs_tank_rock_damage", "24", "Amount of damage done by a vs tank's rock", 0, false, 0.0, false, 0.0);
	if (lateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				OnClientPutInServer(i);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (!IsSurvivor(victim) || !IsTank(attacker))
	{
		return Action:0;
	}
	new var2;
	if (IsIncapped(victim) && IsTank(inflictor))
	{
		damage = GetConVarFloat(vs_tank_pound_damage);
	}
	else
	{
		if (IsTankRock(inflictor))
		{
			damage = GetConVarFloat(vs_tank_rock_damage);
		}
	}
	return Action:1;
}

bool:IsIncapped(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsTank(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8 && IsPlayerAlive(client);
}

bool:IsTankRock(entity)
{
	new var1;
	if (entity > 0 && IsValidEntity(entity) && IsValidEdict(entity))
	{
		decl String:classname[64];
		GetEdictClassname(entity, classname, 64);
		return StrEqual(classname, "tank_rock", true);
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "11/25/2017",
	time = "23:41:54"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public SharedPlugin:__pl_l4d2lib =
{
	name = "l4d2lib",
	file = "l4d2lib.smx",
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1414218835, 1936486255, 0, 1953195123, 1936486255, 1954047278, 0, 1444, 1456, 1, 1, 1919311725, 1920234357, 1869182049, 110, 1919311725, 1920234357, 1869182049, 110, 845427820, 1818850421, 0, 845427820, 1818850421, 2020438830, 0, 1520, 1532, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new Handle:hSurvivorModelsTrie = 1919311725;
new Handle:hWeaponNamesTrie = 845427820;
public SharedPlugin:__pl_l4d2util =
{
	name = "l4d2util",
	file = "l4d2util.smx",
	required = 1,
};
new Handle:hCvarVisionSeconds;
new Handle:hCvarFrustrationGain;
new Float:fVisionSeconds;
new iFrustrationGain;
new iStoredFrustration[66];
new Float:fSecondsVisionHeld[66];
new Handle:hTimer[66];
public Plugin:myinfo =
{
	name = "Tank Vision Frustration",
	description = "Gives Tanks frustration if they keep vision long enough",
	author = "Sir",
	version = "1.0",
	url = "https://github.com/SirPlease/ZoneMod/scripting/scrapped_or_beta_ideas"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public __pl_l4d2lib_SetNTVOptional()
{
	MarkNativeAsOptional("L4D2_GetCurrentRound");
	MarkNativeAsOptional("L4D2_CurrentlyInRound");
	MarkNativeAsOptional("L4D2_GetSurvivorCount");
	MarkNativeAsOptional("L4D2_GetSurvivorOfIndex");
	MarkNativeAsOptional("L4D2_IsMapDataAvailable");
	MarkNativeAsOptional("L4D2_IsEntityInSaferoom");
	MarkNativeAsOptional("L4D2_GetMapStartOrigin");
	MarkNativeAsOptional("L4D2_GetMapEndOrigin");
	MarkNativeAsOptional("L4D2_GetMapStartDistance");
	MarkNativeAsOptional("L4D2_GetMapStartExtraDistance");
	MarkNativeAsOptional("L4D2_GetMapEndDistance");
	MarkNativeAsOptional("L4D2_GetMapValueInt");
	MarkNativeAsOptional("L4D2_GetMapValueFloat");
	MarkNativeAsOptional("L4D2_GetMapValueVector");
	MarkNativeAsOptional("L4D2_GetMapValueString");
	MarkNativeAsOptional("L4D2_CopyMapSubsection");
	return 0;
}

GetTankFrustration(iTankClient)
{
	return 100 - GetEntProp(iTankClient, PropType:0, L4D2_InfectedTimerEntities, 4, 0);
}

SetTankFrustration(iTankClient, iFrustration)
{
	new var1;
	if (iFrustration < 0 || iFrustration > 100)
	{
		return 0;
	}
	SetEntProp(iTankClient, PropType:0, "m_frustration", 100 - iFrustration, 4, 0);
	return 0;
}

public __pl_l4d2util_SetNTVOptional()
{
	return 0;
}

public OnPluginStart()
{
	hCvarVisionSeconds = CreateConVar("tank_vision_seconds", "6.0", "How long to keep Vision before you gain Frustration, (z_frustration_los_delay has a big impact on this)", 0, false, 0.0, false, 0.0);
	hCvarFrustrationGain = CreateConVar("tank_vision_frustration_gain", "4", "Frustration Gain, between 1-100, Steps should be in: (100 / z_frustration_lifetime)", 0, false, 0.0, false, 0.0);
	fVisionSeconds = GetConVarFloat(hCvarVisionSeconds);
	iFrustrationGain = GetConVarInt(hCvarFrustrationGain);
	HookConVarChange(hCvarVisionSeconds, cvarChanged);
	HookConVarChange(hCvarFrustrationGain, cvarChanged);
	HookEvent("round_start", RoundStartEvent, EventHookMode:2);
	return 0;
}

public OnClientPutInServer(client)
{
	iStoredFrustration[client] = 0;
	fSecondsVisionHeld[client] = 0;
	return 0;
}

public OnClientDisconnect_Post(client)
{
	new var1;
	if (IsValidClient(client) && hTimer[client])
	{
		KillTimer(hTimer[client], false);
		hTimer[client] = 0;
	}
	iStoredFrustration[client] = 0;
	fSecondsVisionHeld[client] = 0;
	return 0;
}

public RoundStartEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsValidClient(client))
		{
			if (hTimer[client])
			{
				KillTimer(hTimer[client], false);
				hTimer[client] = 0;
			}
			iStoredFrustration[client] = 0;
			fSecondsVisionHeld[client] = 0;
		}
		client++;
	}
	return 0;
}

public cvarChanged(Handle:cvar, String:oldValue[], String:newValue[])
{
	fVisionSeconds = GetConVarFloat(hCvarVisionSeconds);
	iFrustrationGain = GetConVarInt(hCvarFrustrationGain);
	return 0;
}

public L4D2_OnTankPassControl(oldTank, newTank, passCount)
{
	if (IsValidClient(oldTank))
	{
		if (hTimer[oldTank])
		{
			KillTimer(hTimer[oldTank], false);
			hTimer[oldTank] = 0;
		}
		iStoredFrustration[oldTank] = 0;
		fSecondsVisionHeld[oldTank] = 0;
	}
	if (IsValidClient(newTank))
	{
		if (hTimer[newTank])
		{
			KillTimer(hTimer[newTank], false);
			hTimer[newTank] = 0;
		}
		iStoredFrustration[newTank] = GetTankFrustration(newTank);
		fSecondsVisionHeld[newTank] = 0;
		hTimer[newTank] = CreateTimer(0.1, VisionTimer, newTank, 1);
	}
	return 0;
}

public OnTankSpawn(iTank)
{
	if (IsValidClient(iTank))
	{
		if (hTimer[iTank])
		{
			KillTimer(hTimer[iTank], false);
			hTimer[iTank] = 0;
		}
		iStoredFrustration[iTank] = 0;
		fSecondsVisionHeld[iTank] = 0;
		hTimer[iTank] = CreateTimer(0.1, VisionTimer, iTank, 1);
	}
	return 0;
}

public OnTankDeath(iOldTank)
{
	if (IsValidClient(iOldTank))
	{
		if (hTimer[iOldTank])
		{
			KillTimer(hTimer[iOldTank], false);
			hTimer[iOldTank] = 0;
		}
		iStoredFrustration[iOldTank] = 0;
		fSecondsVisionHeld[iOldTank] = 0;
	}
	return 0;
}

public Action:VisionTimer(Handle:timer, any:client)
{
	if (!IsValidClient(client))
	{
		return Action:4;
	}
	new iFrust = GetTankFrustration(client);
	new var1;
	if (iFrust == 100 || iFrust)
	{
		return Action:0;
	}
	if (iStoredFrustration[client] == iFrust)
	{
		new var3 = fSecondsVisionHeld[client];
		var3 = var3[0.1];
	}
	else
	{
		fSecondsVisionHeld[client] = 0;
	}
	new var2;
	if (iStoredFrustration[client] == iFrust && fSecondsVisionHeld[client] >= fVisionSeconds)
	{
		SetTankFrustration(client, iFrustrationGain + iFrust);
		fSecondsVisionHeld[client] = 0;
	}
	iStoredFrustration[client] = iFrust;
	return Action:0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client) || !IsClientInGame(client) || IsFakeClient(client))
	{
		return false;
	}
	return true;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "12/03/2015",
	time = "22:39:24"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Plugin:myinfo =
{
	name = "L4D2 Tank Melee Fury",
	description = "Aggressive melee Survivors are almost certain to get punished for excessively pushing the Tank",
	author = "Visor",
	version = "1.0",
	url = "https://github.com/Attano/L4D2-Competitive-Framework"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	HookEvent("player_hurt", OnPlayerHurt, EventHookMode:1);
	return 0;
}

public Action:OnPlayerHurt(Handle:event, String:event_name[], bool:dontBroadcast)
{
	new tank = GetClientOfUserId(GetEventInt(event, "userid"));
	new survivor = GetClientOfUserId(GetEventInt(event, "attacker"));
	new var1;
	if (!IsSurvivor(survivor) || !IsTank(tank))
	{
		return Action:0;
	}
	decl String:weaponName[64];
	GetEventString(event, "weapon", weaponName, 64);
	if (!IsMelee(weaponName))
	{
		return Action:0;
	}
	new tankClaw = GetActiveWeapon(tank);
	new Float:swingTime = GetConVarFloat(FindConVar("tank_swing_interval")) + GetConVarFloat(FindConVar("tank_windup_time"));
	SetEntPropFloat(tankClaw, PropType:0, "m_flNextPrimaryAttack", GetEntPropFloat(tankClaw, PropType:0, "m_flNextPrimaryAttack", 0) - swingTime, 0);
	SetEntPropFloat(tankClaw, PropType:0, "m_flNextSecondaryAttack", GetEntPropFloat(tankClaw, PropType:0, "m_flNextSecondaryAttack", 0) - swingTime, 0);
	return Action:0;
}

GetActiveWeapon(client)
{
	return GetEntPropEnt(client, PropType:0, "m_hActiveWeapon", 0);
}

bool:IsMelee(String:weaponName[])
{
	new var1;
	return StrEqual(weaponName, "weapon_melee", false) || StrEqual(weaponName, "melee", false);
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsTank(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8 && IsPlayerAlive(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "06/23/2018",
	time = "18:05:31"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new String:CTag[6][] =
{
	"",
	"",
	"",
	"",
	"",
	""
};
new String:CTagCode[6][16];
new bool:CTagReqSayText2[6];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public SharedPlugin:__pl_l4d2lib =
{
	name = "l4d2lib",
	file = "l4d2lib.smx",
	required = 1,
};
new OUR_COLOR[3];
new bool:bVision[66];
new bool:bTankAlive;
new Handle:g_ArrayHittableClones;
new Handle:g_ArrayHittables;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

GetEntSendPropOffs(ent, String:prop[], bool:actual)
{
	decl String:cls[64];
	if (!GetEntityNetClass(ent, cls, 64))
	{
		return -1;
	}
	if (actual)
	{
		return FindSendPropInfo(cls, prop, 0, 0, 0);
	}
	return FindSendPropOffs(cls, prop);
}

SetEntityRenderMode(entity, RenderMode:mode)
{
	static bool:gotconfig;
	static String:prop[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_nRenderMode", prop, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(prop, 32, "m_nRenderMode");
		}
		gotconfig = true;
	}
	SetEntProp(entity, PropType:0, prop, mode, 1, 0);
	return 0;
}

SetEntityRenderColor(entity, r, g, b, a)
{
	static bool:gotconfig;
	static String:prop[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_clrRender", prop, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(prop, 32, "m_clrRender");
		}
		gotconfig = true;
	}
	new offset = GetEntSendPropOffs(entity, prop, false);
	if (0 >= offset)
	{
		ThrowError("SetEntityRenderColor not supported by this mod");
	}
	SetEntData(entity, offset, r, 1, true);
	SetEntData(entity, offset + 1, g, 1, true);
	SetEntData(entity, offset + 2, b, 1, true);
	SetEntData(entity, offset + 3, a, 1, true);
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CEventIsHooked[i] = false;
		i++;
	}
	return Action:0;
}

public __pl_l4d2lib_SetNTVOptional()
{
	MarkNativeAsOptional("L4D2_GetCurrentRound");
	MarkNativeAsOptional("L4D2_CurrentlyInRound");
	MarkNativeAsOptional("L4D2_GetSurvivorCount");
	MarkNativeAsOptional("L4D2_GetSurvivorOfIndex");
	MarkNativeAsOptional("L4D2_IsMapDataAvailable");
	MarkNativeAsOptional("L4D2_IsEntityInSaferoom");
	MarkNativeAsOptional("L4D2_GetMapStartOrigin");
	MarkNativeAsOptional("L4D2_GetMapEndOrigin");
	MarkNativeAsOptional("L4D2_GetMapStartDistance");
	MarkNativeAsOptional("L4D2_GetMapStartExtraDistance");
	MarkNativeAsOptional("L4D2_GetMapEndDistance");
	MarkNativeAsOptional("L4D2_GetMapValueInt");
	MarkNativeAsOptional("L4D2_GetMapValueFloat");
	MarkNativeAsOptional("L4D2_GetMapValueVector");
	MarkNativeAsOptional("L4D2_GetMapValueString");
	MarkNativeAsOptional("L4D2_CopyMapSubsection");
	return 0;
}

public void:OnPluginStart()
{
	OUR_COLOR[0] = 255;
	OUR_COLOR[1] = 255;
	OUR_COLOR[2] = 255;
	g_ArrayHittableClones = CreateArray(32, 0);
	g_ArrayHittables = CreateArray(32, 0);
	HookEvent("tank_spawn", TankSpawnEvent, EventHookMode:1);
	HookEvent("player_team", ClearVisionEvent, EventHookMode:1);
	HookEvent("tank_killed", ClearArrayEvent, EventHookMode:1);
	HookEvent("round_start", ClearArrayEvent, EventHookMode:1);
	HookEvent("round_end", ClearArrayEvent, EventHookMode:1);
	return void:0;
}

public void:OnPluginEnd()
{
	KillClones(true);
	return void:0;
}

public ClearArrayEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	KillClones(true);
	return 0;
}

public ClearVisionEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	new var1;
	if (client && IsClientInGame(client) && bVision[client])
	{
		bVision[client] = 0;
	}
	return 0;
}

public L4D2_OnTankPassControl(oldTank, newTank, passCount)
{
	KillClones(false);
	bVision[newTank] = 1;
	if (bTankAlive)
	{
		RecreateHittableClones();
	}
	return 0;
}

public TankSpawnEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	new tank = GetClientOfUserId(GetEventInt(event, "userid", 0));
	if (IsFakeClient(tank))
	{
		KillClones(true);
		return 0;
	}
	if (!bTankAlive)
	{
		HookProps();
		bTankAlive = true;
	}
	return 0;
}

public CreateClone(any:entity)
{
	decl Float:vOrigin[3];
	decl Float:vAngles[3];
	GetEntPropVector(entity, PropType:0, "m_vecOrigin", vOrigin, 0);
	GetEntPropVector(entity, PropType:1, "m_angRotation", vAngles, 0);
	decl String:entityModel[64];
	GetEntPropString(entity, PropType:1, "m_ModelName", entityModel, 64, 0);
	new clone = CreateEntityByName("prop_dynamic_override", -1);
	SetEntityModel(clone, entityModel);
	DispatchSpawn(clone);
	TeleportEntity(clone, vOrigin, vAngles, NULL_VECTOR);
	SetEntProp(clone, PropType:0, "m_CollisionGroup", any:0, 4, 0);
	SetEntProp(clone, PropType:0, "m_nSolidType", any:0, 4, 0);
	SetVariantString("!activator");
	AcceptEntityInput(clone, "SetParent", entity, -1, 0);
	return clone;
}

public TankHittablePunched(String:output[], caller, activator, Float:delay)
{
	new iEntity = caller;
	new clone = CreateClone(iEntity);
	if (0 < clone)
	{
		PushArrayCell(g_ArrayHittableClones, clone);
		PushArrayCell(g_ArrayHittables, iEntity);
		MakeEntityVisible(clone, false);
		SDKHook(clone, SDKHookType:6, CloneTransmit);
		L4D2_SetEntGlow(clone, L4D2GlowType:3, 3250, 250, OUR_COLOR, false);
	}
	return 0;
}

public RecreateHittableClones()
{
	new ArraySize = GetArraySize(g_ArrayHittables);
	if (0 < ArraySize)
	{
		new i;
		while (i < ArraySize)
		{
			new storedEntity = GetArrayCell(g_ArrayHittables, i, 0, false);
			if (IsValidEntity(storedEntity))
			{
				new clone = CreateClone(storedEntity);
				if (0 < clone)
				{
					PushArrayCell(g_ArrayHittableClones, clone);
					MakeEntityVisible(clone, false);
					SDKHook(clone, SDKHookType:6, CloneTransmit);
					L4D2_SetEntGlow(clone, L4D2GlowType:3, 3250, 250, OUR_COLOR, false);
				}
			}
			i++;
		}
	}
	return 0;
}

public Action:CloneTransmit(entity, client)
{
	if (bVision[client])
	{
		return Action:0;
	}
	return Action:3;
}

KillClones(bool:both)
{
	new ArraySize = GetArraySize(g_ArrayHittableClones);
	new i;
	while (i < ArraySize)
	{
		new storedEntity = GetArrayCell(g_ArrayHittableClones, i, 0, false);
		if (IsValidEntity(storedEntity))
		{
			SDKUnhook(storedEntity, SDKHookType:6, CloneTransmit);
			AcceptEntityInput(storedEntity, "Kill", -1, -1, 0);
		}
		i++;
	}
	ClearArray(g_ArrayHittableClones);
	if (both)
	{
		ClearArray(g_ArrayHittables);
		bTankAlive = false;
	}
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && bVision[i])
		{
			bVision[i] = 0;
		}
		i++;
	}
	return 0;
}

MakeEntityVisible(ent, bool:visible)
{
	if (visible)
	{
		SetEntityRenderMode(ent, RenderMode:0);
		SetEntityRenderColor(ent, 255, 255, 255, 255);
	}
	else
	{
		SetEntityRenderMode(ent, RenderMode:1);
		SetEntityRenderColor(ent, 0, 0, 0, 0);
	}
	return 0;
}

HookProps()
{
	new iEntity = -1;
	while ((iEntity = FindEntityByClassname(iEntity, "prop_physics")) != -1)
	{
		if (IsTankHittable(iEntity))
		{
			HookSingleEntityOutput(iEntity, "OnHitByTank", TankHittablePunched, true);
		}
	}
	iEntity = -1;
	while ((iEntity = FindEntityByClassname(iEntity, "prop_car_alarm")) != -1)
	{
		HookSingleEntityOutput(iEntity, "OnHitByTank", TankHittablePunched, true);
	}
	return 0;
}

bool:IsTankHittable(iEntity)
{
	if (!IsValidEntity(iEntity))
	{
		return false;
	}
	decl String:className[64];
	GetEdictClassname(iEntity, className, 64);
	if (StrEqual(className, "prop_physics", true))
	{
		if (GetEntProp(iEntity, PropType:0, "m_hasTankGlow", 1, 0))
		{
			return true;
		}
	}
	else
	{
		if (StrEqual(className, "prop_car_alarm", true))
		{
			return true;
		}
	}
	return false;
}

L4D2_SetEntGlow_Type(entity, L4D2GlowType:type)
{
	SetEntProp(entity, PropType:0, "m_iGlowType", type, 4, 0);
	return 0;
}

L4D2_SetEntGlow_Range(entity, range)
{
	SetEntProp(entity, PropType:0, "m_nGlowRange", range, 4, 0);
	return 0;
}

L4D2_SetEntGlow_MinRange(entity, minRange)
{
	SetEntProp(entity, PropType:0, "m_nGlowRangeMin", minRange, 4, 0);
	return 0;
}

L4D2_SetEntGlow_ColorOverride(entity, colorOverride[3])
{
	SetEntProp(entity, PropType:0, "m_glowColorOverride", colorOverride[2] * 65536 + colorOverride[1] * 256 + colorOverride[0], 4, 0);
	return 0;
}

L4D2_SetEntGlow_Flashing(entity, bool:flashing)
{
	SetEntProp(entity, PropType:0, "m_bFlashing", flashing, 4, 0);
	return 0;
}

bool:L4D2_SetEntGlow(entity, L4D2GlowType:type, range, minRange, colorOverride[3], bool:flashing)
{
	decl String:netclass[128];
	GetEntityNetClass(entity, netclass, 128);
	new offset = FindSendPropInfo(netclass, "m_iGlowType", 0, 0, 0);
	if (offset < 1)
	{
		return false;
	}
	L4D2_SetEntGlow_Type(entity, type);
	L4D2_SetEntGlow_Range(entity, range);
	L4D2_SetEntGlow_MinRange(entity, minRange);
	L4D2_SetEntGlow_ColorOverride(entity, colorOverride);
	L4D2_SetEntGlow_Flashing(entity, flashing);
	return true;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.2",
	date = "05/19/2012",
	time = "16:26:36"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "sdkhooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new Handle:hPluginEnabled;
new Handle:hBlockFlags;
public Plugin:myinfo =
{
	name = "Uncommon Infected Blocker",
	description = "Blocks uncommon infected from ruining your day.",
	author = "Tabun",
	version = "0.1b",
	url = "nope"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	hPluginEnabled = CreateConVar("sm_uncinfblock_enabled", "1", "Enable the fix for the jockey-damage glitch.", 262144, true, 0.0, true, 1.0);
	hBlockFlags = CreateConVar("sm_uncinfblock_types", "31", "Which uncommon infected to block (1:ceda, 2:clowns, 4:mudmen, 8:riot cops, 16:roadcrew).", 262144, true, 0.0, false, 0.0);
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	if (!GetConVarBool(hPluginEnabled))
	{
		return 0;
	}
	new var1;
	if (entity > 0 && IsValidEntity(entity) && IsValidEdict(entity))
	{
		if (StrEqual(classname, "infected", false))
		{
			SDKHook(entity, SDKHookType:24, OnEntitySpawned);
		}
	}
	return 0;
}

public OnEntitySpawned(entity)
{
	if (isUncommon(entity))
	{
		new Float:location[3] = 0.0;
		GetEntPropVector(entity, PropType:0, "m_vecOrigin", location, 0);
		AcceptEntityInput(entity, "Kill", -1, -1, 0);
		SpawnCommon(location);
	}
	return 0;
}

bool:isUncommon(entity)
{
	new var1;
	if (entity <= 0 || entity > 2048 || !IsValidEdict(entity))
	{
		return false;
	}
	decl String:model[128];
	GetEntPropString(entity, PropType:1, "m_ModelName", model, 128, 0);
	new bBlockFlags = GetConVarInt(hBlockFlags);
	new var2;
	if (StrContains(model, "_ceda", true) != -1 && bBlockFlags & 1)
	{
		return true;
	}
	new var3;
	if (StrContains(model, "_clown", true) != -1 && bBlockFlags & 2)
	{
		return true;
	}
	new var4;
	if (StrContains(model, "_mud", true) != -1 && bBlockFlags & 4)
	{
		return true;
	}
	new var5;
	if (StrContains(model, "_riot", true) != -1 && bBlockFlags & 8)
	{
		return true;
	}
	new var6;
	if (StrContains(model, "_roadcrew", true) != -1 && bBlockFlags & 16)
	{
		return true;
	}
	return false;
}

public SpawnCommon(Float:location[3])
{
	new zombie = CreateEntityByName("infected", -1);
	new ticktime = RoundToNearest(GetGameTime() / GetTickInterval()) + 5;
	SetEntProp(zombie, PropType:1, "m_nNextThinkTick", ticktime, 4, 0);
	DispatchSpawn(zombie);
	ActivateEntity(zombie);
	TeleportEntity(zombie, location, NULL_VECTOR, NULL_VECTOR);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/19/2016",
	time = "13:12:51"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCvarDamagePerTick;
new Handle:hCvarMaxTicks;
new Handle:hCvarGodframeTicks;
new Handle:hPuddles;
new Float:damagePerTick;
new maxTicks;
new godframeTicks;
new bool:bLateLoad;
public Plugin:myinfo =
{
	name = "L4D2 Uniform Spit",
	description = "Make the spit deal static amounts of DPS under all circumstances",
	author = "Visor",
	version = "1.2",
	url = "https://github.com/Attano/smplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator-(Float:,_:)(Float:oper1, oper2)
{
	return oper1 - float(oper2);
}

bool:operator>(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) > oper2;
}

bool:operator>=(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) >= oper2;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

bool:ITimer_HasStarted(IntervalTimer:timer)
{
	return ITimer_GetTimestamp(timer) > 0.0;
}

Float:ITimer_GetElapsedTime(IntervalTimer:timer)
{
	new var1;
	if (ITimer_HasStarted(timer))
	{
		var1 = GetGameTime() - ITimer_GetTimestamp(timer);
	}
	else
	{
		var1 = 99999.9;
	}
	return var1;
}

Float:ITimer_GetTimestamp(IntervalTimer:timer)
{
	return LoadFromAddress(timer + 4, NumberType:2);
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	hCvarDamagePerTick = CreateConVar("l4d2_spit_dmg", "-1.0", "Damage per tick the spit inflicts. -1 to skip damage adjustments", 0, false, 0.0, false, 0.0);
	hCvarMaxTicks = CreateConVar("l4d2_spit_max_ticks", "28", "Maximum number of acid damage ticks", 0, false, 0.0, false, 0.0);
	hCvarGodframeTicks = CreateConVar("l4d2_spit_godframe_ticks", "4", "Number of initial godframed acid ticks", 0, false, 0.0, false, 0.0);
	hPuddles = CreateTrie();
	if (bLateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				OnClientPutInServer(i);
			}
			i++;
		}
	}
	return 0;
}

public OnConfigsExecuted()
{
	damagePerTick = GetConVarFloat(hCvarDamagePerTick);
	maxTicks = GetConVarInt(hCvarMaxTicks);
	godframeTicks = GetConVarInt(hCvarGodframeTicks);
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	if (StrEqual(classname, "insect_swarm", true))
	{
		decl String:trieKey[8];
		IndexToKey(entity, trieKey, 8);
		new count[MaxClients];
		SetTrieArray(hPuddles, trieKey, count, MaxClients, true);
	}
	return 0;
}

public OnEntityDestroyed(entity)
{
	decl String:trieKey[8];
	IndexToKey(entity, trieKey, 8);
	decl count[MaxClients];
	if (GetTrieArray(hPuddles, trieKey, count, MaxClients, 0))
	{
		RemoveFromTrie(hPuddles, trieKey);
	}
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (victim <= 0 || victim > MaxClients || GetClientTeam(victim) == 2 || !IsValidEdict(inflictor))
	{
		return Action:0;
	}
	decl String:classname[64];
	GetEdictClassname(inflictor, classname, 64);
	if (StrEqual(classname, "insect_swarm", true))
	{
		decl String:trieKey[8];
		IndexToKey(inflictor, trieKey, 8);
		decl count[MaxClients];
		if (GetTrieArray(hPuddles, trieKey, count, MaxClients, 0))
		{
			count[victim]++;
			new var2;
			if (GetPuddleLifetime(inflictor) >= 1045225389 * godframeTicks && count[victim] < godframeTicks)
			{
				count[victim] = godframeTicks + 1;
			}
			SetTrieArray(hPuddles, trieKey, count, MaxClients, true);
			if (damagePerTick > -1.0)
			{
				damage = damagePerTick;
			}
			new var3;
			if (godframeTicks >= count[victim] || count[victim] > maxTicks)
			{
				damage = 0;
			}
			if (count[victim] > maxTicks)
			{
				AcceptEntityInput(inflictor, "Kill", -1, -1, 0);
			}
			return Action:1;
		}
	}
	return Action:0;
}

Float:GetPuddleLifetime(puddle)
{
	return ITimer_GetElapsedTime(GetEntityAddress(puddle) + 2968);
}

IndexToKey(index, String:str[], maxlength)
{
	Format(str, maxlength, "%x", index);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "01/07/2018",
	time = "06:34:44"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new Handle:hCvarDamagePerTick;
new Handle:hCvarAlternateDamagePerTwoTicks;
new Handle:hCvarMaxTicks;
new Handle:hCvarGodframeTicks;
new Handle:hPuddles;
new bool:bAltTick[66];
new Float:damagePerTick;
new Float:alternatePerTick;
new maxTicks;
new godframeTicks;
new bool:bLateLoad;
public Plugin:myinfo =
{
	name = "L4D2 Uniform Spit",
	description = "Make the spit deal static amounts of DPS under all circumstances",
	author = "Visor, Sir",
	version = "1.3",
	url = "https://github.com/Attano/smplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator-(Float:,_:)(Float:oper1, oper2)
{
	return oper1 - float(oper2);
}

bool:operator>(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) > oper2;
}

bool:operator>=(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) >= oper2;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

bool:ITimer_HasStarted(IntervalTimer:timer)
{
	return ITimer_GetTimestamp(timer) > 0.0;
}

Float:ITimer_GetElapsedTime(IntervalTimer:timer)
{
	new var1;
	if (ITimer_HasStarted(timer))
	{
		var1 = GetGameTime() - ITimer_GetTimestamp(timer);
	}
	else
	{
		var1 = 99999.9;
	}
	return var1;
}

Float:ITimer_GetTimestamp(IntervalTimer:timer)
{
	return LoadFromAddress(timer + 4, NumberType:2);
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	hCvarDamagePerTick = CreateConVar("l4d2_spit_dmg", "-1.0", "Damage per tick the spit inflicts. -1 to skip damage adjustments", 0, false, 0.0, false, 0.0);
	hCvarAlternateDamagePerTwoTicks = CreateConVar("l4d2_spit_alternate_dmg", "-1.0", "Damage per alternate tick. -1 to disable", 0, false, 0.0, false, 0.0);
	hCvarMaxTicks = CreateConVar("l4d2_spit_max_ticks", "28", "Maximum number of acid damage ticks", 0, false, 0.0, false, 0.0);
	hCvarGodframeTicks = CreateConVar("l4d2_spit_godframe_ticks", "4", "Number of initial godframed acid ticks", 0, false, 0.0, false, 0.0);
	hPuddles = CreateTrie();
	if (bLateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				OnClientPutInServer(i);
			}
			i++;
		}
	}
	return 0;
}

public OnConfigsExecuted()
{
	damagePerTick = GetConVarFloat(hCvarDamagePerTick);
	alternatePerTick = GetConVarFloat(hCvarAlternateDamagePerTwoTicks);
	maxTicks = GetConVarInt(hCvarMaxTicks);
	godframeTicks = GetConVarInt(hCvarGodframeTicks);
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	if (StrEqual(classname, "insect_swarm", true))
	{
		decl String:trieKey[8];
		IndexToKey(entity, trieKey, 8);
		new count[MaxClients];
		SetTrieArray(hPuddles, trieKey, count, MaxClients, true);
	}
	return 0;
}

public OnEntityDestroyed(entity)
{
	decl String:trieKey[8];
	IndexToKey(entity, trieKey, 8);
	decl count[MaxClients];
	if (GetTrieArray(hPuddles, trieKey, count, MaxClients, 0))
	{
		RemoveFromTrie(hPuddles, trieKey);
	}
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (victim <= 0 || victim > MaxClients || GetClientTeam(victim) == 2 || !IsValidEdict(inflictor))
	{
		return Action:0;
	}
	decl String:classname[64];
	GetEdictClassname(inflictor, classname, 64);
	if (StrEqual(classname, "insect_swarm", true))
	{
		decl String:trieKey[8];
		IndexToKey(inflictor, trieKey, 8);
		decl count[MaxClients];
		if (GetTrieArray(hPuddles, trieKey, count, MaxClients, 0))
		{
			count[victim]++;
			new var2;
			if (GetPuddleLifetime(inflictor) >= 1045225389 * godframeTicks && count[victim] < godframeTicks)
			{
				count[victim] = godframeTicks + 1;
			}
			SetTrieArray(hPuddles, trieKey, count, MaxClients, true);
			if (damagePerTick > -1.0)
			{
				new var3;
				if (alternatePerTick > -1.0 && bAltTick[victim])
				{
					bAltTick[victim] = 0;
					damage = alternatePerTick;
				}
				damage = damagePerTick;
				bAltTick[victim] = 1;
			}
			new var4;
			if (godframeTicks >= count[victim] || count[victim] > maxTicks)
			{
				damage = 0;
			}
			if (count[victim] > maxTicks)
			{
				AcceptEntityInput(inflictor, "Kill", -1, -1, 0);
			}
			return Action:1;
		}
	}
	return Action:0;
}

Float:GetPuddleLifetime(puddle)
{
	return ITimer_GetElapsedTime(GetEntityAddress(puddle) + 2968);
}

IndexToKey(index, String:str[], maxlength)
{
	Format(str, maxlength, "%x", index);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.3",
	date = "11/19/2012",
	time = "12:00:39"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new Handle:hPluginEnabled;
new Handle:hJockeySoundAlways;
new Handle:hJockeySoundTime;
new Float:fJockeyLaughingStop[66];
new Handle:hJockeyLaughingTimer[66];
new String:sJockeySound[18][] =
{
	"player/jockey/voice/idle/jockey_recognize02.wav",
	"player/jockey/voice/idle/jockey_recognize06.wav",
	"player/jockey/voice/idle/jockey_recognize07.wav",
	"player/jockey/voice/idle/jockey_recognize08.wav",
	"player/jockey/voice/idle/jockey_recognize09.wav",
	"player/jockey/voice/idle/jockey_recognize10.wav",
	"player/jockey/voice/idle/jockey_recognize11.wav",
	"player/jockey/voice/idle/jockey_recognize12.wav",
	"player/jockey/voice/idle/jockey_recognize13.wav",
	"player/jockey/voice/idle/jockey_recognize15.wav",
	"player/jockey/voice/idle/jockey_recognize16.wav",
	"player/jockey/voice/idle/jockey_recognize17.wav",
	"player/jockey/voice/idle/jockey_recognize18.wav",
	"player/jockey/voice/idle/jockey_recognize19.wav",
	"player/jockey/voice/idle/jockey_recognize20.wav",
	"player/jockey/voice/idle/jockey_recognize24.wav",
	"player/jockey/voice/idle/jockey_lurk04.wav",
	"player/jockey/voice/idle/jockey_lurk05.wav"
};
public Plugin:myinfo =
{
	name = "Unsilent Jockey",
	description = "Makes jockeys emit sound when just spawned up.",
	author = "Tabun",
	version = "0.1b",
	url = "nope"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:operator>=(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) >= 0;
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

public OnPluginStart()
{
	hPluginEnabled = CreateConVar("sm_unsilentjockey_enabled", "1", "Enable unsilent jockey mode.", 262144, true, 0.0, true, 1.0);
	hJockeySoundAlways = CreateConVar("sm_unsilentjockey_always", "0", "Whether to play jockey spawn sound even if it is not detected as silent.", 262144, true, 0.0, true, 1.0);
	hJockeySoundTime = CreateConVar("sm_unsilentjockey_time", "0.1", "How soon to play sound after spawning (in seconds).", 262144, true, 0.0, true, 10.0);
	AddNormalSoundHook(HookSound_Callback);
	HookEvent("player_spawn", PlayerSpawn_Event, EventHookMode:1);
	return 0;
}

public OnMapStart()
{
	new i;
	while (i <= 17)
	{
		PrefetchSound(sJockeySound[i]);
		PrecacheSound(sJockeySound[i], true);
		i++;
	}
	return 0;
}

public Action:PlayerSpawn_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!GetConVarBool(hPluginEnabled))
	{
		return Action:0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (!IsClientAndInGame(client))
	{
		return Action:0;
	}
	if (GetClientTeam(client) != 3)
	{
		return Action:0;
	}
	if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) != 5)
	{
		return Action:0;
	}
	CreateTimer(GetConVarFloat(hJockeySoundTime), delayedJockeySound, client, 0);
	return Action:0;
}

public Action:delayedJockeySound(Handle:timer, any:client)
{
	new bForced = GetConVarBool(hJockeySoundAlways);
	new var1;
	if (hJockeyLaughingTimer[client] && !bForced)
	{
		PrintToServer("[uj] Jockey [%d] was not silent.", client);
		return Action:0;
	}
	new var2;
	if (bForced)
	{
		var2[0] = 2160;
	}
	else
	{
		var2[0] = 2172;
	}
	PrintToServer("[uj] Jockey [%d] unsilenced.%s", client, var2);
	new rndPick = GetRandomInt(0, 17);
	EmitSoundToAll(sJockeySound[rndPick], client, 2, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
	return Action:0;
}

public Action:HookSound_Callback(Clients[64], &NumClients, String:StrSample[256], &Entity)
{
	if (StrContains(StrSample, "/jockey/voice/", false) == -1)
	{
		return Action:0;
	}
	if (!IsClientAndInGame(Entity))
	{
		return Action:0;
	}
	fJockeyLaughingStop[Entity] = GetTickedTime() + 2.0;
	if (!hJockeyLaughingTimer[Entity])
	{
		hJockeyLaughingTimer[Entity] = CreateTimer(3.0, Timer_IsJockeyLaughing, Entity, 1);
	}
	return Action:0;
}

public Action:Timer_IsJockeyLaughing(Handle:hTimer, any:Client)
{
	if (fJockeyLaughingStop[Client] >= GetTickedTime())
	{
		if (IsClientAndInGame(Client))
		{
			if (IsPlayerAlive(Client))
			{
				return Action:0;
			}
		}
	}
	hJockeyLaughingTimer[Client] = 0;
	return Action:4;
}

bool:IsClientAndInGame(index)
{
	new var1;
	return index > 0 && index <= MaxClients && IsClientInGame(index);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.3.8",
	date = "12/11/2011",
	time = "13:59:05"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:WeaponNames[56][] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced",
	"weapon_shotgun_chrome",
	"weapon_rifle_desert",
	"weapon_sniper_military",
	"weapon_shotgun_spas",
	"weapon_first_aid_kit",
	"weapon_molotov",
	"weapon_pipe_bomb",
	"weapon_pain_pills",
	"weapon_gascan",
	"weapon_propanetank",
	"weapon_oxygentank",
	"weapon_melee",
	"weapon_chainsaw",
	"weapon_grenade_launcher",
	"weapon_ammo_pack",
	"weapon_adrenaline",
	"weapon_defibrillator",
	"weapon_vomitjar",
	"weapon_rifle_ak47",
	"weapon_gnome",
	"weapon_cola_bottles",
	"weapon_fireworkcrate",
	"weapon_upgradepack_incendiary",
	"weapon_upgradepack_explosive",
	"weapon_pistol_magnum",
	"weapon_smg_mp5",
	"weapon_rifle_sg552",
	"weapon_sniper_awp",
	"weapon_sniper_scout",
	"weapon_rifle_m60",
	"weapon_tank_claw",
	"weapon_hunter_claw",
	"weapon_charger_claw",
	"weapon_boomer_claw",
	"weapon_smoker_claw",
	"weapon_spitter_claw",
	"weapon_jockey_claw",
	"weapon_machinegun",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:WeaponModels[56][] =
{
	"",
	"/w_models/weapons/w_pistol_B.mdl",
	"/w_models/weapons/w_smg_uzi.mdl",
	"/w_models/weapons/w_shotgun.mdl",
	"/w_models/weapons/w_autoshot_m4super.mdl",
	"/w_models/weapons/w_rifle_m16a2.mdl",
	"/w_models/weapons/w_sniper_mini14.mdl",
	"/w_models/weapons/w_smg_a.mdl",
	"/w_models/weapons/w_pumpshotgun_a.mdl",
	"/w_models/weapons/w_desert_rifle.mdl",
	"/w_models/weapons/w_sniper_military.mdl",
	"/w_models/weapons/w_shotgun_spas.mdl",
	"/w_models/weapons/w_eq_medkit.mdl",
	"/w_models/weapons/w_eq_molotov.mdl",
	"/w_models/weapons/w_eq_pipebomb.mdl",
	"/w_models/weapons/w_eq_painpills.mdl",
	"/props_junk/gascan001a.mdl",
	"/props_junk/propanecanister001.mdl",
	"/props_equipment/oxygentank01.mdl",
	"",
	"/weapons/melee/w_chainsaw.mdl",
	"/w_models/weapons/w_grenade_launcher.mdl",
	"",
	"/w_models/weapons/w_eq_adrenaline.mdl",
	"/w_models/weapons/w_eq_defibrillator.mdl",
	"/w_models/weapons/w_eq_bile_flask.mdl",
	"/w_models/weapons/w_rifle_ak47.mdl",
	"/props_junk/gnome.mdl",
	"/w_models/weapons/w_cola.mdl",
	"/props_junk/explosive_box001.mdl",
	"/w_models/weapons/w_eq_incendiary_ammopack.mdl",
	"/w_models/weapons/w_eq_explosive_ammopack.mdl",
	"/w_models/weapons/w_desert_eagle.mdl",
	"/w_models/weapons/w_smg_mp5.mdl",
	"/w_models/weapons/w_rifle_sg552.mdl",
	"/w_models/weapons/w_sniper_awp.mdl",
	"/w_models/weapons/w_sniper_scout.mdl",
	"/w_models/weapons/w_m60.mdl",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	""
};
new Handle:hWeaponNamesTrie;
new g_GlobalWeaponRules[56] =
{
	-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
new g_bRoundStartHit;
new g_bConfigsExecuted;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

SetEntityMoveType(entity, MoveType:mt)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_MoveType", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_MoveType");
		}
		gotconfig = true;
	}
	SetEntProp(entity, PropType:1, datamap, mt, 4);
	return 0;
}

bool:IsValidWeaponId(WeaponId:wepid)
{
	new var1;
	return wepid >= WeaponId:0 && wepid < WeaponId:56;
}

bool:HasValidWeaponModel(WeaponId:wepid)
{
	return WeaponModels[wepid][0] != 0;
}

WeaponId:WeaponNameToId(String:weaponName[])
{
	if (!hWeaponNamesTrie)
	{
		InitWeaponNamesTrie();
	}
	new WeaponID:id;
	if (GetTrieValue(hWeaponNamesTrie, weaponName, id))
	{
		return id;
	}
	return WeaponId:0;
}

InitWeaponNamesTrie()
{
	hWeaponNamesTrie = CreateTrie();
	new i;
	while (i < 56)
	{
		SetTrieValue(hWeaponNamesTrie, WeaponNames[i], i, true);
		i++;
	}
	return 0;
}

WeaponId:IdentifyWeapon(entity)
{
	new var1;
	if (!entity || !IsValidEntity(entity) || !IsValidEdict(entity))
	{
		return WeaponId:0;
	}
	decl String:class[64];
	if (!GetEdictClassname(entity, class, 64))
	{
		return WeaponId:0;
	}
	if (StrEqual(class, "weapon_spawn", true))
	{
		return GetEntProp(entity, PropType:0, "m_weaponID", 4);
	}
	new len = strlen(class);
	new var2;
	if (len + -6 > 0 && StrEqual(class[len + -6], "_spawn", true))
	{
		class[len + -6] = MissingTAG:0;
		return WeaponNameToId(class);
	}
	return WeaponId:0;
}

ConvertWeaponSpawn(entity, WeaponId:wepid, count, String:model[])
{
	if (!IsValidEntity(entity))
	{
		return -1;
	}
	if (!IsValidWeaponId(wepid))
	{
		return -1;
	}
	new var1;
	if (model[0] && !HasValidWeaponModel(wepid))
	{
		return -1;
	}
	new Float:origins[3] = 0.0;
	new Float:angles[3] = 0.0;
	GetEntPropVector(entity, PropType:0, "m_vecOrigin", origins);
	GetEntPropVector(entity, PropType:0, "m_angRotation", angles);
	AcceptEntityInput(entity, "kill", -1, -1, 0);
	entity = CreateEntityByName("weapon_spawn", -1);
	if (!IsValidEntity(entity))
	{
		return -1;
	}
	SetEntProp(entity, PropType:0, "m_weaponID", wepid, 4);
	if (model[0])
	{
		SetEntityModel(entity, WeaponModels[wepid]);
	}
	else
	{
		SetEntityModel(entity, model);
	}
	decl String:sCount[64];
	IntToString(count, sCount, 64);
	DispatchKeyValue(entity, "count", sCount);
	TeleportEntity(entity, origins, angles, NULL_VECTOR);
	DispatchSpawn(entity);
	SetEntityMoveType(entity, MoveType:0);
	return entity;
}

public OnPluginStart()
{
	RegServerCmd("l4d2_addweaponrule", AddWeaponRuleCb, "", 0);
	RegServerCmd("l4d2_resetweaponrules", ResetWeaponRulesCb, "", 0);
	HookEvent("round_start", RoundStartCb, EventHookMode:2);
	ResetWeaponRules();
	return 0;
}

public Action:ResetWeaponRulesCb(args)
{
	ResetWeaponRules();
	return Action:3;
}

ResetWeaponRules()
{
	new i;
	while (i < 56)
	{
		g_GlobalWeaponRules[i] = -1;
		i++;
	}
	return 0;
}

public RoundStartCb(Handle:event, String:name[], bool:dontBroadcast)
{
	CreateTimer(0.3, RoundStartDelay, any:0, 2);
	return 0;
}

public OnMapStart()
{
	g_bRoundStartHit = 0;
	g_bConfigsExecuted = 0;
	return 0;
}

public OnConfigsExecuted()
{
	g_bConfigsExecuted = 1;
	if (g_bRoundStartHit)
	{
		WeaponSearchLoop();
	}
	return 0;
}

public Action:RoundStartDelay(Handle:timer)
{
	g_bRoundStartHit = 1;
	if (g_bConfigsExecuted)
	{
		WeaponSearchLoop();
	}
	return Action:0;
}

public Action:AddWeaponRuleCb(args)
{
	if (args < 2)
	{
		PrintToServer("Usage: l4d2_addweaponrule <match> <replace>");
		return Action:3;
	}
	decl String:weaponbuf[64];
	GetCmdArg(1, weaponbuf, 64);
	new WeaponId:match = WeaponNameToId2(weaponbuf);
	GetCmdArg(2, weaponbuf, 64);
	new WeaponId:to = WeaponNameToId2(weaponbuf);
	AddWeaponRule(match, to);
	return Action:3;
}

AddWeaponRule(WeaponId:match, to)
{
	new var2;
	if (IsValidWeaponId(match) && (to == -1 || IsValidWeaponId(to)))
	{
		g_GlobalWeaponRules[match] = to;
	}
	return 0;
}

WeaponSearchLoop()
{
	new entcnt = GetEntityCount();
	new ent = 1;
	while (ent < entcnt)
	{
		new WeaponId:source = IdentifyWeapon(ent);
		new var1;
		if (source > WeaponId:0 && g_GlobalWeaponRules[source] != -1)
		{
			if (g_GlobalWeaponRules[source])
			{
				ConvertWeaponSpawn(ent, g_GlobalWeaponRules[source], 5, "");
			}
			AcceptEntityInput(ent, "kill", -1, -1, 0);
		}
		ent++;
	}
	return 0;
}

WeaponId:WeaponNameToId2(String:name[])
{
	static String:namebuf[64] = "weapon_";
	new WeaponId:wepid = WeaponNameToId(name);
	if (!wepid)
	{
		strcopy(3596 + 7, 57, name);
		wepid = WeaponNameToId(namebuf);
	}
	return wepid;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/19/2016",
	time = "04:26:00"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Weapon Attributes",
	description = "Allowing tweaking of the attributes of all weapons",
	author = "Jahze",
	version = "1.2",
	url = ""
};
new iWeaponAttributes[21] =
{
	0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, -1
};
new String:sWeaponAttrNames[21][32] =
{
	"Damage",
	"Bullets",
	"Clip Size",
	"Max player speed",
	"Spread per shot",
	"Max spread",
	"Spread decay",
	"Min ducking spread",
	"Min standing spread",
	"Min in air spread",
	"Max movement spread",
	"Penetration num layers",
	"Penetration power",
	"Penetration max dist",
	"Char penetration max dist",
	"Range",
	"Range modifier",
	"Cycle time",
	"Pellet scatter pitch",
	"Pellet scatter yaw",
	"Tank damage multiplier"
};
new String:sWeaponAttrShortName[21][32] =
{
	"damage",
	"bullets",
	"clipsize",
	"speed",
	"spreadpershot",
	"maxspread",
	"spreaddecay",
	"minduckspread",
	"minstandspread",
	"minairspread",
	"maxmovespread",
	"penlayers",
	"penpower",
	"penmaxdist",
	"charpenmaxdist",
	"range",
	"rangemod",
	"cycletime",
	"scatterpitch",
	"scatteryaw",
	"tankdamagemult"
};
new bool:bLateLoad;
new Handle:hTankDamageKVs;
new Handle:hVanillaAttributesWeapon;
new Handle:hVanillaAttributesAttribute;
new Handle:hVanillaAttributesValue;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

StrCat(String:buffer[], maxlength, String:source[])
{
	new len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	return Format(buffer[len], maxlength - len, "%s", source);
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	RegServerCmd("sm_weapon", Weapon, "", 0);
	RegConsoleCmd("sm_weapon_attributes", WeaponAttributes, "", 0);
	hVanillaAttributesWeapon = CreateArray(32, 0);
	hVanillaAttributesAttribute = CreateArray(1, 0);
	hVanillaAttributesValue = CreateArray(1, 0);
	hTankDamageKVs = CreateKeyValues("DamageVsTank", "", "");
	if (bLateLoad)
	{
		new i = 1;
		while (MaxClients + 1 > i)
		{
			if (IsClientInGame(i))
			{
				SDKHook(i, SDKHookType:2, DamageBuffVsTank);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, DamageBuffVsTank);
	return 0;
}

public OnPluginEnd()
{
	if (hTankDamageKVs)
	{
		CloseHandle(hTankDamageKVs);
		hTankDamageKVs = MissingTAG:0;
	}
	new iSize = GetArraySize(hVanillaAttributesWeapon);
	new iAtIndex;
	decl String:sBuffer[32];
	new i;
	while (i < iSize)
	{
		GetArrayString(hVanillaAttributesWeapon, i, sBuffer, 32);
		iAtIndex = GetArrayCell(hVanillaAttributesAttribute, i, 0, false);
		if (iAtIndex < 3)
		{
			L4D2_SetIntWeaponAttribute(sBuffer, iWeaponAttributes[iAtIndex], GetArrayCell(hVanillaAttributesValue, i, 0, false));
		}
		else
		{
			if (iAtIndex < 20)
			{
				L4D2_SetFloatWeaponAttribute(sBuffer, iWeaponAttributes[iAtIndex], GetArrayCell(hVanillaAttributesValue, i, 0, false));
			}
		}
		i++;
	}
	return 0;
}

GetWeaponAttributeIndex(String:sAttrName[128])
{
	new i;
	while (i < 21)
	{
		if (StrEqual(sAttrName, sWeaponAttrShortName[i], true))
		{
			return i;
		}
		i++;
	}
	return -1;
}

GetWeaponAttributeInt(String:sWeaponName[], idx)
{
	return L4D2_GetIntWeaponAttribute(sWeaponName, iWeaponAttributes[idx]);
}

Float:GetWeaponAttributeFloat(String:sWeaponName[], idx)
{
	return L4D2_GetFloatWeaponAttribute(sWeaponName, iWeaponAttributes[idx]);
}

SetWeaponAttributeInt(String:sWeaponName[], idx, value)
{
	new iSize = GetArraySize(hVanillaAttributesWeapon);
	decl String:sBuffer[32];
	new i;
	while (i < iSize)
	{
		GetArrayString(hVanillaAttributesWeapon, i, sBuffer, 32);
		new var1;
		if (StrEqual(sWeaponName, sBuffer, true) && GetArrayCell(hVanillaAttributesAttribute, i, 0, false) == idx)
		{
			return 0;
		}
		i++;
	}
	PushArrayCell(hVanillaAttributesValue, L4D2_GetIntWeaponAttribute(sWeaponName, iWeaponAttributes[idx]));
	PushArrayString(hVanillaAttributesWeapon, sWeaponName);
	PushArrayCell(hVanillaAttributesAttribute, idx);
	L4D2_SetIntWeaponAttribute(sWeaponName, iWeaponAttributes[idx], value);
	return 0;
}

SetWeaponAttributeFloat(String:sWeaponName[], idx, Float:value)
{
	new iSize = GetArraySize(hVanillaAttributesWeapon);
	decl String:sBuffer[32];
	new i;
	while (i < iSize)
	{
		GetArrayString(hVanillaAttributesWeapon, i, sBuffer, 32);
		new var1;
		if (StrEqual(sWeaponName, sBuffer, true) && GetArrayCell(hVanillaAttributesAttribute, i, 0, false) == idx)
		{
			return 0;
		}
		i++;
	}
	PushArrayCell(hVanillaAttributesValue, L4D2_GetFloatWeaponAttribute(sWeaponName, iWeaponAttributes[idx]));
	PushArrayString(hVanillaAttributesWeapon, sWeaponName);
	PushArrayCell(hVanillaAttributesAttribute, idx);
	L4D2_SetFloatWeaponAttribute(sWeaponName, iWeaponAttributes[idx], value);
	return 0;
}

public Action:Weapon(args)
{
	new iValue;
	new Float:fValue = 0.0;
	new iAttrIdx;
	decl String:sWeaponName[128];
	decl String:sWeaponNameFull[128];
	decl String:sAttrName[128];
	decl String:sAttrValue[128];
	if (GetCmdArgs() < 3)
	{
		PrintToServer("Syntax: sm_weapon <weapon> <attr> <value>");
		return Action:0;
	}
	GetCmdArg(1, sWeaponName, 128);
	GetCmdArg(2, sAttrName, 128);
	GetCmdArg(3, sAttrValue, 128);
	if (L4D2_IsValidWeapon(sWeaponName))
	{
		PrintToServer("Bad weapon name: %s", sWeaponName);
		return Action:0;
	}
	iAttrIdx = GetWeaponAttributeIndex(sAttrName);
	if (iAttrIdx == -1)
	{
		PrintToServer("Bad attribute name: %s", sAttrName);
		return Action:0;
	}
	sWeaponNameFull[0] = MissingTAG:0;
	StrCat(sWeaponNameFull, 128, "weapon_");
	StrCat(sWeaponNameFull, 128, sWeaponName);
	iValue = StringToInt(sAttrValue, 10);
	fValue = StringToFloat(sAttrValue);
	if (iAttrIdx < 3)
	{
		SetWeaponAttributeInt(sWeaponNameFull, iAttrIdx, iValue);
		PrintToServer("%s for %s set to %d", sWeaponAttrNames[iAttrIdx], sWeaponName, iValue);
	}
	else
	{
		if (iAttrIdx < 20)
		{
			SetWeaponAttributeFloat(sWeaponNameFull, iAttrIdx, fValue);
			PrintToServer("%s for %s set to %.2f", sWeaponAttrNames[iAttrIdx], sWeaponName, fValue);
		}
		KvSetFloat(hTankDamageKVs, sWeaponNameFull, fValue);
		PrintToServer("%s for %s set to %.2f", sWeaponAttrNames[iAttrIdx], sWeaponName, fValue);
	}
	return Action:0;
}

public Action:WeaponAttributes(client, args)
{
	decl String:sWeaponName[128];
	decl String:sWeaponNameFull[128];
	if (GetCmdArgs() < 1)
	{
		ReplyToCommand(client, "Syntax: sm_weapon_attributes <weapon>");
		return Action:0;
	}
	GetCmdArg(1, sWeaponName, 128);
	if (L4D2_IsValidWeapon(sWeaponName))
	{
		ReplyToCommand(client, "Bad weapon name: %s", sWeaponName);
		return Action:0;
	}
	sWeaponNameFull[0] = MissingTAG:0;
	StrCat(sWeaponNameFull, 128, "weapon_");
	StrCat(sWeaponNameFull, 128, sWeaponName);
	ReplyToCommand(client, "Weapon stats for %s", sWeaponName);
	new i;
	while (i < 3)
	{
		new iValue = GetWeaponAttributeInt(sWeaponNameFull, i);
		ReplyToCommand(client, "%s: %d", sWeaponAttrNames[i], iValue);
		i++;
	}
	new i = 3;
	while (i < 20)
	{
		new Float:fValue = GetWeaponAttributeFloat(sWeaponNameFull, i);
		ReplyToCommand(client, "%s: %.2f", sWeaponAttrNames[i], fValue);
		i++;
	}
	new Float:fBuff = KvGetFloat(hTankDamageKVs, sWeaponNameFull, 0.0);
	if (fBuff)
	{
		ReplyToCommand(client, "%s: %.2f", sWeaponAttrNames[20], fBuff);
	}
	return Action:0;
}

public Action:DamageBuffVsTank(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (attacker <= 0 || attacker > MaxClients + 1)
	{
		return Action:0;
	}
	if (!IsTank(victim))
	{
		return Action:0;
	}
	decl String:sWeaponName[128];
	GetClientWeapon(attacker, sWeaponName, 128);
	new Float:fBuff = KvGetFloat(hTankDamageKVs, sWeaponName, 0.0);
	if (!fBuff)
	{
		return Action:0;
	}
	damage = damage * fBuff;
	return Action:1;
}

bool:IsTank(client)
{
	new var1;
	if (client <= 0 || client > MaxClients + 1 || !IsClientInGame(client) || GetClientTeam(client) == 3 || !IsPlayerAlive(client))
	{
		return false;
	}
	new playerClass = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	if (playerClass == 8)
	{
		return true;
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "11/10/2018",
	time = "01:31:42"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Plugin:myinfo =
{
	name = "L4D HOTs",
	description = "Pills and Adrenaline heal over time",
	author = "ProdigySim, CircleSquared",
	version = "0.3",
	url = "https://bitbucket.org/ProdigySim/misc-sourcemod-plugins"
};
new bool:IsL4D2;
new Handle:g_hPillCvar;
new OldPillValue;
new Handle:g_hAdrenCvar;
new OldAdrenValue;
new Handle:pillhot;
new Handle:hCvarPillInterval;
new Handle:hCvarPillIncrement;
new Handle:hCvarPillTotal;
new Handle:adrenhot;
new Handle:hCvarAdrenInterval;
new Handle:hCvarAdrenIncrement;
new Handle:hCvarAdrenTotal;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return oper1 + float(oper2);
}

Float:operator-(Float:,_:)(Float:oper1, oper2)
{
	return oper1 - float(oper2);
}

bool:operator>(Float:,_:)(Float:oper1, oper2)
{
	return oper1 > float(oper2);
}

Handle:CreateDataTimer(Float:interval, Timer:func, &Handle:datapack, flags)
{
	datapack = CreateDataPack();
	flags |= 512;
	return CreateTimer(interval, func, datapack, flags);
}

public void:OnPluginStart()
{
	IsL4D2 = IsTargetL4D2();
	g_hPillCvar = FindConVar("pain_pills_health_value");
	pillhot = CreateConVar("l4d_pills_hot", "0", "Pills heal over time", 262144, false, 0.0, false, 0.0);
	hCvarPillInterval = CreateConVar("l4d_pills_hot_interval", "1.0", "Interval for pills hot", 262144, false, 0.0, false, 0.0);
	hCvarPillIncrement = CreateConVar("l4d_pills_hot_increment", "10", "Increment amount for pills hot", 262144, false, 0.0, false, 0.0);
	hCvarPillTotal = CreateConVar("l4d_pills_hot_total", "50", "Total amount for pills hot", 262144, false, 0.0, false, 0.0);
	if (GetConVarBool(pillhot))
	{
		EnablePillHot();
	}
	HookConVarChange(pillhot, PillHotChanged);
	if (IsL4D2)
	{
		g_hAdrenCvar = FindConVar("adrenaline_health_buffer");
		adrenhot = CreateConVar("l4d_adrenaline_hot", "0", "Adrenaline heals over time", 262144, false, 0.0, false, 0.0);
		hCvarAdrenInterval = CreateConVar("l4d_adrenaline_hot_interval", "1.0", "Interval for adrenaline hot", 262144, false, 0.0, false, 0.0);
		hCvarAdrenIncrement = CreateConVar("l4d_adrenaline_hot_increment", "15", "Increment amount for adrenaline hot", 262144, false, 0.0, false, 0.0);
		hCvarAdrenTotal = CreateConVar("l4d_adrenaline_hot_total", "25", "Total amount for adrenaline hot", 262144, false, 0.0, false, 0.0);
		if (GetConVarBool(adrenhot))
		{
			EnableAdrenHot();
		}
		HookConVarChange(adrenhot, AdrenHotChanged);
	}
	return void:0;
}

public void:OnPluginEnd()
{
	DisablePillHot(false);
	if (IsL4D2)
	{
		DisableAdrenHot(false);
	}
	return void:0;
}

public PillHotChanged(Handle:convar, String:oldValue[], String:newValue[])
{
	new bool:newval = StringToInt(newValue, 10) != 0;
	new var1;
	if (newval && StringToInt(oldValue, 10))
	{
		EnablePillHot();
	}
	else
	{
		new var2;
		if (!newval && StringToInt(oldValue, 10))
		{
			DisablePillHot(true);
		}
	}
	return 0;
}

public AdrenHotChanged(Handle:convar, String:oldValue[], String:newValue[])
{
	new bool:newval = StringToInt(newValue, 10) != 0;
	new var1;
	if (newval && StringToInt(oldValue, 10))
	{
		EnableAdrenHot();
	}
	else
	{
		new var2;
		if (!newval && StringToInt(oldValue, 10))
		{
			DisableAdrenHot(true);
		}
	}
	return 0;
}

EnablePillHot()
{
	OldPillValue = GetConVarInt(g_hPillCvar);
	SetConVarInt(g_hPillCvar, 0, false, false);
	HookEvent("pills_used", PillsUsed_Event, EventHookMode:1);
	return 0;
}

DisablePillHot(bool:unhook)
{
	if (unhook)
	{
		UnhookEvent("pills_used", PillsUsed_Event, EventHookMode:1);
	}
	SetConVarInt(g_hPillCvar, OldPillValue, false, false);
	return 0;
}

EnableAdrenHot()
{
	OldAdrenValue = GetConVarInt(g_hAdrenCvar);
	SetConVarInt(g_hAdrenCvar, 0, false, false);
	HookEvent("adrenaline_used", AdrenalineUsed_Event, EventHookMode:1);
	return 0;
}

DisableAdrenHot(bool:unhook)
{
	if (unhook)
	{
		UnhookEvent("adrenaline_used", AdrenalineUsed_Event, EventHookMode:1);
	}
	SetConVarInt(g_hAdrenCvar, OldAdrenValue, false, false);
	return 0;
}

public Action:PillsUsed_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	new Float:iPillInterval = GetConVarFloat(hCvarPillInterval);
	new iPillIncrement = GetConVarInt(hCvarPillIncrement);
	new iPillTotal = GetConVarInt(hCvarPillTotal);
	HealEntityOverTime(client, iPillInterval, iPillIncrement, iPillTotal);
	return Action:0;
}

public Action:AdrenalineUsed_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	new Float:iAdrenInterval = GetConVarFloat(hCvarAdrenInterval);
	new iAdrenIncrement = GetConVarInt(hCvarAdrenIncrement);
	new iAdrenTotal = GetConVarInt(hCvarAdrenTotal);
	HealEntityOverTime(client, iAdrenInterval, iAdrenIncrement, iAdrenTotal);
	return Action:0;
}

HealEntityOverTime(client, Float:interval, increment, total)
{
	new maxhp = GetEntProp(client, PropType:0, "m_iMaxHealth", 2, 0);
	new var1;
	if (client && !IsClientInGame(client) && !IsPlayerAlive(client))
	{
		return 0;
	}
	if (increment >= total)
	{
		HealTowardsMax(client, total, maxhp);
	}
	else
	{
		HealTowardsMax(client, increment, maxhp);
		new Handle:myDP;
		CreateDataTimer(interval, __HOT_ACTION, myDP, 3);
		WritePackCell(myDP, client);
		WritePackCell(myDP, increment);
		WritePackCell(myDP, total - increment);
		WritePackCell(myDP, maxhp);
	}
	return 0;
}

public Action:__HOT_ACTION(Handle:timer, Handle:pack)
{
	ResetPack(pack, false);
	new client = ReadPackCell(pack);
	new increment = ReadPackCell(pack);
	new pos = GetPackPosition(pack);
	new remaining = ReadPackCell(pack);
	new maxhp = ReadPackCell(pack);
	new var1;
	if (client && !IsClientInGame(client) && !IsPlayerAlive(client))
	{
		return Action:4;
	}
	if (increment >= remaining)
	{
		HealTowardsMax(client, remaining, maxhp);
		return Action:4;
	}
	HealTowardsMax(client, increment, maxhp);
	SetPackPosition(pack, pos);
	WritePackCell(pack, remaining - increment);
	return Action:0;
}

HealTowardsMax(client, amount, max)
{
	new Float:hb = float(amount) + GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0);
	new Float:overflow = hb + GetClientHealth(client) - max;
	if (overflow > 0.0)
	{
		hb -= overflow;
	}
	SetEntPropFloat(client, PropType:0, "m_healthBuffer", hb, 0);
	return 0;
}

bool:IsTargetL4D2()
{
	decl String:gameFolder[32];
	GetGameFolderName(gameFolder, 32);
	return StrContains(gameFolder, "left4dead2", true) >= -1;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "12/24/2011",
	time = "06:22:39"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "sdkhooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new bool:bLateLoad;
new Handle:cvar_bashKills;
public Plugin:myinfo =
{
	name = "L4D2 Bash Kills",
	description = "Stop special infected getting bashed to death",
	author = "Jahze",
	version = "1.0",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:operator==(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) == 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	cvar_bashKills = CreateConVar("l4d_no_bash_kills", "1", "Prevent special infected from getting bashed to death", 262144, false, 0.0, false, 0.0);
	if (bLateLoad)
	{
		new i = 1;
		while (MaxClients + 1 > i)
		{
			if (IsClientInGame(i))
			{
				SDKHook(i, SDKHookType:2, Hurt);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, Hurt);
	return 0;
}

public Action:Hurt(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (!GetConVarBool(cvar_bashKills) || !IsSI(victim))
	{
		return Action:0;
	}
	new var2;
	if (1132068864 == damage && damageType == 128 && weapon == -1 && IsSurvivor(attacker))
	{
		return Action:3;
	}
	return Action:0;
}

bool:IsSI(client)
{
	new var1;
	if (GetClientTeam(client) == 3 && !IsPlayerAlive(client))
	{
		return false;
	}
	new playerClass = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	new var2;
	if (playerClass == 2 || playerClass == 4)
	{
		return false;
	}
	return true;
}

bool:IsSurvivor(client)
{
	new var1;
	if (client < 1 || !IsClientConnected(client) || !IsClientInGame(client) || GetClientTeam(client) == 2 || !IsPlayerAlive(client))
	{
		return false;
	}
	return true;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "01/09/2019",
	time = "21:37:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_builtinvotes =
{
	name = "BuiltinVotes",
	file = "builtinvotes.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1231183725, 1667584878, 1214541423, 1332112481, 1970229862, 25710, 845427820, 1818850421, 0, 845427820, 1818850421, 2020438830, 0, 3276, 3288, 1, 1684104562, 7370105, 1684104562, 779122041, 7892339, 3316, 3324, 1, 1399088193, 1852404340, 1383027815, 2036621669, 1953460038, 29285, 1850307401, 1684104530, 121, 1816359753, 1953391977, 1953718595, 29285, 1145664329, 1953718595, 29285, 24, 32, 36, 48, 52, 56, 1717920891, 1953264993, 125, 1701996411, 8220261, 1734962299, 1919382632, 2104386917, 0, 1684370043
};
new Handle:hSurvivorModelsTrie = 845427820;
new Handle:hWeaponNamesTrie = 845427820;
public SharedPlugin:__pl_l4d2util =
{
	name = "l4d2util",
	file = "l4d2util.smx",
	required = 1,
};
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public Plugin:myinfo =
{
	name = "L4D2 Boss Flow Announce (Back to roots edition)",
	description = "Announce boss flow percents!",
	author = "ProdigySim, Jahze, Stabby, CircleSquared, CanadaRox, Visor, Sir",
	version = "1.6.2",
	url = "https://github.com/Attano/Equilibrium"
};
new iWitchPercent;
new iTankPercent;
new iTank;
new iWitch;
new bool:bTank;
new bool:bWitch;
new bool:bDKR;
new Handle:g_hVsBossBuffer;
new Handle:hCvarPrintToEveryone;
new Handle:hCvarTankPercent;
new Handle:hCvarWitchPercent;
new Handle:hCvarVoteEnable;
new bool:readyUpIsAvailable;
new bool:readyFooterAdded;
new Handle:g_hVote;
new Handle:VoteForward;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

bool:IsNewBuiltinVoteAllowed()
{
	new var1;
	if (IsBuiltinVoteInProgress() || CheckBuiltinVoteDelay())
	{
		return false;
	}
	return true;
}

public __ext_builtinvotes_SetNTVOptional()
{
	MarkNativeAsOptional("CreateBuiltinVote");
	MarkNativeAsOptional("DisplayBuiltinVote");
	MarkNativeAsOptional("AddBuiltinVoteItem");
	MarkNativeAsOptional("InsertBuiltinVoteItem");
	MarkNativeAsOptional("RemoveBuiltinVoteItem");
	MarkNativeAsOptional("RemoveAllBuiltinVoteItems");
	MarkNativeAsOptional("GetBuiltinVoteItem");
	MarkNativeAsOptional("GetBuiltinVoteItemCount");
	MarkNativeAsOptional("SetBuiltinVoteArgument");
	MarkNativeAsOptional("GetBuiltinVoteArgument");
	MarkNativeAsOptional("IsBuiltinVoteInProgress");
	MarkNativeAsOptional("GetBuiltinVoteMaxItems");
	MarkNativeAsOptional("SetBuiltinVoteOptionFlags");
	MarkNativeAsOptional("GetBuiltinVoteOptionFlags");
	MarkNativeAsOptional("SetBuiltinVoteResultCallback");
	MarkNativeAsOptional("CheckBuiltinVoteDelay");
	MarkNativeAsOptional("IsClientInBuiltinVotePool");
	MarkNativeAsOptional("RedrawClientBuiltinVote");
	MarkNativeAsOptional("GetBuiltinVoteType");
	MarkNativeAsOptional("SetBuiltinVoteTeam");
	MarkNativeAsOptional("GetBuiltinVoteTeam");
	MarkNativeAsOptional("SetBuiltinVoteInitiator");
	MarkNativeAsOptional("GetBuiltinVoteInitiator");
	MarkNativeAsOptional("DisplayBuiltinVotePass");
	MarkNativeAsOptional("DisplayBuiltinVotePass2");
	MarkNativeAsOptional("DisplayBuiltinVoteFail");
	return 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetCDirector()
{
	static Address:TheDirector;
	if (!TheDirector)
	{
		TheDirector = GameConfGetAddress(L4D2Direct_GetGameConf(), "CDirector");
	}
	return TheDirector;
}

Address:L4D2Direct_GetCDirectorVersusMode()
{
	static Address:pVersusModeDirector;
	if (!pVersusModeDirector)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode");
		if (offs == -1)
		{
			return Address:0;
		}
		pVersusModeDirector = L4D2Direct_GetCDirector() + offs;
		pVersusModeDirector = LoadFromAddress(pVersusModeDirector, NumberType:2);
	}
	return pVersusModeDirector;
}

Address:L4D2Direct_GetTerrorNavMesh()
{
	static Address:TheNavMesh;
	if (!TheNavMesh)
	{
		TheNavMesh = GameConfGetAddress(L4D2Direct_GetGameConf(), "TerrorNavMesh");
	}
	return TheNavMesh;
}

Address:L4D2Direct_GetVSTankFlowAddr()
{
	static Address:pTankFlowPercent;
	if (!pTankFlowPercent)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_fTankSpawnFlowPercent");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankFlowPercent = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pTankFlowPercent;
}

Address:L4D2Direct_GeVSTankToSpawnAddr()
{
	static Address:pTankSpawnThisRound;
	if (!pTankSpawnThisRound)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_bTankThisRound");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankSpawnThisRound = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pTankSpawnThisRound;
}

Address:L4D2Direct_GetVSWitchFlowAddr()
{
	static Address:pWitchFlowPercent;
	if (!pWitchFlowPercent)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_fWitchSpawnFlowPercent");
		if (offs == -1)
		{
			return Address:0;
		}
		pWitchFlowPercent = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pWitchFlowPercent;
}

Address:L4D2Direct_GetVSWitchToSpawnAddr()
{
	static Address:pWitchSpawnThisRound;
	if (!pWitchSpawnThisRound)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_bWitchThisRound");
		if (offs == -1)
		{
			return Address:0;
		}
		pWitchSpawnThisRound = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pWitchSpawnThisRound;
}

Address:L4D2Direct_GetMapMaxFlowDistanceAddr()
{
	static Address:pMapMaxFlowDistance;
	if (!pMapMaxFlowDistance)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "TerrorNavMesh::m_fMapMaxFlowDistance");
		if (offs == -1)
		{
			return Address:0;
		}
		pMapMaxFlowDistance = L4D2Direct_GetTerrorNavMesh() + offs;
	}
	return pMapMaxFlowDistance;
}

Float:L4D2Direct_GetVSTankFlowPercent(roundNumber)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return -1.0;
	}
	return LoadFromAddress(roundNumber * 4 + L4D2Direct_GetVSTankFlowAddr(), NumberType:2);
}

L4D2Direct_SetVSTankFlowPercent(roundNumber, Float:flow)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(roundNumber * 4 + L4D2Direct_GetVSTankFlowAddr(), flow, NumberType:2);
	return 0;
}

bool:L4D2Direct_GetVSTankToSpawnThisRound(roundNumber)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return false;
	}
	return LoadFromAddress(L4D2Direct_GeVSTankToSpawnAddr() + roundNumber, NumberType:0);
}

L4D2Direct_SetVSTankToSpawnThisRound(roundNumber, bool:spawn)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(L4D2Direct_GeVSTankToSpawnAddr() + roundNumber, spawn, NumberType:0);
	return 0;
}

Float:L4D2Direct_GetVSWitchFlowPercent(roundNumber)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return -1.0;
	}
	return LoadFromAddress(roundNumber * 4 + L4D2Direct_GetVSWitchFlowAddr(), NumberType:2);
}

L4D2Direct_SetVSWitchFlowPercent(roundNumber, Float:flow)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(roundNumber * 4 + L4D2Direct_GetVSWitchFlowAddr(), flow, NumberType:2);
	return 0;
}

bool:L4D2Direct_GetVSWitchToSpawnThisRound(roundNumber)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return false;
	}
	return LoadFromAddress(L4D2Direct_GetVSWitchToSpawnAddr() + roundNumber, NumberType:0);
}

L4D2Direct_SetVSWitchToSpawnThisRound(roundNumber, bool:spawn)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(L4D2Direct_GetVSWitchToSpawnAddr() + roundNumber, spawn, NumberType:0);
	return 0;
}

Float:L4D2Direct_GetMapMaxFlowDistance()
{
	return LoadFromAddress(L4D2Direct_GetMapMaxFlowDistanceAddr(), NumberType:2);
}

bool:InSecondHalfOfRound()
{
	return GameRules_GetProp(L4D2_InfectedNames, 4, 0);
}

public __pl_l4d2util_SetNTVOptional()
{
	return 0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	CreateNative("UpdateBossPercents", Native_UpdateBossPercents);
	MarkNativeAsOptional("AddStringToReadyFooter");
	RegPluginLibrary("l4d_boss_percent");
	return APLRes:0;
}

public void:OnPluginStart()
{
	g_hVsBossBuffer = FindConVar("versus_boss_buffer");
	hCvarPrintToEveryone = CreateConVar("l4d_global_percent", "1", "Display boss percentages to entire team when using commands", 262144, false, 0.0, false, 0.0);
	hCvarTankPercent = CreateConVar("l4d_tank_percent", "1", "Display Tank flow percentage in chat", 262144, false, 0.0, false, 0.0);
	hCvarWitchPercent = CreateConVar("l4d_witch_percent", "1", "Display Witch flow percentage in chat", 262144, false, 0.0, false, 0.0);
	hCvarVoteEnable = CreateConVar("l4d_boss_vote", "1", "Allow for Easy Setup of the Boss Spawns", 262144, false, 0.0, false, 0.0);
	RegConsoleCmd("sm_boss", BossCmd, "", 0);
	RegConsoleCmd("sm_tank", BossCmd, "", 0);
	RegConsoleCmd("sm_witch", BossCmd, "", 0);
	RegConsoleCmd("sm_voteboss", VoteBoss_Cmd, "Let's vote to set those Boss Spawns!", 0);
	RegConsoleCmd("sm_bossvote", VoteBoss_Cmd, "Let's vote to set those Boss Spawns!", 0);
	RegConsoleCmd("sm_settank", VoteBoss_Cmd, "Let's vote to set those Boss Spawns!", 0);
	RegConsoleCmd("sm_setwitch", VoteBoss_Cmd, "Let's vote to set those Boss Spawns!", 0);
	VoteForward = CreateGlobalForward("OnBossVote", ExecType:2);
	HookEvent("player_left_start_area", LeftStartAreaEvent, EventHookMode:2);
	HookEvent("round_start", RoundStartEvent, EventHookMode:2);
	HookEvent("player_say", CuteWorkAround, EventHookMode:0);
	return void:0;
}

public void:OnMapStart()
{
	if (IsDKR())
	{
		bDKR = true;
	}
	else
	{
		bDKR = false;
	}
	return void:0;
}

public void:OnAllPluginsLoaded()
{
	readyUpIsAvailable = LibraryExists("readyup");
	return void:0;
}

public void:OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		readyUpIsAvailable = false;
	}
	return void:0;
}

public void:OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		readyUpIsAvailable = true;
	}
	return void:0;
}

public LeftStartAreaEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!readyUpIsAvailable)
	{
		new client = 1;
		while (client <= MaxClients)
		{
			new var1;
			if (IsClientConnected(client) && IsClientInGame(client))
			{
				PrintBossPercents(client);
			}
			client++;
		}
	}
	return 0;
}

public OnRoundIsLive()
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientConnected(client) && IsClientInGame(client))
		{
			PrintBossPercents(client);
		}
		client++;
	}
	return 0;
}

public RoundStartEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	readyFooterAdded = false;
	if (!IsDKR())
	{
		CreateTimer(5.0, SaveBossFlows, any:0, 0);
		CreateTimer(6.0, AddReadyFooter, any:0, 0);
	}
	return 0;
}

public Native_UpdateBossPercents(Handle:plugin, numParams)
{
	CreateTimer(0.1, SaveBossFlows, any:0, 0);
	CreateTimer(0.2, AddReadyFooter, any:0, 0);
	return 1;
}

public Action:CuteWorkAround(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!bDKR)
	{
		return Action:0;
	}
	new UserID = GetEventInt(event, "userid", 0);
	if (!UserID)
	{
		new String:sBuffer[128];
		GetEventString(event, "text", sBuffer, 128, "");
		if (StrContains(sBuffer, "The Tank", false) != -1)
		{
			iTankPercent = FindNumbers(sBuffer);
			iWitchPercent = 0;
			CreateTimer(0.2, AddReadyFooter, any:0, 0);
			return Action:3;
		}
	}
	return Action:0;
}

public Action:SaveBossFlows(Handle:timer)
{
	if (!InSecondHalfOfRound())
	{
		iWitchPercent = 0;
		iTankPercent = 0;
		if (L4D2Direct_GetVSWitchToSpawnThisRound(0))
		{
			iWitchPercent = RoundToNearest(GetWitchFlow(0) * 100.0);
		}
		if (L4D2Direct_GetVSTankToSpawnThisRound(0))
		{
			iTankPercent = RoundToNearest(GetTankFlow(0) * 100.0);
		}
	}
	else
	{
		if (iWitchPercent)
		{
			iWitchPercent = RoundToNearest(GetWitchFlow(1) * 100.0);
		}
		if (iTankPercent)
		{
			iTankPercent = RoundToNearest(GetTankFlow(1) * 100.0);
		}
	}
	return Action:0;
}

public Action:AddReadyFooter(Handle:timer)
{
	if (readyFooterAdded)
	{
		return Action:0;
	}
	if (readyUpIsAvailable)
	{
		decl String:readyString[68];
		new var1;
		if (iWitchPercent && iTankPercent)
		{
			Format(readyString, 65, "Tank: %d%%, Witch: %d%%", iTankPercent, iWitchPercent);
		}
		else
		{
			if (iTankPercent)
			{
				Format(readyString, 65, "Tank: %d%%, Witch: None", iTankPercent);
			}
			if (iWitchPercent)
			{
				Format(readyString, 65, "Tank: None, Witch: %d%%", iWitchPercent);
			}
			Format(readyString, 65, "Tank: None, Witch: None");
		}
		AddStringToReadyFooter(readyString);
		readyFooterAdded = true;
	}
	return Action:0;
}

PrintBossPercents(client)
{
	FakeClientCommand(client, "say /current");
	CreateTimer(0.1, PrintStuff, client, 0);
	return 0;
}

public Action:PrintStuff(Handle:timer, any:client)
{
	if (IsValidClient(client))
	{
		if (GetConVarBool(hCvarTankPercent))
		{
			if (iTankPercent)
			{
				CPrintToChat(client, "{default}<{olive}Tank{default}> {red}%d%%", iTankPercent);
			}
			CPrintToChat(client, "{default}<{olive}Tank{default}> {red}None");
		}
		if (GetConVarBool(hCvarWitchPercent))
		{
			if (iWitchPercent)
			{
				CPrintToChat(client, "{default}<{olive}Witch{default}> {red}%d%%", iWitchPercent);
			}
			CPrintToChat(client, "{default}<{olive}Witch{default}> {red}None");
		}
	}
	return Action:0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

public Action:BossCmd(client, args)
{
	new L4D2_Team:iTeam = GetClientTeam(client);
	if (iTeam == L4D2_Team:1)
	{
		PrintBossPercents(client);
		return Action:3;
	}
	if (GetConVarBool(hCvarPrintToEveryone))
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientConnected(i) && IsClientInGame(i) && iTeam == GetClientTeam(i))
			{
				PrintBossPercents(i);
			}
			i++;
		}
	}
	else
	{
		PrintBossPercents(client);
	}
	return Action:3;
}

public Action:VoteBoss_Cmd(client, args)
{
	new var1;
	if (IsValidClient(client) && GetConVarBool(hCvarVoteEnable))
	{
		if (IsDKR())
		{
			CPrintToChat(client, "{blue}[{default}VoteBoss{blue}] {olive}Not Available on this Map.");
			return Action:3;
		}
		new var2;
		if (args == 2 && !IsInReady() && InSecondHalfOfRound())
		{
			new var3;
			if (!IsInReady() || InSecondHalfOfRound())
			{
				CPrintToChat(client, "{blue}[{default}BossVote{blue}] {default}You can only set Spawns during Ready-up in the first round.");
			}
			else
			{
				CPrintToChat(client, "{blue}[{default}VoteBoss{blue}] {olive}Usage: {default}!voteboss <tank> <witch>");
				CPrintToChat(client, "{blue}[{default}VoteBoss{blue}] {olive}Use {default}'{blue}0{default}' for {olive}No Spawn.");
			}
			return Action:3;
		}
		new String:sTank[32];
		new String:sWitch[32];
		GetCmdArg(1, sTank, 32);
		GetCmdArg(2, sWitch, 32);
		iTank = StringToInt(sTank, 10);
		iWitch = StringToInt(sWitch, 10);
		bWitch = GetConVarBool(hCvarWitchPercent);
		bTank = GetConVarBool(hCvarTankPercent);
		if (GetUserAdmin(client) != -1)
		{
			SetBoss();
			return Action:3;
		}
		new iNumPlayers;
		decl iPlayers[MaxClients];
		new i = 1;
		while (i <= MaxClients)
		{
			new var4;
			if (!IsClientInGame(i) || IsFakeClient(i) || GetClientTeam(i) == 1)
			{
			}
			else
			{
				iNumPlayers++;
				iPlayers[iNumPlayers] = i;
			}
			i++;
		}
		if (iNumPlayers < 4)
		{
			CPrintToChat(client, "{blue}[{default}VoteBoss{blue}] {default}You need at least 4 Players to start this vote.");
			return Action:3;
		}
		if (IsNewBuiltinVoteAllowed())
		{
			new String:sBuffer[64];
			g_hVote = CreateBuiltinVote(BuiltinVoteActionHandler:33, BuiltinVoteType:3, BuiltinVoteAction:26);
			Format(sBuffer, 64, "Set Tank to %i%% and Witch to %i%%?", iTank, iWitch);
			SetBuiltinVoteArgument(g_hVote, sBuffer);
			SetBuiltinVoteInitiator(g_hVote, client);
			SetBuiltinVoteResultCallback(g_hVote, BuiltinVoteHandler:37);
			DisplayBuiltinVote(g_hVote, iPlayers, iNumPlayers, 20);
			return Action:3;
		}
		CPrintToChat(client, "{blue}[{default}VoteBoss{blue}] {default}Vote can't be started right now...");
	}
	return Action:3;
}

public VoteResultHandler(Handle:vote, num_votes, num_clients, client_info[][2], num_items, item_info[][2])
{
	new i;
	while (i < num_items)
	{
		if (item_info[i][0] == 1)
		{
			if (num_votes / 2 < item_info[i][1])
			{
				DisplayBuiltinVotePass(vote, "Setting Spawns...");
				SetBoss();
				return 0;
			}
		}
		i++;
	}
	DisplayBuiltinVoteFail(vote, BuiltinVoteFailReason:3);
	return 0;
}

public VoteActionHandler(Handle:vote, BuiltinVoteAction:action, param1, param2)
{
	switch (action)
	{
		case 2:
		{
			g_hVote = MissingTAG:0;
			CloseHandle(vote);
		}
		case 8:
		{
			DisplayBuiltinVoteFail(vote, param1);
		}
		default:
		{
		}
	}
	return 0;
}

SetBoss()
{
	new String:sBuffer[64];
	new Float:fSpawnflow = 0.0;
	new var1;
	if (iTank && !bTank)
	{
		L4D2Direct_SetVSTankToSpawnThisRound(0, false);
		L4D2Direct_SetVSTankToSpawnThisRound(1, false);
	}
	else
	{
		if (iTank == 100)
		{
			fSpawnflow = 1.0;
		}
		Format(sBuffer, 64, "0.%i", iTank);
		fSpawnflow = StringToFloat(sBuffer);
	}
	L4D2Direct_SetVSTankFlowPercent(0, fSpawnflow);
	L4D2Direct_SetVSTankFlowPercent(1, fSpawnflow);
	new var2;
	if (iWitch && !bWitch)
	{
		fSpawnflow = 0.0;
		L4D2Direct_SetVSWitchToSpawnThisRound(0, false);
		L4D2Direct_SetVSWitchToSpawnThisRound(1, false);
	}
	else
	{
		if (iWitch == 100)
		{
			fSpawnflow = 1.0;
		}
		Format(sBuffer, 64, "0.%i", iWitch);
		fSpawnflow = StringToFloat(sBuffer);
	}
	L4D2Direct_SetVSWitchFlowPercent(0, fSpawnflow);
	L4D2Direct_SetVSWitchFlowPercent(1, fSpawnflow);
	Call_StartForward(VoteForward);
	Call_Finish(0);
	readyFooterAdded = false;
	CreateTimer(0.1, SaveBossFlows, any:0, 0);
	CreateTimer(0.2, AddReadyFooter, any:0, 0);
	return 0;
}

Float:GetTankFlow(round)
{
	return L4D2Direct_GetVSTankFlowPercent(round) - GetConVarInt(g_hVsBossBuffer) / L4D2Direct_GetMapMaxFlowDistance();
}

Float:GetWitchFlow(round)
{
	return L4D2Direct_GetVSWitchFlowPercent(round) - GetConVarInt(g_hVsBossBuffer) / L4D2Direct_GetMapMaxFlowDistance();
}

bool:IsDKR()
{
	new String:sMap[64];
	GetCurrentMap(sMap, 64);
	new var1;
	if (StrEqual(sMap, "dkr_m1_motel", true) || StrEqual(sMap, "dkr_m2_carnival", true) || StrEqual(sMap, "dkr_m3_tunneloflove", true) || StrEqual(sMap, "dkr_m4_ferris", true) || StrEqual(sMap, "dkr_m5_stadium", true))
	{
		return true;
	}
	return false;
}

FindNumbers(String:sTemp[])
{
	new String:sBuffer[4];
	sBuffer[0] = MissingTAG:65;
	sBuffer[0] = MissingTAG:65;
	new n;
	while (sTemp[n] && (sBuffer[0] == 'A' || sBuffer[0] == 'A'))
	{
		new character = sTemp[n];
		new var3;
		if (character == 48 || character == 49 || character == 50 || character == 51 || character == 52 || character == 53 || character == 54 || character == 55 || character == 56 || character == 57)
		{
			if (StrEqual(sBuffer, "AA", true))
			{
				sBuffer[0] = character;
			}
			sBuffer[0] = character;
		}
		n++;
	}
	return StringToInt(sBuffer, 10);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "05/14/2012",
	time = "23:30:39"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Equalise Alarm Cars",
	description = "Make the alarmed car spawns the same for each team in versus",
	author = "Jahze",
	version = "1.2",
	url = ""
};
new bool:bHooked;
new bool:bActivated;
new bool:bSecondRound;
new bool:bPatched;
new Handle:hFirstRoundCars;
new Handle:hSecondRoundCars;
new Handle:hCvarEqAlarmCars;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

StrCat(String:buffer[], maxlength, String:source[])
{
	new len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	return Format(buffer[len], maxlength - len, "%s", source);
}

bool:GetEntityClassname(entity, String:clsname[], maxlength)
{
	return !!GetEntPropString(entity, PropType:1, "m_iClassname", clsname, maxlength, 0);
}

public OnPluginStart()
{
	hCvarEqAlarmCars = CreateConVar("l4d_equalise_alarm_cars", "1", "Makes alarmed cars spawn in the same way for both teams", 262144, false, 0.0, false, 0.0);
	HookConVarChange(hCvarEqAlarmCars, EqAlarmCarsChange);
	hFirstRoundCars = CreateArray(128, 0);
	hSecondRoundCars = CreateArray(128, 0);
	HookEvents();
	return 0;
}

public OnPluginStop()
{
	UnhookEvents();
	return 0;
}

public OnMapStart()
{
	bActivated = false;
	bSecondRound = false;
	bPatched = false;
	ClearArray(hFirstRoundCars);
	ClearArray(hSecondRoundCars);
	return 0;
}

HookEvents()
{
	if (!bHooked)
	{
		HookEvent("round_start", RoundStart, EventHookMode:1);
		HookEvent("round_end", RoundEnd, EventHookMode:1);
		bHooked = true;
	}
	return 0;
}

UnhookEvents()
{
	if (bHooked)
	{
		UnhookEvent("round_start", RoundStart, EventHookMode:1);
		UnhookEvent("round_end", RoundEnd, EventHookMode:1);
		bHooked = false;
	}
	return 0;
}

public EqAlarmCarsChange(Handle:cvar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10) == 1)
	{
		HookEvents();
	}
	else
	{
		UnhookEvents();
	}
	return 0;
}

public Action:RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CreateTimer(0.1, RoundStartDelay, any:0, 0);
	return Action:0;
}

public Action:RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!bSecondRound)
	{
		bSecondRound = true;
	}
	return Action:0;
}

public Action:RoundStartDelay(Handle:timer)
{
	new iEntity = -1;
	decl String:sTargetName[128];
	new var1;
	if (bSecondRound && !bActivated)
	{
		return Action:0;
	}
	while ((iEntity = FindEntityByClassname(iEntity, "logic_relay")) != -1)
	{
		GetEntityName(iEntity, sTargetName, 128);
		if (!(StrContains(sTargetName, "-relay_caralarm_off", true) == -1))
		{
			HookSingleEntityOutput(iEntity, "OnTrigger", CarAlarmLogicRelayTriggered, false);
		}
	}
	return Action:0;
}

public CarAlarmLogicRelayTriggered(String:output[], caller, activator, Float:delay)
{
	decl String:sTargetName[128];
	GetEntityName(caller, sTargetName, 128);
	if (IsValidEntity(activator))
	{
		decl String:sClassName[128];
		GetEntityClassname(activator, sClassName, 128);
		if (StrEqual(sClassName, "prop_car_alarm", true))
		{
			return 0;
		}
	}
	if (!bSecondRound)
	{
		bActivated = true;
		PushArrayString(hFirstRoundCars, sTargetName);
	}
	else
	{
		PushArrayString(hSecondRoundCars, sTargetName);
		if (!bPatched)
		{
			CreateTimer(1.0, PatchAlarmedCars, any:0, 0);
			bPatched = true;
		}
	}
	return 0;
}

public Action:PatchAlarmedCars(Handle:timer)
{
	decl String:sEntName[128];
	new i;
	while (GetArraySize(hFirstRoundCars) > i)
	{
		GetArrayString(hFirstRoundCars, i, sEntName, 128);
		if (FindStringInArray(hSecondRoundCars, sEntName) == -1)
		{
			DisableCar(sEntName);
		}
		i++;
	}
	new i;
	while (GetArraySize(hSecondRoundCars) > i)
	{
		GetArrayString(hSecondRoundCars, i, sEntName, 128);
		if (FindStringInArray(hFirstRoundCars, sEntName) == -1)
		{
			EnableCar(sEntName);
		}
		i++;
	}
	return Action:0;
}

bool:ExtractCarName(String:sName[], String:sBuffer[], iSize)
{
	return SplitString(sName, "-", sBuffer, iSize) != -1;
}

DisableCar(String:sName[])
{
	TriggerCarRelay(sName, false);
	return 0;
}

EnableCar(String:sName[])
{
	TriggerCarRelay(sName, true);
	return 0;
}

TriggerCarRelay(String:sName[], bool:bOn)
{
	decl String:sCarName[128];
	new iEntity;
	if (!ExtractCarName(sName, sCarName, 128))
	{
		return 0;
	}
	StrCat(sCarName, 128, "-relay_caralarm_");
	if (bOn)
	{
		StrCat(sCarName, 128, "on");
	}
	else
	{
		StrCat(sCarName, 128, "off");
	}
	iEntity = FindEntityByName(sCarName, "logic_relay");
	if (iEntity != -1)
	{
		AcceptEntityInput(iEntity, "Trigger", -1, -1, 0);
	}
	return 0;
}

FindEntityByName(String:sName[], String:sClassName[])
{
	new iEntity = -1;
	decl String:sEntName[128];
	while ((iEntity = FindEntityByClassname(iEntity, sClassName)) != -1)
	{
		if (IsValidEntity(iEntity))
		{
			GetEntityName(iEntity, sEntName, 128);
			if (StrEqual(sEntName, sName, true))
			{
				return iEntity;
			}
		}
	}
	return -1;
}

GetEntityName(iEntity, String:sTargetName[], iSize)
{
	GetEntPropString(iEntity, PropType:1, "m_iName", sTargetName, iSize, 0);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.0-dev",
	date = "06/19/2011",
	time = "23:29:06"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D Inaudible Ghosts",
	description = "Keep survivors from hearing jumping infected ghosts.",
	author = "AtomicStryker, DieTeeTasse, ProdigySim",
	version = "1.1",
	url = "http://bitbucket.org/ProdigySim/misc-sourcemod-plugins/"
};
new isGhostOffset;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	isGhostOffset = FindSendPropInfo("CTerrorPlayer", "m_isGhost", 0, 0, 0);
	AddNormalSoundHook(SoundHook);
	return 0;
}

public Action:SoundHook(clients[64], &numClients, String:sample[256], &entity)
{
	new var1;
	if (StrEqual(sample, "player/jumplanding_zombie.wav", true) && GetEntData(entity, isGhostOffset, 4))
	{
		numClients = 0;
		new i = 1;
		while (MaxClients + 1 > i)
		{
			if (IsClientInGame(i))
			{
				if (!(IsFakeClient(i)))
				{
					if (!(GetClientTeam(i) != 3))
					{
						clients[numClients] = i;
						new var2 = numClients;
						var2++;
						numClients = var2;
					}
				}
			}
			i++;
		}
		return Action:1;
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "05/10/2012",
	time = "22:18:42"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1936285549, 1735287112, 1181183593, 1282240370, 1701274725, 0, 1936285549, 1819042118, 1181183593, 1282240370, 1701274725, 0, 0, 0, 843330636, 1668237856, 544826731, 1734632780, 1632116837, 1377855342, 1634231141, 6645618, 2053661002, 101, 3157553, 1935959105, 1663066400, 544366966, 1629515636, 1937074788, 1752440948, 1701978213, 1918986339, 1948280167, 1919249769, 543584032, 1869226081, 2036689763, 1952866592, 1746956901, 1701584997, 543516516, 1735287144, 543236211, 1987212659, 1919907433, 46, 0, 280, 324, 312, 320, 412, 1701601146, 1767862369, 1919251566
};
new Float:fLedgeHangInterval;
new Handle:hWeaponNamesTrie;
new Handle:hCvarJockeyLedgeHang;
public Plugin:myinfo =
{
	name = "L4D2 Jockey Ledge Hang Recharge",
	description = "Adds a cvar to adjust the recharge timer of a jockey after he ledge hangs a survivor.",
	author = "Jahze",
	version = "1.0",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:IsHangingFromLedge(client)
{
	new var1;
	return GetEntProp(client, PropType:0, L4D2_InfectedNames, 4, 0) || GetEntProp(client, PropType:0, "m_isFallingFromLedge", 4, 0);
}

public OnPluginStart()
{
	hCvarJockeyLedgeHang = CreateConVar("z_leap_interval_post_ledge_hang", "10", "How long before a jockey can leap again after a ledge hang", 0, false, 0.0, false, 0.0);
	HookConVarChange(hCvarJockeyLedgeHang, JockeyLedgeHangChange);
	fLedgeHangInterval = GetConVarFloat(hCvarJockeyLedgeHang);
	PluginEnable();
	return 0;
}

PluginEnable()
{
	HookEvent("jockey_ride_end", JockeyRideEnd, EventHookMode:1);
	return 0;
}

public JockeyLedgeHangChange(Handle:hCvar, String:oldValue[], String:newValue[])
{
	fLedgeHangInterval = StringToFloat(newValue);
	return 0;
}

public Action:JockeyRideEnd(Handle:hEvent, String:name[], bool:bDontBroadcast)
{
	new jockeyAttacker = GetClientOfUserId(GetEventInt(hEvent, "userid"));
	new jockeyVictim = GetClientOfUserId(GetEventInt(hEvent, "victim"));
	if (IsHangingFromLedge(jockeyVictim))
	{
		FixupJockeyTimer(jockeyAttacker);
	}
	return Action:0;
}

FixupJockeyTimer(client)
{
	new iEntity = -1;
	while ((iEntity = FindEntityByClassname(iEntity, "ability_leap")) != -1)
	{
		if (client == GetEntPropEnt(iEntity, PropType:0, "m_owner", 0))
		{
			if (iEntity == -1)
			{
				return 0;
			}
			SetEntPropFloat(iEntity, PropType:0, "m_timestamp", GetGameTime() + fLedgeHangInterval, 0);
			SetEntPropFloat(iEntity, PropType:0, "m_duration", fLedgeHangInterval, 0);
			return 0;
		}
	}
	if (iEntity == -1)
	{
		return 0;
	}
	SetEntPropFloat(iEntity, PropType:0, "m_timestamp", GetGameTime() + fLedgeHangInterval, 0);
	SetEntPropFloat(iEntity, PropType:0, "m_duration", fLedgeHangInterval, 0);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.2",
	date = "05/20/2012",
	time = "21:16:11"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new Handle:g_hUseConfigDir;
new String:g_sUseConfigDir[128];
new Handle:g_hKvOrig;
public Plugin:myinfo =
{
	name = "L4D(2) map-based convar loader.",
	description = "Loads convars on map-load, based on currently active map and confogl config.",
	author = "Tabun",
	version = "0.1b",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

StrCat(String:buffer[], maxlength, String:source[])
{
	new len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	return Format(buffer[len], maxlength - len, "%s", source);
}

public OnPluginStart()
{
	g_hUseConfigDir = CreateConVar("l4d_mapcvars_configdir", "", "Which cfgogl config are we using?", 262144, false, 0.0, false, 0.0);
	GetConVarString(g_hUseConfigDir, g_sUseConfigDir, 128);
	HookConVarChange(g_hUseConfigDir, CvarConfigChange);
	g_hKvOrig = CreateKeyValues("MapCvars_Orig", "", "");
	return 0;
}

public OnPluginEnd()
{
	ResetMapPrefs();
	if (g_hKvOrig)
	{
		CloseHandle(g_hKvOrig);
	}
	return 0;
}

public CvarConfigChange(Handle:cvar, String:oldValue[], String:newValue[])
{
	strcopy(g_sUseConfigDir, 128, newValue);
	ResetMapPrefs();
	GetThisMapPrefs();
	return 0;
}

public OnMapStart()
{
	GetThisMapPrefs();
	return 0;
}

public OnMapEnd()
{
	ResetMapPrefs();
	return 0;
}

public GetThisMapPrefs()
{
	new iNumChanged;
	if (g_hKvOrig)
	{
		CloseHandle(g_hKvOrig);
	}
	g_hKvOrig = CreateKeyValues("MapCvars_Orig", "", "");
	new String:usePath[256] = "../../cfg";
	if (0 < strlen(g_sUseConfigDir))
	{
		StrCat(usePath, 256, g_sUseConfigDir);
		StrCat(usePath, 256, "/mapcvars.txt");
	}
	else
	{
		StrCat(usePath, 256, "/mapcvars.txt");
	}
	BuildPath(PathType:0, usePath, 256, usePath);
	if (!FileExists(usePath, false))
	{
		return 0;
	}
	new Handle:hKv = CreateKeyValues("MapCvars", "", "");
	FileToKeyValues(hKv, usePath);
	if (hKv)
	{
		new String:sMapName[64];
		GetCurrentMap(sMapName, 64);
		if (!KvJumpToKey(hKv, sMapName, false))
		{
			CloseHandle(hKv);
			return 0;
		}
		new String:tmpKey[64];
		new String:tmpValueNew[128];
		new String:tmpValueOld[128];
		new Handle:hConVar;
		if (KvGotoFirstSubKey(hKv, false))
		{
			do {
				KvGetSectionName(hKv, tmpKey, 64);
				hConVar = FindConVar(tmpKey);
				if (hConVar)
				{
					KvGetString(hKv, NULL_STRING, tmpValueNew, 128, "[:none:]");
					if (!StrEqual(tmpValueNew, "[:none:]", true))
					{
						GetConVarString(hConVar, tmpValueOld, 128);
						PrintToServer("[mcv] cvar value changed: [%s] => [%s] (saved old: [%s]))", tmpKey, tmpValueNew, tmpValueOld);
						if (!StrEqual(tmpValueNew, tmpValueOld, true))
						{
							iNumChanged++;
							KvSetString(g_hKvOrig, tmpKey, tmpValueOld);
							SetConVarString(hConVar, tmpValueNew, false, false);
						}
					}
				}
			} while (KvGotoNextKey(hKv, false));
		}
		KvSetString(g_hKvOrig, "__EOF__", "1");
		CloseHandle(hKv);
		return iNumChanged;
	}
	return 0;
}

public ResetMapPrefs()
{
	KvRewind(g_hKvOrig);
	new String:tmpKey[64];
	new String:tmpValueOld[512];
	new Handle:hConVar;
	if (KvGotoFirstSubKey(g_hKvOrig, false))
	{
		KvGetSectionName(g_hKvOrig, tmpKey, 64);
		while (StrEqual(tmpKey, "__EOF__", true))
		{
			hConVar = FindConVar(tmpKey);
			if (hConVar)
			{
				KvGetString(g_hKvOrig, NULL_STRING, tmpValueOld, 512, "[:none:]");
				if (!StrEqual(tmpValueOld, "[:none:]", true))
				{
					SetConVarString(hConVar, tmpValueOld, false, false);
					PrintToServer("[mcv] cvar value reset to original: [%s] => [%s])", tmpKey, tmpValueOld);
				}
			}
			if (KvGotoNextKey(g_hKvOrig, false))
			{
			}
		}
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.3.9-dev",
	date = "09/18/2011",
	time = "04:43:40"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "No Tank",
	description = "Slays any tanks that spawn. Designed for 1v1 configs",
	author = "Don",
	version = "1.1",
	url = "https://bitbucket.org/DonSanchez/random-sourcemod-stuff"
};
new iSpawned;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	decl String:sGame[12];
	GetGameFolderName(sGame, 12);
	new var1;
	if (StrEqual(sGame, "left4dead", true) || StrEqual(sGame, "left4dead2", true))
	{
		return APLRes:0;
	}
	strcopy(error, err_max, "Plugin only supports L4D1/2");
	return APLRes:1;
}

public OnPluginStart()
{
	HookEvent("tank_spawn", Event_tank_spawn_Callback, EventHookMode:1);
	return 0;
}

public Event_tank_spawn_Callback(Handle:event, String:name[], bool:dontBroadcast)
{
	iSpawned = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (IsClientInGame(iSpawned) && IsPlayerAlive(iSpawned))
	{
		CreateTimer(1.0, SlayTank, any:0, 0);
	}
	return 0;
}

public Action:SlayTank(Handle:timer)
{
	ForcePlayerSuicide(iSpawned);
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "12/04/2018",
	time = "11:43:34"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "No Witch",
	description = "Slays any Witch that spwns",
	author = "Sir",
	version = "1",
	url = "Nuh-uh"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

public void:OnPluginStart()
{
	HookEvent("witch_spawn", WitchSpawn, EventHookMode:1);
	return void:0;
}

public WitchSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	new iEnt = GetEventInt(event, "witchid", 0);
	if (IsValidEntity(iEnt))
	{
		AcceptEntityInput(iEnt, "Kill", -1, -1, 0);
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+3935",
	date = "06/07/2014",
	time = "12:44:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new bool:bNoCans = 1;
new bool:bNoPropane = 1;
new bool:bNoOxygen = 1;
new bool:bNoFireworks = 1;
new Handle:cvar_noCans;
new Handle:cvar_noPropane;
new Handle:cvar_noOxygen;
new Handle:cvar_noFireworks;
new String:CAN_GASCAN[36] = "models/props_junk/gascan001a.mdl";
new String:CAN_PROPANE[44] = "models/props_junk/propanecanister001a.mdl";
new String:CAN_OXYGEN[40] = "models/props_equipment/oxygentank01.mdl";
new String:CAN_FIREWORKS[40] = "models/props_junk/explosive_box001.mdl";
public Plugin:myinfo =
{
	name = "L4D2 Remove Cans",
	description = "Provides the ability to remove Gascans, Propane, Oxygen Tanks and Fireworks",
	author = "Jahze, Sir",
	version = "0.3",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	cvar_noCans = CreateConVar("l4d_no_cans", "1", "Remove Gascans?", 262144, false, 0.0, false, 0.0);
	cvar_noPropane = CreateConVar("l4d_no_propane", "1", "Remove Propane Tanks?", 262144, false, 0.0, false, 0.0);
	cvar_noOxygen = CreateConVar("l4d_no_oxygen", "1", "Remove Oxygen Tanks?", 262144, false, 0.0, false, 0.0);
	cvar_noFireworks = CreateConVar("l4d_no_fireworks", "1", "Remove Fireworks?", 262144, false, 0.0, false, 0.0);
	HookConVarChange(cvar_noCans, NoCansChange);
	HookConVarChange(cvar_noPropane, NoPropaneChange);
	HookConVarChange(cvar_noOxygen, NoOxygenChange);
	HookConVarChange(cvar_noFireworks, NoFireworksChange);
	HookEvent("round_start", RoundStartHook, EventHookMode:1);
	return 0;
}

IsCan(iEntity)
{
	decl String:sModelName[128];
	GetEntPropString(iEntity, PropType:1, "m_ModelName", sModelName, 128, 0);
	if (GetEntProp(iEntity, PropType:0, "m_isCarryable", 1, 0))
	{
		new var1;
		if (StrEqual(sModelName, CAN_GASCAN, false) && bNoCans)
		{
			return 1;
		}
		new var2;
		if (StrEqual(sModelName, CAN_PROPANE, false) && bNoPropane)
		{
			return 1;
		}
		new var3;
		if (StrEqual(sModelName, CAN_OXYGEN, false) && bNoOxygen)
		{
			return 1;
		}
		new var4;
		if (StrEqual(sModelName, CAN_FIREWORKS, false) && bNoFireworks)
		{
			return 1;
		}
	}
	return 0;
}

public Action:RoundStartHook(Handle:event, String:name[], bool:dontBroadcast)
{
	CreateTimer(1.0, RoundStartNoCans, any:0, 0);
	return Action:0;
}

public NoCansChange(Handle:cvar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10))
	{
		bNoCans = true;
	}
	else
	{
		bNoCans = false;
	}
	return 0;
}

public NoPropaneChange(Handle:cvar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10))
	{
		bNoPropane = true;
	}
	else
	{
		bNoPropane = false;
	}
	return 0;
}

public NoOxygenChange(Handle:cvar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10))
	{
		bNoOxygen = true;
	}
	else
	{
		bNoOxygen = false;
	}
	return 0;
}

public NoFireworksChange(Handle:cvar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10))
	{
		bNoFireworks = true;
	}
	else
	{
		bNoFireworks = false;
	}
	return 0;
}

public Action:RoundStartNoCans(Handle:timer)
{
	new iEntity;
	while ((iEntity = FindEntityByClassname(iEntity, "prop_physics")) != -1)
	{
		new var1;
		if (!(!IsValidEdict(iEntity) || !IsValidEntity(iEntity)))
		{
			if (IsCan(iEntity))
			{
				AcceptEntityInput(iEntity, "Kill", -1, -1, 0);
			}
		}
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "01/22/2013",
	time = "20:47:51"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_dhooks =
{
	name = "dhooks",
	file = "dhooks.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "L4D2 Pounce Protect",
	description = "Prevent damage from blocking a hunter's ability to pounce",
	author = "ProdigySim",
	version = "1.0",
	url = "http://www.l4dnation.com/"
};
new Handle:hCBaseAbility_OnOwnerTakeDamage;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	new Handle:gameConf = LoadGameConfigFile("l4d_pounceprotect");
	new OnOwnerTakeDamageOffset = GameConfGetOffset(gameConf, "CBaseAbility_OnOwnerTakeDamage");
	hCBaseAbility_OnOwnerTakeDamage = DHookCreate(OnOwnerTakeDamageOffset, HookType:0, ReturnType:1, ThisPointerType:0, CBaseAbility_OnOwnerTakeDamage);
	DHookAddParam(hCBaseAbility_OnOwnerTakeDamage, HookParamType:9);
	DHookAddEntityListener(ListenType:0, OnEntityCreated);
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	if (StrEqual(classname, "ability_lunge", true))
	{
		DHookEntity(hCBaseAbility_OnOwnerTakeDamage, false, entity, DHookRemovalCB:-1);
	}
	return 0;
}

public MRESReturn:CBaseAbility_OnOwnerTakeDamage(Handle:hParams)
{
	return MRESReturn:3;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.3",
	date = "11/21/2012",
	time = "05:27:03"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "sdkhooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new bool:bLateLoad;
new Handle:cvar_siSlowdown;
new Handle:cvar_tankSlowdown;
public Plugin:myinfo =
{
	name = "L4D2 Remove Special Infected Slowdown",
	description = "Removes the slow down from special infected",
	author = "Jahze",
	version = "1.2",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	cvar_siSlowdown = CreateConVar("l4d_si_slowdown", "1", "Enables/disables removal of the slow down that weapons to do special infected", 262144, false, 0.0, false, 0.0);
	cvar_tankSlowdown = CreateConVar("l4d_si_slowdown_tank", "1", "Enables/disables removal of the slow down that weapons do to tanks", 262144, false, 0.0, false, 0.0);
	if (bLateLoad)
	{
		new i = 1;
		while (MaxClients + 1 > i)
		{
			if (IsClientInGame(i))
			{
				SDKHook(i, SDKHookType:3, SiSlowdown);
			}
			i++;
		}
	}
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:3, SiSlowdown);
	return 0;
}

public Action:SiSlowdown(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new zc = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
	new var1;
	if (GetConVarBool(cvar_siSlowdown) && IsSi(victim) && zc != 8)
	{
		SetEntPropFloat(victim, PropType:0, "m_flVelocityModifier", 1.0, 0);
	}
	else
	{
		new var2;
		if (GetConVarBool(cvar_tankSlowdown) && IsSi(victim))
		{
			SetEntPropFloat(victim, PropType:0, "m_flVelocityModifier", 1.0, 0);
		}
	}
	return Action:0;
}

bool:IsSi(client)
{
	new var1;
	if (IsClientConnected(client) && IsClientInGame(client) && GetClientTeam(client) == 3)
	{
		return true;
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.3.9-dev",
	date = "10/29/2011",
	time = "22:29:49"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Stuck Zombie Melee Fix",
	description = "Smash nonstaggering Zombies",
	author = "AtomicStryker",
	version = "1.0.4",
	url = "http://forums.alliedmods.net/showthread.php?p=932416"
};
new bool:MeleeDelay[66];
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:operator>(Float:,_:)(Float:oper1, oper2)
{
	return FloatCompare(oper1, float(oper2)) > 0;
}

bool:operator<(Float:,_:)(Float:oper1, oper2)
{
	return FloatCompare(oper1, float(oper2)) < 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	HookEvent("entity_shoved", Event_EntShoved, EventHookMode:1);
	AddNormalSoundHook(HookSound_Callback);
	CreateConVar("l4d_stuckzombiemeleefix_version", "1.0.4", " Version of L4D Stuck Zombie Melee Fix on this server ", 393536, false, 0.0, false, 0.0);
	return 0;
}

public Action:HookSound_Callback(Clients[64], &NumClients, String:StrSample[256], &Entity)
{
	if (StrContains(StrSample, "Swish", false) == -1)
	{
		return Action:0;
	}
	if (Entity > 65)
	{
		return Action:0;
	}
	if (MeleeDelay[Entity])
	{
		return Action:0;
	}
	MeleeDelay[Entity] = 1;
	CreateTimer(1.0, ResetMeleeDelay, Entity, 0);
	new entid = GetClientAimTarget(Entity, false);
	if (0 >= entid)
	{
		return Action:0;
	}
	decl String:entclass[96];
	GetEntityNetClass(entid, entclass, 96);
	if (!StrEqual(entclass, "Infected", true))
	{
		return Action:0;
	}
	decl Float:clientpos[3];
	decl Float:entpos[3];
	GetEntityAbsOrigin(entid, entpos);
	GetClientEyePosition(Entity, clientpos);
	if (GetVectorDistance(clientpos, entpos, false) < 50)
	{
		return Action:0;
	}
	new Handle:newEvent = CreateEvent("entity_shoved", true);
	SetEventInt(newEvent, "attacker", Entity);
	SetEventInt(newEvent, "entityid", entid);
	FireEvent(newEvent, true);
	return Action:0;
}

public Action:ResetMeleeDelay(Handle:timer, any:client)
{
	MeleeDelay[client] = 0;
	return Action:0;
}

public Event_EntShoved(Handle:event, String:name[], bool:dontBroadcast)
{
	new entid = GetEventInt(event, "entityid");
	decl String:entclass[96];
	GetEntityNetClass(entid, entclass, 96);
	if (!StrEqual(entclass, "Infected", true))
	{
		return 0;
	}
	new Handle:data = CreateDataPack();
	CreateTimer(0.5, CheckForMovement, data, 0);
	WritePackCell(data, entid);
	decl Float:pos[3];
	GetEntityAbsOrigin(entid, pos);
	WritePackFloat(data, pos[0]);
	WritePackFloat(data, pos[1]);
	WritePackFloat(data, pos[2]);
	return 0;
}

public Action:CheckForMovement(Handle:timer, Handle:data)
{
	ResetPack(data, false);
	new zombieid = ReadPackCell(data);
	if (!IsValidEntity(zombieid))
	{
		return Action:3;
	}
	decl String:entclass[96];
	GetEntityNetClass(zombieid, entclass, 96);
	if (!StrEqual(entclass, "Infected", true))
	{
		return Action:3;
	}
	decl Float:oldpos[3];
	oldpos[0] = ReadPackFloat(data);
	oldpos[1] = ReadPackFloat(data);
	oldpos[2] = ReadPackFloat(data);
	CloseHandle(data);
	decl Float:newpos[3];
	GetEntityAbsOrigin(zombieid, newpos);
	if (GetVectorDistance(oldpos, newpos, false) > 5)
	{
		return Action:3;
	}
	new zombiehealth = GetEntProp(zombieid, PropType:1, "m_iHealth", 4);
	new zombiehealthmax = GetConVarInt(FindConVar("z_health"));
	if (0 >= zombiehealth - zombiehealthmax / 2)
	{
		AcceptEntityInput(zombieid, "BecomeRagdoll", -1, -1, 0);
	}
	else
	{
		SetEntProp(zombieid, PropType:1, "m_iHealth", zombiehealth - zombiehealthmax / 2, 4);
	}
	return Action:3;
}

public Action:GetEntityAbsOrigin(entity, Float:origin[3])
{
	decl Float:mins[3];
	decl Float:maxs[3];
	GetEntPropVector(entity, PropType:0, "m_vecOrigin", origin);
	GetEntPropVector(entity, PropType:0, "m_vecMins", mins);
	GetEntPropVector(entity, PropType:0, "m_vecMaxs", maxs);
	new var1 = origin;
	var1[0] = var1[0] + mins[0] + maxs[0] * 0.5;
	origin[1] += mins[1] + maxs[1] * 0.5;
	origin[2] += mins[2] + maxs[2] * 0.5;
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "12/10/2015",
	time = "12:51:29"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new bool:g_bLateLoad;
new Handle:g_hInflictorTrie;
new Float:g_fPlayerPunch[66];
new bool:g_bPlayerFlight[66];
new Float:g_fPlayerStuck[66];
new Float:g_fPlayerLocation[66][3];
new Handle:g_hCvarDeStuckTime;
new Handle:tpsf_debug_print;
public Plugin:myinfo =
{
	name = "Tank Punch Ceiling Stuck Fix",
	description = "Fixes the problem where tank-punches get a survivor stuck in the roof.",
	author = "Tabun, Visor",
	version = "0.3",
	url = "https://github.com/jacob404/Pro-Mod-4.0/releases/latest"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator==(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) == 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator!(Float:)(Float:oper)
{
	return oper & -1 == 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 2);
	new index = CFormat(szCMessage, 250, -1);
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			if (index == -1)
			{
				PrintToChat(i, szCMessage);
			}
			CSayText2(i, index, szCMessage);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	BfWriteByte(hBuffer, author);
	BfWriteByte(hBuffer, 1);
	BfWriteString(hBuffer, szMessage);
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	g_bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	if (g_bLateLoad)
	{
		new i = 1;
		while (MaxClients + 1 > i)
		{
			if (IsClientInGame(i))
			{
				SDKHook(i, SDKHookType:2, OnTakeDamage);
			}
			i++;
		}
	}
	g_hCvarDeStuckTime = CreateConVar("sm_punchstuckfix_unstucktime", "1.0", "How many seconds to wait before detecting and unstucking a punched motionless player.", 262144, true, 0.05, false, 0.0);
	tpsf_debug_print = CreateConVar("tpsf_debug_print", "1", "Enable the Debug Print?", 262144, true, 0.0, true, 1.0);
	HookEvent("round_start", RoundStart_Event, EventHookMode:2);
	g_hInflictorTrie = BuildInflictorTrie();
	return 0;
}

public OnClientPostAdminCheck(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnMapStart()
{
	setCleanSlate();
	return 0;
}

public Action:RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	setCleanSlate();
	return Action:0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (!inflictor || !attacker || !IsSurvivor(victim) || !IsValidEdict(inflictor))
	{
		return Action:0;
	}
	decl String:classname[64];
	new var2;
	if (IsClientAndInGame(attacker) && IsClientAndInGame(victim) && GetClientTeam(victim) == 2)
	{
		if (inflictor == attacker)
		{
			GetClientWeapon(inflictor, classname, 64);
		}
		else
		{
			GetEdictClassname(inflictor, classname, 64);
		}
		new eTankWeapon:inflictorID;
		if (!GetTrieValue(g_hInflictorTrie, classname, inflictorID))
		{
			return Action:0;
		}
		g_fPlayerPunch[victim] = GetTickedTime();
		g_bPlayerFlight[victim] = 0;
		g_fPlayerStuck[victim] = 0;
		g_fPlayerLocation[victim][0] = 0.0;
		g_fPlayerLocation[victim][1] = 0.0;
		g_fPlayerLocation[victim][2] = 0.0;
		CreateTimer(0.025, Timer_CheckPunch, victim, 3);
		return Action:0;
	}
	return Action:0;
}

public Action:Timer_CheckPunch(Handle:hTimer, any:client)
{
	if (!IsSurvivor(client))
	{
		return Action:4;
	}
	new var1;
	if (GetTickedTime() - g_fPlayerPunch[client] > 1056964608 && g_fPlayerStuck[client])
	{
		g_fPlayerPunch[client] = 0;
		g_bPlayerFlight[client] = 0;
		g_fPlayerStuck[client] = 0;
		return Action:4;
	}
	new iSeq = GetEntProp(client, PropType:0, "m_nSequence", 4, 0);
	new var2;
	if (iSeq == 629 || iSeq == 634 || iSeq == 637 || iSeq == 537 || iSeq == 540 || iSeq == 546)
	{
		new Float:vOrigin[3] = 0.0;
		GetEntPropVector(client, PropType:0, "m_vecOrigin", vOrigin, 0);
		if (!g_bPlayerFlight[client])
		{
			g_bPlayerFlight[client] = 1;
			PrintDebug("[test] %i - flight start [seq:%4i][loc:%.f %.f %.f]", client, iSeq, vOrigin, vOrigin[1], vOrigin[2]);
		}
		else
		{
			if (0 == GetVectorDistance(g_fPlayerLocation[client], vOrigin, false))
			{
				if (!g_fPlayerStuck[client])
				{
					if (GetTickedTime() - g_fPlayerStuck[client] > GetConVarFloat(g_hCvarDeStuckTime))
					{
						PrintDebug("[test] %i - stuckness FIX triggered!", client);
						g_fPlayerPunch[client] = 0;
						g_bPlayerFlight[client] = 0;
						g_fPlayerStuck[client] = 0;
						CTerrorPlayer_WarpToValidPositionIfStuck(client);
						if (GetConVarBool(tpsf_debug_print))
						{
							CPrintToChatAll("<{olive}TankPunchStuck{default}> Found {blue}%N{default} stuck after a punch. Warped him to a valid position.", client);
						}
						return Action:4;
					}
				}
				else
				{
					g_fPlayerStuck[client] = GetTickedTime();
					PrintDebug("[test] %i - stuck start [loc:%.f %.f %.f]", client, vOrigin, vOrigin[1], vOrigin[2]);
				}
			}
			if (g_fPlayerStuck[client])
			{
				g_fPlayerStuck[client] = 0;
				PrintDebug("[test] %i - stuck end (previously detected, now gone) [loc:%.f %.f %.f]", client, vOrigin, vOrigin[1], vOrigin[2]);
			}
		}
	}
	else
	{
		new var3;
		if (iSeq == 630 || iSeq == 635 || iSeq == 638 || iSeq == 538 || iSeq == 541 || iSeq == 547)
		{
			if (g_bPlayerFlight[client])
			{
				g_fPlayerPunch[client] = 0;
				g_bPlayerFlight[client] = 0;
				g_fPlayerStuck[client] = 0;
				PrintDebug("[test] %i - flight end (natural)", client);
			}
			return Action:4;
		}
	}
	return Action:0;
}

bool:IsClientAndInGame(index)
{
	new var1;
	return index > 0 && index <= MaxClients && IsClientInGame(index);
}

bool:IsSurvivor(client)
{
	if (IsClientAndInGame(client))
	{
		return GetClientTeam(client) == 2;
	}
	return false;
}

setCleanSlate()
{
	new i;
	new maxplayers = MaxClients;
	i = 1;
	while (i <= maxplayers)
	{
		g_fPlayerPunch[i] = 0;
		g_bPlayerFlight[i] = 0;
		g_fPlayerStuck[i] = 0;
		g_fPlayerLocation[i][0] = 0.0;
		g_fPlayerLocation[i][1] = 0.0;
		g_fPlayerLocation[i][2] = 0.0;
		i++;
	}
	return 0;
}

public PrintDebug(String:Message[])
{
	return 0;
}

Handle:BuildInflictorTrie()
{
	new Handle:trie = CreateTrie();
	SetTrieValue(trie, "weapon_tank_claw", any:0, true);
	return trie;
}

CTerrorPlayer_WarpToValidPositionIfStuck(client)
{
	static Handle:WarpToValidPositionSDKCall;
	if (!WarpToValidPositionSDKCall)
	{
		StartPrepSDKCall(SDKCallType:2);
		if (!PrepSDKCall_SetSignature(SDKLibrary:0, "@_ZN13CTerrorPlayer26WarpToValidPositionIfStuckEv", 0))
		{
			return 0;
		}
		WarpToValidPositionSDKCall = EndPrepSDKCall();
		if (!WarpToValidPositionSDKCall)
		{
			return 0;
		}
	}
	SDKCall(WarpToValidPositionSDKCall, client, 0);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "09/03/2016",
	time = "15:48:07"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1919311725, 1920234357, 1869182049, 110, 845427820, 1818850421, 0, 845427820, 1818850421, 2020438830, 0, 1324, 1336, 1, 0, 845427820, 1919509599, 7627621, 0, 1919501379, 1869898597, 114, 0, 1919501379, 1869898597, 1919243890, 1299412339, 6644847, 0, 1919501379, 1869898597, 1832532594, 1632921951, 1632660334, 1684370291, 1853189955, 116, 0, 1919501379, 1869898597, 1919243890, 1299412339, 979723375, 1767861562, 1886216515, 1852270945, 1919902547, 29541, 1919243331, 1349676914, 1702453612, 1832532594, 1632921951, 1767140206, 1952803683, 115
};
new Handle:hSurvivorModelsTrie = 1919311725;
new Handle:hWeaponNamesTrie = 845427820;
public SharedPlugin:__pl_l4d2util =
{
	name = "l4d2util",
	file = "l4d2util.smx",
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 1,
};
new Handle:h_whosHadTank;
new String:queuedTankSteamId[64];
new Handle:hTankPrint;
new Handle:hTankDebug;
public Plugin:myinfo =
{
	name = "L4D2 Tank Control",
	description = "Distributes the role of the tank evenly throughout the team",
	author = "arti",
	version = "0.0.16",
	url = "https://github.com/alexberriman/l4d2-plugins/tree/master/l4d_tank_control"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

ReplyToTargetError(client, reason)
{
	switch (reason)
	{
		case -7:
		{
			ReplyToCommand(client, "[SM] %t", "More than one client matched");
		}
		case -6:
		{
			ReplyToCommand(client, "[SM] %t", "Cannot target bot");
		}
		case -5:
		{
			ReplyToCommand(client, "[SM] %t", "No matching clients");
		}
		case -4:
		{
			ReplyToCommand(client, "[SM] %t", "Unable to target");
		}
		case -3:
		{
			ReplyToCommand(client, "[SM] %t", "Target is not in game");
		}
		case -2:
		{
			ReplyToCommand(client, "[SM] %t", "Target must be dead");
		}
		case -1:
		{
			ReplyToCommand(client, "[SM] %t", "Target must be alive");
		}
		case 0:
		{
			ReplyToCommand(client, "[SM] %t", "No matching client");
		}
		default:
		{
		}
	}
	return 0;
}

FindTarget(client, String:target[], bool:nobots, bool:immunity)
{
	decl String:target_name[64];
	decl target_list[1];
	decl target_count;
	decl bool:tn_is_ml;
	new flags = 16;
	if (nobots)
	{
		flags |= 32;
	}
	if (!immunity)
	{
		flags |= 8;
	}
	if (0 < (target_count = ProcessTargetString(target, client, target_list, 1, flags, target_name, 64, tn_is_ml)))
	{
		return target_list[0];
	}
	ReplyToTargetError(client, target_count);
	return -1;
}

bool:IsInfected(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 3)
	{
		return false;
	}
	return true;
}

SetTankFrustration(iTankClient, iFrustration)
{
	new var1;
	if (iFrustration < 0 || iFrustration > 100)
	{
		return 0;
	}
	SetEntProp(iTankClient, PropType:0, L4D2_InfectedNames, 100 - iFrustration, 4, 0);
	return 0;
}

public __pl_l4d2util_SetNTVOptional()
{
	return 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetCDirector()
{
	static Address:TheDirector;
	if (!TheDirector)
	{
		TheDirector = GameConfGetAddress(L4D2Direct_GetGameConf(), "CDirector");
	}
	return TheDirector;
}

Address:L4D2Direct_GetCDirectorVersusMode()
{
	static Address:pVersusModeDirector;
	if (!pVersusModeDirector)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode");
		if (offs == -1)
		{
			return Address:0;
		}
		pVersusModeDirector = L4D2Direct_GetCDirector() + offs;
		pVersusModeDirector = LoadFromAddress(pVersusModeDirector, NumberType:2);
	}
	return pVersusModeDirector;
}

Address:L4D2Direct_GetTankPassedCountAddr()
{
	static Address:pTankPassedCount;
	if (!pTankPassedCount)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirector::m_iTankPassedCount");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankPassedCount = L4D2Direct_GetCDirector() + offs;
	}
	return pTankPassedCount;
}

Address:L4D2Direct_GetVSCampaignScoresAddr()
{
	static Address:pCampaignScores;
	if (!pCampaignScores)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_iCampaignScores");
		if (offs == -1)
		{
			return Address:0;
		}
		pCampaignScores = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pCampaignScores;
}

SetEntityValueFromOffset(entity, String:offset[], NumberType:size, value)
{
	new Address:pEntity = GetEntityAddress(entity);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), offset);
		if (offs == -1)
		{
			return 0;
		}
		StoreToAddress(offs + pEntity, value, size);
		return 1;
	}
	return 0;
}

L4D2Direct_GetTankPassedCount()
{
	return LoadFromAddress(L4D2Direct_GetTankPassedCountAddr(), NumberType:2);
}

L4D2Direct_SetTankPassedCount(passes)
{
	StoreToAddress(L4D2Direct_GetTankPassedCountAddr(), passes, NumberType:2);
	return 0;
}

L4D2Direct_GetVSCampaignScore(teamNumber)
{
	new var1;
	if (teamNumber < 0 || teamNumber > 1)
	{
		return -1;
	}
	return LoadFromAddress(teamNumber * 4 + L4D2Direct_GetVSCampaignScoresAddr(), NumberType:2);
}

L4D2Direct_SetTankTickets(client, tickets)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return 0;
	}
	SetEntityValueFromOffset(client, "CTerrorPlayer::m_iTankTickets", NumberType:2, tickets);
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public OnPluginStart()
{
	LoadTranslations("common.phrases");
	HookEvent("player_left_start_area", PlayerLeftStartArea_Event, EventHookMode:2);
	HookEvent("round_end", RoundEnd_Event, EventHookMode:2);
	HookEvent("player_team", PlayerTeam_Event, EventHookMode:2);
	HookEvent("tank_killed", TankKilled_Event, EventHookMode:2);
	HookEvent("player_death", PlayerDeath_Event, EventHookMode:1);
	h_whosHadTank = CreateArray(64, 0);
	RegAdminCmd("sm_tankshuffle", TankShuffle_Cmd, 32, "Re-picks at random someone to become tank.", "", 0);
	RegAdminCmd("sm_givetank", GiveTank_Cmd, 32, "Gives the tank to a selected player", "", 0);
	RegConsoleCmd("sm_tank", Tank_Cmd, "Shows who is becoming the tank.", 0);
	RegConsoleCmd("sm_boss", Tank_Cmd, "Shows who is becoming the tank.", 0);
	RegConsoleCmd("sm_witch", Tank_Cmd, "Shows who is becoming the tank.", 0);
	hTankPrint = CreateConVar("tankcontrol_print_all", "0", "Who gets to see who will become the tank? (0 = Infected, 1 = Everyone)", 262144, false, 0.0, false, 0.0);
	hTankDebug = CreateConVar("tankcontrol_debug", "0", "Whether or not to debug to console", 262144, false, 0.0, false, 0.0);
	return 0;
}

public OnClientDisconnect(client)
{
	decl String:tmpSteamId[64];
	if (client)
	{
		GetClientAuthString(client, tmpSteamId, 64, true);
		if (!(strcmp(queuedTankSteamId, tmpSteamId, true)))
		{
			chooseTank();
			outputTankToAll();
		}
	}
	return 0;
}

public OnRoundStart()
{
	CreateTimer(10.0, newGame, any:0, 0);
	return 0;
}

public Action:newGame(Handle:timer)
{
	new teamAScore = L4D2Direct_GetVSCampaignScore(0);
	new teamBScore = L4D2Direct_GetVSCampaignScore(1);
	new var1;
	if (teamAScore && teamBScore)
	{
		h_whosHadTank = CreateArray(64, 0);
	}
	return Action:0;
}

public RoundEnd_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	return 0;
}

public PlayerLeftStartArea_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	chooseTank();
	outputTankToAll();
	return 0;
}

public PlayerTeam_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new L4D2Team:oldTeam = GetEventInt(event, "oldteam");
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	decl String:tmpSteamId[64];
	new var1;
	if (client && oldTeam == L4D2Team:3)
	{
		GetClientAuthString(client, tmpSteamId, 64, true);
		if (!(strcmp(queuedTankSteamId, tmpSteamId, true)))
		{
			chooseTank();
			outputTankToAll();
		}
	}
	return 0;
}

public PlayerDeath_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new zombieClass;
	new victimId = GetEventInt(event, "userid");
	new victim = GetClientOfUserId(victimId);
	new var1;
	if (victimId && IsClientInGame(victim))
	{
		zombieClass = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
		if (zombieClass == 8)
		{
			if (GetConVarBool(hTankDebug))
			{
				PrintToConsoleAll("[TC] Tank died(1), choosing a new tank");
			}
			chooseTank();
		}
	}
	return 0;
}

public TankKilled_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (GetConVarBool(hTankDebug))
	{
		PrintToConsoleAll("[TC] Tank died(2), choosing a new tank");
	}
	chooseTank();
	return 0;
}

public Action:Tank_Cmd(client, args)
{
	new tankClientId;
	decl String:tankClientName[128];
	if (!strcmp(queuedTankSteamId, "", true))
	{
		return Action:3;
	}
	tankClientId = getInfectedPlayerBySteamId(queuedTankSteamId);
	if (tankClientId != -1)
	{
		GetClientName(tankClientId, tankClientName, 128);
		new var1;
		if (GetClientTeam(client) == 3 || IsClientCaster(client))
		{
			if (tankClientId == client)
			{
				CPrintToChat(client, "{red}<{default}Tank Selection{red}> {green}You {default}will become the {red}Tank{default}!");
			}
			CPrintToChat(client, "{red}<{default}Tank Selection{red}> {olive}%s {default}will become the {red}Tank!", tankClientName);
		}
	}
	return Action:3;
}

public Action:TankShuffle_Cmd(client, args)
{
	chooseTank();
	outputTankToAll();
	return Action:3;
}

public Action:GiveTank_Cmd(client, args)
{
	new String:arg1[32];
	GetCmdArg(1, arg1, 32);
	new target = FindTarget(client, arg1, false, true);
	if (target == -1)
	{
		return Action:3;
	}
	new String:name[32];
	GetClientName(target, name, 32);
	new var1;
	if (IsClientConnected(target) && IsClientInGame(target) && !IsFakeClient(target))
	{
		if (GetClientTeam(target) != 3)
		{
			CPrintToChatAll("{olive}[SM] {default}%s not on infected. Unable to give tank", name);
			return Action:3;
		}
		decl String:steamId[64];
		GetClientAuthString(target, steamId, 64, true);
		outputTankToAll();
	}
	return Action:3;
}

public chooseTank()
{
	new Handle:infectedPool = teamSteamIds(L4D2Team:3);
	if (GetArraySize(infectedPool))
	{
		infectedPool = removeTanksFromPool(infectedPool, h_whosHadTank);
		if (GetArraySize(infectedPool))
		{
			new rndIndex = GetRandomInt(0, GetArraySize(infectedPool) + -1);
			GetArrayString(infectedPool, rndIndex, queuedTankSteamId, 64);
			return 0;
		}
		new Handle:infectedTeam = teamSteamIds(L4D2Team:3);
		if (GetArraySize(infectedTeam) > 1)
		{
			h_whosHadTank = removeTanksFromPool(h_whosHadTank, teamSteamIds(L4D2Team:3));
			chooseTank();
		}
		return 0;
	}
	return 0;
}

public Action:L4D_OnTryOfferingTankBot(tank_index, &bool:enterStatis)
{
	if (!IsFakeClient(tank_index))
	{
		PrintHintText(tank_index, "Rage Meter Refilled");
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (!IsClientInGame(i) || !IsInfected(i))
			{
			}
			else
			{
				if (i == tank_index)
				{
					CPrintToChat(i, "{red}<{default}Tank Rage{red}> {olive}Rage Meter {red}Refilled");
				}
				else
				{
					CPrintToChat(i, "{red}<{default}Tank Rage{red}> {default}({green}%N{default}'s) {olive}Rage Meter {red}Refilled", tank_index);
				}
			}
			i++;
		}
		SetTankFrustration(tank_index, 100);
		L4D2Direct_SetTankPassedCount(L4D2Direct_GetTankPassedCount() + 1);
		return Action:3;
	}
	if (!strcmp(queuedTankSteamId, "", true))
	{
		chooseTank();
	}
	if (strcmp(queuedTankSteamId, "", true))
	{
		setTankTickets(queuedTankSteamId, 20000);
		PushArrayString(h_whosHadTank, queuedTankSteamId);
	}
	return Action:0;
}

public setTankTickets(String:steamId[], tickets)
{
	new tankClientId = getInfectedPlayerBySteamId(steamId);
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientConnected(i) && IsClientInGame(i) && !IsFakeClient(i) && IsInfected(i))
		{
			new var2;
			if (tankClientId == i)
			{
				var2 = tickets;
			}
			else
			{
				var2 = 0;
			}
			L4D2Direct_SetTankTickets(i, var2);
		}
		i++;
	}
	return 0;
}

public outputTankToAll()
{
	decl String:tankClientName[128];
	new tankClientId = getInfectedPlayerBySteamId(queuedTankSteamId);
	if (tankClientId != -1)
	{
		GetClientName(tankClientId, tankClientName, 128);
		if (GetConVarBool(hTankPrint))
		{
			CPrintToChatAll("{red}<{default}Tank Selection{red}> {olive}%s {default}will become the {red}Tank!", tankClientName);
		}
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && (GetClientTeam(i) == 3 && ((i > 0 && i <= MaxClients) && IsClientInGame(i) && IsClientCaster(i))))
			{
			}
		}
	}
	return 0;
}

public Handle:teamSteamIds(L4D2Team:team)
{
	new Handle:steamIds = CreateArray(64, 0);
	decl String:steamId[64];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientConnected(i) && IsClientInGame(i) && !IsFakeClient(i))
		{
			if (!(team != GetClientTeam(i)))
			{
				GetClientAuthString(i, steamId, 64, true);
				PushArrayString(steamIds, steamId);
			}
			i++;
		}
		i++;
	}
	return steamIds;
}

public Handle:removeTanksFromPool(Handle:steamIdTankPool, Handle:tanks)
{
	decl index;
	decl String:steamId[64];
	new i;
	while (GetArraySize(tanks) > i)
	{
		GetArrayString(tanks, i, steamId, 64);
		index = FindStringInArray(steamIdTankPool, steamId);
		if (index != -1)
		{
			RemoveFromArray(steamIdTankPool, index);
		}
		i++;
	}
	return steamIdTankPool;
}

public getInfectedPlayerBySteamId(String:steamId[])
{
	decl String:tmpSteamId[64];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (!IsClientConnected(i) || !IsInfected(i))
		{
		}
		else
		{
			GetClientAuthString(i, tmpSteamId, 64, true);
			if (StrEqual(steamId, tmpSteamId, true))
			{
				return i;
			}
		}
		i++;
	}
	return -1;
}

PrintToConsoleAll(String:format[])
{
	decl String:text[192];
	new x = 1;
	while (x <= MaxClients)
	{
		if (IsClientInGame(x))
		{
			SetGlobalTransTarget(x);
			VFormat(text, 192, format, 2);
			PrintToConsole(x, text);
		}
		x++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5292",
	date = "03/13/2016",
	time = "11:13:49"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new TEAM_SURVIVOR = 2;
new TEAM_INFECTED = 3;
new ZOMBIECLASS_TANK = 8;
new bool:g_bEnabled = 1;
new bool:g_bAnnounceTankDamage;
new bool:g_bIsTankInPlay;
new bool:bPrintedHealth;
new g_iWasTank[66];
new g_iWasTankAI;
new g_iOffset_Incapacitated;
new g_iTankClient;
new g_iLastTankHealth;
new g_iSurvivorLimit = 4;
new g_iDamage[66];
new Float:g_fMaxTankHealth = 1169915904;
new Handle:g_hCvarEnabled;
new Handle:g_hCvarTankHealth;
new Handle:g_hCvarSurvivorLimit;
new Handle:fwdOnTankDeath;
public Plugin:myinfo =
{
	name = "Tank Damage Announce L4D2",
	description = "Announce damage dealt to tanks by survivors",
	author = "Griffin and Blade",
	version = "0.6.6",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public void:OnPluginStart()
{
	g_bIsTankInPlay = false;
	g_bAnnounceTankDamage = false;
	g_iTankClient = 0;
	ClearTankDamage();
	HookEvent("tank_spawn", Event_TankSpawn, EventHookMode:1);
	HookEvent("player_death", Event_PlayerKilled, EventHookMode:1);
	HookEvent("round_start", Event_RoundStart, EventHookMode:1);
	HookEvent("round_end", Event_RoundEnd, EventHookMode:1);
	HookEvent("player_hurt", Event_PlayerHurt, EventHookMode:1);
	g_hCvarEnabled = CreateConVar("l4d_tankdamage_enabled", "1", "Announce damage done to tanks when enabled", 262464, true, 0.0, true, 1.0);
	g_hCvarSurvivorLimit = FindConVar("survivor_limit");
	g_hCvarTankHealth = FindConVar("z_tank_health");
	HookConVarChange(g_hCvarEnabled, Cvar_Enabled);
	HookConVarChange(g_hCvarSurvivorLimit, Cvar_SurvivorLimit);
	HookConVarChange(g_hCvarTankHealth, Cvar_TankHealth);
	HookConVarChange(FindConVar("mp_gamemode"), Cvar_TankHealth);
	g_bEnabled = GetConVarBool(g_hCvarEnabled);
	CalculateTankHealth();
	g_iOffset_Incapacitated = FindSendPropInfo("Tank", "m_isIncapacitated", 0, 0, 0);
	fwdOnTankDeath = CreateGlobalForward("OnTankDeath", ExecType:2);
	return void:0;
}

public void:OnMapStart()
{
	ClearTankDamage();
	PrecacheSound("ui/pickup_secret01.wav", false);
	return void:0;
}

public void:OnClientDisconnect_Post(client)
{
	new var1;
	if (!g_bIsTankInPlay || g_iTankClient == client)
	{
		return void:0;
	}
	CreateTimer(0.1, Timer_CheckTank, client, 0);
	return void:0;
}

public Cvar_Enabled(Handle:convar, String:oldValue[], String:newValue[])
{
	new var1;
	if (StringToInt(newValue, 10) > 0)
	{
		var1 = 1;
	}
	else
	{
		var1 = 0;
	}
	g_bEnabled = var1;
	return 0;
}

public Cvar_SurvivorLimit(Handle:convar, String:oldValue[], String:newValue[])
{
	g_iSurvivorLimit = StringToInt(newValue, 10);
	return 0;
}

public Cvar_TankHealth(Handle:convar, String:oldValue[], String:newValue[])
{
	CalculateTankHealth();
	return 0;
}

CalculateTankHealth()
{
	new String:sGameMode[32];
	GetConVarString(FindConVar("mp_gamemode"), sGameMode, 32);
	new var1;
	if (StrEqual(sGameMode, "versus", true) || StrEqual(sGameMode, "mutation12", true))
	{
		g_fMaxTankHealth = GetConVarFloat(g_hCvarTankHealth) * 1.5;
	}
	else
	{
		g_fMaxTankHealth = GetConVarFloat(g_hCvarTankHealth);
	}
	if (g_fMaxTankHealth <= 0.0)
	{
		g_fMaxTankHealth = 1.0;
	}
	return 0;
}

public Event_PlayerHurt(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_bIsTankInPlay)
	{
		return 0;
	}
	new victim = GetClientOfUserId(GetEventInt(event, "userid", 0));
	new var1;
	if (GetTankClient() == victim && IsTankDying())
	{
		return 0;
	}
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker", 0));
	new var2;
	if (attacker && !IsClientInGame(attacker) && TEAM_SURVIVOR == GetClientTeam(attacker))
	{
		return 0;
	}
	new var3 = g_iDamage[attacker];
	var3 = var3[GetEventInt(event, "dmg_health", 0)];
	g_iLastTankHealth = GetEventInt(event, "health", 0);
	return 0;
}

public Event_PlayerKilled(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_bIsTankInPlay)
	{
		return 0;
	}
	new victim = GetClientOfUserId(GetEventInt(event, "userid", 0));
	if (g_iTankClient != victim)
	{
		return 0;
	}
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker", 0));
	new var1;
	if (attacker && IsClientInGame(attacker))
	{
		new var2 = g_iDamage[attacker];
		var2 = var2[g_iLastTankHealth];
	}
	if (!IsFakeClient(victim))
	{
		g_iWasTank[victim] = 1;
	}
	else
	{
		g_iWasTankAI = 1;
	}
	CreateTimer(0.1, Timer_CheckTank, victim, 0);
	return 0;
}

public Event_TankSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	g_iTankClient = client;
	if (g_bIsTankInPlay)
	{
		return 0;
	}
	EmitSoundToAll("ui/pickup_secret01.wav", -2, 0, 75, 0, 0.8, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
	g_bAnnounceTankDamage = true;
	g_bIsTankInPlay = true;
	g_iLastTankHealth = GetClientHealth(client);
	return 0;
}

public Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	bPrintedHealth = false;
	g_bIsTankInPlay = false;
	g_iTankClient = 0;
	ClearTankDamage();
	return 0;
}

public Event_RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bAnnounceTankDamage)
	{
		PrintRemainingHealth();
		PrintTankDamage();
	}
	ClearTankDamage();
	return 0;
}

public Action:Timer_CheckTank(Handle:timer, any:oldtankclient)
{
	if (oldtankclient != g_iTankClient)
	{
		return Action:0;
	}
	new tankclient = FindTankClient();
	new var1;
	if (tankclient && oldtankclient != tankclient)
	{
		g_iTankClient = tankclient;
		return Action:0;
	}
	if (g_bAnnounceTankDamage)
	{
		PrintTankDamage();
	}
	ClearTankDamage();
	g_bIsTankInPlay = false;
	Call_StartForward(fwdOnTankDeath);
	Call_Finish(0);
	return Action:0;
}

bool:IsTankDying()
{
	new tankclient = GetTankClient();
	if (!tankclient)
	{
		return false;
	}
	return GetEntData(tankclient, g_iOffset_Incapacitated, 4);
}

PrintRemainingHealth()
{
	bPrintedHealth = true;
	if (!g_bEnabled)
	{
		return 0;
	}
	new tankclient = GetTankClient();
	if (!tankclient)
	{
		return 0;
	}
	new String:name[32] = "AI";
	if (!(IsFakeClient(tankclient)))
	{
		GetClientName(tankclient, name, 32);
	}
	CPrintToChatAll("{default}[{green}!{default}] {blue}Tank {default}({olive}%s{default}) had {green}%d {default}health remaining", name, g_iLastTankHealth);
	return 0;
}

PrintTankDamage()
{
	if (!g_bEnabled)
	{
		return 0;
	}
	if (!bPrintedHealth)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (0 < g_iWasTank[i])
			{
				decl String:name[32];
				GetClientName(i, name, 32);
				CPrintToChatAll("{default}[{green}!{default}] {blue}Damage {default}dealt to {blue}Tank {default}({olive}%s{default})", name);
				g_iWasTank[i] = 0;
			}
			else
			{
				if (0 < g_iWasTankAI)
				{
					CPrintToChatAll("{default}[{green}!{default}] {blue}Damage {default}dealt to {blue}Tank {default}({olive}AI{default})");
				}
			}
			g_iWasTankAI = 0;
			i++;
		}
	}
	new client;
	new percent_total;
	new damage_total;
	new survivor_index = -1;
	new survivor_clients[g_iSurvivorLimit];
	decl percent_damage;
	decl damage;
	client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (!IsClientInGame(client) || TEAM_SURVIVOR == GetClientTeam(client) || g_iDamage[client])
		{
		}
		else
		{
			survivor_index++;
			survivor_clients[survivor_index] = client;
			damage = g_iDamage[client];
			damage_total = damage + damage_total;
			percent_damage = GetDamageAsPercent(damage);
			percent_total = percent_damage + percent_total;
		}
		client++;
	}
	SortCustom1D(survivor_clients, g_iSurvivorLimit, SortByDamageDesc, Handle:0);
	new percent_adjustment;
	new var2;
	if (percent_total < 100 && float(damage_total) > g_fMaxTankHealth - g_fMaxTankHealth / 200.0)
	{
		percent_adjustment = 100 - percent_total;
	}
	new last_percent = 100;
	decl adjusted_percent_damage;
	new k;
	while (k <= survivor_index)
	{
		client = survivor_clients[k];
		damage = g_iDamage[client];
		percent_damage = GetDamageAsPercent(damage);
		new var3;
		if (percent_adjustment && damage > 0 && !IsExactPercent(damage))
		{
			adjusted_percent_damage = percent_adjustment + percent_damage;
			if (adjusted_percent_damage <= last_percent)
			{
				percent_damage = adjusted_percent_damage;
				percent_adjustment = 0;
			}
		}
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				CPrintToChat(i, "{blue}[{default}%d{blue}] ({default}%i%%{blue}) {olive}%N", damage, percent_damage, client);
			}
			i++;
		}
		k++;
	}
	return 0;
}

ClearTankDamage()
{
	g_iLastTankHealth = 0;
	g_iWasTankAI = 0;
	new i = 1;
	while (i <= MaxClients)
	{
		g_iDamage[i] = 0;
		g_iWasTank[i] = 0;
		i++;
	}
	g_bAnnounceTankDamage = false;
	return 0;
}

GetTankClient()
{
	if (!g_bIsTankInPlay)
	{
		return 0;
	}
	new tankclient = g_iTankClient;
	if (!IsClientInGame(tankclient))
	{
		tankclient = FindTankClient();
		if (!tankclient)
		{
			return 0;
		}
		g_iTankClient = tankclient;
	}
	return tankclient;
}

FindTankClient()
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (!(!IsClientInGame(client) || TEAM_INFECTED == GetClientTeam(client) || !IsPlayerAlive(client) || ZOMBIECLASS_TANK == GetEntProp(client, PropType:0, "m_zombieClass", 4, 0)))
		{
			return client;
		}
		client++;
	}
	return 0;
}

GetDamageAsPercent(damage)
{
	return RoundToFloor(float(damage) / g_fMaxTankHealth * 100.0);
}

bool:IsExactPercent(damage)
{
	new var1;
	if (FloatAbs(float(GetDamageAsPercent(damage)) - float(damage) / g_fMaxTankHealth * 100.0) < 0.001)
	{
		var1 = true;
	}
	else
	{
		var1 = false;
	}
	return var1;
}

public SortByDamageDesc(elem1, elem2, array[], Handle:hndl)
{
	if (g_iDamage[elem2] < g_iDamage[elem1])
	{
		return -1;
	}
	if (g_iDamage[elem1] < g_iDamage[elem2])
	{
		return 1;
	}
	if (elem1 > elem2)
	{
		return -1;
	}
	if (elem2 > elem1)
	{
		return 1;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "04/06/2014",
	time = "16:03:55"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new String:L4D2_InfectedNames[8][32];
new String:MeleeWeaponModels[15][];
new String:MeleeWeaponNames[15][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1414218835, 1936486255, 0, 1953195123, 1936486255, 1954047278, 0, 992, 1004, 1, 1, 1919311725, 1920234357, 1869182049, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new Handle:hSurvivorModelsTrie = 1919311725;
new bool:CEventIsHooked;
new bool:CSkipList[66];
new String:CTag[6][] =
{
	"",
	"",
	"",
	"",
	"",
	""
};
new String:CTagCode[6][16];
new bool:CTagReqSayText2[6];
new Handle:hMeleeWeaponModelsTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hWeaponNamesTrie;
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new Handle:cvarSmallRefill;
public Plugin:myinfo =
{
	name = "L4D2 Tank Hittable Refill",
	description = "Refill Tank's frustration whenever a hittable hits a Survivor",
	author = "Sir",
	version = "1",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

SetTankFrustration(iTankClient, iFrustration)
{
	new var1;
	if (iFrustration < 0 || iFrustration > 100)
	{
		return 0;
	}
	SetEntProp(iTankClient, PropType:0, L4D2_InfectedTimerEntities, 100 - iFrustration, 4, 0);
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CEventIsHooked[i] = false;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	cvarSmallRefill = CreateConVar("l4d_tank_hittable_small", "0", "Do we allow Small hittables such as Garbage Bins and Tables to refill frustration?", 0, false, 0.0, false, 0.0);
	HookEvent("player_hurt", PlayerHurt, EventHookMode:1);
	HookEvent("player_incapacitated", PlayerIncap, EventHookMode:1);
	return 0;
}

public PlayerHurt(Handle:event, String:name[], bool:dontBroadcast)
{
	new Victim = GetClientOfUserId(GetEventInt(event, "userid"));
	new Attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new dmg = GetEventInt(event, "dmg_health");
	if (!CheckForTank(Attacker, Victim))
	{
		return 0;
	}
	new var1;
	if (dmg < 5 && GetConVarInt(cvarSmallRefill))
	{
		return 0;
	}
	SetTankFrustration(Attacker, 100);
	return 0;
}

public PlayerIncap(Handle:event, String:name[], bool:dontBroadcast)
{
	new Victim = GetClientOfUserId(GetEventInt(event, "userid"));
	new Attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	if (!CheckForTank(Attacker, Victim))
	{
		return 0;
	}
	SetTankFrustration(Attacker, 100);
	return 0;
}

bool:IsLegitClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return false;
	}
	if (!IsClientInGame(client))
	{
		return false;
	}
	return true;
}

bool:CheckForTank(Attacker, Victim)
{
	new var1;
	if (!IsLegitClient(Victim) || !IsLegitClient(Attacker))
	{
		return false;
	}
	new var2;
	if (GetClientTeam(Victim) == 2 && GetClientTeam(Attacker) == 3)
	{
		return false;
	}
	if (GetEntProp(Attacker, PropType:0, "m_zombieClass", 4, 0) != 8)
	{
		return false;
	}
	return true;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:42"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new Handle:g_hCvarEnabled;
new Handle:g_hCvarFadeDuration;
new Handle:g_hCvarWeaponFlags;
new iFadeDuration;
new iWeaponFlags;
new bool:bEnabled;
new bool:bIsTankInPlay;
public Plugin:myinfo =
{
	name = "L4D Tank Pain Fade",
	description = "Tank's screen fades into red when taking damage",
	author = "Visor",
	version = "1.1",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	g_hCvarEnabled = CreateConVar("l4d_tank_painfade", "1", "Enable/disable plugin", 262400, true, 0.0, true, 1.0);
	g_hCvarFadeDuration = CreateConVar("l4d_tank_painfade_duration", "150", "Fade duration in ticks", 0, false, 0.0, false, 0.0);
	g_hCvarWeaponFlags = CreateConVar("l4d_tank_painfade_flags", "8", "What kind of weapons will cause the fade effect(1:Uzi,2:Shotgun,4:Sniper,8:Melee)", 262400, true, 1.0, true, 15.0);
	bEnabled = GetConVarBool(g_hCvarEnabled);
	iFadeDuration = GetConVarInt(g_hCvarFadeDuration);
	iWeaponFlags = GetConVarInt(g_hCvarWeaponFlags);
	HookEvent("tank_spawn", TankSpawn, EventHookMode:2);
	HookEvent("player_death", PlayerDeath, EventHookMode:1);
	return 0;
}

public OnClientDisconnect(client)
{
	new var1;
	if (bEnabled && IsTank(client))
	{
		CreateTimer(0.1, CheckForTanksDelay, any:2, 0);
	}
	return 0;
}

public Action:TankSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	new var1;
	if (!bEnabled || bIsTankInPlay)
	{
		return Action:0;
	}
	bIsTankInPlay = true;
	AttachEffect();
	return Action:0;
}

public Action:PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!bEnabled)
	{
		return Action:0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (IsTank(client))
	{
		CreateTimer(0.1, CheckForTanksDelay, any:2, 0);
	}
	return Action:0;
}

public Action:CheckForTanksDelay(Handle:timer)
{
	if (FindTank() == -1)
	{
		bIsTankInPlay = false;
		DetachEffect();
	}
	return Action:0;
}

public Action:OnTankDamaged(victim, &attacker, &inflictor, &Float:damage, &damageType, &weapon, Float:damageForce[3], Float:damagePosition[3])
{
	new var1;
	if (!attacker || weapon < 1 || !IsTank(victim))
	{
		return Action:0;
	}
	if (IdentifyWeapon(weapon) & iWeaponFlags)
	{
		UTIL_ScreenFade(victim, 1, iFadeDuration, 0, 128, 0, 0, 128);
	}
	return Action:0;
}

AttachEffect()
{
	new i = 1;
	while (MaxClients + 1 > i)
	{
		new var1;
		if (!IsClientConnected(i) || !IsClientInGame(i))
		{
		}
		else
		{
			if (IsInfected(i))
			{
				SDKHook(i, SDKHookType:2, OnTankDamaged);
			}
		}
		i++;
	}
	return 0;
}

DetachEffect()
{
	new i = 1;
	while (MaxClients + 1 > i)
	{
		new var1;
		if (!IsClientConnected(i) || !IsClientInGame(i))
		{
		}
		else
		{
			SDKUnhook(i, SDKHookType:2, OnTankDamaged);
		}
		i++;
	}
	return 0;
}

IdentifyWeapon(ent_id)
{
	if (ent_id < 1)
	{
		return 0;
	}
	decl String:ent_name[64];
	GetEdictClassname(ent_id, ent_name, 64);
	if (StrContains(ent_name, "smg", false) != -1)
	{
		return 1;
	}
	if (StrContains(ent_name, "shotgun", false) != -1)
	{
		return 2;
	}
	new var1;
	if (StrContains(ent_name, "hunting_rifle", false) == -1 && StrContains(ent_name, "sniper", false) == -1)
	{
		return 4;
	}
	if (StrContains(ent_name, "melee", false) != -1)
	{
		return 8;
	}
	return 0;
}

bool:IsInfected(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 3)
	{
		return false;
	}
	return true;
}

FindTank()
{
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsTank(i) && IsPlayerAlive(i))
		{
			return i;
		}
		i++;
	}
	return -1;
}

bool:IsTank(client)
{
	new var1;
	if (client <= 0 || !IsInfected(client))
	{
		return false;
	}
	if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8)
	{
		return true;
	}
	return false;
}

UTIL_ScreenFade(client, duration, time, flags, r, g, b, a)
{
	new clients[1];
	new Handle:bf;
	clients[0] = client;
	bf = StartMessage("Fade", clients, 1, 0);
	BfWriteShort(bf, duration);
	BfWriteShort(bf, time);
	BfWriteShort(bf, flags);
	BfWriteByte(bf, r);
	BfWriteByte(bf, g);
	BfWriteByte(bf, b);
	BfWriteByte(bf, a);
	EndMessage();
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.3",
	date = "11/19/2012",
	time = "11:28:11"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "sdkhooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new bool:tankSpawned;
new iTankClient = -1;
new Handle:cvar_tankProps;
new Handle:hTankProps;
new Handle:hTankPropsHit;
public Plugin:myinfo =
{
	name = "L4D2 Tank Props",
	description = "Stop tank props from fading whilst the tank is alive",
	author = "Jahze",
	version = "1.1",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	cvar_tankProps = CreateConVar("l4d_tank_props", "1", "Prevent tank props from fading whilst the tank is alive", 262144, false, 0.0, false, 0.0);
	HookConVarChange(cvar_tankProps, TankPropsChange);
	PluginEnable();
	return 0;
}

PluginEnable()
{
	SetConVarBool(FindConVar("sv_tankpropfade"), false, false, false);
	hTankProps = CreateArray(1, 0);
	hTankPropsHit = CreateArray(1, 0);
	HookEvent("round_start", TankPropRoundReset, EventHookMode:1);
	HookEvent("round_end", TankPropRoundReset, EventHookMode:1);
	HookEvent("tank_spawn", TankPropTankSpawn, EventHookMode:1);
	HookEvent("player_death", TankPropTankKilled, EventHookMode:1);
	return 0;
}

PluginDisable()
{
	SetConVarBool(FindConVar("sv_tankpropfade"), true, false, false);
	CloseHandle(hTankProps);
	CloseHandle(hTankPropsHit);
	UnhookEvent("round_start", TankPropRoundReset, EventHookMode:1);
	UnhookEvent("round_end", TankPropRoundReset, EventHookMode:1);
	UnhookEvent("tank_spawn", TankPropTankSpawn, EventHookMode:1);
	UnhookEvent("player_death", TankPropTankKilled, EventHookMode:1);
	return 0;
}

public TankPropsChange(Handle:cvar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10))
	{
		PluginEnable();
	}
	else
	{
		PluginDisable();
	}
	return 0;
}

public Action:TankPropRoundReset(Handle:event, String:name[], bool:dontBroadcast)
{
	tankSpawned = false;
	UnhookTankProps();
	ClearArray(hTankPropsHit);
	return Action:0;
}

public Action:TankPropTankSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!tankSpawned)
	{
		UnhookTankProps();
		ClearArray(hTankPropsHit);
		HookTankProps();
		tankSpawned = true;
	}
	return Action:0;
}

public Action:TankPropTankKilled(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!tankSpawned)
	{
		return Action:0;
	}
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (iTankClient != client)
	{
		return Action:0;
	}
	CreateTimer(0.1, TankDeadCheck, any:0, 0);
	return Action:0;
}

public Action:TankDeadCheck(Handle:timer)
{
	if (GetTankClient() == -1)
	{
		UnhookTankProps();
		CreateTimer(5.0, FadeTankProps, any:0, 0);
		tankSpawned = false;
	}
	return Action:0;
}

public PropDamaged(victim, attacker, inflictor, Float:damage, damageType)
{
	new var1;
	if (GetTankClient() != attacker && FindValueInArray(hTankPropsHit, inflictor) == -1)
	{
		if (FindValueInArray(hTankPropsHit, victim) == -1)
		{
			PushArrayCell(hTankPropsHit, victim);
		}
	}
	return 0;
}

public Action:FadeTankProps(Handle:timer)
{
	new i;
	while (GetArraySize(hTankPropsHit) > i)
	{
		if (IsValidEdict(GetArrayCell(hTankPropsHit, i, 0, false)))
		{
			RemoveEdict(GetArrayCell(hTankPropsHit, i, 0, false));
		}
		i++;
	}
	ClearArray(hTankPropsHit);
	return Action:0;
}

bool:IsTankProp(iEntity)
{
	if (!IsValidEdict(iEntity))
	{
		return false;
	}
	decl String:className[64];
	GetEdictClassname(iEntity, className, 64);
	if (StrEqual(className, "prop_physics", true))
	{
		if (GetEntProp(iEntity, PropType:0, "m_hasTankGlow", 1, 0))
		{
			return true;
		}
	}
	else
	{
		if (StrEqual(className, "prop_car_alarm", true))
		{
			return true;
		}
	}
	return false;
}

HookTankProps()
{
	new iEntCount = GetMaxEntities();
	new i = 1;
	while (i <= iEntCount)
	{
		if (IsTankProp(i))
		{
			SDKHook(i, SDKHookType:3, PropDamaged);
			PushArrayCell(hTankProps, i);
		}
		i++;
	}
	return 0;
}

UnhookTankProps()
{
	new i;
	while (GetArraySize(hTankProps) > i)
	{
		SDKUnhook(GetArrayCell(hTankProps, i, 0, false), SDKHookType:3, PropDamaged);
		i++;
	}
	ClearArray(hTankProps);
	return 0;
}

GetTankClient()
{
	new var1;
	if (iTankClient == -1 || !IsTank(iTankClient))
	{
		iTankClient = FindTank();
	}
	return iTankClient;
}

FindTank()
{
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsTank(i))
		{
			return i;
		}
		i++;
	}
	return -1;
}

bool:IsTank(client)
{
	new var1;
	if (client < 0 || !IsClientConnected(client) || !IsClientInGame(client) || GetClientTeam(client) == 3 || !IsPlayerAlive(client))
	{
		return false;
	}
	new playerClass = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	if (playerClass == 8)
	{
		return true;
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.3",
	date = "08/31/2012",
	time = "15:33:07"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new bool:bSecondRound;
new bool:bTankAlive;
new bool:bHooked;
new iDistance;
new Handle:cvar_noTankRush;
public Plugin:myinfo =
{
	name = "L4D2 No Tank Rush",
	description = "Stops distance points accumulating whilst the tank is alive",
	author = "Jahze, vintik",
	version = "1.1",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public OnPluginStart()
{
	cvar_noTankRush = CreateConVar("l4d_no_tank_rush", "1", "Prevents survivor team from accumulating points whilst the tank is alive", 262144, false, 0.0, false, 0.0);
	HookConVarChange(cvar_noTankRush, NoTankRushChange);
	if (GetConVarBool(cvar_noTankRush))
	{
		PluginEnable();
	}
	return 0;
}

public OnPluginEnd()
{
	bHooked = false;
	PluginDisable();
	return 0;
}

public OnMapStart()
{
	bSecondRound = false;
	bTankAlive = false;
	return 0;
}

PluginEnable()
{
	if (!bHooked)
	{
		HookEvent("round_start", RoundStart, EventHookMode:1);
		HookEvent("round_end", RoundEnd, EventHookMode:1);
		HookEvent("tank_spawn", TankSpawn, EventHookMode:1);
		HookEvent("player_death", PlayerDeath, EventHookMode:1);
		if (0 < FindTank())
		{
			FreezePoints(false);
		}
		bHooked = true;
	}
	return 0;
}

PluginDisable()
{
	if (bHooked)
	{
		UnhookEvent("round_start", RoundStart, EventHookMode:1);
		UnhookEvent("round_end", RoundEnd, EventHookMode:1);
		UnhookEvent("tank_spawn", TankSpawn, EventHookMode:1);
		UnhookEvent("player_death", PlayerDeath, EventHookMode:1);
		bHooked = false;
	}
	UnFreezePoints(false);
	return 0;
}

public NoTankRushChange(Handle:cvar, String:oldValue[], String:newValue[])
{
	if (StringToInt(newValue, 10))
	{
		PluginEnable();
	}
	else
	{
		PluginDisable();
	}
	return 0;
}

public Action:RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	if (bSecondRound)
	{
		UnFreezePoints(false);
	}
	return Action:0;
}

public Action:RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	bSecondRound = true;
	return Action:0;
}

public Action:TankSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	FreezePoints(true);
	return Action:0;
}

public Action:PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (IsTank(client))
	{
		CreateTimer(0.1, CheckForTanksDelay, any:2, 0);
	}
	return Action:0;
}

public OnClientDisconnect(client)
{
	if (IsTank(client))
	{
		CreateTimer(0.1, CheckForTanksDelay, any:2, 0);
	}
	return 0;
}

public Action:CheckForTanksDelay(Handle:timer)
{
	if (FindTank() == -1)
	{
		UnFreezePoints(true);
	}
	return Action:0;
}

FreezePoints(bool:show_message)
{
	if (!bTankAlive)
	{
		iDistance = L4D_GetVersusMaxCompletionScore();
		if (show_message)
		{
			PrintToChatAll("[NoTankRush] Tank spawned. Freezing distance points!");
		}
		L4D_SetVersusMaxCompletionScore(0);
		bTankAlive = true;
	}
	return 0;
}

UnFreezePoints(bool:show_message)
{
	if (bTankAlive)
	{
		if (show_message)
		{
			PrintToChatAll("[NoTankRush] Tank is dead. Unfreezing distance points!");
		}
		L4D_SetVersusMaxCompletionScore(iDistance);
		bTankAlive = false;
	}
	return 0;
}

FindTank()
{
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsTank(i) && IsPlayerAlive(i))
		{
			return i;
		}
		i++;
	}
	return -1;
}

bool:IsTank(client)
{
	new var1;
	if (client <= 0 || !IsClientInGame(client) || GetClientTeam(client) == 3)
	{
		return false;
	}
	new playerClass = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	if (playerClass == 8)
	{
		return true;
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "04/28/2014",
	time = "23:10:42"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Plugin:myinfo =
{
	name = "Mathack Block",
	description = "Kicks out clients who are potentially attempting to enable mathack",
	author = "Sir, Visor",
	version = "1.0",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public OnPluginStart()
{
	CreateTimer(GetRandomFloat(2.5, 3.5), CheckClients, any:0, 1);
	return 0;
}

public Action:CheckClients(Handle:timer)
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && !IsFakeClient(client))
		{
			if (GetClientTeam(client) > 1)
			{
				QueryClientConVar(client, "mat_texture_list", ClientQueryCallback, any:0);
			}
		}
		client++;
	}
	return Action:0;
}

public ClientQueryCallback(QueryCookie:cookie, client, ConVarQueryResult:result, String:cvarName[], String:cvarValue[])
{
	switch (result)
	{
		case 0:
		{
			new mathax = StringToInt(cvarValue, 10);
			if (0 < mathax)
			{
				decl String:t_name[32];
				decl String:t_ip[32];
				decl String:t_steamid[32];
				decl String:path[256];
				GetClientName(client, t_name, 31);
				GetClientAuthString(client, t_steamid, 31, true);
				if (IsFakeClient(client))
				{
					return 0;
				}
				GetClientIP(client, t_ip, 31, true);
				BuildPath(PathType:0, path, 256, "logs/mathack_cheaters.txt");
				LogToFile(path, ".:[Name: %s | STEAMID: %s | IP: %s]:.", t_name, t_steamid, t_ip);
				PrintToChatAll("\x04[\x01Mathack Detector\x04] \x03%s \x01has been kicked for using mathack!", t_name);
				KickClient(client, "You have been kicked for using hacks. No rest for the wicked.");
			}
		}
		case 1:
		{
			KickClient(client, "ConVarQuery_NotFound");
		}
		case 2:
		{
			KickClient(client, "ConVarQuery_NotValid");
		}
		case 3:
		{
			KickClient(client, "ConVarQuery_Protected");
		}
		default:
		{
		}
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.3",
	date = "11/20/2012",
	time = "01:45:35"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Plugin:myinfo =
{
	name = "Thirdpersonshoulder Block",
	description = "Kicks clients who enable the thirdpersonshoulder mode on L4D1/2 to prevent them from looking around corners, through walls etc.",
	author = "Don",
	version = "1.4",
	url = "http://forums.alliedmods.net/showthread.php?t=159582"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	decl String:sGame[12];
	GetGameFolderName(sGame, 12);
	new var1;
	if (StrEqual(sGame, "left4dead", true) || StrEqual(sGame, "left4dead2", true))
	{
		return APLRes:0;
	}
	strcopy(error, err_max, "Plugin only supports L4D1/2");
	return APLRes:1;
}

public OnPluginStart()
{
	CreateConVar("l4d_tpsblock_version", "1.4", "Version of the Thirdpersonshoulder Block plugin", 393472, false, 0.0, false, 0.0);
	CreateTimer(GetRandomFloat(2.5, 3.5), CheckClients, any:0, 1);
	return 0;
}

public Action:CheckClients(Handle:timer)
{
	new iClientIndex = 1;
	while (iClientIndex <= MaxClients)
	{
		new var1;
		if (IsClientInGame(iClientIndex) && !IsFakeClient(iClientIndex))
		{
			new var2;
			if (GetClientTeam(iClientIndex) == 2 || GetClientTeam(iClientIndex) == 3)
			{
				QueryClientConVar(iClientIndex, "c_thirdpersonshoulder", QueryClientConVarCallback, any:0);
			}
		}
		iClientIndex++;
	}
	return Action:0;
}

public QueryClientConVarCallback(QueryCookie:cookie, client, ConVarQueryResult:result, String:cvarName[], String:cvarValue[])
{
	new var1;
	if (IsClientInGame(client) && !IsClientInKickQueue(client))
	{
		if (result)
		{
			new String:sName[32];
			GetClientName(client, sName, 32);
			ChangeClientTeam(client, 1);
			PrintToChatAll("\x01\x03%s\x01 spectated due to \x04c_thirdpersonshoulder\x01 not valid or protected!", sName);
		}
		new var2;
		if (!StrEqual(cvarValue, "false", true) && !StrEqual(cvarValue, "0", true))
		{
			new String:sName[32];
			GetClientName(client, sName, 32);
			ChangeClientTeam(client, 1);
			PrintToChatAll("\x01\x03%s\x01 spectated due to \x04c_thirdpersonshoulder\x01, set at\x05 0\x01 to play!", sName);
		}
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4140",
	date = "11/19/2013",
	time = "13:47:03"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new String:WeaponNames[56][] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced",
	"weapon_shotgun_chrome",
	"weapon_rifle_desert",
	"weapon_sniper_military",
	"weapon_shotgun_spas",
	"weapon_first_aid_kit",
	"weapon_molotov",
	"weapon_pipe_bomb",
	"weapon_pain_pills",
	"weapon_gascan",
	"weapon_propanetank",
	"weapon_oxygentank",
	"weapon_melee",
	"weapon_chainsaw",
	"weapon_grenade_launcher",
	"weapon_ammo_pack",
	"weapon_adrenaline",
	"weapon_defibrillator",
	"weapon_vomitjar",
	"weapon_rifle_ak47",
	"weapon_gnome",
	"weapon_cola_bottles",
	"weapon_fireworkcrate",
	"weapon_upgradepack_incendiary",
	"weapon_upgradepack_explosive",
	"weapon_pistol_magnum",
	"weapon_smg_mp5",
	"weapon_rifle_sg552",
	"weapon_sniper_awp",
	"weapon_sniper_scout",
	"weapon_rifle_m60",
	"weapon_tank_claw",
	"weapon_hunter_claw",
	"weapon_charger_claw",
	"weapon_boomer_claw",
	"weapon_smoker_claw",
	"weapon_spitter_claw",
	"weapon_jockey_claw",
	"weapon_machinegun",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:WeaponModels[56][] =
{
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"\x01",
	"",
	"\x01",
	"\x01",
	"",
	"",
	"",
	"",
	"\x03",
	"",
	"",
	"",
	"",
	"\x03",
	"\x03",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?",
	"?"
};
new WeaponSlots[56] =
{
	-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 2, 4, -1, -1, -1, 1, 1, 0, 3, 4, 3, 2, 0, -1, -1, -1, 3, 3, 1, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};
new Handle:hWeaponNamesTrie;
public Plugin:myinfo =
{
	name = "L4D Weapon Limits",
	description = "Restrict weapons individually or together",
	author = "CanadaRox, Stabby",
	version = "1.3",
	url = "https://www.github.com/CanadaRox/sourcemod-plugins/tree/master/weapon_limits"
};
new Handle:hSDKGiveDefaultAmmo;
new Handle:hLimitArray;
new bIsLocked;
new bIsIncappedWithMelee[66];
new iAmmoPile;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

L4D2Weapons_Init()
{
	if (!hWeaponNamesTrie)
	{
		InitWeaponNamesTrie();
	}
	return 0;
}

GetSlotFromWeaponId(WeaponId:wepid)
{
	return WeaponModels[wepid];
}

WeaponId:WeaponNameToId(String:weaponName[])
{
	if (!hWeaponNamesTrie)
	{
		InitWeaponNamesTrie();
	}
	new WeaponID:id;
	if (GetTrieValue(hWeaponNamesTrie, weaponName, id))
	{
		return id;
	}
	return WeaponId:0;
}

InitWeaponNamesTrie()
{
	hWeaponNamesTrie = CreateTrie();
	new i;
	while (i < 56)
	{
		SetTrieValue(hWeaponNamesTrie, WeaponNames[i], i, true);
		i++;
	}
	return 0;
}

WeaponId:IdentifyWeapon(entity)
{
	new var1;
	if (!entity || !IsValidEntity(entity) || !IsValidEdict(entity))
	{
		return WeaponId:0;
	}
	decl String:class[64];
	if (!GetEdictClassname(entity, class, 64))
	{
		return WeaponId:0;
	}
	if (StrEqual(class, "weapon_spawn", true))
	{
		return GetEntProp(entity, PropType:0, "m_weaponID", 4, 0);
	}
	new len = strlen(class);
	new var2;
	if (len + -6 > 0 && StrEqual(class[len + -6], "_spawn", true))
	{
		class[len + -6] = MissingTAG:0;
		return WeaponNameToId(class);
	}
	return WeaponNameToId(class);
}

public OnPluginStart()
{
	hLimitArray = CreateArray(4, 0);
	L4D2Weapons_Init();
	new Handle:conf = LoadGameConfigFile("l4d_wlimits");
	if (!conf)
	{
		ThrowError("Gamedata missing: %s", "l4d_wlimits");
	}
	StartPrepSDKCall(SDKCallType:1);
	if (!PrepSDKCall_SetFromConf(conf, SDKFuncConfSource:1, "CWeaponAmmoSpawn_Use"))
	{
		ThrowError("Gamedata missing signature: %s", "CWeaponAmmoSpawn_Use");
	}
	PrepSDKCall_AddParameter(SDKType:1, SDKPassMethod:0, 0, 0);
	hSDKGiveDefaultAmmo = EndPrepSDKCall();
	RegServerCmd("l4d_wlimits_add", AddLimit_Cmd, "Add a weapon limit", 0);
	RegServerCmd("l4d_wlimits_lock", LockLimits_Cmd, "Locks the limits to improve search speeds", 0);
	RegServerCmd("l4d_wlimits_clear", ClearLimits_Cmd, "Clears all weapon limits (limits must be locked to be cleared)", 0);
	HookEvent("player_incapacitated_start", OnIncap, EventHookMode:1);
	HookEvent("revive_success", OnRevive, EventHookMode:1);
	HookEvent("round_end", OnRoundEnd, EventHookMode:1);
	return 0;
}

public OnRoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new i = 1;
	while (i <= MaxClients)
	{
		bIsIncappedWithMelee[i] = 0;
		i++;
	}
	return 0;
}

public OnPluginEnd()
{
	ClearLimits();
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:14, WeaponCanUse);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:14, WeaponCanUse);
	return 0;
}

public RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	CreateTimer(2.0, RoundStartDelay_Timer, any:0, 0);
	return 0;
}

public Action:RoundStartDelay_Timer(Handle:timer)
{
	FindAmmoSpawn();
	return Action:0;
}

public Action:AddLimit_Cmd(args)
{
	if (bIsLocked)
	{
		PrintToServer("Limits have been locked");
		return Action:3;
	}
	if (args < 3)
	{
		PrintToServer("Usage: l4d_wlimits_add <limit> <ammo> <weapon1> <weapon2> ... <weaponN>\nAmmo: -1: Given for primary weapon spawns only, 0: no ammo given ever, else: ammo always given");
		return Action:3;
	}
	decl String:sTempBuff[32];
	GetCmdArg(1, sTempBuff, 32);
	new newEntry[4];
	decl WeaponId:wepid;
	newEntry[0] = StringToInt(sTempBuff, 10);
	GetCmdArg(2, sTempBuff, 32);
	newEntry[1] = StringToInt(sTempBuff, 10);
	new i = 3;
	while (i <= args)
	{
		GetCmdArg(i, sTempBuff, 32);
		wepid = WeaponNameToId(sTempBuff);
		new var1 = newEntry[2][wepid / 32];
		var1 = 1 << wepid % 32 | var1;
		i++;
	}
	PushArrayArray(hLimitArray, newEntry, -1);
	return Action:3;
}

public Action:LockLimits_Cmd(args)
{
	if (bIsLocked)
	{
		PrintToServer("Weapon limits already locked");
	}
	else
	{
		bIsLocked = 1;
	}
	return Action:0;
}

public Action:ClearLimits_Cmd(args)
{
	if (bIsLocked)
	{
		bIsLocked = 0;
		PrintToChatAll("[L4D Weapon Limits] Weapon limits cleared!");
		ClearLimits();
	}
	return Action:0;
}

public Action:WeaponCanUse(client, weapon)
{
	new var1;
	if (GetClientTeam(client) == 2 && !bIsLocked)
	{
		return Action:0;
	}
	new WeaponId:wepid = IdentifyWeapon(weapon);
	decl arrayEntry[4];
	new size = GetArraySize(hLimitArray);
	decl wep_slot;
	decl player_weapon;
	decl WeaponId:player_wepid;
	new i;
	while (i < size)
	{
		GetArrayArray(hLimitArray, i, arrayEntry, -1);
		new var2;
		if (1 << wepid % 32 & arrayEntry[2][wepid / 32] && GetWeaponCount(arrayEntry[2]) >= arrayEntry[0])
		{
			wep_slot = GetSlotFromWeaponId(wepid);
			player_weapon = GetPlayerWeaponSlot(client, wep_slot);
			player_wepid = IdentifyWeapon(player_weapon);
			new var3;
			if (!player_wepid || player_wepid != wepid || !1 << player_wepid % 32 & arrayEntry[2][player_wepid / 32])
			{
				new var4;
				if ((wep_slot && arrayEntry[1] == -1) || arrayEntry[1])
				{
					GiveDefaultAmmo(client);
				}
				new var6;
				if (player_wepid == WeaponId:19 && wepid == WeaponId:19)
				{
					return Action:0;
				}
				if (player_wepid)
				{
					PrintToChat(client, "[Weapon Limits] This weapon group has reached its max of %d", arrayEntry);
				}
				return Action:3;
			}
		}
		i++;
	}
	return Action:0;
}

public Action:OnIncap(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (GetClientTeam(client) == 2 && IdentifyWeapon(GetPlayerWeaponSlot(client, 1)) == 19)
	{
		bIsIncappedWithMelee[client] = 1;
	}
	return Action:0;
}

public Action:OnRevive(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "subject"));
	if (bIsIncappedWithMelee[client])
	{
		bIsIncappedWithMelee[client] = 0;
	}
	return Action:0;
}

GetWeaponCount(mask[])
{
	new count;
	decl WeaponId:wepid;
	decl j;
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && GetClientTeam(i) == 2 && IsPlayerAlive(i))
		{
			j = 0;
			while (j < 5)
			{
				wepid = IdentifyWeapon(GetPlayerWeaponSlot(i, j));
				new var3;
				if (1 << wepid % 32 & mask[wepid / 32] || (j == 1 && bIsIncappedWithMelee[i] && wepid != WeaponId:32))
				{
					count++;
				}
				j++;
			}
		}
		i++;
	}
	return count;
}

ClearLimits()
{
	if (hLimitArray)
	{
		ClearArray(hLimitArray);
	}
	return 0;
}

GiveDefaultAmmo(client)
{
	if (iAmmoPile != -1)
	{
		SDKCall(hSDKGiveDefaultAmmo, iAmmoPile, client);
	}
	return 0;
}

FindAmmoSpawn()
{
	new psychonic = GetEntityCount();
	decl String:classname[64];
	new i = MaxClients;
	while (i < psychonic)
	{
		if (IsValidEntity(i))
		{
			GetEdictClassname(i, classname, 64);
			if (StrEqual(classname, "weapon_ammo_spawn", true))
			{
				return i;
			}
		}
		i++;
	}
	return MakeAmmoPile();
}

MakeAmmoPile()
{
	new ammo = CreateEntityByName("weapon_ammo_spawn", -1);
	DispatchSpawn(ammo);
	LogMessage("No ammo pile found, creating one: %d", iAmmoPile);
	return ammo;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "06/06/2017",
	time = "16:57:42"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new ARRAY_STEAMID;
new ARRAY_LERP = 1;
new ARRAY_CHANGES = 2;
new ARRAY_COUNT = 3;
new Handle:arrayLerps;
new Handle:cVarReadyUpLerpChanges;
new Handle:cVarAllowedLerpChanges;
new Handle:cVarLerpChangeSpec;
new Handle:cVarMinLerp;
new Handle:cVarMaxLerp;
new Handle:cVarMinUpdateRate;
new Handle:cVarMaxUpdateRate;
new Handle:cVarMinInterpRatio;
new Handle:cVarMaxInterpRatio;
new bool:isFirstHalf = 1;
new bool:isMatchLife = 1;
new bool:isTransfer;
new Handle:cvarL4DReadyEnabled;
new Handle:cvarL4DReadyBothHalves;
new bool:bBadValveCoding[66];
public Plugin:myinfo =
{
	name = "LerpMonitor++",
	description = "Keep track of players' lerp settings",
	author = "ProdigySim, Die Teetasse, vintik",
	version = "1.0",
	url = "https://bitbucket.org/vintik/various-plugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator/(Float:,_:)(Float:oper1, oper2)
{
	return oper1 / float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

ByteCountToCells(size)
{
	if (!size)
	{
		return 1;
	}
	return size + 3 / 4;
}

CPrintToChatEx(client, author, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	new var2;
	if (author < 0 || author > MaxClients)
	{
		ThrowError("Invalid client index %d", author);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 4);
	new index = CFormat(szCMessage, 250, author);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, author, szCMessage);
	}
	return 0;
}

CPrintToChatAllEx(author, String:szMessage[])
{
	new var1;
	if (author < 0 || author > MaxClients)
	{
		ThrowError("Invalid client index %d", author);
	}
	if (!IsClientInGame(author))
	{
		ThrowError("Client %d is not in game", author);
	}
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var2;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 3);
			CPrintToChatEx(i, author, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	cVarMinUpdateRate = FindConVar("sv_minupdaterate");
	cVarMaxUpdateRate = FindConVar("sv_maxupdaterate");
	cVarMinInterpRatio = FindConVar("sv_client_min_interp_ratio");
	cVarMaxInterpRatio = FindConVar("sv_client_max_interp_ratio");
	cvarL4DReadyEnabled = FindConVar("l4d_ready_enabled");
	cvarL4DReadyBothHalves = FindConVar("l4d_ready_both_halves");
	cVarAllowedLerpChanges = CreateConVar("sm_allowed_lerp_changes", "1", "Allowed number of lerp changes for a half", 262144, false, 0.0, false, 0.0);
	cVarLerpChangeSpec = CreateConVar("sm_lerp_change_spec", "1", "Move to spectators on exceeding lerp changes count?", 262144, false, 0.0, false, 0.0);
	cVarReadyUpLerpChanges = CreateConVar("sm_readyup_lerp_changes", "1", "Allow lerp changes during ready-up", 262144, false, 0.0, false, 0.0);
	cVarMinLerp = CreateConVar("sm_min_lerp", "0.000", "Minimum allowed lerp value", 262144, false, 0.0, false, 0.0);
	cVarMaxLerp = CreateConVar("sm_max_lerp", "0.067", "Maximum allowed lerp value", 262144, false, 0.0, false, 0.0);
	RegConsoleCmd("sm_lerps", Lerps_Cmd, "List the Lerps of all players in game", 262144);
	HookEvent("round_start", Event_RoundStart, EventHookMode:1);
	HookEvent("round_end", Event_RoundEnd, EventHookMode:1);
	HookEvent("player_team", OnTeamChange, EventHookMode:1);
	arrayLerps = CreateArray(ByteCountToCells(32), 0);
	new client = 1;
	while (MaxClients + 1 > client)
	{
		new var1;
		if (!IsClientInGame(client) || IsFakeClient(client))
		{
		}
		else
		{
			ProcessPlayerLerp(client, true, false);
		}
		client++;
	}
	return 0;
}

public OnClientPutInServer(client)
{
	new var1;
	if (IsValidEntity(client) && !IsFakeClient(client))
	{
		CreateTimer(1.0, Process, client, 0);
	}
	return 0;
}

public Action:Process(Handle:timer, any:client)
{
	new var1;
	if (IsValidEntity(client) && !IsFakeClient(client) && GetClientTeam(client) != 1)
	{
		ProcessPlayerLerp(client, false, false);
	}
	return Action:0;
}

public OnMapStart()
{
	new var1;
	if (cvarL4DReadyEnabled && GetConVarBool(cvarL4DReadyEnabled))
	{
		isMatchLife = false;
	}
	else
	{
		isMatchLife = true;
	}
	return 0;
}

public OnMapEnd()
{
	isFirstHalf = true;
	ClearArray(arrayLerps);
	return 0;
}

public OnClientSettingsChanged(client)
{
	new var1;
	if (IsValidEntity(client) && !IsFakeClient(client))
	{
		ProcessPlayerLerp(client, false, false);
	}
	return 0;
}

public OnTeamChange(Handle:event, String:name[], bool:dontBroadcast)
{
	if (GetEventInt(event, "team") != 1)
	{
		new client = GetClientOfUserId(GetEventInt(event, "userid"));
		if (0 < client)
		{
			new var1;
			if (IsClientInGame(client) && !IsFakeClient(client) && !bBadValveCoding[client] && !isTransfer)
			{
				CreateTimer(0.1, OnTeamChangeDelay, client, 2);
			}
		}
	}
	return 0;
}

public Action:OnTeamChangeDelay(Handle:timer, any:client)
{
	ProcessPlayerLerp(client, false, true);
	return Action:3;
}

public Action:OnBadCoding(Handle:timer, any:client)
{
	bBadValveCoding[client] = 0;
	return Action:3;
}

public Action:OnRoundIsLive()
{
	isMatchLife = true;
	return Action:0;
}

public Event_RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	CreateTimer(0.5, Timer_RoundEndDelay, any:0, 0);
	return 0;
}

public Action:Timer_RoundEndDelay(Handle:timer)
{
	isFirstHalf = false;
	isTransfer = true;
	new var1;
	if (cvarL4DReadyBothHalves && GetConVarBool(cvarL4DReadyBothHalves))
	{
		isMatchLife = false;
	}
	return Action:0;
}

bool:IsFirstHalf()
{
	return isFirstHalf;
}

bool:IsMatchLife()
{
	return isMatchLife;
}

GetClientBySteamID(String:steamID[])
{
	decl String:tempSteamID[32];
	new client = 1;
	while (MaxClients + 1 > client)
	{
		if (IsClientInGame(client))
		{
			GetClientAuthString(client, tempSteamID, 32, true);
			if (StrEqual(steamID, tempSteamID, true))
			{
				return client;
			}
		}
		client++;
	}
	return -1;
}

public Action:Lerps_Cmd(client, args)
{
	new clientID;
	new index;
	decl Float:lerp;
	decl String:steamID[32];
	new i;
	while (GetArraySize(arrayLerps) / ARRAY_COUNT > i)
	{
		index = ARRAY_COUNT * i;
		GetArrayString(arrayLerps, ARRAY_STEAMID + index, steamID, 32);
		clientID = GetClientBySteamID(steamID);
		lerp = GetArrayCell(arrayLerps, ARRAY_LERP + index, 0, false);
		new var1;
		if (clientID != -1 && GetClientTeam(clientID) != 1)
		{
			ReplyToCommand(client, "%N [%s]: %.01f", clientID, steamID, lerp * 1000);
		}
		i++;
	}
	return Action:3;
}

public Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!IsFirstHalf())
	{
		new i;
		while (GetArraySize(arrayLerps) / ARRAY_COUNT > i)
		{
			SetArrayCell(arrayLerps, ARRAY_COUNT * i + ARRAY_CHANGES, any:0, 0, false);
			i++;
		}
	}
	CreateTimer(0.5, OnTransfer, any:2, 0);
	return 0;
}

public Action:OnTransfer(Handle:timer, any:client)
{
	isTransfer = false;
	return Action:3;
}

ProcessPlayerLerp(client, bool:load, bool:team)
{
	if (!IsValidClient(client))
	{
		return 0;
	}
	new Float:newLerpTime = GetLerpTime(client);
	SetEntPropFloat(client, PropType:1, "m_fLerpTime", newLerpTime, 0);
	if (GetClientTeam(client) == 1)
	{
		return 0;
	}
	decl String:steamID[32];
	GetClientAuthString(client, steamID, 32, true);
	new index = FindStringInArray(arrayLerps, steamID);
	new var1;
	if (FloatCompare(newLerpTime, GetConVarFloat(cVarMinLerp)) == -1 || FloatCompare(newLerpTime, GetConVarFloat(cVarMaxLerp)) == 1)
	{
		if (!load)
		{
			if (index != -1)
			{
				new Float:currentLerpTime = GetArrayCell(arrayLerps, ARRAY_LERP + index, 0, false);
				if (currentLerpTime == newLerpTime)
				{
					ChangeClientTeam(client, 1);
					return 0;
				}
			}
			CPrintToChatAllEx(client, "{default}<{olive}Lerp{default}> {teamcolor}%N {default}was moved to spectators for lerp {teamcolor}%.01f", client, newLerpTime * 1000);
			ChangeClientTeam(client, 1);
			CPrintToChatEx(client, client, "{default}<{olive}Lerp{default}> Illegal lerp value (min: {teamcolor}%.01f{default}, max: {teamcolor}%.01f{default})", GetConVarFloat(cVarMinLerp) * 1000, GetConVarFloat(cVarMaxLerp) * 1000);
		}
		return 0;
	}
	if (index != -1)
	{
		new Float:currentLerpTime = GetArrayCell(arrayLerps, ARRAY_LERP + index, 0, false);
		if (currentLerpTime == newLerpTime)
		{
			if (team)
			{
				CPrintToChatAllEx(client, "{default}<{olive}Lerp{default}> {teamcolor}%N {default}@ {teamcolor}%.01f", client, newLerpTime * 1000);
			}
			return 0;
		}
		new var2;
		if (IsMatchLife() || !GetConVarBool(cVarReadyUpLerpChanges))
		{
			new count = GetArrayCell(arrayLerps, ARRAY_CHANGES + index, 0, false) + 1;
			new max = GetConVarInt(cVarAllowedLerpChanges);
			new var3;
			if (count > max)
			{
				var3 = 3428;
			}
			else
			{
				var3 = 3440;
			}
			CPrintToChatAllEx(client, "{default}<{olive}Lerp{default}> {teamcolor}%N {default}@ {teamcolor}%.01f {default}<== {green}%.01f {default}[%s%d{default}/%d {olive}changes]", client, newLerpTime * 1000, currentLerpTime * 1000, var3, count, max);
			new var4;
			if (GetConVarBool(cVarLerpChangeSpec) && count > max)
			{
				CPrintToChatAllEx(client, "{default}<{olive}Lerp{default}> {teamcolor}%N {default}was moved to spectators (illegal lerp change)!", client);
				ChangeClientTeam(client, 1);
				CPrintToChatEx(client, client, "{default}<{olive}Lerp{default}> Illegal change of Lerp midgame! Change it back to {teamcolor}%.01f", currentLerpTime * 1000);
				return 0;
			}
			SetArrayCell(arrayLerps, ARRAY_CHANGES + index, count, 0, false);
		}
		else
		{
			CPrintToChatAllEx(client, "{default}<{olive}Lerp{default}> {teamcolor}%N {default}@ {teamcolor}%.01f {default}<== {green}%.01f", client, newLerpTime * 1000, currentLerpTime * 1000);
		}
		SetArrayCell(arrayLerps, ARRAY_LERP + index, newLerpTime, 0, false);
	}
	else
	{
		if (team)
		{
			CPrintToChatAllEx(client, "{default}<{olive}Lerp{default}> {teamcolor}%N {default}@ {teamcolor}%.01f", client, newLerpTime * 1000);
		}
		PushArrayString(arrayLerps, steamID);
		PushArrayCell(arrayLerps, newLerpTime);
		PushArrayCell(arrayLerps, any:0);
	}
	return 0;
}

Float:GetLerpTime(client)
{
	new String:buffer[64] = "";
	if (GetClientInfo(client, "cl_updaterate", buffer, 64))
	{
	}
	new updateRate = StringToInt(buffer, 10);
	updateRate = RoundFloat(clamp(float(updateRate), GetConVarFloat(cVarMinUpdateRate), GetConVarFloat(cVarMaxUpdateRate)));
	if (GetClientInfo(client, "cl_interp_ratio", buffer, 64))
	{
	}
	new Float:flLerpRatio = StringToFloat(buffer);
	if (GetClientInfo(client, "cl_interp", buffer, 64))
	{
	}
	new Float:flLerpAmount = StringToFloat(buffer);
	new var1;
	if (cVarMinInterpRatio && cVarMaxInterpRatio && -1.0 != GetConVarFloat(cVarMinInterpRatio))
	{
		flLerpRatio = clamp(flLerpRatio, GetConVarFloat(cVarMinInterpRatio), GetConVarFloat(cVarMaxInterpRatio));
	}
	return maximum(flLerpAmount, flLerpRatio / updateRate);
}

Float:clamp(Float:in, Float:low, Float:high)
{
	new var1;
	if (in > high)
	{
		var1 = high;
	}
	else
	{
		if (in < low)
		{
			var1 = low;
		}
		var1 = in;
	}
	return var1;
}

Float:maximum(Float:a, Float:b)
{
	new var1;
	if (a > b)
	{
		var1 = a;
	}
	else
	{
		var1 = b;
	}
	return var1;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client) || !IsClientInGame(client) || IsFakeClient(client))
	{
		return false;
	}
	return true;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "11/10/2018",
	time = "00:29:52"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new Handle:g_hEnabled;
new Handle:g_hWeaponRandom;
new Handle:g_hWeaponRandomAmount;
new Handle:g_hWeaponBaseballBat;
new Handle:g_hWeaponCricketBat;
new Handle:g_hWeaponCrowbar;
new Handle:g_hWeaponElecGuitar;
new Handle:g_hWeaponFireAxe;
new Handle:g_hWeaponFryingPan;
new Handle:g_hWeaponGolfClub;
new Handle:g_hWeaponKnife;
new Handle:g_hWeaponKatana;
new Handle:g_hWeaponMachete;
new Handle:g_hWeaponRiotShield;
new Handle:g_hWeaponTonfa;
new bool:g_bSpawnedMelee;
new g_iMeleeClassCount;
new g_iMeleeRandomSpawn[20];
new g_iRound = 2;
new String:g_sMeleeClass[16][32];
public Plugin:myinfo =
{
	name = "Melee In The Saferoom",
	description = "Spawns a selection of melee weapons in the saferoom, at the start of each round.",
	author = "N3wton",
	version = "2.0.7",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return oper1 + float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public void:OnPluginStart()
{
	decl String:GameName[12];
	GetGameFolderName(GameName, 12);
	if (!StrEqual(GameName, "left4dead2", true))
	{
		SetFailState("Melee In The Saferoom is only supported on left 4 dead 2.");
	}
	CreateConVar("l4d2_MITSR_Version", "2.0.7", "The version of Melee In The Saferoom", 262144, false, 0.0, false, 0.0);
	g_hEnabled = CreateConVar("l4d2_MITSR_Enabled", "1", "Should the plugin be enabled", 262144, false, 0.0, false, 0.0);
	g_hWeaponRandom = CreateConVar("l4d2_MITSR_Random", "1", "Spawn Random Weapons (1) or custom list (0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponRandomAmount = CreateConVar("l4d2_MITSR_Amount", "8", "Number of weapons to spawn if l4d2_MITSR_Random is 1", 262144, false, 0.0, false, 0.0);
	g_hWeaponBaseballBat = CreateConVar("l4d2_MITSR_BaseballBat", "1", "Number of baseball bats to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponCricketBat = CreateConVar("l4d2_MITSR_CricketBat", "1", "Number of cricket bats to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponCrowbar = CreateConVar("l4d2_MITSR_Crowbar", "1", "Number of crowbars to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponElecGuitar = CreateConVar("l4d2_MITSR_ElecGuitar", "1", "Number of electric guitars to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponFireAxe = CreateConVar("l4d2_MITSR_FireAxe", "1", "Number of fireaxes to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponFryingPan = CreateConVar("l4d2_MITSR_FryingPan", "1", "Number of frying pans to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponGolfClub = CreateConVar("l4d2_MITSR_GolfClub", "1", "Number of golf clubs to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponKnife = CreateConVar("l4d2_MITSR_Knife", "1", "Number of knifes to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponKatana = CreateConVar("l4d2_MITSR_Katana", "1", "Number of katanas to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponMachete = CreateConVar("l4d2_MITSR_Machete", "1", "Number of machetes to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponRiotShield = CreateConVar("l4d2_MITSR_RiotShield", "1", "Number of riot shields to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	g_hWeaponTonfa = CreateConVar("l4d2_MITSR_Tonfa", "1", "Number of tonfas to spawn (l4d2_MITSR_Random must be 0)", 262144, false, 0.0, false, 0.0);
	HookEvent("round_start", Event_RoundStart, EventHookMode:1);
	RegAdminCmd("sm_melee", Command_SMMelee, 4, "Lists all melee weapons spawnable in current campaign", "", 0);
	return void:0;
}

public Action:Command_SMMelee(client, args)
{
	new i;
	while (i < g_iMeleeClassCount)
	{
		PrintToChat(client, "%d : %s", i, g_sMeleeClass[i]);
		i++;
	}
	return Action:0;
}

public void:OnMapStart()
{
	PrecacheModel("models/weapons/melee/v_bat.mdl", true);
	PrecacheModel("models/weapons/melee/v_cricket_bat.mdl", true);
	PrecacheModel("models/weapons/melee/v_crowbar.mdl", true);
	PrecacheModel("models/weapons/melee/v_electric_guitar.mdl", true);
	PrecacheModel("models/weapons/melee/v_fireaxe.mdl", true);
	PrecacheModel("models/weapons/melee/v_frying_pan.mdl", true);
	PrecacheModel("models/weapons/melee/v_golfclub.mdl", true);
	PrecacheModel("models/weapons/melee/v_katana.mdl", true);
	PrecacheModel("models/weapons/melee/v_machete.mdl", true);
	PrecacheModel("models/weapons/melee/v_tonfa.mdl", true);
	PrecacheModel("models/weapons/melee/w_bat.mdl", true);
	PrecacheModel("models/weapons/melee/w_cricket_bat.mdl", true);
	PrecacheModel("models/weapons/melee/w_crowbar.mdl", true);
	PrecacheModel("models/weapons/melee/w_electric_guitar.mdl", true);
	PrecacheModel("models/weapons/melee/w_fireaxe.mdl", true);
	PrecacheModel("models/weapons/melee/w_frying_pan.mdl", true);
	PrecacheModel("models/weapons/melee/w_golfclub.mdl", true);
	PrecacheModel("models/weapons/melee/w_katana.mdl", true);
	PrecacheModel("models/weapons/melee/w_machete.mdl", true);
	PrecacheModel("models/weapons/melee/w_tonfa.mdl", true);
	PrecacheModel("models/w_models/weapons/w_sniper_scout.mdl", false);
	PrecacheModel("models/v_models/v_snip_scout.mdl", false);
	PrecacheGeneric("scripts/melee/baseball_bat.txt", true);
	PrecacheGeneric("scripts/melee/cricket_bat.txt", true);
	PrecacheGeneric("scripts/melee/crowbar.txt", true);
	PrecacheGeneric("scripts/melee/electric_guitar.txt", true);
	PrecacheGeneric("scripts/melee/fireaxe.txt", true);
	PrecacheGeneric("scripts/melee/frying_pan.txt", true);
	PrecacheGeneric("scripts/melee/golfclub.txt", true);
	PrecacheGeneric("scripts/melee/katana.txt", true);
	PrecacheGeneric("scripts/melee/machete.txt", true);
	PrecacheGeneric("scripts/melee/tonfa.txt", true);
	new index = CreateEntityByName("weapon_sniper_scout", -1);
	DispatchSpawn(index);
	RemoveEdict(index);
	return void:0;
}

public Action:Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!GetConVarBool(g_hEnabled))
	{
		return Action:0;
	}
	g_bSpawnedMelee = false;
	new var1;
	if (g_iRound == 2 && IsVersus())
	{
		g_iRound = 1;
	}
	else
	{
		g_iRound = 2;
	}
	GetMeleeClasses();
	CreateTimer(1.0, Timer_SpawnMelee, any:0, 0);
	return Action:0;
}

public Action:Timer_SpawnMelee(Handle:timer)
{
	new client = GetInGameClient();
	new var1;
	if (client && !g_bSpawnedMelee)
	{
		decl Float:SpawnPosition[3];
		decl Float:SpawnAngle[3];
		GetClientAbsOrigin(client, SpawnPosition);
		SpawnPosition[2] += 20;
		SpawnAngle[0] = 90.0;
		if (GetConVarBool(g_hWeaponRandom))
		{
			new i;
			while (GetConVarInt(g_hWeaponRandomAmount) > i)
			{
				new RandomMelee = GetRandomInt(0, g_iMeleeClassCount + -1);
				new var2;
				if (IsVersus() && g_iRound == 2)
				{
					RandomMelee = g_iMeleeRandomSpawn[i];
				}
				SpawnMelee(g_sMeleeClass[RandomMelee], SpawnPosition, SpawnAngle);
				new var3;
				if (IsVersus() && g_iRound == 1)
				{
					g_iMeleeRandomSpawn[i] = RandomMelee;
				}
				i++;
			}
			g_bSpawnedMelee = true;
		}
		else
		{
			SpawnCustomList(SpawnPosition, SpawnAngle);
			g_bSpawnedMelee = true;
		}
	}
	else
	{
		if (!g_bSpawnedMelee)
		{
			CreateTimer(1.0, Timer_SpawnMelee, any:0, 0);
		}
	}
	return Action:0;
}

SpawnCustomList(Float:Position[3], Float:Angle[3])
{
	decl String:ScriptName[32];
	if (0 < GetConVarInt(g_hWeaponBaseballBat))
	{
		new i;
		while (GetConVarInt(g_hWeaponBaseballBat) > i)
		{
			GetScriptName("baseball_bat", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponCricketBat))
	{
		new i;
		while (GetConVarInt(g_hWeaponCricketBat) > i)
		{
			GetScriptName("cricket_bat", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponCrowbar))
	{
		new i;
		while (GetConVarInt(g_hWeaponCrowbar) > i)
		{
			GetScriptName("crowbar", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponElecGuitar))
	{
		new i;
		while (GetConVarInt(g_hWeaponElecGuitar) > i)
		{
			GetScriptName("electric_guitar", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponFireAxe))
	{
		new i;
		while (GetConVarInt(g_hWeaponFireAxe) > i)
		{
			GetScriptName("fireaxe", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponFryingPan))
	{
		new i;
		while (GetConVarInt(g_hWeaponFryingPan) > i)
		{
			GetScriptName("frying_pan", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponGolfClub))
	{
		new i;
		while (GetConVarInt(g_hWeaponGolfClub) > i)
		{
			GetScriptName("golfclub", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponKnife))
	{
		new i;
		while (GetConVarInt(g_hWeaponKnife) > i)
		{
			GetScriptName("hunting_knife", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponKatana))
	{
		new i;
		while (GetConVarInt(g_hWeaponKatana) > i)
		{
			GetScriptName("katana", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponMachete))
	{
		new i;
		while (GetConVarInt(g_hWeaponMachete) > i)
		{
			GetScriptName("machete", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponRiotShield))
	{
		new i;
		while (GetConVarInt(g_hWeaponRiotShield) > i)
		{
			GetScriptName("riotshield", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	if (0 < GetConVarInt(g_hWeaponTonfa))
	{
		new i;
		while (GetConVarInt(g_hWeaponTonfa) > i)
		{
			GetScriptName("tonfa", ScriptName);
			SpawnMelee(ScriptName, Position, Angle);
			i++;
		}
	}
	return 0;
}

SpawnMelee(String:Class[32], Float:Position[3], Float:Angle[3])
{
	decl Float:SpawnPosition[3];
	decl Float:SpawnAngle[3];
	new var1 = Position;
	SpawnPosition = var1;
	new var2 = Angle;
	SpawnAngle = var2;
	SpawnPosition[0] = SpawnPosition[0] + GetRandomInt(0, 20) + -10;
	SpawnPosition[1] += GetRandomInt(0, 20) + -10;
	SpawnPosition[2] += GetRandomInt(0, 10);
	SpawnAngle[1] = GetRandomFloat(0.0, 360.0);
	new MeleeSpawn = CreateEntityByName("weapon_melee", -1);
	DispatchKeyValue(MeleeSpawn, "melee_script_name", Class);
	DispatchSpawn(MeleeSpawn);
	TeleportEntity(MeleeSpawn, SpawnPosition, SpawnAngle, NULL_VECTOR);
	return 0;
}

GetMeleeClasses()
{
	new MeleeStringTable = FindStringTable("MeleeWeapons");
	g_iMeleeClassCount = GetStringTableNumStrings(MeleeStringTable);
	new i;
	while (i < g_iMeleeClassCount)
	{
		ReadStringTable(MeleeStringTable, i, g_sMeleeClass[i], 32);
		i++;
	}
	return 0;
}

GetScriptName(String:Class[32], String:ScriptName[32])
{
	new i;
	while (i < g_iMeleeClassCount)
	{
		if (!(StrContains(g_sMeleeClass[i], Class, false)))
		{
			Format(ScriptName, 32, "%s", g_sMeleeClass[i]);
			return 0;
		}
		i++;
	}
	new var1 = g_sMeleeClass;
	Format(ScriptName, 32, "%s", var1[0][var1]);
	return 0;
}

GetInGameClient()
{
	new x = 1;
	while (GetClientCount(true) >= x)
	{
		new var1;
		if (IsClientInGame(x) && GetClientTeam(x) == 2)
		{
			return x;
		}
		x++;
	}
	return 0;
}

bool:IsVersus()
{
	new String:GameMode[32];
	GetConVarString(FindConVar("mp_gamemode"), GameMode, 32);
	if (StrContains(GameMode, "versus", false) != -1)
	{
		return true;
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2",
	date = "12/07/2014",
	time = "03:34:58"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new bool:isJockey[66];
public Plugin:myinfo =
{
	name = "Musical Jockeys",
	description = "Prevents jockeys being able to spawn without making any noise.",
	author = "Jacob",
	version = "1.1",
	url = "github.com/jacob404/myplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_spawn", Event_PlayerSpawn, EventHookMode:1);
	return 0;
}

public OnMapStart()
{
	PrecacheSound("music/bacteria/jockeybacterias.wav", false);
	return 0;
}

public L4D_OnEnterGhostState(client)
{
	if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 5)
	{
		isJockey[client] = 1;
	}
	return 0;
}

public Action:Event_PlayerSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (IsValidPlayer(client) && GetClientTeam(client) == 3 && isJockey[client])
	{
		EmitSoundToAll("music/bacteria/jockeybacterias.wav", -2, 0, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
	}
	isJockey[client] = 0;
	return Action:0;
}

bool:IsValidPlayer(client)
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return false;
	}
	if (!IsClientInGame(client))
	{
		return false;
	}
	if (IsFakeClient(client))
	{
		return false;
	}
	return true;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/20/2017",
	time = "14:18:13"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new bool:isJockey[66];
public Plugin:myinfo =
{
	name = "Musical Jockeys",
	description = "Prevents the Jockey from having silent spawns.",
	author = "Jacob",
	version = "1.2",
	url = "Earth"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_spawn", Event_PlayerSpawn, EventHookMode:1);
	return 0;
}

public OnMapStart()
{
	PrecacheSound("music/bacteria/smokerbacterias.wav", false);
	PrecacheSound("music/bacteria/boomerbacterias.wav", false);
	PrecacheSound("music/bacteria/hunterbacterias.wav", false);
	PrecacheSound("music/bacteria/jockeybacterias.wav", false);
	PrecacheSound("music/bacteria/chargerbacterias.wav", false);
	return 0;
}

public L4D_OnEnterGhostState(client)
{
	Clear(client);
	new SI = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	if (SI == 5)
	{
		isJockey[client] = 1;
	}
	return 0;
}

public Action:Event_PlayerSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (IsValidPlayer(client) && GetClientTeam(client) == 3)
	{
		if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8)
		{
			Clear(client);
		}
		if (isJockey[client])
		{
			PlaySound(5);
		}
	}
	return Action:0;
}

bool:IsValidPlayer(client)
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		return false;
	}
	if (!IsClientInGame(client))
	{
		return false;
	}
	if (IsFakeClient(client))
	{
		return false;
	}
	return true;
}

public Clear(client)
{
	isJockey[client] = 0;
	return 0;
}

public PlaySound(ZClass)
{
	EmitSoundToAll("music/bacteria/jockeybacterias.wav", -2, 0, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "12/10/2015",
	time = "12:51:30"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new bool:g_bIsSewers;
public Plugin:myinfo =
{
	name = "No Mercy 3 Ladder Fix",
	description = "Blocks players getting incapped from full hp on the ladder.",
	author = "Jacob",
	version = "1.0",
	url = "github.com/jacob404/myplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnMapStart()
{
	decl String:mapname[64];
	GetCurrentMap(mapname, 64);
	if (StrEqual(mapname, "c8m3_sewers", true))
	{
		g_bIsSewers = true;
	}
	else
	{
		g_bIsSewers = false;
	}
	return 0;
}

public OnClientPostAdminCheck(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}


/* ERROR! lysis.nodes.types.DReturn incompatible with lysis.nodes.types.DJump */
 function "OnTakeDamage" (number 6)
public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "08/05/2014",
	time = "18:01:56"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "NoBoom, NoHorde",
	description = "A plugin designed to reset the horde timer if a boomer dies without successfully landing a boom.",
	author = "CanadaRox",
	version = "1",
	url = "http://github.com/CanadaRox/sourcemod-plugins/"
};
new bool:hasBoomerSpawned;
new bool:hasBoomerBoomed;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_spawn", PlayerSpawn_Event, EventHookMode:1);
	HookEvent("player_now_it", PlayerNowIt_Event, EventHookMode:1);
	HookEvent("player_death", PlayerDeath_Event, EventHookMode:1);
	HookEvent("round_start", Reset_Event, EventHookMode:1);
	HookEvent("round_end", Reset_Event, EventHookMode:1);
	return 0;
}

public Reset_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	hasBoomerSpawned = false;
	hasBoomerBoomed = false;
	return 0;
}

public PlayerSpawn_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client && IsClientInGame(client) && !IsFakeClient(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 2)
	{
		hasBoomerSpawned = true;
	}
	return 0;
}

public PlayerNowIt_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new bool:by_boomer = GetEventBool(event, "by_boomer");
	new var1;
	if (by_boomer && hasBoomerSpawned)
	{
		hasBoomerBoomed = true;
	}
	return 0;
}

public PlayerDeath_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client && IsClientInGame(client) && GetClientTeam(client) == 3 && GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 2 && hasBoomerSpawned && !hasBoomerBoomed)
	{
		L4D2_CTimerReset(L4D2CountdownTimer:0);
	}
	hasBoomerSpawned = false;
	hasBoomerBoomed = false;
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "05/24/2018",
	time = "22:07:35"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new bool:Blocked[66];
new bool:bSkipPrint[66];
new Float:fSavedTime[66];
public Plugin:myinfo =
{
	name = "Death Cam Skip Fix",
	description = "Blocks players skipping their death cam by going spec, also puts players in a spec mode on death so they don't get bored.",
	author = "Jacob, Sir",
	version = "1.4",
	url = "..."
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public void:OnPluginStart()
{
	HookEvent("player_death", Event_PlayerDeath, EventHookMode:1);
	AddCommandListener(Listener_Join, "jointeam");
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i))
		{
			Blocked[i] = 0;
			bSkipPrint[i] = 0;
			fSavedTime[i] = 0;
		}
		i++;
	}
	return void:0;
}

public Action:Listener_Join(client, String:command[], argc)
{
	new var1;
	if (client && argc)
	{
		new String:sJoin[32];
		GetCmdArg(1, sJoin, 32);
		new var2;
		if (StrEqual(sJoin, "Infected", false) || StringToInt(sJoin, 10) == 3)
		{
			if (GetConVarInt(FindConVar("z_max_player_zombies")) == GetInfectedPlayers())
			{
				return Action:3;
			}
			if (Blocked[client])
			{
				if (!bSkipPrint[client])
				{
					CPrintToChatAll("{red}[{default}Exploit{red}] {olive}%N {default}tried skipping the Death Timer.", client);
					bSkipPrint[client] = 1;
				}
				CPrintToChat(client, "{red}[{default}Exploit{red}] {default}You will be unable to join the Team for {red}%.1f {default}Seconds.", fSavedTime[client][6.0] - GetGameTime());
				CPrintToChat(client, "{red}[{default}Exploit{red}] {default}You will be moved automatically.");
				return Action:3;
			}
			if (GetConVarInt(FindConVar("z_max_player_zombies")) == GetBlockedPlayers() + GetInfectedPlayers())
			{
				CPrintToChat(client, "{red}[{default}!{red}] {default}This team currently has slots {olive}reserved{default}.");
				return Action:3;
			}
		}
	}
	return Action:0;
}

GetInfectedPlayers()
{
	new count;
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && GetClientTeam(i) == 3 && !IsFakeClient(i))
		{
			count++;
		}
		i++;
	}
	return count;
}

GetBlockedPlayers()
{
	new count;
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && bSkipPrint[i] && !IsFakeClient(i))
		{
			count++;
		}
		i++;
	}
	return count;
}

public void:OnClientPutInServer(client)
{
	bSkipPrint[client] = 0;
	Blocked[client] = 0;
	fSavedTime[client] = 0;
	return void:0;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	new var1;
	if (IsValidInfected(client) && Blocked[client])
	{
		if (IsPlayerAlive(client))
		{
			Blocked[client] = 0;
			fSavedTime[client] = 0;
			bSkipPrint[client] = 0;
			return Action:0;
		}
	}
	return Action:0;
}

public Event_PlayerDeath(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid", 0));
	new var1;
	if (IsValidInfected(client) && 0.0 == fSavedTime[client])
	{
		Blocked[client] = 1;
		fSavedTime[client] = GetGameTime();
		CreateTimer(0.1, UnblockTimer, client, 3);
	}
	return 0;
}

public Action:UnblockTimer(Handle:timer, any:client)
{
	if (IsValidClient(client))
	{
		new Float:Time = GetGameTime();
		if (Time >= fSavedTime[client][6.0])
		{
			Blocked[client] = 0;
			fSavedTime[client] = 0;
			new var1;
			if (bSkipPrint[client] && GetClientTeam(client) == 1)
			{
				ChangeClientTeam(client, 3);
			}
			bSkipPrint[client] = 0;
			return Action:4;
		}
		return Action:0;
	}
	return Action:4;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	new var2;
	return IsClientInGame(client) && !IsFakeClient(client);
}

bool:IsValidInfected(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	new var2;
	return IsClientInGame(client) && GetClientTeam(client) == 3 && !IsFakeClient(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1-dev",
	date = "02/20/2012",
	time = "12:59:42"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new Float:SurvivorStart[3];
public Plugin:myinfo =
{
	name = "No Safe Room Medkits",
	description = "Removes Safe Room Medkits",
	author = "Blade",
	version = "0.1.1",
	url = "nope"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:operator==(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) == 0;
}

bool:operator<(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) < 0;
}

bool:operator<(Float:,_:)(Float:oper1, oper2)
{
	return FloatCompare(oper1, float(oper2)) < 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	CreateConVar("nokits_version", "0.1.1", "No Safe Room Medkits Version", 270656, false, 0.0, false, 0.0);
	HookEvent("round_start", Event_RoundStart, EventHookMode:1);
	decl String:game[64];
	GetGameFolderName(game, 64);
	if (!StrEqual(game, "left4dead2", false))
	{
		SetFailState("Plugin supports Left 4 Dead 2 only.");
	}
	return 0;
}

public Action:Event_RoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	new String:GameMode[32];
	GetConVarString(FindConVar("mp_gamemode"), GameMode, 32);
	if (StrContains(GameMode, "versus", false) != -1)
	{
		FindSurvivorStart();
		ReplaceMedkits();
	}
	return Action:0;
}

public FindSurvivorStart()
{
	new EntityCount = GetEntityCount();
	new String:EdictClassName[128];
	new Float:Location[3] = 0.0;
	new i;
	while (i <= EntityCount)
	{
		if (IsValidEntity(i))
		{
			GetEdictClassname(i, EdictClassName, 128);
			new var1;
			if (StrContains(EdictClassName, "prop_door_rotating_checkpoint", false) != -1 && GetEntProp(i, PropType:0, "m_bLocked", 4, 0) == 1)
			{
				GetEntPropVector(i, PropType:0, "m_vecOrigin", Location, 0);
				return 0;
			}
		}
		i++;
	}
	new i;
	while (i <= EntityCount)
	{
		if (IsValidEntity(i))
		{
			GetEdictClassname(i, EdictClassName, 128);
			if (StrContains(EdictClassName, "info_survivor_position", false) != -1)
			{
				GetEntPropVector(i, PropType:0, "m_vecOrigin", Location, 0);
				return 0;
			}
		}
		i++;
	}
	return 0;
}

public ReplaceMedkits()
{
	new EntityCount = GetEntityCount();
	new String:EdictClassName[128];
	new Float:NearestMedkit[3] = 0.0;
	new Float:Location[3] = 0.0;
	new i;
	while (i <= EntityCount)
	{
		if (IsValidEntity(i))
		{
			GetEdictClassname(i, EdictClassName, 128);
			if (StrContains(EdictClassName, "weapon_first_aid_kit", false) != -1)
			{
				GetEntPropVector(i, PropType:0, "m_vecOrigin", Location, 0);
				if (!(0 == NearestMedkit[0] + NearestMedkit[1] + NearestMedkit[2]))
				{
					if (GetVectorDistance(SurvivorStart, Location, false) < GetVectorDistance(SurvivorStart, NearestMedkit, false))
					{
					}
				}
				i++;
			}
		}
		i++;
	}
	new i;
	while (i <= EntityCount)
	{
		if (IsValidEntity(i))
		{
			GetEdictClassname(i, EdictClassName, 128);
			if (StrContains(EdictClassName, "weapon_first_aid_kit", false) != -1)
			{
				GetEntPropVector(i, PropType:0, "m_vecOrigin", Location, 0);
				if (GetVectorDistance(NearestMedkit, Location, false) < 400)
				{
					AcceptEntityInput(i, "Kill", -1, -1, 0);
				}
			}
		}
		i++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+3944",
	date = "07/17/2013",
	time = "14:43:27"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 1,
};
public Plugin:myinfo =
{
	name = "Add Text To Readyup Panel",
	description = "Displays custom text in the readyup panel. Spanks for the help CanadaRox!",
	author = "epilimic",
	version = "1 point 1",
	url = "http://buttsecs.org"
};
new String:panelText[10][68];
new stringCount;
new bool:areStringsLocked;
new Handle:sm_readypaneltextdelay;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public OnPluginStart()
{
	RegServerCmd("sm_addreadystring", AddReadyString_Cmd, "Sets the string to add to the ready-up panel", 262144);
	RegServerCmd("sm_resetstringcount", ResetStringCount_Cmd, "Resets the string count", 262144);
	RegServerCmd("sm_lockstrings", LockStrings_Cmd, "Locks the strings", 262144);
	HookEvent("round_start", RoundStart_Event, EventHookMode:2);
	sm_readypaneltextdelay = CreateConVar("sm_readypaneltextdelay", "4.0", "Delay before adding the text to the ready-up panel for order control", 262144, true, 0.0, true, 10.0);
	return 0;
}

public Action:LockStrings_Cmd(args)
{
	areStringsLocked = true;
	return Action:3;
}

public Action:AddReadyString_Cmd(args)
{
	new var1;
	if (stringCount < 10 && !areStringsLocked)
	{
		GetCmdArg(1, panelText[stringCount], 65);
		stringCount += 1;
	}
	return Action:3;
}

public Action:ResetStringCount_Cmd(args)
{
	stringCount = 0;
	areStringsLocked = false;
	return Action:3;
}

public RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	CreateTimer(GetConVarFloat(sm_readypaneltextdelay), panelTimer, any:0, 0);
	return 0;
}

public Action:panelTimer(Handle:timer)
{
	new i;
	while (i < stringCount && AddStringToReadyFooter(panelText[i]))
	{
		i++;
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "07/13/2017",
	time = "05:48:59"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 0,
};
public Plugin:myinfo =
{
	name = "Pause plugin",
	description = "Adds pause functionality without breaking pauses, also prevents SI from spawning because of the Pause.",
	author = "CanadaRox, Sir",
	version = "6.1",
	url = ""
};
new String:teamString[4][] =
{
	"None",
	"Spectator",
	"Survivors",
	"Infected"
};
new Handle:menuPanel;
new Handle:readyCountdownTimer;
new Handle:sv_pausable;
new Handle:sv_noclipduringpause;
new bool:adminPause;
new bool:isPaused;
new bool:teamReady[4];
new readyDelay;
new Handle:pauseDelayCvar;
new pauseDelay;
new bool:readyUpIsAvailable;
new Handle:pauseForward;
new Handle:unpauseForward;
new Handle:deferredPauseTimer;
new Handle:SpecTimer[66];
new IgnorePlayer[66];
new bool:RoundEnd;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

FindCharInString(String:str[], c, bool:reverse)
{
	new i;
	new len = strlen(str);
	if (!reverse)
	{
		i = 0;
		while (i < len)
		{
			if (c == str[i])
			{
				return i;
			}
			i++;
		}
	}
	else
	{
		i = len + -1;
		while (0 <= i)
		{
			if (c == str[i])
			{
				return i;
			}
			i--;
		}
	}
	return -1;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

PrintHintTextToAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintHintText(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

GetClientButtons(client)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_nButtons", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_nButtons");
		}
		gotconfig = true;
	}
	return GetEntProp(client, PropType:1, datamap, 4, 0);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CPrintToChatEx(client, author, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	new var2;
	if (author < 0 || author > MaxClients)
	{
		ThrowError("Invalid client index %d", author);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 4);
	new index = CFormat(szCMessage, 250, author);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, author, szCMessage);
	}
	return 0;
}

CPrintToChatAllEx(author, String:szMessage[])
{
	new var1;
	if (author < 0 || author > MaxClients)
	{
		ThrowError("Invalid client index %d", author);
	}
	if (!IsClientInGame(author))
	{
		ThrowError("Client %d is not in game", author);
	}
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var2;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 3);
			CPrintToChatEx(i, author, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

min(a, b)
{
	new var1;
	if (a < b)
	{
		var1 = a;
	}
	else
	{
		var1 = b;
	}
	return var1;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	CreateNative("IsInPause", Native_IsInPause);
	pauseForward = CreateGlobalForward("OnPause", ExecType:2);
	unpauseForward = CreateGlobalForward("OnUnpause", ExecType:2);
	RegPluginLibrary("pause");
	MarkNativeAsOptional("IsInReady");
	return APLRes:0;
}

public OnPluginStart()
{
	RegConsoleCmd("sm_spectate", Spectate_Cmd, "Moves you to the spectator team", 0);
	RegConsoleCmd("sm_spec", Spectate_Cmd, "Moves you to the spectator team", 0);
	RegConsoleCmd("sm_s", Spectate_Cmd, "Moves you to the spectator team", 0);
	RegConsoleCmd("sm_pause", Pause_Cmd, "Pauses the game", 0);
	RegConsoleCmd("sm_unpause", Unpause_Cmd, "Marks your team as ready for an unpause", 0);
	RegConsoleCmd("sm_ready", Unpause_Cmd, "Marks your team as ready for an unpause", 0);
	RegConsoleCmd("sm_unready", Unready_Cmd, "Marks your team as ready for an unpause", 0);
	RegConsoleCmd("sm_toggleready", Toggleready_Cmd, "Marks your team as ready for an unpause", 0);
	RegAdminCmd("sm_forcepause", ForcePause_Cmd, 8, "Pauses the game and only allows admins to unpause", "", 0);
	RegAdminCmd("sm_forceunpause", ForceUnpause_Cmd, 8, "Unpauses the game regardless of team ready status.  Must be used to unpause admin pauses", "", 0);
	AddCommandListener(Say_Callback, "say");
	AddCommandListener(TeamSay_Callback, "say_team");
	AddCommandListener(Unpause_Callback, "unpause");
	AddCommandListener(Callvote_Callback, "callvote");
	sv_pausable = FindConVar("sv_pausable");
	sv_noclipduringpause = FindConVar("sv_noclipduringpause");
	pauseDelayCvar = CreateConVar("sm_pausedelay", "0", "Delay to apply before a pause happens.  Could be used to prevent Tactical Pauses", 262144, true, 0.0, false, 0.0);
	HookEvent("round_end", RoundEnd_Event, EventHookMode:2);
	HookEvent("round_start", RoundStart_Event, EventHookMode:1);
	return 0;
}

public OnAllPluginsLoaded()
{
	readyUpIsAvailable = LibraryExists("readyup");
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		readyUpIsAvailable = false;
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		readyUpIsAvailable = true;
	}
	return 0;
}

public Native_IsInPause(Handle:plugin, numParams)
{
	return isPaused;
}

public OnClientPutInServer(client)
{
	if (isPaused)
	{
		if (!IsFakeClient(client))
		{
			CPrintToChatAll("{default}[{green}!{default}] {olive}%N {default}has fully loaded", client);
		}
	}
	return 0;
}

public RoundEnd_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (deferredPauseTimer)
	{
		CloseHandle(deferredPauseTimer);
		deferredPauseTimer = MissingTAG:0;
	}
	RoundEnd = true;
	return 0;
}

public RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			IgnorePlayer[client] = 0;
		}
		client++;
	}
	RoundEnd = false;
	return 0;
}

public Action:Spectate_Cmd(client, args)
{
	if (IgnorePlayer[client] <= 10)
	{
		IgnorePlayer[client] = IgnorePlayer[client] + 2;
	}
	if (!SpecTimer[client])
	{
		SpecTimer[client] = CreateTimer(1.0, SecureSpec, client, 1);
	}
	return Action:0;
}

public Action:SecureSpec(Handle:timer, any:client)
{
	IgnorePlayer[client]--;
	if (IgnorePlayer[client])
	{
		return Action:0;
	}
	SpecTimer[client] = 0;
	return Action:4;
}

public Action:Pause_Cmd(client, args)
{
	new var1;
	if ((!readyUpIsAvailable || !IsInReady()) && (pauseDelay && !isPaused && IsPlayer(client) && !RoundEnd))
	{
		CPrintToChatAll("{default}[{green}!{default}] {olive}%N {blue}Paused{default}.", client);
		pauseDelay = GetConVarInt(pauseDelayCvar);
		if (pauseDelay)
		{
			CreateTimer(1.0, PauseDelay_Timer, any:0, 3);
		}
		AttemptPause();
	}
	return Action:3;
}

public Action:PauseDelay_Timer(Handle:timer)
{
	if (pauseDelay)
	{
		CPrintToChatAll("{default}[{green}!{default}] {blue}Pausing in{default}: {olive}%d", pauseDelay);
		pauseDelay -= 1;
		return Action:0;
	}
	CPrintToChatAll("{default}[{green}!{default}] {red}PAUSED");
	AttemptPause();
	return Action:4;
}

public Action:Unpause_Cmd(client, args)
{
	new var1;
	if (isPaused && IsPlayer(client))
	{
		new L4D2Team:clientTeam = GetClientTeam(client);
		if (!teamReady[clientTeam])
		{
			if (GetClientTeam(client) == 2)
			{
				CPrintToChatAll("{default}[{green}!{default}] {olive}%N {default}marked {blue}%s {default}ready.", client, teamString[GetClientTeam(client)]);
			}
			CPrintToChatAll("{default}[{green}!{default}] {olive}%N {default}marked {red}%s {default}ready.", client, teamString[GetClientTeam(client)]);
		}
		teamReady[clientTeam] = 1;
		if (CheckFullReady())
		{
			InitiateLiveCountdown();
		}
	}
	return Action:3;
}

public Action:Unready_Cmd(client, args)
{
	new var1;
	if (isPaused && IsPlayer(client) && !adminPause)
	{
		new L4D2Team:clientTeam = GetClientTeam(client);
		if (teamReady[clientTeam])
		{
			if (GetClientTeam(client) == 2)
			{
				CPrintToChatAll("{default}[{green}!{default}] {olive}%N {default}marked {blue}%s {default}not ready.", client, teamString[GetClientTeam(client)]);
			}
			CPrintToChatAll("{default}[{green}!{default}] {olive}%N {default}marked {red}%s {default}not ready.", client, teamString[GetClientTeam(client)]);
		}
		teamReady[clientTeam] = 0;
		CancelFullReady(client);
	}
	return Action:3;
}

public Action:Toggleready_Cmd(client, args)
{
	new var1;
	if (isPaused && IsPlayer(client) && !adminPause)
	{
		new L4D2Team:clientTeam = GetClientTeam(client);
		if (teamReady[clientTeam])
		{
			if (GetClientTeam(client) == 2)
			{
				CPrintToChatAll("{default}[{green}!{default}] {olive}%N {default}marked {blue}%s {default}not ready.", client, teamString[GetClientTeam(client)]);
			}
			else
			{
				CPrintToChatAll("{default}[{green}!{default}] {olive}%N {default}marked {red}%s {default}not ready.", client, teamString[GetClientTeam(client)]);
			}
			teamReady[clientTeam] = 0;
			CancelFullReady(client);
		}
		else
		{
			if (!teamReady[clientTeam])
			{
				if (GetClientTeam(client) == 2)
				{
					CPrintToChatAll("{default}[{green}!{default}] {olive}%N {default}marked {blue}%s {default}ready.", client, teamString[GetClientTeam(client)]);
				}
				else
				{
					CPrintToChatAll("{default}[{green}!{default}] {olive}%N {default}marked {red}%s {default}ready.", client, teamString[GetClientTeam(client)]);
				}
				teamReady[clientTeam] = 1;
				if (CheckFullReady())
				{
					InitiateLiveCountdown();
				}
			}
		}
	}
	return Action:3;
}

public Action:ForcePause_Cmd(client, args)
{
	if (!isPaused)
	{
		adminPause = true;
		Pause();
	}
	return Action:0;
}

public Action:ForceUnpause_Cmd(client, args)
{
	if (isPaused)
	{
		InitiateLiveCountdown();
	}
	return Action:0;
}

AttemptPause()
{
	if (!deferredPauseTimer)
	{
		if (CanPause())
		{
			Pause();
		}
		CPrintToChatAll("{default}[{green}!{default}] {red}Pause has been delayed due to a pick-up in progress!");
		deferredPauseTimer = CreateTimer(0.1, DeferredPause_Timer, any:0, 1);
	}
	return 0;
}

public Action:DeferredPause_Timer(Handle:timer)
{
	if (CanPause())
	{
		deferredPauseTimer = MissingTAG:0;
		Pause();
		return Action:4;
	}
	return Action:0;
}

Pause()
{
	new L4D2Team:team;
	while (team < L4D2Team:4)
	{
		teamReady[team] = 0;
		team++;
	}
	isPaused = true;
	readyCountdownTimer = MissingTAG:0;
	CreateTimer(1.0, MenuRefresh_Timer, any:0, 3);
	new bool:pauseProcessed;
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			new var1;
			if (GetClientTeam(client) == 3 && IsGhost(client))
			{
				SetEntProp(client, PropType:0, "m_hasVisibleThreats", any:1, 4, 0);
				new buttons = GetClientButtons(client);
				if (buttons & 1)
				{
					buttons &= -2;
					SetClientButtons(client, buttons);
					CPrintToChat(client, "{default}[{green}!{default}] {default}Your {red}Spawn {default}has been prevented because of the Pause");
				}
			}
			if (!pauseProcessed)
			{
				SetConVarBool(sv_pausable, true, false, false);
				FakeClientCommand(client, "pause");
				SetConVarBool(sv_pausable, false, false, false);
				pauseProcessed = true;
			}
			if (GetClientTeam(client) == 1)
			{
				SendConVarValue(client, sv_noclipduringpause, "1");
			}
		}
		client++;
	}
	Call_StartForward(pauseForward);
	Call_Finish(0);
	return 0;
}

Unpause()
{
	isPaused = false;
	new bool:unpauseProcessed;
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			if (!unpauseProcessed)
			{
				SetConVarBool(sv_pausable, true, false, false);
				FakeClientCommand(client, "unpause");
				SetConVarBool(sv_pausable, false, false, false);
				unpauseProcessed = true;
			}
			new var1;
			if (GetClientTeam(client) == 1 && !IsFakeClient(client))
			{
				SendConVarValue(client, sv_noclipduringpause, "0");
			}
		}
		client++;
	}
	Call_StartForward(unpauseForward);
	Call_Finish(0);
	return 0;
}

public Action:MenuRefresh_Timer(Handle:timer)
{
	if (isPaused)
	{
		UpdatePanel();
		return Action:0;
	}
	return Action:3;
}

UpdatePanel()
{
	if (menuPanel)
	{
		CloseHandle(menuPanel);
		menuPanel = MissingTAG:0;
	}
	menuPanel = CreatePanel(Handle:0);
	DrawPanelText(menuPanel, "Team Status");
	new var1;
	if (teamReady[2])
	{
		var1[0] = 4924;
	}
	else
	{
		var1[0] = 4948;
	}
	DrawPanelText(menuPanel, var1);
	new var2;
	if (teamReady[3])
	{
		var2[0] = 4976;
	}
	else
	{
		var2[0] = 5000;
	}
	DrawPanelText(menuPanel, var2);
	new client = 1;
	while (client <= MaxClients)
	{
		new var3;
		if (IsClientInGame(client) && !IsFakeClient(client))
		{
			SendPanelToClient(menuPanel, client, DummyHandler, 1);
		}
		client++;
	}
	return 0;
}

InitiateLiveCountdown()
{
	if (!readyCountdownTimer)
	{
		CPrintToChatAll("{default}[{green}!{default}] Say {olive}!unready {default}to cancel");
		readyDelay = 3;
		readyCountdownTimer = CreateTimer(1.0, ReadyCountdownDelay_Timer, any:0, 3);
	}
	return 0;
}

public Action:ReadyCountdownDelay_Timer(Handle:timer)
{
	if (readyDelay)
	{
		CPrintToChatAll("{default}[{green}!{default}] {blue}Live in{default}: {olive}%d{default}...", readyDelay);
		readyDelay -= 1;
		return Action:0;
	}
	PrintHintTextToAll("Game is live!");
	Unpause();
	return Action:4;
}

CancelFullReady(client)
{
	if (readyCountdownTimer)
	{
		CloseHandle(readyCountdownTimer);
		readyCountdownTimer = MissingTAG:0;
		CPrintToChatAll("{default}[{green}!{default}] {olive}%N {default}cancelled the countdown!", client);
	}
	return 0;
}

public Action:Callvote_Callback(client, String:command[], argc)
{
	if (GetClientTeam(client) == 1)
	{
		CPrintToChat(client, "{blue}[{green}!{blue}] {default}You're unable to call votes as a spectator.");
		return Action:3;
	}
	if (0 < IgnorePlayer[client])
	{
		CPrintToChat(client, "{blue}[{green}!{blue}] {default}You've just switched Teams, you are unable to vote for a few seconds.");
		return Action:3;
	}
	if (argc < 2)
	{
		return Action:0;
	}
	decl String:votereason[16];
	GetCmdArg(1, votereason, 16);
	if (!!strcmp(votereason, "kick", false))
	{
		return Action:0;
	}
	decl String:therest[256];
	GetCmdArg(2, therest, 256);
	new userid;
	new spacepos = FindCharInString(therest, 32, false);
	if (spacepos > -1)
	{
		decl String:temp[12];
		strcopy(temp, min(spacepos + 1, 12), therest);
		userid = StringToInt(temp, 10);
	}
	else
	{
		userid = StringToInt(therest, 10);
	}
	new target = GetClientOfUserId(userid);
	if (target < 1)
	{
		return Action:0;
	}
	new AdminId:clientAdmin = GetUserAdmin(client);
	new AdminId:targetAdmin = GetUserAdmin(target);
	new var1;
	if (clientAdmin == AdminId:-1 && targetAdmin == AdminId:-1)
	{
		return Action:0;
	}
	if (CanAdminTarget(clientAdmin, targetAdmin))
	{
		return Action:0;
	}
	CPrintToChat(client, "{blue}[{green}!{blue}] {default}You may not kick Admins.", target);
	return Action:3;
}

public Action:Say_Callback(client, String:command[], argc)
{
	if (isPaused)
	{
		decl String:buffer[256];
		GetCmdArgString(buffer, 256);
		StripQuotes(buffer);
		new var1;
		if (buffer[0] == '!' || buffer[0] == '/')
		{
			return Action:3;
		}
		if (client)
		{
			CPrintToChatAllEx(client, "{teamcolor}%N{default} : %s", client, buffer);
		}
		else
		{
			PrintToChatAll("Console : %s", buffer);
		}
		return Action:3;
	}
	return Action:0;
}

public Action:TeamSay_Callback(client, String:command[], argc)
{
	if (isPaused)
	{
		decl String:buffer[256];
		GetCmdArgString(buffer, 256);
		StripQuotes(buffer);
		new var1;
		if (buffer[0] == '!' || buffer[0] == '/')
		{
			return Action:3;
		}
		PrintToTeam(client, GetClientTeam(client), buffer);
		return Action:3;
	}
	return Action:0;
}

public Action:Unpause_Callback(client, String:command[], argc)
{
	if (isPaused)
	{
		return Action:3;
	}
	return Action:0;
}

bool:CheckFullReady()
{
	new var1;
	return (teamReady[2] || GetTeamHumanCount(L4D2Team:2)) && (teamReady[3] || GetTeamHumanCount(L4D2Team:3));
}

IsPlayer(client)
{
	new L4D2Team:team = GetClientTeam(client);
	if (0 < IgnorePlayer[client])
	{
		return 0;
	}
	new var2;
	return client && (team == L4D2Team:2 || team == L4D2Team:3);
}

PrintToTeam(author, L4D2Team:team, String:buffer[])
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && team == GetClientTeam(client))
		{
			CPrintToChatEx(client, author, "(%s) {teamcolor}%N{default} :  %s", teamString[GetClientTeam(author)], author, buffer);
		}
		client++;
	}
	return 0;
}

public DummyHandler(Handle:menu, MenuAction:action, param1, param2)
{
	return 0;
}

GetTeamHumanCount(L4D2Team:team)
{
	new humans;
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && !IsFakeClient(client) && team == GetClientTeam(client))
		{
			humans++;
		}
		client++;
	}
	return humans;
}

bool:IsPlayerIncap(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

bool:CanPause()
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client) == 2)
		{
			if (IsPlayerIncap(client))
			{
				if (0 < GetEntProp(client, PropType:0, "m_reviveOwner", 4, 0))
				{
					return false;
				}
			}
			if (0 < GetEntProp(client, PropType:0, "m_reviveTarget", 4, 0))
			{
				return false;
			}
		}
		client++;
	}
	return true;
}

bool:IsGhost(client)
{
	return GetEntProp(client, PropType:0, "m_isGhost", 4, 0) == 1;
}

public SetClientButtons(client, button)
{
	new var1;
	if (IsClientConnected(client) && IsClientInGame(client))
	{
		SetEntProp(client, PropType:1, "m_nButtons", button, 4, 0);
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+3944",
	date = "07/22/2013",
	time = "22:58:28"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:WeaponNames[56][] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced",
	"weapon_shotgun_chrome",
	"weapon_rifle_desert",
	"weapon_sniper_military",
	"weapon_shotgun_spas",
	"weapon_first_aid_kit",
	"weapon_molotov",
	"weapon_pipe_bomb",
	"weapon_pain_pills",
	"weapon_gascan",
	"weapon_propanetank",
	"weapon_oxygentank",
	"weapon_melee",
	"weapon_chainsaw",
	"weapon_grenade_launcher",
	"weapon_ammo_pack",
	"weapon_adrenaline",
	"weapon_defibrillator",
	"weapon_vomitjar",
	"weapon_rifle_ak47",
	"weapon_gnome",
	"weapon_cola_bottles",
	"weapon_fireworkcrate",
	"weapon_upgradepack_incendiary",
	"weapon_upgradepack_explosive",
	"weapon_pistol_magnum",
	"weapon_smg_mp5",
	"weapon_rifle_sg552",
	"weapon_sniper_awp",
	"weapon_sniper_scout",
	"weapon_rifle_m60",
	"weapon_tank_claw",
	"weapon_hunter_claw",
	"weapon_charger_claw",
	"weapon_boomer_claw",
	"weapon_smoker_claw",
	"weapon_spitter_claw",
	"weapon_jockey_claw",
	"weapon_machinegun",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:WeaponModels[56][];
new WeaponSlots[56] =
{
	0, 1769169221, 1344303717, 543976553, 1936941392, 29285, 1634623811, 1867669860, 120, 1937007948, 1634496544, 1936876921, 1935765536, 1768956019, 544435308, 543452769, 1701995617, 1768710510, 1998611822, 543716457, 1818587691, 543449455, 1852139639, 1701344288, 1918967929, 1869095013, 1852400748, 1852776551, 1718558821, 1869116448, 1763730803, 1936549236, 0, 3288624, 1886680168, 1731145530, 1969779817, 1868770914, 1631793005, 1633968494, 796421970, 1920298867, 1869440355, 1819290980, 1852401525, 12147, 2448, 2480, 2468, 2576, 2580, 1819044171, 0, 1885431159, 1734307439, 1852143209
};
new Handle:hWeaponNamesTrie;
public Plugin:myinfo =
{
	name = "Easier Pill Passer",
	description = "Lets players pass pills and adrenaline with +reload when they are holding one of those items",
	author = "CanadaRox",
	version = "0.2",
	url = "http://github.com/CanadaRox/sourcemod-plugins/"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:operator<(Float:,_:)(Float:oper1, oper2)
{
	return FloatCompare(oper1, float(oper2)) < 0;
}

WeaponId:WeaponNameToId(String:weaponName[])
{
	if (!WeaponModels[0])
	{
		InitWeaponNamesTrie();
	}
	new WeaponID:id;
	if (GetTrieValue(WeaponModels[0], weaponName, id))
	{
		return id;
	}
	return WeaponId:0;
}

InitWeaponNamesTrie()
{
	WeaponModels[0] = CreateTrie();
	new i;
	while (i < 56)
	{
		SetTrieValue(WeaponModels[0], WeaponNames[i], i, true);
		i++;
	}
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	new var1;
	if (buttons & 8192 && !buttons & 32)
	{
		decl String:weapon_name[64];
		GetClientWeapon(client, weapon_name, 64);
		new WeaponId:wep = WeaponNameToId(weapon_name);
		new var2;
		if (wep == WeaponId:15 || wep == WeaponId:23)
		{
			new target = GetClientAimTarget(client, true);
			new var3;
			if (target != -1 && GetClientTeam(target) == 2 && GetPlayerWeaponSlot(target, 4) == -1 && !IsPlayerIncap(target))
			{
				decl Float:clientOrigin[3];
				decl Float:targetOrigin[3];
				GetClientAbsOrigin(client, clientOrigin);
				GetClientAbsOrigin(target, targetOrigin);
				if (GetVectorDistance(clientOrigin, targetOrigin, true) < 75076)
				{
					AcceptEntityInput(GetPlayerWeaponSlot(client, 4), "Kill", -1, -1, 0);
					new ent = CreateEntityByName(WeaponNames[wep], -1);
					DispatchSpawn(ent);
					EquipPlayerWeapon(target, ent);
					new Handle:hFakeEvent = CreateEvent("weapon_given", false);
					SetEventInt(hFakeEvent, "userid", GetClientUserId(target));
					SetEventInt(hFakeEvent, "giver", GetClientUserId(client));
					SetEventInt(hFakeEvent, "weapon", wep);
					SetEventInt(hFakeEvent, "weaponentid", ent);
					FireEvent(hFakeEvent, false);
				}
			}
		}
	}
	return Action:0;
}

bool:IsPlayerIncap(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "03/15/2014",
	time = "01:52:55"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public Plugin:myinfo =
{
	name = "Player Management Plugin",
	description = "Player management!  Swap players/teams and spectate!",
	author = "CanadaRox",
	version = "8",
	url = ""
};
new L4D2Team:oppositeTeamMap[4] =
{
	0, 1, 3, 2
};
new Handle:survivor_limit;
new Handle:z_max_player_zombies;
new L4D2Team:pendingSwaps[66];
new bool:blockVotes[66];
new bool:isMapActive;
new Handle:l4d_pm_supress_spectate;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

CPrintToChatEx(client, author, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	new var2;
	if (author < 0 || author > MaxClients)
	{
		ThrowError("Invalid client index %d", author);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 4);
	new index = CFormat(szCMessage, 250, author);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, author, szCMessage);
	}
	return 0;
}

CPrintToChatAllEx(author, String:szMessage[])
{
	new var1;
	if (author < 0 || author > MaxClients)
	{
		ThrowError("Invalid client index %d", author);
	}
	if (!IsClientInGame(author))
	{
		ThrowError("Client %d is not in game", author);
	}
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var2;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 3);
			CPrintToChatEx(i, author, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	LoadTranslations("common.phrases");
	RegAdminCmd("sm_swap", Swap_Cmd, 4, "sm_swap <player1> [player2] ... [playerN] - swap all listed players to opposite teams", "", 0);
	RegAdminCmd("sm_swapto", SwapTo_Cmd, 4, "sm_swapto [force] <teamnum> <player1> [player2] ... [playerN] - swap all listed players to <teamnum> (1,2, or 3)", "", 0);
	RegAdminCmd("sm_swapteams", SwapTeams_Cmd, 4, "sm_swapteams - swap the players between both teams", "", 0);
	RegAdminCmd("sm_fixbots", FixBots_Cmd, 8, "sm_fixbots - Spawns survivor bots to match survivor_limit", "", 0);
	RegConsoleCmd("sm_spectate", Spectate_Cmd, "Moves you to the spectator team", 0);
	RegConsoleCmd("sm_spec", Spectate_Cmd, "Moves you to the spectator team", 0);
	RegConsoleCmd("sm_s", Spectate_Cmd, "Moves you to the spectator team", 0);
	AddCommandListener(Vote_Listener, "vote");
	AddCommandListener(Vote_Listener, "callvote");
	survivor_limit = FindConVar("survivor_limit");
	SetConVarBounds(survivor_limit, ConVarBounds:0, false, 0.0);
	HookConVarChange(survivor_limit, survivor_limitChanged);
	z_max_player_zombies = FindConVar("z_max_player_zombies");
	SetConVarBounds(z_max_player_zombies, ConVarBounds:0, false, 0.0);
	l4d_pm_supress_spectate = CreateConVar("l4d_pm_supress_spectate", "0", "Don't print messages when players spectate", 262144, true, 0.0, true, 1.0);
	return 0;
}

public OnMapStart()
{
	isMapActive = true;
	return 0;
}

public OnMapEnd()
{
	isMapActive = false;
	return 0;
}

public Action:FixBots_Cmd(client, args)
{
	if (client)
	{
		PrintToChatAll("[SM] %N is attempting to fix bot counts");
	}
	else
	{
		PrintToChatAll("[SM] Console is attempting to fix bot counts");
	}
	FixBotCount();
	return Action:3;
}

public survivor_limitChanged(Handle:convar, String:oldValue[], String:newValue[])
{
	FixBotCount();
	return 0;
}

public OnClientAuthorized(client, String:auth[])
{
	decl String:name[32];
	new var1;
	if (IsFakeClient(client) && GetClientName(client, name, 32) && StrContains(name, "k9Q6CK42", true) > -1)
	{
		KickClient(client, "");
	}
	return 0;
}

public OnClientDisconnect_Post(client)
{
	if (isMapActive)
	{
		FixBotCount();
	}
	return 0;
}

public Action:Spectate_Cmd(client, args)
{
	if (!GetConVarBool(l4d_pm_supress_spectate))
	{
		CPrintToChatAllEx(client, "{teamcolor}%N{default} has become a spectator!", client);
	}
	new L4D2Team:team = GetClientTeamEx(client);
	if (team == L4D2Team:2)
	{
		ChangeClientTeamEx(client, L4D2Team:1, true);
	}
	else
	{
		if (team == L4D2Team:3)
		{
			if (GetZombieClass(client) != 8)
			{
				ForcePlayerSuicide(client);
			}
			ChangeClientTeamEx(client, L4D2Team:1, true);
		}
		blockVotes[client] = 1;
		ChangeClientTeamEx(client, L4D2Team:3, true);
		CreateTimer(0.1, RespecDelay_Timer, client, 0);
	}
	return Action:3;
}

public Action:RespecDelay_Timer(Handle:timer, any:client)
{
	ChangeClientTeamEx(client, L4D2Team:1, true);
	blockVotes[client] = 0;
	return Action:0;
}

public Action:Vote_Listener(client, String:command[], argc)
{
	new var1;
	if (blockVotes[client])
	{
		var1 = MissingTAG:3;
	}
	else
	{
		var1 = MissingTAG:0;
	}
	return var1;
}

public Action:SwapTeams_Cmd(client, args)
{
	new cli = 1;
	while (cli <= MaxClients)
	{
		new var1;
		if (IsClientInGame(cli) && !IsFakeClient(cli) && IsPlayer(cli))
		{
			pendingSwaps[cli] = oppositeTeamMap[GetClientTeamEx(cli)];
		}
		cli++;
	}
	ApplySwaps(client, false);
	return Action:3;
}

public Action:Swap_Cmd(client, args)
{
	if (args < 1)
	{
		ReplyToCommand(client, "[SM] Usage: sm_swap <player1> <player2> ... <playerN>");
		return Action:3;
	}
	decl String:argbuf[32];
	decl targets[MaxClients + 1];
	decl target;
	decl targetCount;
	decl String:target_name[64];
	decl bool:tn_is_ml;
	new i = 1;
	while (i <= args)
	{
		GetCmdArg(i, argbuf, 32);
		targetCount = ProcessTargetString(argbuf, 0, targets, MaxClients + 1, 32, target_name, 64, tn_is_ml);
		new j;
		while (j < targetCount)
		{
			target = targets[j];
			if (IsClientInGame(target))
			{
				pendingSwaps[target] = oppositeTeamMap[GetClientTeamEx(target)];
			}
			j++;
		}
		i++;
	}
	ApplySwaps(client, false);
	return Action:3;
}

public Action:SwapTo_Cmd(client, args)
{
	if (args < 2)
	{
		ReplyToCommand(client, "[SM] Usage: sm_swapto <teamnum> <player1> <player2> ... <playerN>\n%d = Spectators, %d = Survivors, %d = Infected", 1, 2, 3);
		ReplyToCommand(client, "[SM] Usage: sm_swapto force <teamnum> <player1> <player2> ... <playerN>\n%d = Spectators, %d = Survivors, %d = Infected", 1, 2, 3);
		return Action:3;
	}
	decl String:argbuf[32];
	new bool:force;
	GetCmdArg(1, argbuf, 32);
	if (StrEqual(argbuf, "force", true))
	{
		force = true;
		GetCmdArg(2, argbuf, 32);
	}
	new L4D2Team:team = StringToInt(argbuf, 10);
	new var1;
	if (team < L4D2Team:1 || team > L4D2Team:3)
	{
		ReplyToCommand(client, "[SM] Valid teams: %d = Spectators, %d = Survivors, %d = Infected", 1, 2, 3);
		return Action:3;
	}
	decl targets[MaxClients + 1];
	decl target;
	decl targetCount;
	decl String:target_name[64];
	decl bool:tn_is_ml;
	decl i;
	new var2;
	if (force)
	{
		var2 = 3;
	}
	else
	{
		var2 = 2;
	}
	i = var2;
	while (i <= args)
	{
		GetCmdArg(i, argbuf, 32);
		targetCount = ProcessTargetString(argbuf, 0, targets, MaxClients + 1, 32, target_name, 64, tn_is_ml);
		new j;
		while (j < targetCount)
		{
			target = targets[j];
			if (IsClientInGame(target))
			{
				pendingSwaps[target] = team;
			}
			j++;
		}
		i++;
	}
	ApplySwaps(client, force);
	return Action:3;
}

ApplySwaps(sender, bool:force)
{
	decl L4D2Team:clientTeam;
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			clientTeam = GetClientTeamEx(client);
			new var1;
			if (pendingSwaps[client] != clientTeam && pendingSwaps[client])
			{
				new var2;
				if (clientTeam == L4D2Team:3 && GetZombieClass(client) != 8)
				{
					ForcePlayerSuicide(client);
				}
				ChangeClientTeamEx(client, L4D2Team:1, true);
			}
		}
		client++;
	}
	new client = 1;
	while (client <= MaxClients)
	{
		new var3;
		if (IsClientInGame(client) && pendingSwaps[client])
		{
			if (!ChangeClientTeamEx(client, pendingSwaps[client], force))
			{
				if (0 < sender)
				{
					PrintToChat(sender, "%N could not be switched because the target team was full or has no bot to take over.", client);
				}
			}
			pendingSwaps[client] = 0;
		}
		client++;
	}
	new i = MaxClients + 1;
	while (i <= 65)
	{
		pendingSwaps[i] = 0;
		i++;
	}
	return 0;
}

bool:ChangeClientTeamEx(client, L4D2Team:team, bool:force)
{
	if (team == GetClientTeamEx(client))
	{
		return true;
	}
	new var1;
	if (!force && GetTeamMaxHumans(team) == GetTeamHumanCount(team))
	{
		return false;
	}
	if (team != L4D2Team:2)
	{
		ChangeClientTeam(client, team);
		return true;
	}
	new bot = FindSurvivorBot();
	if (0 < bot)
	{
		new flags = GetCommandFlags("sb_takecontrol");
		SetCommandFlags("sb_takecontrol", flags & -16385);
		FakeClientCommand(client, "sb_takecontrol");
		SetCommandFlags("sb_takecontrol", flags);
		return true;
	}
	return false;
}

GetTeamHumanCount(L4D2Team:team)
{
	new humans;
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && !IsFakeClient(client) && team == GetClientTeamEx(client))
		{
			humans++;
		}
		client++;
	}
	return humans;
}

GetTeamMaxHumans(L4D2Team:team)
{
	if (team == L4D2Team:2)
	{
		return GetConVarInt(survivor_limit);
	}
	if (team == L4D2Team:3)
	{
		return GetConVarInt(z_max_player_zombies);
	}
	return MaxClients;
}

FindSurvivorBot()
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && IsFakeClient(client) && GetClientTeamEx(client) == 2)
		{
			return client;
		}
		client++;
	}
	return -1;
}

IsPlayer(client)
{
	new L4D2Team:team = GetClientTeamEx(client);
	new var1;
	return team == L4D2Team:2 || team == L4D2Team:3;
}

GetZombieClass(client)
{
	return GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
}

FixBotCount()
{
	new survivor_count;
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && GetClientTeamEx(client) == 2)
		{
			survivor_count++;
		}
		client++;
	}
	new limit = GetConVarInt(survivor_limit);
	if (survivor_count < limit)
	{
		decl bot;
		while (survivor_count < limit)
		{
			bot = CreateFakeClient("k9Q6CK42");
			if (bot)
			{
				ChangeClientTeam(bot, 2);
				if (DispatchKeyValue(bot, "classname", "survivorbot"))
				{
					DispatchSpawn(bot);
				}
			}
			survivor_count++;
		}
	}
	else
	{
		if (survivor_count > limit)
		{
			new client = 1;
			while (client <= MaxClients)
			{
				new var2;
				if (IsClientInGame(client) && GetClientTeamEx(client) == 2)
				{
					if (IsFakeClient(client))
					{
						KickClient(client, "");
					}
				}
				client++;
			}
			PrintToChatAll("[SM] Make sure there are no duplicate survivors and everyone is able to gain points, or restart the map.");
		}
	}
	return 0;
}

L4D2Team:GetClientTeamEx(client)
{
	return GetClientTeam(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "07/18/2017",
	time = "23:00:29"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public Plugin:myinfo =
{
	name = "Player Management Plugin",
	description = "Player management!  Swap players/teams and spectate!",
	author = "CanadaRox",
	version = "7",
	url = ""
};
new L4D2Team:oppositeTeamMap[4] =
{
	0, 1, 3, 2
};
new Handle:survivor_limit;
new Handle:z_max_player_zombies;
new L4D2Team:pendingSwaps[66];
new bool:blockVotes[66];
new bool:isMapActive;
new Handle:SpecTimer[66];
new TimerLive;
new Handle:l4d_pm_supress_spectate;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

CPrintToChatEx(client, author, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	new var2;
	if (author < 0 || author > MaxClients)
	{
		ThrowError("Invalid client index %d", author);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 4);
	new index = CFormat(szCMessage, 250, author);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, author, szCMessage);
	}
	return 0;
}

CPrintToChatAllEx(author, String:szMessage[])
{
	new var1;
	if (author < 0 || author > MaxClients)
	{
		ThrowError("Invalid client index %d", author);
	}
	if (!IsClientInGame(author))
	{
		ThrowError("Client %d is not in game", author);
	}
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var2;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 3);
			CPrintToChatEx(i, author, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	LoadTranslations("common.phrases");
	RegAdminCmd("sm_swap", Swap_Cmd, 4, "sm_swap <player1> [player2] ... [playerN] - swap all listed players to opposite teams", "", 0);
	RegAdminCmd("sm_swapto", SwapTo_Cmd, 4, "sm_swapto [force] <teamnum> <player1> [player2] ... [playerN] - swap all listed players to <teamnum> (1,2, or 3)", "", 0);
	RegAdminCmd("sm_swapteams", SwapTeams_Cmd, 4, "sm_swapteams - swap the players between both teams", "", 0);
	RegAdminCmd("sm_fixbots", FixBots_Cmd, 8, "sm_fixbots - Spawns survivor bots to match survivor_limit", "", 0);
	RegConsoleCmd("sm_spectate", Spectate_Cmd, "Moves you to the spectator team", 0);
	RegConsoleCmd("sm_spec", Spectate_Cmd, "Moves you to the spectator team", 0);
	RegConsoleCmd("sm_s", Spectate_Cmd, "Moves you to the spectator team", 0);
	AddCommandListener(Vote_Listener, "vote");
	AddCommandListener(Vote_Listener, "callvote");
	survivor_limit = FindConVar("survivor_limit");
	SetConVarBounds(survivor_limit, ConVarBounds:0, false, 0.0);
	HookConVarChange(survivor_limit, survivor_limitChanged);
	z_max_player_zombies = FindConVar("z_max_player_zombies");
	SetConVarBounds(z_max_player_zombies, ConVarBounds:0, false, 0.0);
	l4d_pm_supress_spectate = CreateConVar("l4d_pm_supress_spectate", "0", "Don't print messages when players spectate", 262144, true, 0.0, true, 1.0);
	return 0;
}

public OnMapStart()
{
	isMapActive = true;
	return 0;
}

public OnMapEnd()
{
	isMapActive = false;
	return 0;
}

public OnRoundIsLive()
{
	TimerLive = 0;
	return 0;
}

public OnTimerStart()
{
	if (TimerLive)
	{
		TimerLive = 0;
	}
	else
	{
		TimerLive = 1;
	}
	return 0;
}

public Action:FixBots_Cmd(client, args)
{
	if (client)
	{
		PrintToChatAll("[SM] %N is attempting to fix bot counts");
	}
	else
	{
		PrintToChatAll("[SM] Console is attempting to fix bot counts");
	}
	FixBotCount();
	return Action:3;
}

public survivor_limitChanged(Handle:convar, String:oldValue[], String:newValue[])
{
	FixBotCount();
	return 0;
}

public OnClientAuthorized(client, String:auth[])
{
	decl String:name[32];
	new var1;
	if (IsFakeClient(client) && GetClientName(client, name, 32) && StrContains(name, "k9Q6CK42", true) > -1)
	{
		KickClient(client, "");
	}
	return 0;
}

public OnClientDisconnect_Post(client)
{
	if (isMapActive)
	{
		FixBotCount();
	}
	return 0;
}

public Action:Spectate_Cmd(client, args)
{
	new L4D2Team:team = GetClientTeamEx(client);
	new var1;
	if (!GetConVarBool(l4d_pm_supress_spectate) && team != L4D2Team:1 && SpecTimer[client])
	{
		CPrintToChatAllEx(client, "{teamcolor}%N{default} has become a spectator!", client);
	}
	if (team == L4D2Team:2)
	{
		ChangeClientTeamEx(client, L4D2Team:1, true);
	}
	else
	{
		if (team == L4D2Team:3)
		{
			new var2;
			if (GetZombieClass(client) != 8 && !IsGhost(client))
			{
				ForcePlayerSuicide(client);
			}
			else
			{
				if (GetZombieClass(client) == 8)
				{
					return Action:3;
				}
			}
			ChangeClientTeamEx(client, L4D2Team:1, true);
		}
		if (!TimerLive)
		{
			blockVotes[client] = 1;
			ChangeClientTeamEx(client, L4D2Team:3, true);
			CreateTimer(0.1, RespecDelay_Timer, client, 0);
		}
	}
	if (!SpecTimer[client])
	{
		SpecTimer[client] = CreateTimer(7.0, SecureSpec, client, 0);
	}
	return Action:3;
}

public Action:SecureSpec(Handle:timer, any:client)
{
	KillTimer(SpecTimer[client], false);
	SpecTimer[client] = 0;
	return Action:0;
}

public Action:RespecDelay_Timer(Handle:timer, any:client)
{
	ChangeClientTeamEx(client, L4D2Team:1, true);
	blockVotes[client] = 0;
	return Action:0;
}

public Action:Vote_Listener(client, String:command[], argc)
{
	new var1;
	if (blockVotes[client])
	{
		var1 = MissingTAG:3;
	}
	else
	{
		var1 = MissingTAG:0;
	}
	return var1;
}

public Action:SwapTeams_Cmd(client, args)
{
	new cli = 1;
	while (cli <= MaxClients)
	{
		new var1;
		if (IsClientInGame(cli) && !IsFakeClient(cli) && IsPlayer(cli))
		{
			pendingSwaps[cli] = oppositeTeamMap[GetClientTeamEx(cli)];
		}
		cli++;
	}
	ApplySwaps(client, false);
	return Action:3;
}

bool:IsGhost(client)
{
	return GetEntProp(client, PropType:0, "m_isGhost", 4, 0) == 1;
}

public Action:Swap_Cmd(client, args)
{
	if (args < 1)
	{
		ReplyToCommand(client, "[SM] Usage: sm_swap <player1> <player2> ... <playerN>");
		return Action:3;
	}
	decl String:argbuf[32];
	decl targets[MaxClients + 1];
	decl target;
	decl targetCount;
	decl String:target_name[64];
	decl bool:tn_is_ml;
	new i = 1;
	while (i <= args)
	{
		GetCmdArg(i, argbuf, 32);
		targetCount = ProcessTargetString(argbuf, 0, targets, MaxClients + 1, 32, target_name, 64, tn_is_ml);
		new j;
		while (j < targetCount)
		{
			target = targets[j];
			if (IsClientInGame(target))
			{
				pendingSwaps[target] = oppositeTeamMap[GetClientTeamEx(target)];
			}
			j++;
		}
		i++;
	}
	ApplySwaps(client, false);
	return Action:3;
}

public Action:SwapTo_Cmd(client, args)
{
	if (args < 2)
	{
		ReplyToCommand(client, "[SM] Usage: sm_swapto <teamnum> <player1> <player2> ... <playerN>\n%d = Spectators, %d = Survivors, %d = Infected", 1, 2, 3);
		ReplyToCommand(client, "[SM] Usage: sm_swapto force <teamnum> <player1> <player2> ... <playerN>\n%d = Spectators, %d = Survivors, %d = Infected", 1, 2, 3);
		return Action:3;
	}
	decl String:argbuf[32];
	new bool:force;
	GetCmdArg(1, argbuf, 32);
	if (StrEqual(argbuf, "force", true))
	{
		force = true;
		GetCmdArg(2, argbuf, 32);
	}
	new L4D2Team:team = StringToInt(argbuf, 10);
	new var1;
	if (team < L4D2Team:1 || team > L4D2Team:3)
	{
		ReplyToCommand(client, "[SM] Valid teams: %d = Spectators, %d = Survivors, %d = Infected", 1, 2, 3);
		return Action:3;
	}
	decl targets[MaxClients + 1];
	decl target;
	decl targetCount;
	decl String:target_name[64];
	decl bool:tn_is_ml;
	decl i;
	new var2;
	if (force)
	{
		var2 = 3;
	}
	else
	{
		var2 = 2;
	}
	i = var2;
	while (i <= args)
	{
		GetCmdArg(i, argbuf, 32);
		targetCount = ProcessTargetString(argbuf, 0, targets, MaxClients + 1, 32, target_name, 64, tn_is_ml);
		new j;
		while (j < targetCount)
		{
			target = targets[j];
			if (IsClientInGame(target))
			{
				pendingSwaps[target] = team;
			}
			j++;
		}
		i++;
	}
	ApplySwaps(client, force);
	return Action:3;
}

ApplySwaps(sender, bool:force)
{
	decl L4D2Team:clientTeam;
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			clientTeam = GetClientTeamEx(client);
			new var1;
			if (pendingSwaps[client] != clientTeam && pendingSwaps[client])
			{
				new var2;
				if (clientTeam == L4D2Team:3 && GetZombieClass(client) != 8)
				{
					ForcePlayerSuicide(client);
				}
				ChangeClientTeamEx(client, L4D2Team:1, true);
			}
		}
		client++;
	}
	new client = 1;
	while (client <= MaxClients)
	{
		new var3;
		if (IsClientInGame(client) && pendingSwaps[client])
		{
			if (!ChangeClientTeamEx(client, pendingSwaps[client], force))
			{
				if (0 < sender)
				{
					PrintToChat(sender, "%N could not be switched because the target team was full or has no bot to take over.", client);
				}
			}
			pendingSwaps[client] = 0;
		}
		client++;
	}
	new i = MaxClients + 1;
	while (i <= 65)
	{
		pendingSwaps[i] = 0;
		i++;
	}
	return 0;
}

bool:ChangeClientTeamEx(client, L4D2Team:team, bool:force)
{
	if (team == GetClientTeamEx(client))
	{
		return true;
	}
	new var1;
	if (!force && GetTeamMaxHumans(team) == GetTeamHumanCount(team))
	{
		return false;
	}
	if (team != L4D2Team:2)
	{
		ChangeClientTeam(client, team);
		return true;
	}
	new bot = FindSurvivorBot();
	if (0 < bot)
	{
		new flags = GetCommandFlags("sb_takecontrol");
		SetCommandFlags("sb_takecontrol", flags & -16385);
		FakeClientCommand(client, "sb_takecontrol");
		SetCommandFlags("sb_takecontrol", flags);
		return true;
	}
	return false;
}

GetTeamHumanCount(L4D2Team:team)
{
	new humans;
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && !IsFakeClient(client) && team == GetClientTeamEx(client))
		{
			humans++;
		}
		client++;
	}
	return humans;
}

GetTeamMaxHumans(L4D2Team:team)
{
	if (team == L4D2Team:2)
	{
		return GetConVarInt(survivor_limit);
	}
	if (team == L4D2Team:3)
	{
		return GetConVarInt(z_max_player_zombies);
	}
	return MaxClients;
}

FindSurvivorBot()
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && IsFakeClient(client) && GetClientTeamEx(client) == 2)
		{
			return client;
		}
		client++;
	}
	return -1;
}

IsPlayer(client)
{
	new L4D2Team:team = GetClientTeamEx(client);
	new var1;
	return team == L4D2Team:2 || team == L4D2Team:3;
}

GetZombieClass(client)
{
	return GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
}

FixBotCount()
{
	new survivor_count;
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && GetClientTeamEx(client) == 2)
		{
			survivor_count++;
		}
		client++;
	}
	new limit = GetConVarInt(survivor_limit);
	if (survivor_count < limit)
	{
		decl bot;
		while (survivor_count < limit)
		{
			bot = CreateFakeClient("k9Q6CK42");
			if (bot)
			{
				ChangeClientTeam(bot, 2);
				if (DispatchKeyValue(bot, "classname", "survivorbot"))
				{
					DispatchSpawn(bot);
				}
			}
			survivor_count++;
		}
	}
	else
	{
		if (survivor_count > limit)
		{
			new client = 1;
			while (client <= MaxClients)
			{
				new var2;
				if (IsClientInGame(client) && GetClientTeamEx(client) == 2)
				{
					if (IsFakeClient(client))
					{
						KickClient(client, "");
					}
				}
				client++;
			}
			PrintToChatAll("[SM] Make sure there are no duplicate survivors and everyone is able to gain points, or restart the map.");
		}
	}
	return 0;
}

L4D2Team:GetClientTeamEx(client)
{
	return GetClientTeam(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "01/09/2017",
	time = "16:35:44"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:L4D2_InfectedNames[8][32];
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	24, 32, 36, 48, 52, 56, 1717920891, 1953264993, 125, 1701996411, 8220261, 1734962299, 1919382632, 2104386917, 0, 1684370043, 125, 1970037371, 32101, 1768714107, 8217974, 24, 24, 24, 24, 24, 24, 1, 4, 3, 3, 3, 5, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
new Handle:hSurvivorModelsTrie = 24;
new Handle:hWeaponNamesTrie = 24;
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new Handle:hCvarAllowedRateChanges;
new Handle:hCvarMinRate;
new Handle:hCvarMinCmd;
new Handle:hCvarProhibitFakePing;
new Handle:hCvarProhibitedAction;
new Handle:hClientSettingsArray;
new Handle:hCvarPublicNotice;
new iAllowedRateChanges;
new iMinRate;
new iMinCmd;
new iActionUponExceed;
new bool:bPublic;
new bool:bProhibitFakePing;
new bool:bIsMatchLive;
public Plugin:myinfo =
{
	name = "RateMonitor",
	description = "Keep track of players' netsettings",
	author = "Visor, Sir",
	version = "2.2.1",
	url = "https://github.com/Attano/smplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChatEx(client, author, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	new var2;
	if (author < 0 || author > MaxClients)
	{
		ThrowError("Invalid client index %d", author);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 4);
	new index = CFormat(szCMessage, 250, author);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, author, szCMessage);
	}
	return 0;
}

CPrintToChatAllEx(author, String:szMessage[])
{
	new var1;
	if (author < 0 || author > MaxClients)
	{
		ThrowError("Invalid client index %d", author);
	}
	if (!IsClientInGame(author))
	{
		ThrowError("Client %d is not in game", author);
	}
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var2;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 3);
			CPrintToChatEx(i, author, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	hCvarAllowedRateChanges = CreateConVar("rm_allowed_rate_changes", "-1", "Allowed number of rate changes during a live round(-1: no limit)", 262144, false, 0.0, false, 0.0);
	hCvarPublicNotice = CreateConVar("rm_public_notice", "0", "Print Rate Changes to the Public? (rm_countermeasure 1 and 3 will still be Public Notice)", 262144, false, 0.0, false, 0.0);
	hCvarMinRate = CreateConVar("rm_min_rate", "20000", "Minimum allowed value of rate(-1: none)", 262144, false, 0.0, false, 0.0);
	hCvarMinCmd = CreateConVar("rm_min_cmd", "20", "Minimum allowed value of cl_cmdrate(-1: none)", 262144, false, 0.0, false, 0.0);
	hCvarProhibitFakePing = CreateConVar("rm_no_fake_ping", "0", "Allow or disallow the use of + - . in netsettings, which is commonly used to hide true ping in the scoreboard.", 262144, false, 0.0, false, 0.0);
	hCvarProhibitedAction = CreateConVar("rm_countermeasure", "2", "Countermeasure against illegal actions - change overlimit/forbidden netsettings(1:chat notify,2:move to spec,3:kick)", 262144, true, 1.0, true, 3.0);
	iAllowedRateChanges = GetConVarInt(hCvarAllowedRateChanges);
	iMinRate = GetConVarInt(hCvarMinRate);
	iMinCmd = GetConVarInt(hCvarMinCmd);
	bProhibitFakePing = GetConVarBool(hCvarProhibitFakePing);
	iActionUponExceed = GetConVarInt(hCvarProhibitedAction);
	bPublic = GetConVarBool(hCvarPublicNotice);
	HookConVarChange(hCvarAllowedRateChanges, cvarChanged_AllowedRateChanges);
	HookConVarChange(hCvarMinRate, cvarChanged_MinRate);
	HookConVarChange(hCvarMinCmd, cvarChanged_MinCmd);
	HookConVarChange(hCvarProhibitFakePing, cvarChanged_ProhibitFakePing);
	HookConVarChange(hCvarProhibitedAction, cvarChanged_ExceedAction);
	HookConVarChange(hCvarPublicNotice, cvarChanged_PublicNotice);
	RegConsoleCmd("sm_rates", ListRates, "List netsettings of all players in game", 262144);
	HookEvent("player_team", OnTeamChange, EventHookMode:1);
	hClientSettingsArray = CreateArray(36, 0);
	return 0;
}

public OnRoundStart()
{
	decl player[36];
	new i;
	while (GetArraySize(hClientSettingsArray) > i)
	{
		GetArrayArray(hClientSettingsArray, i, player, -1);
		player[35] = 0;
		SetArrayArray(hClientSettingsArray, i, player, -1);
		i++;
	}
	return 0;
}

public Action:OnRoundIsLive()
{
	bIsMatchLive = true;
	return Action:0;
}

public OnRoundEnd()
{
	bIsMatchLive = false;
	return 0;
}

public OnMapEnd()
{
	ClearArray(hClientSettingsArray);
	return 0;
}

public OnTeamChange(Handle:event, String:name[], bool:dontBroadcast)
{
	if (GetEventInt(event, "team") != 1)
	{
		new client = GetClientOfUserId(GetEventInt(event, "userid"));
		if (0 < client)
		{
			new var1;
			if (IsClientInGame(client) && !IsFakeClient(client))
			{
				CreateTimer(0.1, OnTeamChangeDelay, client, 2);
			}
		}
	}
	return 0;
}

public Action:OnTeamChangeDelay(Handle:timer, any:client)
{
	RegisterSettings(client);
	return Action:3;
}

public OnClientSettingsChanged(client)
{
	RegisterSettings(client);
	return 0;
}

public Action:ListRates(client, args)
{
	decl player[36];
	new iClient;
	ReplyToCommand(client, "\x01[RateMonitor] List of player netsettings(\x03cmd\x01/\x04upd\x01/\x05rate\x01):");
	new i;
	while (GetArraySize(hClientSettingsArray) > i)
	{
		GetArrayArray(hClientSettingsArray, i, player, -1);
		iClient = GetClientBySteamId(player);
		if (!(0 > iClient))
		{
			new var1;
			if (IsClientConnected(iClient) && !IsSpectator(iClient))
			{
				ReplyToCommand(client, "\x03%N\x01 : %d/%d/%d", iClient, player[33], player[34], player[32]);
			}
		}
		i++;
	}
	return Action:3;
}

RegisterSettings(client)
{
	new var1;
	if (!IsValidClient(client) || IsSpectator(client) || IsFakeClient(client))
	{
		return 0;
	}
	decl player[36];
	decl String:sCmdRate[32];
	decl String:sUpdateRate[32];
	decl String:sRate[32];
	decl String:sSteamId[32];
	new String:sCounter[32] = "[low cmd/rate]";
	new iCmdRate;
	new iUpdateRate;
	new iRate;
	GetClientAuthString(client, sSteamId, 32, true);
	new iIndex = FindStringInArray(hClientSettingsArray, sSteamId);
	iRate = GetClientDataRate(client);
	GetClientInfo(client, "cl_cmdrate", sCmdRate, 32);
	iCmdRate = StringToInt(sCmdRate, 10);
	GetClientInfo(client, "cl_updaterate", sUpdateRate, 32);
	iUpdateRate = StringToInt(sUpdateRate, 10);
	if (bProhibitFakePing)
	{
		new bool:bIsCmdRateClean;
		new bIsUpdateRateClean;
		bIsCmdRateClean = IsNatural(sCmdRate);
		bIsUpdateRateClean = IsNatural(sUpdateRate);
		new var2;
		if (!bIsCmdRateClean || !bIsUpdateRateClean)
		{
			Format(sCmdRate, 32, "%s", sCmdRate);
			Format(sUpdateRate, 32, "%s", sUpdateRate);
			Format(sRate, 32, "%d", iRate);
			PunishPlayer(client, sCmdRate, sUpdateRate, sRate, sCounter, iIndex);
			return 0;
		}
	}
	new var3;
	if ((iCmdRate < iMinCmd && iMinCmd > -1) || (iRate < iMinRate && iRate > -1))
	{
		new var6;
		if (iCmdRate < iMinCmd)
		{
			var6[0] = 2984;
		}
		else
		{
			var6[0] = 2988;
		}
		new var7;
		if (iCmdRate < iMinCmd)
		{
			var7[0] = 2976;
		}
		else
		{
			var7[0] = 2980;
		}
		Format(sCmdRate, 32, "%s%d%s", var7, iCmdRate, var6);
		Format(sUpdateRate, 32, "%d", iUpdateRate);
		new var8;
		if (iRate < iMinRate)
		{
			var8[0] = 3012;
		}
		else
		{
			var8[0] = 3016;
		}
		new var9;
		if (iRate < iMinRate)
		{
			var9[0] = 3004;
		}
		else
		{
			var9[0] = 3008;
		}
		Format(sRate, 32, "%s%d%s", var9, iRate, var8);
		PunishPlayer(client, sCmdRate, sUpdateRate, sRate, sCounter, iIndex);
		return 0;
	}
	if (iIndex > -1)
	{
		GetArrayArray(hClientSettingsArray, iIndex, player, -1);
		new var10;
		if (player[32] == iRate && player[33] == iCmdRate && player[34] == iUpdateRate)
		{
			return 0;
		}
		new var11;
		if (bIsMatchLive && iAllowedRateChanges > -1)
		{
			player[35] += 1;
			Format(sCounter, 32, "[%d/%d]", player[35], iAllowedRateChanges);
			if (player[35] > iAllowedRateChanges)
			{
				new var12;
				if (player[33] != iCmdRate)
				{
					var12[0] = 3036;
				}
				else
				{
					var12[0] = 3040;
				}
				Format(sCmdRate, 32, "%s%d", var12, iCmdRate);
				new var13;
				if (player[34] != iUpdateRate)
				{
					var13[0] = 3052;
				}
				else
				{
					var13[0] = 3056;
				}
				Format(sUpdateRate, 32, "%s%d\x01", var13, iUpdateRate);
				new var14;
				if (player[32] != iRate)
				{
					var14[0] = 3068;
				}
				else
				{
					var14[0] = 3072;
				}
				Format(sRate, 32, "%s%d\x01", var14, iRate);
				PunishPlayer(client, sCmdRate, sUpdateRate, sRate, sCounter, iIndex);
				return 0;
			}
		}
		if (bPublic)
		{
			CPrintToChatAllEx(client, "{default}<{olive}Rates{default}> {teamcolor}%N{default}'s netsettings changed from {teamcolor}%d/%d/%d {default}to {teamcolor}%d/%d/%d {olive}%s", client, player[33], player[34], player[32], iCmdRate, iUpdateRate, iRate, sCounter);
		}
		player[33] = iCmdRate;
		player[34] = iUpdateRate;
		player[32] = iRate;
		SetArrayArray(hClientSettingsArray, iIndex, player, -1);
	}
	else
	{
		strcopy(player, 32, sSteamId);
		player[33] = iCmdRate;
		player[34] = iUpdateRate;
		player[32] = iRate;
		player[35] = 0;
		PushArrayArray(hClientSettingsArray, player, -1);
		if (bPublic)
		{
			CPrintToChatAllEx(client, "{default}<{olive}Rates{default}> {teamcolor}%N{default}'s netsettings set to {teamcolor}%d/%d/%d", client, player[33], player[34], player[32]);
		}
	}
	return 0;
}

PunishPlayer(client, String:sCmdRate[], String:sUpdateRate[], String:sRate[], String:sCounter[], iIndex)
{
	decl bool:bInitialRegister;
	new var1;
	if (iIndex > -1)
	{
		var1 = 0;
	}
	else
	{
		var1 = 1;
	}
	bInitialRegister = var1;
	switch (iActionUponExceed)
	{
		case 1:
		{
			if (bInitialRegister)
			{
				CPrintToChatAllEx(client, "{default}<{olive}Rates{default}> {teamcolor}%N{default}'s netsettings set to illegal values: {teamcolor}%s/%s/%s {olive}%s", client, sCmdRate, sUpdateRate, sRate, sCounter);
			}
			else
			{
				CPrintToChatAllEx(client, "{default}<{olive}Rates{default}> {teamcolor}%N{default}'s illegaly changed netsettings midgame: {teamcolor}%s/%s/%s {olive}%s", client, sCmdRate, sUpdateRate, sRate, sCounter);
			}
		}
		case 2:
		{
			ChangeClientTeam(client, 1);
			if (bInitialRegister)
			{
				if (bPublic)
				{
					CPrintToChatAllEx(client, "{default}<{olive}Rates{default}> {teamcolor}%N {default}was moved to spectators for illegal netsettings: {teamcolor}%s/%s/%s {olive}%s", client, sCmdRate, sUpdateRate, sRate, sCounter);
				}
				new var3;
				if (bProhibitFakePing)
				{
					var3 = 3812;
				}
				else
				{
					var3 = 3852;
				}
				CPrintToChatEx(client, client, "{default}<{olive}Rates{default}> Please adjust your rates to values higher than {olive}%d/%d/%d %s", iMinCmd, iMinRate, var3);
			}
			else
			{
				decl player[36];
				GetArrayArray(hClientSettingsArray, iIndex, player, -1);
				if (bPublic)
				{
					CPrintToChatAllEx(client, "{default}<{olive}Rates{default}> {teamcolor}%N {default}was moved to spectators for illegal netsettings: {teamcolor}%s/%s/%s {olive}%s", client, sCmdRate, sUpdateRate, sRate, sCounter);
				}
				CPrintToChatEx(client, client, "{default}<{olive}Rates{default}> Change your netsettings back to: {teamcolor}%d/%d/%d", player[33], player[34], player[32]);
			}
		}
		case 3:
		{
			if (bInitialRegister)
			{
				new var2;
				if (bProhibitFakePing)
				{
					var2[0] = 4120;
				}
				else
				{
					var2[0] = 4148;
				}
				KickClient(client, "Please use rates higher than %d/%d%s", iMinCmd, iMinRate, var2);
				CPrintToChatAllEx(client, "{default}<{olive}Rates{default}> {teamcolor}%N {default}was kicked for illegal netsettings: {teamcolor}%s/%s/%s {olive}%s", client, sCmdRate, sUpdateRate, sRate, sCounter);
			}
			else
			{
				decl player[36];
				GetArrayArray(hClientSettingsArray, iIndex, player, -1);
				KickClient(client, "Change your rates to previous values and remove non-digits: %d/%d/%d", player[33], player[34], player[32]);
				CPrintToChatAllEx(client, "{default}<{olive}Rates{default}> {teamcolor}%N {default}was kicked due to illegal netsettings change: {teamcolor}%s/%s/%s {olive}%s", client, sCmdRate, sUpdateRate, sRate, sCounter);
			}
		}
		default:
		{
		}
	}
	return 0;
}

GetClientBySteamId(String:steamID[])
{
	decl String:tempSteamID[32];
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			GetClientAuthString(client, tempSteamID, 32, true);
			if (StrEqual(steamID, tempSteamID, true))
			{
				return client;
			}
		}
		client++;
	}
	return -1;
}

bool:IsSpectator(client)
{
	new L4D2_Team:team = GetClientTeam(client);
	new var1;
	if (team != L4D2_Team:2 && team != L4D2_Team:3)
	{
		return true;
	}
	return false;
}

bool:IsNatural(String:str[])
{
	new x;
	while (str[x])
	{
		if (!IsCharNumeric(str[x]))
		{
			return false;
		}
		x++;
	}
	return true;
}

public cvarChanged_AllowedRateChanges(Handle:cvar, String:oldValue[], String:newValue[])
{
	iAllowedRateChanges = GetConVarInt(hCvarAllowedRateChanges);
	return 0;
}

public cvarChanged_MinRate(Handle:cvar, String:oldValue[], String:newValue[])
{
	iMinRate = GetConVarInt(hCvarMinRate);
	return 0;
}

public cvarChanged_MinCmd(Handle:cvar, String:oldValue[], String:newValue[])
{
	iMinCmd = GetConVarInt(hCvarMinCmd);
	return 0;
}

public cvarChanged_ProhibitFakePing(Handle:cvar, String:oldValue[], String:newValue[])
{
	bProhibitFakePing = GetConVarBool(hCvarProhibitFakePing);
	return 0;
}

public cvarChanged_ExceedAction(Handle:cvar, String:oldValue[], String:newValue[])
{
	iActionUponExceed = GetConVarInt(hCvarProhibitedAction);
	return 0;
}

public cvarChanged_PublicNotice(Handle:cvar, String:oldValue[], String:newValue[])
{
	bPublic = GetConVarBool(hCvarPublicNotice);
	return 0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "01/03/2017",
	time = "20:34:09"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_builtinvotes =
{
	name = "BuiltinVotes",
	file = "builtinvotes.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public Plugin:myinfo =
{
	name = "L4D2 Ready-Up",
	description = "New and improved ready-up plugin.",
	author = "CanadaRox, (Lazy unoptimized additions by Sir)",
	version = "9.1",
	url = ""
};
new Handle:l4d_ready_disable_spawns;
new Handle:l4d_ready_cfg_name;
new Handle:l4d_ready_survivor_freeze;
new Handle:l4d_ready_max_players;
new Handle:l4d_ready_enable_sound;
new Handle:l4d_ready_delay;
new Handle:l4d_ready_chuckle;
new Handle:l4d_ready_live_sound;
new Handle:g_hVote;
new Float:g_fButtonTime[66];
new Handle:director_no_specials;
new Handle:god;
new Handle:sb_stop;
new Handle:survivor_limit;
new Handle:z_max_player_zombies;
new Handle:sv_infinite_primary_ammo;
new Handle:ServerNamer;
new Handle:casterTrie;
new Handle:liveForward;
new Handle:menuPanel;
new Handle:readyCountdownTimer;
new String:readyFooter[10][68];
new bool:hiddenPanel[66];
new bool:hiddenManually[66];
new bool:inLiveCountdown;
new bool:inReadyUp;
new bool:isPlayerReady[66];
new footerCounter;
new readyDelay;
new Handle:allowedCastersTrie;
new String:liveSound[256];
new bool:bSkipWarp;
new bool:bFrozenYet;
new bool:blockSecretSpam[66];
new iCmd;
new String:sCmd[32];
new String:countdownSound[5][160] =
{
	"/npc/moustachio/strengthattract01.wav",
	"/npc/moustachio/strengthattract02.wav",
	"/npc/moustachio/strengthattract05.wav",
	"/npc/moustachio/strengthattract06.wav",
	"/npc/moustachio/strengthattract09.wav"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator+(Float:,_:)(Float:oper1, oper2)
{
	return oper1 + float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

StrCat(String:buffer[], maxlength, String:source[])
{
	new len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	return Format(buffer[len], maxlength - len, "%s", source);
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

PrintCenterTextAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintCenterText(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

PrintHintTextToAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintHintText(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

ReplyToTargetError(client, reason)
{
	switch (reason)
	{
		case -7:
		{
			ReplyToCommand(client, "[SM] %t", "More than one client matched");
		}
		case -6:
		{
			ReplyToCommand(client, "[SM] %t", "Cannot target bot");
		}
		case -5:
		{
			ReplyToCommand(client, "[SM] %t", "No matching clients");
		}
		case -4:
		{
			ReplyToCommand(client, "[SM] %t", "Unable to target");
		}
		case -3:
		{
			ReplyToCommand(client, "[SM] %t", "Target is not in game");
		}
		case -2:
		{
			ReplyToCommand(client, "[SM] %t", "Target must be dead");
		}
		case -1:
		{
			ReplyToCommand(client, "[SM] %t", "Target must be alive");
		}
		case 0:
		{
			ReplyToCommand(client, "[SM] %t", "No matching client");
		}
		default:
		{
		}
	}
	return 0;
}

FindTarget(client, String:target[], bool:nobots, bool:immunity)
{
	decl String:target_name[64];
	decl target_list[1];
	decl target_count;
	decl bool:tn_is_ml;
	new flags = 16;
	if (nobots)
	{
		flags |= 32;
	}
	if (!immunity)
	{
		flags |= 8;
	}
	if (0 < (target_count = ProcessTargetString(target, client, target_list, 1, flags, target_name, 64, tn_is_ml)))
	{
		return target_list[0];
	}
	ReplyToTargetError(client, target_count);
	return -1;
}

MoveType:GetEntityMoveType(entity)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_MoveType", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_MoveType");
		}
		gotconfig = true;
	}
	return GetEntProp(entity, PropType:1, datamap, 4, 0);
}

SetEntityMoveType(entity, MoveType:mt)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_MoveType", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_MoveType");
		}
		gotconfig = true;
	}
	SetEntProp(entity, PropType:1, datamap, mt, 4, 0);
	return 0;
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

bool:IsNewBuiltinVoteAllowed()
{
	new var1;
	if (IsBuiltinVoteInProgress() || CheckBuiltinVoteDelay())
	{
		return false;
	}
	return true;
}

public __ext_builtinvotes_SetNTVOptional()
{
	MarkNativeAsOptional("CreateBuiltinVote");
	MarkNativeAsOptional("DisplayBuiltinVote");
	MarkNativeAsOptional("AddBuiltinVoteItem");
	MarkNativeAsOptional("InsertBuiltinVoteItem");
	MarkNativeAsOptional("RemoveBuiltinVoteItem");
	MarkNativeAsOptional("RemoveAllBuiltinVoteItems");
	MarkNativeAsOptional("GetBuiltinVoteItem");
	MarkNativeAsOptional("GetBuiltinVoteItemCount");
	MarkNativeAsOptional("SetBuiltinVoteArgument");
	MarkNativeAsOptional("GetBuiltinVoteArgument");
	MarkNativeAsOptional("IsBuiltinVoteInProgress");
	MarkNativeAsOptional("GetBuiltinVoteMaxItems");
	MarkNativeAsOptional("SetBuiltinVoteOptionFlags");
	MarkNativeAsOptional("GetBuiltinVoteOptionFlags");
	MarkNativeAsOptional("SetBuiltinVoteResultCallback");
	MarkNativeAsOptional("CheckBuiltinVoteDelay");
	MarkNativeAsOptional("IsClientInBuiltinVotePool");
	MarkNativeAsOptional("RedrawClientBuiltinVote");
	MarkNativeAsOptional("GetBuiltinVoteType");
	MarkNativeAsOptional("SetBuiltinVoteTeam");
	MarkNativeAsOptional("GetBuiltinVoteTeam");
	MarkNativeAsOptional("SetBuiltinVoteInitiator");
	MarkNativeAsOptional("GetBuiltinVoteInitiator");
	MarkNativeAsOptional("DisplayBuiltinVotePass");
	MarkNativeAsOptional("DisplayBuiltinVotePass2");
	MarkNativeAsOptional("DisplayBuiltinVoteFail");
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	CreateNative("AddStringToReadyFooter", Native_AddStringToReadyFooter);
	CreateNative("IsInReady", Native_IsInReady);
	CreateNative("IsClientCaster", Native_IsClientCaster);
	CreateNative("IsIDCaster", Native_IsIDCaster);
	liveForward = CreateGlobalForward("OnRoundIsLive", ExecType:2);
	RegPluginLibrary("readyup");
	return APLRes:0;
}

public OnPluginStart()
{
	CreateConVar("l4d_ready_enabled", "1", "This cvar doesn't do anything, but if it is 0 the logger wont log this game.", 262144, true, 0.0, true, 1.0);
	l4d_ready_cfg_name = CreateConVar("l4d_ready_cfg_name", "", "Configname to display on the ready-up panel", 263168, false, 0.0, false, 0.0);
	l4d_ready_disable_spawns = CreateConVar("l4d_ready_disable_spawns", "0", "Prevent SI from having spawns during ready-up", 262144, true, 0.0, true, 1.0);
	l4d_ready_survivor_freeze = CreateConVar("l4d_ready_survivor_freeze", "1", "Freeze the survivors during ready-up.  When unfrozen they are unable to leave the saferoom but can move freely inside", 262144, true, 0.0, true, 1.0);
	l4d_ready_max_players = CreateConVar("l4d_ready_max_players", "12", "Maximum number of players to show on the ready-up panel.", 262144, true, 0.0, true, 1065353216 + 65);
	l4d_ready_delay = CreateConVar("l4d_ready_delay", "3", "Number of seconds to count down before the round goes live.", 262144, true, 0.0, false, 0.0);
	l4d_ready_enable_sound = CreateConVar("l4d_ready_enable_sound", "1", "Enable sound during countdown & on live", 0, false, 0.0, false, 0.0);
	l4d_ready_chuckle = CreateConVar("l4d_ready_chuckle", "1", "Enable chuckle during countdown", 0, false, 0.0, false, 0.0);
	l4d_ready_live_sound = CreateConVar("l4d_ready_live_sound", "ui/bigreward.wav", "The sound that plays when a round goes live", 0, false, 0.0, false, 0.0);
	HookConVarChange(l4d_ready_survivor_freeze, SurvFreezeChange);
	HookEvent("round_start", RoundStart_Event, EventHookMode:1);
	HookEvent("player_team", PlayerTeam_Event, EventHookMode:1);
	casterTrie = CreateTrie();
	allowedCastersTrie = CreateTrie();
	director_no_specials = FindConVar("director_no_specials");
	god = FindConVar("god");
	sb_stop = FindConVar("sb_stop");
	survivor_limit = FindConVar("survivor_limit");
	z_max_player_zombies = FindConVar("z_max_player_zombies");
	sv_infinite_primary_ammo = FindConVar("sv_infinite_primary_ammo");
	ServerNamer = FindConVar("sn_main_name");
	RegAdminCmd("sm_caster", Caster_Cmd, 8, "Registers a player as a caster so the round will not go live unless they are ready", "", 0);
	RegAdminCmd("sm_forcestart", ForceStart_Cmd, 8, "Forces the round to start regardless of player ready status.  Players can unready to stop a force", "", 0);
	RegAdminCmd("sm_fs", ForceStart_Cmd, 8, "Forces the round to start regardless of player ready status.  Players can unready to stop a force", "", 0);
	RegConsoleCmd("sm_bonesaw", Secret_Cmd, "Every player has a different secret number between 0-1023", 0);
	RegConsoleCmd("sm_hide", Hide_Cmd, "Hides the ready-up panel so other menus can be seen", 0);
	RegConsoleCmd("sm_show", Show_Cmd, "Shows a hidden ready-up panel", 0);
	AddCommandListener(Say_Callback, "say");
	AddCommandListener(Say_Callback, "say_team");
	RegConsoleCmd("sm_notcasting", NotCasting_Cmd, "Deregister yourself as a caster or allow admins to deregister other players", 0);
	RegConsoleCmd("sm_uncast", NotCasting_Cmd, "Deregister yourself as a caster or allow admins to deregister other players", 0);
	RegConsoleCmd("sm_ready", Ready_Cmd, "Mark yourself as ready for the round to go live", 0);
	RegConsoleCmd("sm_toggleready", ToggleReady_Cmd, "Toggle your ready status", 0);
	RegConsoleCmd("sm_unready", Unready_Cmd, "Mark yourself as not ready if you have set yourself as ready", 0);
	RegConsoleCmd("sm_return", Return_Cmd, "Return to a valid saferoom spawn if you get stuck during an unfrozen ready-up period", 0);
	RegConsoleCmd("sm_cast", Cast_Cmd, "Registers the calling player as a caster so the round will not go live unless they are ready", 0);
	RegConsoleCmd("sm_kickspecs", KickSpecs_Cmd, "Let's vote to kick those Spectators!", 0);
	RegServerCmd("sm_resetcasters", ResetCaster_Cmd, "Used to reset casters between matches.  This should be in confogl_off.cfg or equivalent for your system", 0);
	RegServerCmd("sm_add_caster_id", AddCasterSteamID_Cmd, "Used for adding casters to the whitelist -- i.e. who's allowed to self-register as a caster", 0);
	LoadTranslations("common.phrases");
	return 0;
}

public Action:Say_Callback(client, String:command[], argc)
{
	SetEngineTime(client);
	return Action:0;
}

public OnPluginEnd()
{
	if (inReadyUp)
	{
		InitiateLive(false);
	}
	return 0;
}

public OnMapStart()
{
	GetConVarString(l4d_ready_live_sound, liveSound, 256);
	PrecacheSound("/level/gnomeftw.wav", false);
	PrecacheSound("buttons/blip1.wav", false);
	PrecacheSound("buttons/blip2.wav", false);
	PrecacheSound("quake/prepare.mp3", false);
	PrecacheSound(liveSound, false);
	new i;
	while (i < 5)
	{
		PrecacheSound(countdownSound[i], false);
		i++;
	}
	new client = 1;
	while (client <= 65)
	{
		blockSecretSpam[client] = 0;
		client++;
	}
	readyCountdownTimer = MissingTAG:0;
	new String:sMap[64];
	GetCurrentMap(sMap, 64);
	if (StrEqual(sMap, "dprm1_milltown_a", false))
	{
		bSkipWarp = true;
	}
	else
	{
		bSkipWarp = false;
	}
	return 0;
}

public Action:KickSpecs_Cmd(client, args)
{
	new var1;
	if (IsClientInGame(client) && GetClientTeam(client) != 1)
	{
		if (IsNewBuiltinVoteAllowed())
		{
			new iNumPlayers;
			decl iPlayers[MaxClients];
			new i = 1;
			while (i <= MaxClients)
			{
				new var2;
				if (!IsClientInGame(i) || IsFakeClient(i) || GetClientTeam(i) == 1)
				{
				}
				else
				{
					iNumPlayers++;
					iPlayers[iNumPlayers] = i;
				}
				i++;
			}
			new String:sBuffer[64];
			g_hVote = CreateBuiltinVote(BuiltinVoteActionHandler:79, BuiltinVoteType:3, BuiltinVoteAction:26);
			Format(sBuffer, 64, "Kick Non-Admin & Non-Casting Spectators?");
			SetBuiltinVoteArgument(g_hVote, sBuffer);
			SetBuiltinVoteInitiator(g_hVote, client);
			SetBuiltinVoteResultCallback(g_hVote, BuiltinVoteHandler:71);
			DisplayBuiltinVote(g_hVote, iPlayers, iNumPlayers, 20);
			return Action:0;
		}
		PrintToChat(client, "Vote cannot be started now.");
	}
	return Action:0;
}

public VoteActionHandler(Handle:vote, BuiltinVoteAction:action, param1, param2)
{
	switch (action)
	{
		case 2:
		{
			g_hVote = MissingTAG:0;
			CloseHandle(vote);
		}
		case 8:
		{
			DisplayBuiltinVoteFail(vote, param1);
		}
		default:
		{
		}
	}
	return 0;
}

public SpecVoteResultHandler(Handle:vote, num_votes, num_clients, client_info[][2], num_items, item_info[][2])
{
	new i;
	while (i < num_items)
	{
		if (item_info[i][0] == 1)
		{
			if (num_votes / 2 < item_info[i][1])
			{
				DisplayBuiltinVotePass(vote, "Ciao Spectators!");
				new c = 1;
				while (c <= MaxClients)
				{
					new var1;
					if (IsClientInGame(c) && GetClientTeam(c) == 1 && !IsClientCaster(c) && GetUserAdmin(c) == -1)
					{
						KickClient(c, "No Spectators, please!");
					}
					c++;
				}
				return 0;
			}
		}
		i++;
	}
	DisplayBuiltinVoteFail(vote, BuiltinVoteFailReason:3);
	return 0;
}

public Action:Secret_Cmd(client, args)
{
	if (inReadyUp)
	{
		decl String:steamid[64];
		decl String:argbuf[32];
		GetCmdArg(1, argbuf, 30);
		new arg = StringToInt(argbuf, 10);
		GetClientAuthString(client, steamid, 64, true);
		new id = StringToInt(steamid[2], 10);
		if (arg ^ id & 1023 == 881)
		{
			DoSecrets(client);
			isPlayerReady[client] = 1;
			if (CheckFullReady())
			{
				InitiateLiveCountdown();
			}
			return Action:3;
		}
	}
	return Action:0;
}

DoSecrets(client)
{
	PrintCenterTextAll("BONESAW IS READY!");
	new var1;
	if (GetClientTeam(client) == 2 && !blockSecretSpam[client])
	{
		new particle = CreateEntityByName("info_particle_system", -1);
		decl Float:pos[3];
		GetClientAbsOrigin(client, pos);
		pos[2] += 50;
		TeleportEntity(particle, pos, NULL_VECTOR, NULL_VECTOR);
		DispatchKeyValue(particle, "effect_name", "achieved");
		DispatchKeyValue(particle, "targetname", "particle");
		DispatchSpawn(particle);
		ActivateEntity(particle);
		AcceptEntityInput(particle, "start", -1, -1, 0);
		CreateTimer(10.0, killParticle, particle, 2);
		EmitSoundToAll("/level/gnomeftw.wav", client, 0, 75, 0, 0.5, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
		CreateTimer(2.0, SecretSpamDelay, client, 0);
		blockSecretSpam[client] = 1;
	}
	return 0;
}

public Action:SecretSpamDelay(Handle:timer, any:client)
{
	blockSecretSpam[client] = 0;
	return Action:0;
}

public Action:killParticle(Handle:timer, any:entity)
{
	new var1;
	if (entity > any:0 && IsValidEntity(entity) && IsValidEdict(entity))
	{
		AcceptEntityInput(entity, "Kill", -1, -1, 0);
	}
	return Action:0;
}

public OnMapEnd()
{
	if (inReadyUp)
	{
		InitiateLive(false);
	}
	return 0;
}

public OnClientDisconnect(client)
{
	hiddenPanel[client] = 0;
	hiddenManually[client] = 0;
	isPlayerReady[client] = 0;
	g_fButtonTime[client] = 0;
	return 0;
}

SetEngineTime(client)
{
	g_fButtonTime[client] = GetEngineTime();
	return 0;
}

public Native_AddStringToReadyFooter(Handle:plugin, numParams)
{
	decl String:footer[68];
	GetNativeString(1, footer, 65, 0);
	if (footerCounter < 10)
	{
		if (strlen(footer) < 65)
		{
			strcopy(readyFooter[footerCounter], 65, footer);
			footerCounter += 1;
			return 1;
		}
	}
	return 0;
}

public Native_IsInReady(Handle:plugin, numParams)
{
	return inReadyUp;
}

public Native_IsClientCaster(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	return IsClientCaster(client);
}

public Native_IsIDCaster(Handle:plugin, numParams)
{
	decl String:buffer[64];
	GetNativeString(1, buffer, 64, 0);
	return IsIDCaster(buffer);
}

bool:IsClientCaster(client)
{
	decl String:buffer[64];
	new var1;
	return GetClientAuthId(client, AuthIdType:1, buffer, 64, true) && IsIDCaster(buffer);
}

bool:IsIDCaster(String:AuthID[])
{
	decl dummy;
	return GetTrieValue(casterTrie, AuthID, dummy);
}

public Action:Cast_Cmd(client, args)
{
	decl String:buffer[64];
	GetClientAuthId(client, AuthIdType:1, buffer, 64, true);
	if (GetClientTeam(client) != 1)
	{
		ChangeClientTeam(client, 1);
	}
	SetTrieValue(casterTrie, buffer, any:1, true);
	CPrintToChat(client, "{blue}[{default}Cast{blue}] {default}You have registered yourself as a caster");
	CPrintToChat(client, "{blue}[{default}Cast{blue}] {default}Reconnect to make your Addons work.");
	return Action:3;
}

public Action:Caster_Cmd(client, args)
{
	if (args < 1)
	{
		ReplyToCommand(client, "[SM] Usage: sm_caster <player>");
		return Action:3;
	}
	decl String:buffer[64];
	GetCmdArg(1, buffer, 64);
	new target = FindTarget(client, buffer, true, false);
	if (0 < target)
	{
		if (GetClientAuthId(target, AuthIdType:1, buffer, 64, true))
		{
			SetTrieValue(casterTrie, buffer, any:1, true);
			ReplyToCommand(client, "Registered %N as a caster", target);
			CPrintToChat(client, "{blue}[{olive}!{blue}] {default}An Admin has registered you as a caster");
		}
		ReplyToCommand(client, "Couldn't find Steam ID.  Check for typos and let the player get fully connected.");
	}
	return Action:3;
}

public Action:ResetCaster_Cmd(args)
{
	ClearTrie(casterTrie);
	return Action:3;
}

public Action:AddCasterSteamID_Cmd(args)
{
	decl String:buffer[128];
	GetCmdArgString(buffer, 128);
	if (buffer[0])
	{
		new index;
		GetTrieValue(allowedCastersTrie, buffer, index);
		if (index != 1)
		{
			SetTrieValue(allowedCastersTrie, buffer, any:1, true);
			PrintToServer("[casters_database] Added '%s'", buffer);
		}
		else
		{
			PrintToServer("[casters_database] '%s' already exists", buffer);
		}
	}
	else
	{
		PrintToServer("[casters_database] No args specified / empty buffer");
	}
	return Action:3;
}

public Action:Hide_Cmd(client, args)
{
	hiddenPanel[client] = 1;
	hiddenManually[client] = 1;
	return Action:3;
}

public Action:Show_Cmd(client, args)
{
	hiddenPanel[client] = 0;
	hiddenManually[client] = 0;
	return Action:3;
}

public Action:NotCasting_Cmd(client, args)
{
	decl String:buffer[64];
	if (args < 1)
	{
		GetClientAuthId(client, AuthIdType:1, buffer, 64, true);
		RemoveFromTrie(casterTrie, buffer);
		CPrintToChat(client, "{blue}[{default}Reconnect{blue}] {default}You will be reconnected to the server..");
		CPrintToChat(client, "{blue}[{default}Reconnect{blue}] {default}There's a black screen instead of a loading bar!");
		CreateTimer(3.0, Reconnect, client, 0);
		return Action:3;
	}
	new AdminId:id = GetUserAdmin(client);
	new bool:hasFlag;
	if (id != AdminId:-1)
	{
		hasFlag = GetAdminFlag(id, AdminFlag:3, AdmAccessMode:1);
	}
	if (!hasFlag)
	{
		ReplyToCommand(client, "Only admins can remove other casters. Use sm_notcasting without arguments if you wish to remove yourself.");
		return Action:3;
	}
	GetCmdArg(1, buffer, 64);
	new target = FindTarget(client, buffer, true, false);
	if (0 < target)
	{
		if (GetClientAuthId(target, AuthIdType:1, buffer, 64, true))
		{
			RemoveFromTrie(casterTrie, buffer);
			ReplyToCommand(client, "%N is no longer a caster", target);
		}
		ReplyToCommand(client, "Couldn't find Steam ID.  Check for typos and let the player get fully connected.");
	}
	return Action:3;
}

public Action:Reconnect(Handle:timer, any:client)
{
	new var1;
	if (IsClientConnected(client) && IsClientInGame(client))
	{
		ReconnectClient(client);
	}
	return Action:0;
}

public Action:ForceStart_Cmd(client, args)
{
	if (inReadyUp)
	{
		InitiateLiveCountdown();
	}
	return Action:3;
}

public Action:Ready_Cmd(client, args)
{
	if (inReadyUp)
	{
		isPlayerReady[client] = 1;
		if (CheckFullReady())
		{
			InitiateLiveCountdown();
		}
	}
	return Action:3;
}

public Action:Unready_Cmd(client, args)
{
	if (inReadyUp)
	{
		SetEngineTime(client);
		isPlayerReady[client] = 0;
		CancelFullReady();
	}
	return Action:3;
}

public Action:ToggleReady_Cmd(client, args)
{
	if (inReadyUp)
	{
		if (!isPlayerReady[client])
		{
			isPlayerReady[client] = 1;
			if (CheckFullReady())
			{
				InitiateLiveCountdown();
			}
		}
		SetEngineTime(client);
		isPlayerReady[client] = 0;
		CancelFullReady();
	}
	return Action:3;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	if (inReadyUp)
	{
		new var1;
		if (buttons && !IsFakeClient(client))
		{
			SetEngineTime(client);
		}
		new var2;
		if (IsClientInGame(client) && GetClientTeam(client) == 2)
		{
			if (GetConVarBool(l4d_ready_survivor_freeze))
			{
				new var3;
				if (GetEntityMoveType(client) && GetEntityMoveType(client) == 8)
				{
					SetClientFrozen(client, 1);
				}
			}
			else
			{
				if (GetEntityFlags(client) & 512)
				{
					ReturnPlayerToSaferoom(client, false);
				}
			}
			new var4;
			if (bSkipWarp && !bFrozenYet)
			{
				SetTeamFrozen(L4D2Team:2, true);
				bFrozenYet = true;
			}
		}
	}
	return Action:0;
}

public SurvFreezeChange(Handle:convar, String:oldValue[], String:newValue[])
{
	ReturnTeamToSaferoom(L4D2Team:2);
	if (bSkipWarp)
	{
		SetTeamFrozen(L4D2Team:2, true);
	}
	else
	{
		SetTeamFrozen(L4D2Team:2, GetConVarBool(convar));
	}
	return 0;
}

public Action:L4D_OnFirstSurvivorLeftSafeArea(client)
{
	if (inReadyUp)
	{
		if (bSkipWarp)
		{
			return Action:3;
		}
		ReturnPlayerToSaferoom(client, false);
		return Action:3;
	}
	return Action:0;
}

public Action:Return_Cmd(client, args)
{
	new var1;
	if (client > 0 && inReadyUp && GetClientTeam(client) == 2)
	{
		ReturnPlayerToSaferoom(client, false);
	}
	return Action:3;
}

public RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	InitiateReadyUp();
	bFrozenYet = false;
	return 0;
}

public PlayerTeam_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	SetEngineTime(client);
	new L4D2Team:oldteam = GetEventInt(event, "oldteam");
	new L4D2Team:team = GetEventInt(event, "team");
	new var1;
	if ((oldteam == L4D2Team:2 || oldteam == L4D2Team:3 || team == L4D2Team:2 || team == L4D2Team:3) && isPlayerReady[client])
	{
		CancelFullReady();
	}
	return 0;
}

public DummyHandler(Handle:menu, MenuAction:action, param1, param2)
{
	return 0;
}

public Action:MenuRefresh_Timer(Handle:timer)
{
	if (inReadyUp)
	{
		UpdatePanel();
		return Action:0;
	}
	return Action:4;
}

public Action:MenuCmd_Timer(Handle:timer)
{
	if (inReadyUp)
	{
		iCmd += 1;
		return Action:0;
	}
	return Action:4;
}

UpdatePanel()
{
	if (IsBuiltinVoteInProgress())
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientConnected(i) && IsClientInGame(i) && IsClientInBuiltinVotePool(i))
			{
				hiddenPanel[i] = 1;
			}
			i++;
		}
	}
	else
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var2;
			if (IsClientConnected(i) && IsClientInGame(i))
			{
				new var3;
				if (IsClientConnected(i) && IsClientInGame(i) && !hiddenManually[i])
				{
					hiddenPanel[i] = 0;
				}
			}
			i++;
		}
	}
	if (menuPanel)
	{
		CloseHandle(menuPanel);
		menuPanel = MissingTAG:0;
	}
	new String:readyBuffer[800];
	new String:unreadyBuffer[800];
	new String:casterBuffer[500];
	new String:specBuffer[500];
	new readyCount;
	new unreadyCount;
	new casterCount;
	new playerCount;
	new specCount;
	menuPanel = CreatePanel(Handle:0);
	new String:ServerBuffer[128];
	new String:ServerName[32];
	new String:cfgName[32];
	PrintCmd();
	if (ServerNamer)
	{
		GetConVarString(ServerNamer, ServerName, 32);
	}
	else
	{
		GetConVarString(FindConVar("hostname"), ServerName, 32);
	}
	GetConVarString(l4d_ready_cfg_name, cfgName, 32);
	Format(ServerBuffer, 128, "? Server: %s \n? Slots: %d/%d\n? Config: %s", ServerName, GetSeriousClientCount(), GetConVarInt(FindConVar("sv_maxplayers")), cfgName);
	DrawPanelText(menuPanel, ServerBuffer);
	DrawPanelText(menuPanel, " ");
	DrawPanelText(menuPanel, "? Commands ?");
	DrawPanelText(menuPanel, sCmd);
	DrawPanelText(menuPanel, " ");
	decl String:nameBuf[64];
	decl String:authBuffer[64];
	decl bool:caster;
	decl dummy;
	new Float:fTime = GetEngineTime();
	new client = 1;
	while (client <= MaxClients)
	{
		new var4;
		if (IsClientInGame(client) && !IsFakeClient(client))
		{
			playerCount++;
			GetClientName(client, nameBuf, 64);
			GetClientAuthId(client, AuthIdType:1, authBuffer, 64, true);
			caster = GetTrieValue(casterTrie, authBuffer, dummy);
			if (IsPlayer(client))
			{
				if (isPlayerReady[client])
				{
					if (!inLiveCountdown)
					{
						PrintHintText(client, "You are ready.\nSay !unready to unready.");
					}
					readyCount++;
					Format(nameBuf, 64, "->%d. %s\n", readyCount, nameBuf);
					StrCat(readyBuffer, 800, nameBuf);
				}
				else
				{
					if (!inLiveCountdown)
					{
						PrintHintText(client, "You are not ready.\nSay !ready to ready up.");
					}
					if (fTime - g_fButtonTime[client] > 15.0)
					{
						unreadyCount++;
						Format(nameBuf, 64, "->%d. %s [AFK]\n", unreadyCount, nameBuf);
					}
					else
					{
						unreadyCount++;
						Format(nameBuf, 64, "->%d. %s\n", unreadyCount, nameBuf);
					}
					StrCat(unreadyBuffer, 800, nameBuf);
				}
			}
			if (caster)
			{
				casterCount++;
				Format(nameBuf, 64, "->%d. %s\n", casterCount, nameBuf);
				StrCat(casterBuffer, 500, nameBuf);
			}
			specCount++;
			if (GetConVarInt(l4d_ready_max_players) >= playerCount)
			{
				Format(nameBuf, 64, "->%d. %s\n", specCount, nameBuf);
				StrCat(specBuffer, 500, nameBuf);
			}
		}
		client++;
	}
	new bufLen = strlen(readyBuffer);
	if (bufLen)
	{
		readyBuffer[bufLen] = MissingTAG:0;
		ReplaceString(readyBuffer, 800, "#buy", "<- TROLL", true);
		ReplaceString(readyBuffer, 800, "#", "_", true);
		DrawPanelText(menuPanel, "READY");
		DrawPanelText(menuPanel, readyBuffer);
	}
	bufLen = strlen(unreadyBuffer);
	if (bufLen)
	{
		unreadyBuffer[bufLen] = MissingTAG:0;
		ReplaceString(unreadyBuffer, 800, "#buy", "<- TROLL", true);
		ReplaceString(unreadyBuffer, 800, "#", "_", true);
		DrawPanelText(menuPanel, "UNREADY");
		DrawPanelText(menuPanel, unreadyBuffer);
	}
	bufLen = strlen(casterBuffer);
	if (bufLen)
	{
		casterBuffer[bufLen] = MissingTAG:0;
		DrawPanelText(menuPanel, "CASTERS");
		ReplaceString(casterBuffer, 500, "#", "_", true);
		DrawPanelText(menuPanel, casterBuffer);
	}
	bufLen = strlen(specBuffer);
	if (bufLen)
	{
		specBuffer[bufLen] = MissingTAG:0;
		DrawPanelText(menuPanel, "SPECTATORS");
		ReplaceString(specBuffer, 500, "#", "_", true);
		if (GetConVarInt(l4d_ready_max_players) < playerCount)
		{
			FormatEx(specBuffer, 500, "->1. Many (%d)", specCount);
		}
		DrawPanelText(menuPanel, specBuffer);
	}
	new i;
	while (i < 10)
	{
		DrawPanelText(menuPanel, readyFooter[i]);
		i++;
	}
	new client = 1;
	while (client <= MaxClients)
	{
		new var5;
		if (IsClientInGame(client) && !IsFakeClient(client) && !hiddenPanel[client])
		{
			SendPanelToClient(menuPanel, client, DummyHandler, 1);
		}
		client++;
	}
	return 0;
}

InitiateReadyUp()
{
	new i;
	while (i <= 65)
	{
		isPlayerReady[i] = 0;
		i++;
	}
	UpdatePanel();
	CreateTimer(1.0, MenuRefresh_Timer, any:0, 3);
	CreateTimer(4.0, MenuCmd_Timer, any:0, 3);
	inReadyUp = true;
	inLiveCountdown = false;
	readyCountdownTimer = MissingTAG:0;
	if (GetConVarBool(l4d_ready_disable_spawns))
	{
		SetConVarBool(director_no_specials, true, false, false);
	}
	DisableEntities();
	SetConVarFlags(sv_infinite_primary_ammo, GetConVarFlags(god) & -257);
	SetConVarBool(sv_infinite_primary_ammo, true, false, false);
	SetConVarFlags(sv_infinite_primary_ammo, GetConVarFlags(god) | 256);
	SetConVarFlags(god, GetConVarFlags(god) & -257);
	SetConVarBool(god, true, false, false);
	SetConVarFlags(god, GetConVarFlags(god) | 256);
	SetConVarBool(sb_stop, true, false, false);
	L4D2_CTimerStart(L4D2CountdownTimer:7, 99999.9);
	return 0;
}

PrintCmd()
{
	if (iCmd > 9)
	{
		iCmd = 1;
	}
	switch (iCmd)
	{
		case 1:
		{
			Format(sCmd, 32, "->1. !kickspecs");
		}
		case 2:
		{
			Format(sCmd, 32, "->2. !slots #");
		}
		case 3:
		{
			Format(sCmd, 32, "->3. !voteboss <tank> <witch>");
		}
		case 4:
		{
			Format(sCmd, 32, "->4. !rmatch");
		}
		case 5:
		{
			Format(sCmd, 32, "->5. !cast / !uncast");
		}
		case 6:
		{
			Format(sCmd, 32, "->6. !setscores <survs> <inf>");
		}
		case 7:
		{
			Format(sCmd, 32, "->7. !lerps");
		}
		case 8:
		{
			Format(sCmd, 32, "->8. !secondary");
		}
		case 9:
		{
			Format(sCmd, 32, "->9. !changelog");
		}
		default:
		{
		}
	}
	return 0;
}

InitiateLive(bool:real)
{
	inReadyUp = false;
	inLiveCountdown = false;
	SetTeamFrozen(L4D2Team:2, false);
	EnableEntities();
	SetConVarFlags(sv_infinite_primary_ammo, GetConVarFlags(god) & -257);
	SetConVarBool(sv_infinite_primary_ammo, false, false, false);
	SetConVarFlags(sv_infinite_primary_ammo, GetConVarFlags(god) | 256);
	SetConVarBool(director_no_specials, false, false, false);
	SetConVarFlags(god, GetConVarFlags(god) & -257);
	SetConVarBool(god, false, false, false);
	SetConVarFlags(god, GetConVarFlags(god) | 256);
	SetConVarBool(sb_stop, false, false, false);
	L4D2_CTimerStart(L4D2CountdownTimer:7, 60.0);
	new i;
	while (i < 4)
	{
		GameRules_SetProp("m_iVersusDistancePerSurvivor", any:0, 4, GameRules_GetProp("m_bAreTeamsFlipped", 4, 0) * 4 + i, false);
		i++;
	}
	new i;
	while (i < 10)
	{
		i++;
	}
	footerCounter = 0;
	if (real)
	{
		Call_StartForward(liveForward);
		Call_Finish(0);
	}
	return 0;
}

public OnBossVote()
{
	footerCounter = 1;
	return 0;
}

ReturnPlayerToSaferoom(client, bool:flagsSet)
{
	new warp_flags;
	new give_flags;
	if (!flagsSet)
	{
		warp_flags = GetCommandFlags("warp_to_start_area");
		SetCommandFlags("warp_to_start_area", warp_flags & -16385);
		give_flags = GetCommandFlags("give");
		SetCommandFlags("give", give_flags & -16385);
	}
	if (GetEntProp(client, PropType:0, "m_isHangingFromLedge", 4, 0))
	{
		FakeClientCommand(client, "give health");
	}
	FakeClientCommand(client, "warp_to_start_area");
	if (!flagsSet)
	{
		SetCommandFlags("warp_to_start_area", warp_flags);
		SetCommandFlags("give", give_flags);
	}
	return 0;
}

ReturnTeamToSaferoom(L4D2Team:team)
{
	new warp_flags = GetCommandFlags("warp_to_start_area");
	SetCommandFlags("warp_to_start_area", warp_flags & -16385);
	new give_flags = GetCommandFlags("give");
	SetCommandFlags("give", give_flags & -16385);
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && team == GetClientTeam(client))
		{
			ReturnPlayerToSaferoom(client, true);
		}
		client++;
	}
	SetCommandFlags("warp_to_start_area", warp_flags);
	SetCommandFlags("give", give_flags);
	return 0;
}

SetTeamFrozen(L4D2Team:team, bool:freezeStatus)
{
	new client = 1;
	while (client <= MaxClients)
	{
		new var1;
		if (IsClientInGame(client) && team == GetClientTeam(client))
		{
			SetClientFrozen(client, freezeStatus);
		}
		client++;
	}
	return 0;
}

bool:CheckFullReady()
{
	new readyCount;
	new casterCount;
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			if (IsClientCaster(client))
			{
				casterCount++;
			}
			if (IsPlayer(client))
			{
				if (isPlayerReady[client])
				{
					readyCount++;
				}
			}
		}
		client++;
	}
	new String:GameMode[32];
	GetConVarString(FindConVar("mp_gamemode"), GameMode, 32);
	new var1;
	if (StrContains(GameMode, "coop", false) == -1 && StrContains(GameMode, "survival", false) == -1 && StrEqual(GameMode, "realism", false))
	{
		return readyCount >= GetRealClientCount();
	}
	return readyCount >= GetConVarInt(z_max_player_zombies) + GetConVarInt(survivor_limit);
}

InitiateLiveCountdown()
{
	if (!readyCountdownTimer)
	{
		ReturnTeamToSaferoom(L4D2Team:2);
		SetTeamFrozen(L4D2Team:2, true);
		PrintHintTextToAll("Going live!\nSay !unready to cancel");
		inLiveCountdown = true;
		readyDelay = GetConVarInt(l4d_ready_delay);
		readyCountdownTimer = CreateTimer(1.0, ReadyCountdownDelay_Timer, any:0, 3);
	}
	return 0;
}

public Action:ReadyCountdownDelay_Timer(Handle:timer)
{
	if (readyDelay)
	{
		PrintHintTextToAll("Live in: %d\nSay !unready to cancel", readyDelay);
		if (GetConVarBool(l4d_ready_enable_sound))
		{
			EmitSoundToAll("buttons/blip1.wav", -2, 0, 75, 0, 0.5, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
		}
		readyDelay -= 1;
		return Action:0;
	}
	PrintHintTextToAll("Round is live!");
	InitiateLive(true);
	readyCountdownTimer = MissingTAG:0;
	if (GetConVarBool(l4d_ready_enable_sound))
	{
		if (GetConVarBool(l4d_ready_chuckle))
		{
			EmitSoundToAll(countdownSound[GetRandomInt(0, 4)], -2, 0, 75, 0, 1.0, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
		}
		EmitSoundToAll(liveSound, -2, 0, 75, 0, 0.5, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
	}
	return Action:4;
}

CancelFullReady()
{
	if (readyCountdownTimer)
	{
		if (bSkipWarp)
		{
			SetTeamFrozen(L4D2Team:2, true);
		}
		else
		{
			SetTeamFrozen(L4D2Team:2, GetConVarBool(l4d_ready_survivor_freeze));
		}
		inLiveCountdown = false;
		CloseHandle(readyCountdownTimer);
		readyCountdownTimer = MissingTAG:0;
		PrintHintTextToAll("Countdown Cancelled!");
	}
	return 0;
}

GetRealClientCount()
{
	new clients;
	new i = 1;
	while (GetMaxClients() >= i)
	{
		if (IsClientConnected(i))
		{
			if (!IsClientInGame(i))
			{
				clients++;
			}
			new var1;
			if (!IsFakeClient(i) && GetClientTeam(i) == 2)
			{
				clients++;
			}
		}
		i++;
	}
	return clients;
}

GetSeriousClientCount()
{
	new clients;
	new i = 1;
	while (GetMaxClients() >= i)
	{
		new var1;
		if (IsClientConnected(i) && !IsFakeClient(i))
		{
			clients++;
		}
		i++;
	}
	return clients;
}

SetClientFrozen(client, freeze)
{
	new var1;
	if (freeze)
	{
		var1 = MissingTAG:0;
	}
	else
	{
		var1 = MissingTAG:2;
	}
	SetEntityMoveType(client, var1);
	return 0;
}

IsPlayer(client)
{
	new L4D2Team:team = GetClientTeam(client);
	new var1;
	return team == L4D2Team:2 || team == L4D2Team:3;
}

DisableEntities()
{
	ActivateEntities("prop_door_rotating", "SetUnbreakable");
	MakePropsUnbreakable();
	return 0;
}

EnableEntities()
{
	ActivateEntities("prop_door_rotating", "SetBreakable");
	MakePropsBreakable();
	return 0;
}

ActivateEntities(String:className[], String:inputName[])
{
	new iEntity;
	while ((iEntity = FindEntityByClassname(iEntity, className)) != -1)
	{
		new var1;
		if (!(!IsValidEdict(iEntity) || !IsValidEntity(iEntity)))
		{
			if (GetEntProp(iEntity, PropType:1, "m_spawnflags", 4, 0) != 526336)
			{
				AcceptEntityInput(iEntity, inputName, -1, -1, 0);
			}
		}
	}
	return 0;
}

MakePropsUnbreakable()
{
	new iEntity;
	while ((iEntity = FindEntityByClassname(iEntity, "prop_physics")) != -1)
	{
		new var1;
		if (!(!IsValidEdict(iEntity) || !IsValidEntity(iEntity)))
		{
			DispatchKeyValueFloat(iEntity, "minhealthdmg", 10000.0);
		}
	}
	return 0;
}

MakePropsBreakable()
{
	new iEntity;
	while ((iEntity = FindEntityByClassname(iEntity, "prop_physics")) != -1)
	{
		new var1;
		if (!(!IsValidEdict(iEntity) || !IsValidEntity(iEntity)))
		{
			DispatchKeyValueFloat(iEntity, "minhealthdmg", 5.0);
		}
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2",
	date = "12/20/2014",
	time = "15:43:20"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new bool:blockStumble;
public Plugin:myinfo =
{
	name = "Tank Rock Stumble Block",
	description = "Fixes rocks disappearing if tank gets stumbled while throwing.",
	author = "Jacob",
	version = "1.0",
	url = "github.com/jacob404/myplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public Action:L4D_OnCThrowActivate()
{
	blockStumble = true;
	CreateTimer(2.0, UnblockStumble, any:0, 0);
	return Action:0;
}

public Action:UnblockStumble(Handle:timer)
{
	blockStumble = false;
	return Action:0;
}

public Action:L4D2_OnStagger(target, source)
{
	if (GetClientTeam(target) != 3)
	{
		return Action:0;
	}
	new var1;
	if (GetInfectedClass(target) == 8 && !blockStumble)
	{
		return Action:0;
	}
	return Action:3;
}

GetInfectedClass(client)
{
	new var1;
	if (client > 0 && client <= MaxClients && IsClientInGame(client))
	{
		return GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	}
	return -1;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.5.2",
	date = "06/26/2014",
	time = "09:28:47"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_sceneproces =
{
	name = "sceneprocessor",
	file = "sceneprocessor.smx",
	required = 1,
};
public Plugin:myinfo =
{
	name = "Scene Processor",
	description = "Provides forwards and natives for manipulation of scenes",
	author = "Buster \"Mr. Zero\" Nielsen",
	version = "1.0.1",
	url = "https://forums.alliedmods.net/showthread.php?t=241585"
};
new bool:g_IsL4D1;
new Float:g_MapStartTimeStamp;
new bool:g_IsJailBreakingVocalizeCommand;
new bool:g_IsInGame[66];
new g_PlayingScene[66];
new String:g_VocalizeString[66][128];
new g_VocalizeTick[66];
new bool:g_VocalizeGotInitiator[66];
new g_VocalizeInitiator[66];
new Float:g_VocalizePreDelay[66];
new Float:g_VocalizePitch[66];
new Handle:g_FwdOnSceneStageChanged;
new Handle:g_FwdOnVocalizeCommand;
new bool:g_HasAnySceneToProcess;
new Handle:g_SceneStack;
new bool:g_HasAnyVocalizeCommandsToProcess;
new Handle:g_VocalizeArray;
new g_SceneDataArray[2049][391];
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

ExplodeString(String:text[], String:split[], String:buffers[][], maxStrings, maxStringLength, bool:copyRemainder)
{
	new reloc_idx;
	new idx;
	new total;
	new var1;
	if (maxStrings < 1 || !split[0])
	{
		return 0;
	}
	while ((idx = SplitString(text[reloc_idx], split, buffers[total], maxStringLength)) != -1)
	{
		reloc_idx = idx + reloc_idx;
		total++;
		if (maxStrings == total)
		{
			if (copyRemainder)
			{
				strcopy(buffers[total + -1], maxStringLength, text[reloc_idx - idx]);
			}
			return total;
		}
	}
	total++;
	strcopy(buffers[total], maxStringLength, text[reloc_idx]);
	return total;
}

PopStack(Handle:stack)
{
	new value;
	return PopStackCell(stack, value, 0, false);
}

bool:IsValidScene(scene)
{
	return GetSceneStage(scene) != 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	if (!IsDedicatedServer())
	{
		strcopy(error, err_max, "This plugin only support dedicated servers");
		return APLRes:1;
	}
	new EngineVersion:engine = GetEngineVersion();
	if (engine == EngineVersion:4)
	{
		g_IsL4D1 = true;
	}
	else
	{
		if (engine != EngineVersion:7)
		{
			strcopy(error, err_max, "This plugin only support Left 4 Dead & Left 4 Dead 2");
			return APLRes:1;
		}
	}
	CreateNative("GetSceneStage", N_GetSceneStage);
	CreateNative("GetSceneStartTimeStamp", N_GetSceneStartTimeStamp);
	CreateNative("GetActorFromScene", N_GetSceneActor);
	CreateNative("GetSceneFromActor", N_GetActorScene);
	CreateNative("GetSceneInitiator", N_GetSceneInitiator);
	CreateNative("GetSceneFile", N_GetSceneFile);
	CreateNative("GetSceneVocalize", N_GetSceneVocalize);
	CreateNative("GetScenePreDelay", N_GetScenePreDelay);
	CreateNative("SetScenePreDelay", N_SetScenePreDelay);
	CreateNative("GetScenePitch", N_GetScenePitch);
	CreateNative("SetScenePitch", N_SetScenePitch);
	CreateNative("CancelScene", N_CancelScene);
	CreateNative("PerformScene", N_PerformScene);
	CreateNative("PerformSceneEx", N_PerformSceneEx);
	RegPluginLibrary("sceneprocessor");
	return APLRes:0;
}

public OnPluginStart()
{
	g_SceneStack = CreateStack(1);
	g_VocalizeArray = CreateArray(128, 0);
	new i = 1;
	while (i <= 2048)
	{
		SceneData_SetStage(i, SceneStages:0);
		i++;
	}
	new i = 1;
	while (i <= 65)
	{
		ResetClientVocalizeData(i);
		i++;
	}
	g_FwdOnSceneStageChanged = CreateGlobalForward("OnSceneStageChanged", ExecType:0, 2, 2);
	g_FwdOnVocalizeCommand = CreateGlobalForward("OnVocalizeCommand", ExecType:3, 2, 7, 2);
	if (!g_IsL4D1)
	{
		new Handle:convar = CreateConVar("sceneprocessor_jailbreak_vocalize", "1", "Whether the vocalize command will function once again as it did in L4D1, allowing players to type vocalize commands into their console. 0 = Disallow, 1 = Allow", 262144, false, 0.0, false, 0.0);
		HookConVarChange(convar, OnJailBreakConVarChanged);
		g_IsJailBreakingVocalizeCommand = GetConVarBool(convar);
	}
	CreateConVar("sceneprocessor_version", "1.0.1", "Version of Scene Processor SourceMod plugin", 262400, false, 0.0, false, 0.0);
	AddCommandListener(OnVocalize_Command, "vocalize");
	return 0;
}

public OnJailBreakConVarChanged(Handle:convar, String:oldValue[], String:newValue[])
{
	g_IsJailBreakingVocalizeCommand = GetConVarBool(convar);
	return 0;
}

public OnAllPluginsLoaded()
{
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			g_IsInGame[client] = 1;
		}
		client++;
	}
	return 0;
}

public OnMapStart()
{
	g_MapStartTimeStamp = GetGameTime();
	return 0;
}

public OnMapEnd()
{
	g_HasAnySceneToProcess = false;
	g_HasAnyVocalizeCommandsToProcess = false;
	while (!IsStackEmpty(g_SceneStack))
	{
		PopStack(g_SceneStack);
	}
	ClearArray(g_VocalizeArray);
	new i = 1;
	while (i <= 2048)
	{
		SceneData_SetStage(i, SceneStages:0);
		i++;
	}
	new i = 1;
	while (i <= 65)
	{
		g_PlayingScene[i] = -1;
		i++;
	}
	return 0;
}

public OnClientPutInServer(client)
{
	if (client)
	{
		g_IsInGame[client] = 1;
		return 0;
	}
	return 0;
}

public OnClientDisconnect(client)
{
	if (client)
	{
		g_IsInGame[client] = 0;
		g_PlayingScene[client] = -1;
		return 0;
	}
	return 0;
}

public Action:OnVocalize_Command(client, String:command[], argc)
{
	new var1;
	if (client <= 0 || client > MaxClients || !g_IsInGame[client] || argc)
	{
		return Action:0;
	}
	new var2;
	if (!g_IsL4D1 && argc != 2)
	{
		if (g_IsJailBreakingVocalizeCommand)
		{
			decl String:vocalize[128];
			GetCmdArg(1, vocalize, 128);
			JailbreakVocalize(client, vocalize);
		}
		return Action:3;
	}
	decl String:vocalize[128];
	GetCmdArg(1, vocalize, 128);
	new tick = GetGameTickCount();
	new var4;
	if (!g_VocalizeGotInitiator[client] || (g_VocalizeTick[client] > 0 && tick != g_VocalizeTick[client]))
	{
		g_VocalizeInitiator[client] = client;
		new var5;
		if (!g_IsL4D1 && argc > 1 && StrEqual(vocalize, "smartlook", false))
		{
			decl String:time[32];
			GetCmdArg(2, time, 32);
			if (StrEqual(time, "auto", false))
			{
				g_VocalizeInitiator[client] = 0;
			}
		}
	}
	strcopy(g_VocalizeString[client], 128, vocalize);
	g_VocalizeTick[client] = tick;
	new Action:result;
	Call_StartForward(g_FwdOnVocalizeCommand);
	Call_PushCell(client);
	Call_PushString(vocalize);
	Call_PushCell(g_VocalizeInitiator[client]);
	Call_Finish(result);
	new var6;
	if (result == Action:4)
	{
		var6 = MissingTAG:3;
	}
	else
	{
		var6 = MissingTAG:0;
	}
	return var6;
}

public OnEntityCreated(entity, String:classname[])
{
	new var1;
	if (entity <= 0 || entity > 2048)
	{
		return 0;
	}
	if (StrEqual(classname, "instanced_scripted_scene", true))
	{
		SDKHook(entity, SDKHookType:24, OnPostSceneSpawn);
		SceneData_SetStage(entity, SceneStages:1);
	}
	return 0;
}

public OnEntityDestroyed(entity)
{
	new var1;
	if (entity <= 0 || entity > 2048)
	{
		return 0;
	}
	new SceneStages:sceneStage = SceneData_GetStage(entity);
	if (sceneStage)
	{
		if (sceneStage == SceneStages:4)
		{
			SceneData_SetStage(entity, SceneStages:6);
		}
		SceneData_SetStage(entity, SceneStages:7);
		new actor = 1;
		while (actor <= MaxClients)
		{
			if (!(entity != g_PlayingScene[actor]))
			{
				g_PlayingScene[actor] = -1;
			}
			actor++;
		}
	}
	SceneData_SetStage(entity, SceneStages:0);
	return 0;
}

public OnPostSceneSpawn(entity)
{
	new actor = GetEntPropEnt(entity, PropType:1, "m_hOwner", 0);
	SceneData_SetActor(entity, actor);
	decl String:file[256];
	GetEntPropString(entity, PropType:1, "m_iszSceneFile", file, 256, 0);
	SceneData_SetFile(entity, file);
	SceneData_SetPitch(entity, GetEntPropFloat(entity, PropType:1, "m_fPitch", 0));
	new var1;
	if (actor > 0 && actor <= MaxClients)
	{
		if (GetGameTickCount() == g_VocalizeTick[actor])
		{
			SceneData_SetVocalize(entity, g_VocalizeString[actor]);
			SceneData_SetInitiator(entity, g_VocalizeInitiator[actor]);
			SceneData_SetPreDelay(entity, g_VocalizePreDelay[actor]);
			SceneData_SetPitch(entity, g_VocalizePitch[actor]);
		}
		ResetClientVocalizeData(actor);
	}
	SetEntPropFloat(entity, PropType:1, "m_fPitch", SceneData_GetPitch(entity), 0);
	SetEntPropFloat(entity, PropType:1, "m_flPreDelay", SceneData_GetPreDelay(entity), 0);
	PushStackCell(g_SceneStack, entity);
	g_HasAnySceneToProcess = true;
	HookSingleEntityOutput(entity, "OnStart", OnSceneStart_EntOutput, false);
	HookSingleEntityOutput(entity, "OnCanceled", OnSceneCanceled_EntOutput, false);
	SceneData_SetStage(entity, SceneStages:2);
	return 0;
}

ResetClientVocalizeData(client)
{
	g_VocalizeTick[client] = 0;
	g_VocalizeGotInitiator[client] = 0;
	g_VocalizeInitiator[client] = 0;
	g_VocalizePreDelay[client] = 0;
	g_VocalizePitch[client] = 1065353216;
	return 0;
}

public OnGameFrame()
{
	if (g_HasAnySceneToProcess)
	{
		decl scene;
		while (!IsStackEmpty(g_SceneStack))
		{
			PopStackCell(g_SceneStack, scene, 0, false);
			new var1;
			if (!(scene <= 0 || scene > 2048 || !IsValidEntity(scene)))
			{
				if (!(SceneData_GetStage(scene) != 2))
				{
					SceneData_SetPreDelay(scene, GetEntPropFloat(scene, PropType:1, "m_flPreDelay", 0));
					SceneData_SetIsInFakePostSpawn(scene, false);
					SceneData_SetStage(scene, SceneStages:3);
				}
			}
		}
		g_HasAnySceneToProcess = false;
	}
	if (g_HasAnyVocalizeCommandsToProcess)
	{
		new arraySize = GetArraySize(g_VocalizeArray);
		new currentTick = GetGameTickCount();
		decl client;
		decl String:vocalize[128];
		decl Float:preDelay;
		decl Float:pitch;
		decl initiator;
		decl tick;
		new i;
		while (i < arraySize)
		{
			tick = GetArrayCell(g_VocalizeArray, i + 5, 0, false);
			if (!(tick != currentTick))
			{
				client = GetArrayCell(g_VocalizeArray, i + 0, 0, false);
				GetArrayString(g_VocalizeArray, i + 1, vocalize, 128);
				preDelay = GetArrayCell(g_VocalizeArray, i + 2, 0, false);
				pitch = GetArrayCell(g_VocalizeArray, i + 3, 0, false);
				initiator = GetArrayCell(g_VocalizeArray, i + 4, 0, false);
				Scene_Perform(client, vocalize, "", preDelay, pitch, initiator, true);
				new j;
				while (j < 6)
				{
					RemoveFromArray(g_VocalizeArray, i);
					arraySize--;
					j++;
				}
			}
			i += 6;
		}
		if (0 >= arraySize)
		{
			ClearArray(g_VocalizeArray);
			g_HasAnyVocalizeCommandsToProcess = false;
		}
	}
	return 0;
}

public OnSceneStart_EntOutput(String:output[], caller, activator, Float:delay)
{
	new var1;
	if (caller <= 0 || caller > 2048 || !IsValidEntity(caller))
	{
		return 0;
	}
	decl String:file[256];
	SceneData_GetFile(caller, file, 256);
	if (strlen(file))
	{
		SceneData_SetStartTimeStamp(caller, GetEngineTime());
		if (SceneData_GetStage(caller) == 2)
		{
			SceneData_SetIsInFakePostSpawn(caller, true);
			SceneData_SetStage(caller, SceneStages:3);
		}
		if (SceneData_GetStage(caller) == 3)
		{
			new actor = SceneData_GetActor(caller);
			new var2;
			if (actor > 0 && actor <= MaxClients && g_IsInGame[actor])
			{
				g_PlayingScene[actor] = caller;
			}
			SceneData_SetStage(caller, SceneStages:4);
		}
		return 0;
	}
	return 0;
}

public OnSceneCanceled_EntOutput(String:output[], caller, activator, Float:delay)
{
	new var1;
	if (caller <= 0 || caller > 2048 || !IsValidEntity(caller))
	{
		return 0;
	}
	new actor = 1;
	while (actor <= MaxClients)
	{
		if (caller == g_PlayingScene[actor])
		{
			g_PlayingScene[actor] = -1;
			SceneData_SetStage(caller, SceneStages:5);
			return 0;
		}
		actor++;
	}
	SceneData_SetStage(caller, SceneStages:5);
	return 0;
}

SceneStages:SceneData_GetStage(scene)
{
	return g_SceneDataArray[scene][0];
}

public N_GetSceneStage(Handle:plugin, numParams)
{
	if (numParams)
	{
		new scene = GetNativeCell(1);
		new var1;
		if (scene <= 0 || scene > 2048)
		{
			return 0;
		}
		return SceneData_GetStage(scene);
	}
	return 0;
}

SceneData_SetStage(scene, SceneStages:stage)
{
	g_SceneDataArray[scene][0] = stage;
	if (stage)
	{
		Call_StartForward(g_FwdOnSceneStageChanged);
		Call_PushCell(scene);
		Call_PushCell(stage);
		Call_Finish(0);
	}
	else
	{
		SceneData_SetIsInFakePostSpawn(scene, false);
		SceneData_SetStartTimeStamp(scene, 0.0);
		SceneData_SetActor(scene, 0);
		SceneData_SetInitiator(scene, 0);
		SceneData_SetFile(scene, "");
		SceneData_SetVocalize(scene, "");
		SceneData_SetPreDelay(scene, 0.0);
		SceneData_SetPitch(scene, 1.0);
	}
	return 0;
}

SceneData_SetIsInFakePostSpawn(scene, bool:fake)
{
	g_SceneDataArray[scene][1] = fake;
	return 0;
}

bool:SceneData_InFakePostSpawn(scene)
{
	return g_SceneDataArray[scene][1];
}

Float:SceneData_GetStartTimeStamp(scene)
{
	return g_SceneDataArray[scene][2];
}

public N_GetSceneStartTimeStamp(Handle:plugin, numParams)
{
	if (numParams)
	{
		new scene = GetNativeCell(1);
		if (!IsValidScene(scene))
		{
			return 0;
		}
		return SceneData_GetStartTimeStamp(scene);
	}
	return 0;
}

SceneData_SetStartTimeStamp(scene, Float:timeStamp)
{
	g_SceneDataArray[scene][2] = timeStamp;
	return 0;
}

SceneData_GetActor(scene)
{
	return g_SceneDataArray[scene][3];
}

public N_GetSceneActor(Handle:plugin, numParams)
{
	if (numParams)
	{
		new scene = GetNativeCell(1);
		if (!IsValidScene(scene))
		{
			return 0;
		}
		return SceneData_GetActor(scene);
	}
	return 0;
}

public N_GetActorScene(Handle:plugin, numParams)
{
	if (numParams)
	{
		new actor = GetNativeCell(1);
		new var1;
		if (actor <= 0 || actor > MaxClients || !IsClientInGame(actor))
		{
			return -1;
		}
		return g_PlayingScene[actor];
	}
	return -1;
}

SceneData_SetActor(scene, actor)
{
	g_SceneDataArray[scene][3] = actor;
	return 0;
}

SceneData_GetInitiator(scene)
{
	return g_SceneDataArray[scene][4];
}

public N_GetSceneInitiator(Handle:plugin, numParams)
{
	if (numParams)
	{
		new scene = GetNativeCell(1);
		if (!IsValidScene(scene))
		{
			return 0;
		}
		return SceneData_GetInitiator(scene);
	}
	return 0;
}

SceneData_SetInitiator(scene, initiator)
{
	g_SceneDataArray[scene][4] = initiator;
	return 0;
}

SceneData_GetFile(scene, String:dest[], len)
{
	return strcopy(dest, len, g_SceneDataArray[scene][5]);
}

public N_GetSceneFile(Handle:plugin, numParams)
{
	if (numParams != 3)
	{
		return 0;
	}
	new scene = GetNativeCell(1);
	if (!IsValidScene(scene))
	{
		return 0;
	}
	new len = GetNativeCell(3);
	new bytesWritten;
	SetNativeString(2, g_SceneDataArray[scene][5], len, true, bytesWritten);
	return bytesWritten;
}

SceneData_SetFile(scene, String:file[])
{
	strcopy(g_SceneDataArray[scene][5], 256, file);
	return 0;
}

public N_GetSceneVocalize(Handle:plugin, numParams)
{
	if (numParams != 3)
	{
		return 0;
	}
	new scene = GetNativeCell(1);
	if (!IsValidScene(scene))
	{
		return 0;
	}
	new len = GetNativeCell(3);
	new bytesWritten;
	SetNativeString(2, g_SceneDataArray[scene][261], len, true, bytesWritten);
	return bytesWritten;
}

SceneData_SetVocalize(scene, String:vocalize[])
{
	strcopy(g_SceneDataArray[scene][261], 128, vocalize);
	return 0;
}

Float:SceneData_GetPreDelay(scene)
{
	return g_SceneDataArray[scene][389];
}

public N_GetScenePreDelay(Handle:plugin, numParams)
{
	if (numParams)
	{
		new scene = GetNativeCell(1);
		if (!IsValidScene(scene))
		{
			return 0;
		}
		return SceneData_GetPreDelay(scene);
	}
	return 0;
}

SceneData_SetPreDelay(scene, Float:preDelay)
{
	g_SceneDataArray[scene][389] = preDelay;
	return 0;
}

public N_SetScenePreDelay(Handle:plugin, numParams)
{
	if (numParams != 2)
	{
		return 0;
	}
	new scene = GetNativeCell(1);
	if (!IsValidScene(scene))
	{
		return 0;
	}
	new Float:preDelay = GetNativeCell(2);
	SceneData_SetPreDelay(scene, preDelay);
	SetEntPropFloat(scene, PropType:1, "m_flPreDelay", preDelay, 0);
	return 0;
}

Float:SceneData_GetPitch(scene)
{
	return g_SceneDataArray[scene][390];
}

public N_GetScenePitch(Handle:plugin, numParams)
{
	if (numParams)
	{
		new scene = GetNativeCell(1);
		if (!IsValidScene(scene))
		{
			return 0;
		}
		return SceneData_GetPitch(scene);
	}
	return 0;
}

SceneData_SetPitch(scene, Float:pitch)
{
	g_SceneDataArray[scene][390] = pitch;
	return 0;
}

public N_SetScenePitch(Handle:plugin, numParams)
{
	if (numParams != 2)
	{
		return 0;
	}
	new scene = GetNativeCell(1);
	if (!IsValidScene(scene))
	{
		return 0;
	}
	new Float:pitch = GetNativeCell(2);
	SceneData_SetPreDelay(scene, pitch);
	SetEntPropFloat(scene, PropType:1, "m_fPitch", pitch, 0);
	return 0;
}

public N_CancelScene(Handle:plugin, numParams)
{
	if (numParams)
	{
		new scene = GetNativeCell(1);
		new var1;
		if (scene <= 0 || scene > 2048)
		{
			return 0;
		}
		new SceneStages:sceneStage = SceneData_GetStage(scene);
		if (sceneStage)
		{
			new var3;
			if (sceneStage == SceneStages:4 || (sceneStage == SceneStages:3 && SceneData_InFakePostSpawn(scene)))
			{
				AcceptEntityInput(scene, "Cancel", -1, -1, 0);
			}
			else
			{
				new var4;
				if (sceneStage != SceneStages:5 && sceneStage != SceneStages:6 && sceneStage != SceneStages:7)
				{
					AcceptEntityInput(scene, "Kill", -1, -1, 0);
				}
			}
			return 0;
		}
		return 0;
	}
	return 0;
}

Scene_Perform(client, String:vocalize[], String:file[], Float:preDelay, Float:pitch, initiator, bool:vocalizeNow)
{
	new var1;
	if (strlen(file) > 0 && FileExists(file, true))
	{
		new scene = CreateEntityByName("instanced_scripted_scene", -1);
		DispatchKeyValue(scene, "SceneFile", file);
		SetEntPropEnt(scene, PropType:1, "m_hOwner", client, 0);
		SceneData_SetActor(scene, client);
		SetEntPropFloat(scene, PropType:1, "m_flPreDelay", preDelay, 0);
		SceneData_SetPreDelay(scene, preDelay);
		SetEntPropFloat(scene, PropType:1, "m_fPitch", pitch, 0);
		SceneData_SetPitch(scene, pitch);
		SceneData_SetInitiator(scene, initiator);
		SceneData_SetVocalize(scene, vocalize);
		DispatchSpawn(scene);
		ActivateEntity(scene);
		AcceptEntityInput(scene, "Start", client, client, 0);
	}
	else
	{
		if (0 < strlen(vocalize))
		{
			if (vocalizeNow)
			{
				g_VocalizeInitiator[client] = initiator;
				g_VocalizeGotInitiator[client] = 1;
				g_VocalizePreDelay[client] = preDelay;
				g_VocalizePitch[client] = pitch;
				if (g_IsL4D1)
				{
					FakeClientCommandEx(client, "%s %s", "vocalize", vocalize);
				}
				else
				{
					JailbreakVocalize(client, vocalize);
				}
			}
			PushArrayCell(g_VocalizeArray, client);
			PushArrayString(g_VocalizeArray, vocalize);
			PushArrayCell(g_VocalizeArray, preDelay);
			PushArrayCell(g_VocalizeArray, pitch);
			PushArrayCell(g_VocalizeArray, initiator);
			PushArrayCell(g_VocalizeArray, GetGameTickCount() + 9);
			g_HasAnyVocalizeCommandsToProcess = true;
		}
	}
	return 0;
}

public N_PerformScene(Handle:plugin, numParams)
{
	if (numParams < 2)
	{
		return 0;
	}
	new client = GetNativeCell(1);
	new var1;
	if (client <= 0 || client > MaxClients || !g_IsInGame[client] || GetClientTeam(client) == 2 || !IsPlayerAlive(client))
	{
		return 0;
	}
	new String:vocalize[128];
	new String:file[256];
	new Float:preDelay = 0.0;
	new Float:pitch = 1.0;
	new initiator = -1;
	if (GetNativeString(2, vocalize, 128, 0))
	{
		ThrowNativeError(0, "Failed to get \"vocalize\" parameter to perform scene!");
		return 0;
	}
	if (numParams >= 3)
	{
		if (GetNativeString(3, file, 256, 0))
		{
			ThrowNativeError(0, "Failed to get \"file\" parameter to perform scene!");
			return 0;
		}
	}
	if (numParams >= 4)
	{
		preDelay = GetNativeCell(4);
	}
	if (numParams >= 5)
	{
		pitch = GetNativeCell(5);
	}
	if (numParams >= 5)
	{
		initiator = GetNativeCell(6);
	}
	Scene_Perform(client, vocalize, file, preDelay, pitch, initiator, false);
	return 0;
}

public N_PerformSceneEx(Handle:plugin, numParams)
{
	if (numParams < 2)
	{
		return 0;
	}
	new client = GetNativeCell(1);
	new var1;
	if (client <= 0 || client > MaxClients || !g_IsInGame[client] || GetClientTeam(client) == 2 || !IsPlayerAlive(client))
	{
		return 0;
	}
	new String:vocalize[128];
	new String:file[256];
	new Float:preDelay = 0.0;
	new Float:pitch = 1.0;
	new initiator = -1;
	if (GetNativeString(2, vocalize, 128, 0))
	{
		ThrowNativeError(0, "Failed to get \"vocalize\" parameter to perform scene!");
		return 0;
	}
	if (numParams >= 3)
	{
		if (GetNativeString(3, file, 256, 0))
		{
			ThrowNativeError(0, "Failed to get \"file\" parameter to perform scene!");
			return 0;
		}
	}
	if (numParams >= 4)
	{
		preDelay = GetNativeCell(4);
	}
	if (numParams >= 5)
	{
		pitch = GetNativeCell(5);
	}
	if (numParams >= 5)
	{
		initiator = GetNativeCell(6);
	}
	Scene_Perform(client, vocalize, file, preDelay, pitch, initiator, true);
	return 0;
}

JailbreakVocalize(client, String:vocalize[])
{
	new String:buffer[2][32] = {
		".",
		""
	};
	FloatToString(GetGameTime() - g_MapStartTimeStamp + 2.0, buffer[0][buffer], 32);
	ExplodeString(buffer[0][buffer], ".", buffer, 2, 32, false);
	Format(buffer[1], 2, "%s", buffer[1]);
	FakeClientCommandEx(client, "%s %s #%s%s", "vocalize", vocalize, buffer[0][buffer], buffer[1]);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "08/21/2014",
	time = "18:14:00"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_l4d2lib =
{
	name = "l4d2lib",
	file = "l4d2lib.smx",
	required = 1,
};
new Handle:hCvarBonusPerSurvivorMultiplier;
new Handle:hCvarPermanentHealthProportion;
new Handle:hCvarPillsDivisor;
new Handle:hCvarSurvivalBonus;
new Handle:hCvarTieBreaker;
new Float:fMapBonus;
new Float:fMapHealthBonus;
new Float:fMapDamageBonus;
new Float:fMapTempHealthBonus;
new Float:fPermHpWorth;
new Float:fTempHpWorth;
new Float:fSurvivorBonus[2];
new iMapDistance;
new iTeamSize;
new iPillWorth;
new iLostTempHealth[2];
new iTempHealth[66];
new String:sSurvivorState[2][32];
new bool:bLateLoad;
new bool:bRoundOver;
public Plugin:myinfo =
{
	name = "L4D2 Scoremod+",
	description = "EQ2.0 Scoremod, modified for ProMod 5",
	author = "Visor",
	version = "1.6",
	url = "https://github.com/ConfoglTeam/ProMod"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator/(Float:,_:)(Float:oper1, oper2)
{
	return oper1 / float(oper2);
}

Float:operator/(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) / oper2;
}

bool:operator==(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) == 0;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator>=(_:,Float:)(oper1, Float:oper2)
{
	return FloatCompare(float(oper1), oper2) >= 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

GetEntityValueFromOffset(entity, String:offset[], NumberType:size, &value)
{
	new Address:pEntity = GetEntityAddress(entity);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), offset);
		if (offs == -1)
		{
			return 0;
		}
		value = LoadFromAddress(offs + pEntity, size);
		return 1;
	}
	return 0;
}

L4D2Direct_GetPreIncapHealthBuffer(client)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return -1;
	}
	decl value;
	if (!GetEntityValueFromOffset(client, "CTerrorPlayer::m_preIncapacitatedHealthBuffer", NumberType:2, value))
	{
		value = -1;
	}
	return value;
}

public __pl_l4d2lib_SetNTVOptional()
{
	MarkNativeAsOptional("L4D2_GetCurrentRound");
	MarkNativeAsOptional("L4D2_CurrentlyInRound");
	MarkNativeAsOptional("L4D2_GetSurvivorCount");
	MarkNativeAsOptional("L4D2_GetSurvivorOfIndex");
	MarkNativeAsOptional("L4D2_IsMapDataAvailable");
	MarkNativeAsOptional("L4D2_IsEntityInSaferoom");
	MarkNativeAsOptional("L4D2_GetMapStartOrigin");
	MarkNativeAsOptional("L4D2_GetMapEndOrigin");
	MarkNativeAsOptional("L4D2_GetMapStartDistance");
	MarkNativeAsOptional("L4D2_GetMapStartExtraDistance");
	MarkNativeAsOptional("L4D2_GetMapEndDistance");
	MarkNativeAsOptional("L4D2_GetMapValueInt");
	MarkNativeAsOptional("L4D2_GetMapValueFloat");
	MarkNativeAsOptional("L4D2_GetMapValueVector");
	MarkNativeAsOptional("L4D2_GetMapValueString");
	MarkNativeAsOptional("L4D2_CopyMapSubsection");
	return 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	bLateLoad = late;
	return APLRes:0;
}

public OnPluginStart()
{
	hCvarBonusPerSurvivorMultiplier = CreateConVar("sm2_bonus_per_survivor_multiplier", "0.5", "Total Survivor Bonus = this * Number of Survivors * Map Distance", 262144, true, 0.25, false, 0.0);
	hCvarPermanentHealthProportion = CreateConVar("sm2_permament_health_proportion", "0.75", "Permanent Health Bonus = this * Map Bonus; rest goes for Temporary Health Bonus", 262144, false, 0.0, false, 0.0);
	hCvarPillsDivisor = CreateConVar("sm2_pills_multiplier_divisor", "3.0", "Unused pills worth = map HP value / this", 262144, false, 0.0, false, 0.0);
	hCvarSurvivalBonus = FindConVar("vs_survival_bonus");
	hCvarTieBreaker = FindConVar("vs_tiebreak_bonus");
	HookConVarChange(hCvarBonusPerSurvivorMultiplier, CvarChanged);
	HookConVarChange(hCvarPermanentHealthProportion, CvarChanged);
	HookEvent("round_start", OnRoundStart, EventHookMode:2);
	HookEvent("player_ledge_grab", OnPlayerLedgeGrab, EventHookMode:1);
	RegConsoleCmd("sm_health", CmdBonus, "", 0);
	RegConsoleCmd("sm_damage", CmdBonus, "", 0);
	RegConsoleCmd("sm_bonus", CmdBonus, "", 0);
	RegConsoleCmd("sm_mapinfo", CmdMapInfo, "", 0);
	if (bLateLoad)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			if (IsClientInGame(i))
			{
				OnClientPutInServer(i);
			}
			i++;
		}
	}
	return 0;
}

public OnPluginEnd()
{
	ResetConVar(hCvarSurvivalBonus, false, false);
	ResetConVar(hCvarTieBreaker, false, false);
	return 0;
}

public OnConfigsExecuted()
{
	iTeamSize = GetConVarInt(FindConVar("survivor_limit"));
	SetConVarInt(hCvarTieBreaker, 0, false, false);
	iMapDistance = L4D2_GetMapValueInt("max_distance", L4D_GetVersusMaxCompletionScore());
	L4D_SetVersusMaxCompletionScore(iMapDistance);
	new Float:fPermHealthProportion = GetConVarFloat(hCvarPermanentHealthProportion);
	new Float:fTempHealthProportion = 1.0 - fPermHealthProportion;
	fMapBonus = GetConVarFloat(hCvarBonusPerSurvivorMultiplier) * iTeamSize * iMapDistance;
	fMapHealthBonus = fMapBonus * fPermHealthProportion;
	fMapDamageBonus = fMapBonus * fTempHealthProportion;
	fMapTempHealthBonus = iTeamSize * 100 / fPermHealthProportion * fTempHealthProportion;
	fPermHpWorth = fMapBonus / iTeamSize / 100 * fPermHealthProportion;
	fTempHpWorth = fMapBonus * fTempHealthProportion / fMapTempHealthBonus;
	iPillWorth = RoundToNearest(fPermHpWorth / GetConVarFloat(hCvarPillsDivisor) * 50 / 5) * 5;
	return 0;
}

public OnMapStart()
{
	OnConfigsExecuted();
	iLostTempHealth[0] = 0;
	iLostTempHealth[1] = 0;
	return 0;
}

public CvarChanged(Handle:convar, String:oldValue[], String:newValue[])
{
	OnConfigsExecuted();
	return 0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:2, OnTakeDamage);
	SDKHook(client, SDKHookType:3, OnTakeDamagePost);
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	SDKUnhook(client, SDKHookType:3, OnTakeDamagePost);
	return 0;
}

public OnRoundStart()
{
	new i;
	while (i < 65)
	{
		iTempHealth[i] = 0;
		i++;
	}
	bRoundOver = false;
	return 0;
}

public Action:CmdBonus(client, args)
{
	new var1;
	if (bRoundOver || !client)
	{
		return Action:3;
	}
	decl String:sCmdType[64];
	GetCmdArg(1, sCmdType, 64);
	new Float:fHealthBonus = GetSurvivorHealthBonus();
	new Float:fDamageBonus = GetSurvivorDamageBonus();
	new Float:fPillsBonus = GetSurvivorPillBonus();
	new Float:fMaxPillsBonus = float(iTeamSize * iPillWorth);
	if (StrEqual(sCmdType, "full", true))
	{
		if (InSecondHalfOfRound())
		{
			new var2 = sSurvivorState;
			PrintToChat(client, "\x01R\x04#1\x01 Bonus: \x05%d\x01/\x05%d\x01 <\x03%.1f%%\x01> [%s]", RoundToFloor(fSurvivorBonus[0]), RoundToFloor(fMapBonus + fMaxPillsBonus), CalculateBonusPercent(fSurvivorBonus[0], -1.0), var2[0][var2]);
		}
		PrintToChat(client, "\x01R\x04#%i\x01 Bonus: \x05%d\x01 <\x03%.1f%%\x01> [HB: \x05%d\x01 <\x03%.1f%%\x01> | DB: \x05%d\x01 <\x03%.1f%%\x01> | Pills: \x05%d\x01 <\x03%.1f%%\x01>]", InSecondHalfOfRound() + 1, RoundToFloor(fHealthBonus + fDamageBonus + fPillsBonus), CalculateBonusPercent(fHealthBonus + fDamageBonus + fPillsBonus, fMapHealthBonus + fMapDamageBonus + fMaxPillsBonus), RoundToFloor(fHealthBonus), CalculateBonusPercent(fHealthBonus, fMapHealthBonus), RoundToFloor(fDamageBonus), CalculateBonusPercent(fDamageBonus, fMapDamageBonus), RoundToFloor(fPillsBonus), CalculateBonusPercent(fPillsBonus, fMaxPillsBonus));
	}
	else
	{
		if (StrEqual(sCmdType, "lite", true))
		{
			PrintToChat(client, "\x01R\x04#%i\x01 Bonus: \x05%d\x01 <\x03%.1f%%\x01>", InSecondHalfOfRound() + 1, RoundToFloor(fHealthBonus + fDamageBonus + fPillsBonus), CalculateBonusPercent(fHealthBonus + fDamageBonus + fPillsBonus, fMapHealthBonus + fMapDamageBonus + fMaxPillsBonus));
		}
		if (InSecondHalfOfRound())
		{
			PrintToChat(client, "\x01R\x04#1\x01 Bonus: \x05%d\x01 <\x03%.1f%%\x01>", RoundToFloor(fSurvivorBonus[0]), CalculateBonusPercent(fSurvivorBonus[0], -1.0));
		}
		PrintToChat(client, "\x01R\x04#%i\x01 Bonus: \x05%d\x01 <\x03%.1f%%\x01> [HB: \x03%.0f%%\x01 | DB: \x03%.0f%%\x01 | Pills: \x03%.0f%%\x01]", InSecondHalfOfRound() + 1, RoundToFloor(fHealthBonus + fDamageBonus + fPillsBonus), CalculateBonusPercent(fHealthBonus + fDamageBonus + fPillsBonus, fMapHealthBonus + fMapDamageBonus + fMaxPillsBonus), CalculateBonusPercent(fHealthBonus, fMapHealthBonus), CalculateBonusPercent(fDamageBonus, fMapDamageBonus), CalculateBonusPercent(fPillsBonus, fMaxPillsBonus));
	}
	return Action:3;
}

public Action:CmdMapInfo(client, args)
{
	new Float:fMaxPillsBonus = float(iTeamSize * iPillWorth);
	new Float:fTotalBonus = fMapBonus + fMaxPillsBonus;
	PrintToChat(client, "\x01[\x04ScoreMod 2\x01 :: \x03%iv%i\x01] Map Info", iTeamSize, iTeamSize);
	PrintToChat(client, "\x01Distance: \x05%d\x01", iMapDistance);
	PrintToChat(client, "\x01Total Bonus: \x05%d\x01 <\x03100.0%%\x01>", RoundToFloor(fTotalBonus));
	PrintToChat(client, "\x01Health Bonus: \x05%d\x01 <\x03%.1f%%\x01>", RoundToFloor(fMapHealthBonus), CalculateBonusPercent(fMapHealthBonus, fTotalBonus));
	PrintToChat(client, "\x01Damage Bonus: \x05%d\x01 <\x03%.1f%%\x01>", RoundToFloor(fMapDamageBonus), CalculateBonusPercent(fMapDamageBonus, fTotalBonus));
	PrintToChat(client, "\x01Pill Bonus: \x05%d\x01(max \x05%d\x01) <\x03%.1f%%\x01>", iPillWorth, RoundToFloor(fMaxPillsBonus), CalculateBonusPercent(fMaxPillsBonus, fTotalBonus));
	return Action:3;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	new var1;
	if (!IsSurvivor(victim) || !IsAnyInfected(attacker) || IsPlayerIncap(victim))
	{
		return Action:0;
	}
	iTempHealth[victim] = GetSurvivorTemporaryHealth(victim);
	return Action:0;
}

public OnPlayerLedgeGrab(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1 = iLostTempHealth[InSecondHalfOfRound()];
	var1 = var1[L4D2Direct_GetPreIncapHealthBuffer(client)];
	return 0;
}

public Action:L4D2_OnRevived(client)
{
	iLostTempHealth[InSecondHalfOfRound()] -= GetSurvivorTemporaryHealth(client);
	return Action:0;
}

public OnTakeDamagePost(victim, attacker, inflictor, Float:damage, damagetype)
{
	new var1;
	if (!IsSurvivor(victim) || !IsAnyInfected(attacker))
	{
		return 0;
	}
	new var3;
	if (!IsPlayerAlive(victim) || (IsPlayerIncap(victim) && !IsPlayerLedged(victim)))
	{
		new var6 = iLostTempHealth[InSecondHalfOfRound()];
		var6 = iTempHealth[victim][var6];
	}
	else
	{
		if (!IsPlayerLedged(victim))
		{
			new var7 = iLostTempHealth[InSecondHalfOfRound()];
			new var4;
			if (iTempHealth[victim])
			{
				var4 = iTempHealth[victim] - GetSurvivorTemporaryHealth(victim);
			}
			else
			{
				var4 = 0;
			}
			var7 = var7[var4];
		}
	}
	new var5;
	if (IsPlayerIncap(victim))
	{
		var5 = 0;
	}
	else
	{
		var5 = GetSurvivorTemporaryHealth(victim);
	}
	iTempHealth[victim] = var5;
	return 0;
}

public Action:L4D2_OnEndVersusModeRound(bool:countSurvivors)
{
	if (bRoundOver)
	{
		return Action:0;
	}
	new team = InSecondHalfOfRound();
	new iSurvivalMultiplier = GetUprightSurvivors();
	fSurvivorBonus[team] = GetSurvivorHealthBonus() + GetSurvivorDamageBonus() + GetSurvivorPillBonus();
	new var1;
	if (iSurvivalMultiplier > 0 && RoundToFloor(fSurvivorBonus[team] / iSurvivalMultiplier) >= 1065353216)
	{
		SetConVarInt(hCvarSurvivalBonus, RoundToFloor(fSurvivorBonus[team] / iSurvivalMultiplier), false, false);
		fSurvivorBonus[team] = float(iSurvivalMultiplier * GetConVarInt(hCvarSurvivalBonus));
		new var2;
		if (iTeamSize == iSurvivalMultiplier)
		{
			var2[0] = 3312;
		}
		else
		{
			var2[0] = 3316;
		}
		Format(sSurvivorState[team], 32, "%s%i\x01/\x05%i\x01", var2, iSurvivalMultiplier, iTeamSize);
	}
	else
	{
		SetConVarInt(hCvarSurvivalBonus, 0, false, false);
		new var3;
		if (iSurvivalMultiplier)
		{
			var3[0] = 3340;
		}
		else
		{
			var3[0] = 3328;
		}
		Format(sSurvivorState[team], 32, "\x04%s\x01", var3);
	}
	CreateTimer(3.0, PrintRoundEndStats, any:0, 2);
	bRoundOver = true;
	return Action:0;
}

public Action:PrintRoundEndStats(Handle:timer)
{
	new i;
	while (InSecondHalfOfRound() >= i)
	{
		PrintToChatAll("\x01Round \x04%i\x01 Bonus: \x05%d\x01/\x05%d\x01 <\x03%.1f%%\x01> [%s]", i + 1, RoundToFloor(fSurvivorBonus[i]), RoundToFloor(fMapBonus), CalculateBonusPercent(fSurvivorBonus[i], -1.0), sSurvivorState[i]);
		i++;
	}
	return Action:0;
}

Float:GetSurvivorHealthBonus()
{
	new Float:fHealthBonus = 0.0;
	new survivorCount;
	new survivalMultiplier;
	new i = 1;
	while (i <= MaxClients && survivorCount < iTeamSize)
	{
		if (IsSurvivor(i))
		{
			survivorCount++;
			new var2;
			if (IsPlayerAlive(i) && !IsPlayerIncap(i) && !IsPlayerLedged(i))
			{
				survivalMultiplier++;
				fHealthBonus += fPermHpWorth * GetSurvivorPermanentHealth(i);
			}
		}
		i++;
	}
	return fHealthBonus / iTeamSize * survivalMultiplier;
}

Float:GetSurvivorDamageBonus()
{
	new survivalMultiplier = GetUprightSurvivors();
	new Float:fDamageBonus = fMapTempHealthBonus - float(iLostTempHealth[InSecondHalfOfRound()]) * fTempHpWorth / iTeamSize * survivalMultiplier;
	new var1;
	if (fDamageBonus > 0.0 && survivalMultiplier > 0)
	{
		var2 = fDamageBonus;
	}
	else
	{
		var2 = 0.0;
	}
	return var2;
}

Float:GetSurvivorPillBonus()
{
	new pillsBonus;
	new survivorCount;
	new i = 1;
	while (i <= MaxClients && survivorCount < iTeamSize)
	{
		if (IsSurvivor(i))
		{
			survivorCount++;
			new var2;
			if (IsPlayerAlive(i) && HasPills(i))
			{
				pillsBonus = iPillWorth + pillsBonus;
			}
		}
		i++;
	}
	return float(pillsBonus);
}

Float:CalculateBonusPercent(Float:score, Float:maxbonus)
{
	new var1;
	if (-1.0 == maxbonus)
	{
		var1 = fMapBonus;
	}
	else
	{
		var1 = maxbonus;
	}
	return score / var1 * 100;
}

InSecondHalfOfRound()
{
	return GameRules_GetProp("m_bInSecondHalfOfRound", 4, 0);
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsAnyInfected(entity)
{
	new var1;
	if (entity > 0 && entity <= MaxClients)
	{
		new var2;
		return IsClientInGame(entity) && GetClientTeam(entity) == 3;
	}
	if (entity > MaxClients)
	{
		decl String:classname[64];
		GetEdictClassname(entity, classname, 64);
		new var3;
		if (StrEqual(classname, "infected", true) || StrEqual(classname, "witch", true))
		{
			return true;
		}
	}
	return false;
}

bool:IsPlayerIncap(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

bool:IsPlayerLedged(client)
{
	return GetEntProp(client, PropType:0, "m_isFallingFromLedge", 4, 0) | GetEntProp(client, PropType:0, "m_isHangingFromLedge", 4, 0);
}

GetUprightSurvivors()
{
	new aliveCount;
	new survivorCount;
	new i = 1;
	while (i <= MaxClients && survivorCount < iTeamSize)
	{
		if (IsSurvivor(i))
		{
			survivorCount++;
			new var2;
			if (IsPlayerAlive(i) && !IsPlayerIncap(i) && !IsPlayerLedged(i))
			{
				aliveCount++;
			}
		}
		i++;
	}
	return aliveCount;
}

GetSurvivorTemporaryHealth(client)
{
	new temphp = RoundToCeil(GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0) - GetGameTime() - GetEntPropFloat(client, PropType:0, "m_healthBufferTime", 0) * GetConVarFloat(FindConVar("pain_pills_decay_rate"))) + -1;
	new var1;
	if (temphp > 0)
	{
		var1 = temphp;
	}
	else
	{
		var1 = 0;
	}
	return var1;
}

GetSurvivorPermanentHealth(client)
{
	new var1;
	if (GetEntProp(client, PropType:0, "m_currentReviveCount", 4, 0) > 0)
	{
		var1 = 0;
	}
	else
	{
		if (GetEntProp(client, PropType:0, "m_iHealth", 4, 0) > 0)
		{
			var1 = GetEntProp(client, PropType:0, "m_iHealth", 4, 0);
		}
		var1 = 0;
	}
	return var1;
}

bool:HasPills(client)
{
	new item = GetPlayerWeaponSlot(client, 4);
	if (IsValidEdict(item))
	{
		decl String:buffer[64];
		GetEdictClassname(item, buffer, 64);
		return StrEqual(buffer, "weapon_pain_pills", true);
	}
	return false;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4171",
	date = "02/28/2015",
	time = "17:28:42"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new bool:CustomName;
new bool:IsConfoglAvailable;
new Handle:cvarMainName;
new Handle:cvarServerNameFormatCase1;
new Handle:cvarServerNameFormatCase2;
new Handle:cvarServerNameFormatCase3;
new Handle:cvarMpGameMode;
new Handle:cvarZDifficulty;
new Handle:cvarHostname;
new Handle:cvarReadyUpEnabled;
new Handle:cvarReadyUpCfgName;
new Handle:kv;
new bool:isempty;
public Plugin:myinfo =
{
	name = "Server namer",
	description = "Changes server hostname according to the current game mode",
	author = "sheo",
	version = "3.2",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	decl String:gfstring[128];
	GetGameFolderName(gfstring, 128);
	if (!StrEqual(gfstring, "left4dead2", false))
	{
		SetFailState("Plugin supports Left 4 dead 2 only!");
	}
	kv = CreateKeyValues("GameMods", "", "");
	decl String:filepath[64];
	BuildPath(PathType:0, filepath, 64, "configs/server_namer.txt");
	if (!FileToKeyValues(kv, filepath))
	{
		SetFailState("configs/server_namer.txt not found!");
	}
	RegAdminCmd("sn_hostname", Cmd_Hostname, 4, "", "", 0);
	cvarMainName = CreateConVar("sn_main_name", "Hostname", "Main server name.", 0, false, 0.0, false, 0.0);
	cvarServerNameFormatCase1 = CreateConVar("sn_hostname_format1", "{hostname} | {gamemode}", "Hostname format. Case: Confogl or Vanilla without difficulty levels, such as Versus.", 0, false, 0.0, false, 0.0);
	cvarServerNameFormatCase2 = CreateConVar("sn_hostname_format2", "{hostname} | {gamemode} - {difficulty}", "Hostname format. Case: Vanilla with difficulty levels, such as Campaign.", 0, false, 0.0, false, 0.0);
	cvarServerNameFormatCase3 = CreateConVar("sn_hostname_format3", "{hostname} |", "Hostname format. Case: empty server.", 0, false, 0.0, false, 0.0);
	CreateConVar("l4d2_server_namer_version", "3.2", "Server namer version", 262400, false, 0.0, false, 0.0);
	cvarMpGameMode = FindConVar("mp_gamemode");
	cvarHostname = FindConVar("hostname");
	cvarZDifficulty = FindConVar("z_difficulty");
	HookConVarChange(cvarMpGameMode, OnCvarChanged);
	HookConVarChange(cvarZDifficulty, OnCvarChanged);
	HookConVarChange(cvarMainName, OnCvarChanged);
	HookConVarChange(cvarServerNameFormatCase1, OnCvarChanged);
	HookConVarChange(cvarServerNameFormatCase2, OnCvarChanged);
	HookConVarChange(cvarServerNameFormatCase3, OnCvarChanged);
	IsConfoglAvailable = LibraryExists("confogl");
	SetName();
	return 0;
}

public OnClientConnected(client)
{
	SetName();
	return 0;
}

public OnConfigsExecuted()
{
	IsConfoglAvailable = LibraryExists("confogl");
	SetName();
	return 0;
}

public OnClientDisconnect_Post(client)
{
	SetName();
	return 0;
}

public OnCvarChanged(Handle:cvar, String:oldVal[], String:newVal[])
{
	SetName();
	return 0;
}

public Action:Cmd_Hostname(client, args)
{
	if (args)
	{
		CustomName = true;
		decl String:arg1[128];
		GetCmdArg(1, arg1, 128);
		SetConVarString(cvarHostname, arg1, false, false);
	}
	else
	{
		CustomName = false;
		SetName();
	}
	return Action:0;
}

SetName()
{
	if (CustomName)
	{
		return 0;
	}
	isempty = ServerIsEmpty();
	if (IsConfoglAvailable)
	{
		if (!cvarReadyUpEnabled)
		{
			cvarReadyUpEnabled = FindConVar("l4d_ready_enabled");
			cvarReadyUpCfgName = FindConVar("l4d_ready_cfg_name");
		}
		new var1;
		if (cvarReadyUpEnabled && GetConVarBool(cvarReadyUpEnabled))
		{
			SetConfoglName();
		}
		else
		{
			SetVanillaName();
		}
	}
	else
	{
		SetVanillaName();
	}
	return 0;
}

SetVanillaName()
{
	decl String:GameMode[128];
	decl String:FinalHostname[128];
	if (isempty)
	{
		GetConVarString(cvarServerNameFormatCase3, FinalHostname, 128);
		ParseNameAndSendToMainConVar(FinalHostname);
	}
	else
	{
		decl String:CurGamemode[128];
		GetConVarString(cvarMpGameMode, CurGamemode, 128);
		KvRewind(kv);
		if (KvJumpToKey(kv, CurGamemode, false))
		{
			KvGetString(kv, "name", GameMode, 128, "");
			if (KvGetNum(kv, "difficulty", 0) == 1)
			{
				decl String:CurDiff[32];
				GetConVarString(cvarZDifficulty, CurDiff, 32);
				KvRewind(kv);
				KvJumpToKey(kv, "difficulties", false);
				decl String:CurDiffBuffer[32];
				KvGetString(kv, CurDiff, CurDiffBuffer, 32, "");
				GetConVarString(cvarServerNameFormatCase2, FinalHostname, 128);
				ReplaceString(FinalHostname, 128, "{gamemode}", GameMode, true);
				ReplaceString(FinalHostname, 128, "{difficulty}", CurDiffBuffer, true);
				ParseNameAndSendToMainConVar(FinalHostname);
			}
			else
			{
				GetConVarString(cvarServerNameFormatCase1, FinalHostname, 128);
				ReplaceString(FinalHostname, 128, "{gamemode}", GameMode, true);
				ParseNameAndSendToMainConVar(FinalHostname);
			}
		}
		else
		{
			GetConVarString(cvarServerNameFormatCase1, FinalHostname, 128);
			ReplaceString(FinalHostname, 128, "{gamemode}", CurGamemode, true);
			ParseNameAndSendToMainConVar(FinalHostname);
		}
	}
	return 0;
}

SetConfoglName()
{
	decl String:GameMode[128];
	decl String:FinalHostname[128];
	if (isempty)
	{
		GetConVarString(cvarServerNameFormatCase3, FinalHostname, 128);
		ParseNameAndSendToMainConVar(FinalHostname);
	}
	else
	{
		GetConVarString(cvarReadyUpCfgName, GameMode, 128);
		GetConVarString(cvarServerNameFormatCase1, FinalHostname, 128);
		ReplaceString(FinalHostname, 128, "{gamemode}", GameMode, true);
		ParseNameAndSendToMainConVar(FinalHostname);
	}
	return 0;
}

ParseNameAndSendToMainConVar(String:sBuffer[])
{
	decl String:tBuffer[128];
	GetConVarString(cvarMainName, tBuffer, 128);
	ReplaceString(sBuffer, 128, "{hostname}", tBuffer, true);
	SetConVarString(cvarHostname, sBuffer, false, false);
	return 0;
}

bool:ServerIsEmpty()
{
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientConnected(i) && !IsFakeClient(i))
		{
			return false;
		}
		i++;
	}
	return true;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.5.0-dev+3832",
	date = "04/26/2013",
	time = "16:24:14"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public SharedPlugin:__pl_updater =
{
	name = "updater",
	file = "updater.smx",
	required = 0,
};
new Handle:g_hDPArray;
new eMods:g_CurrentMod;
new String:g_sGameName[16][32] =
{
	"Unknown",
	"Age of Chivalry",
	"Counter-Strike: GO",
	"Counter Strike",
	"Day Of Defeat",
	"Fortress Forever",
	"Hidden: Source",
	"Half Life 2: Deathmatch",
	"Insurgency",
	"Left 4 Dead",
	"Left 4 Dead 2",
	"Neotokyo",
	"Stargate TLS",
	"Team Fortress 2",
	"Dark Messiah",
	"Zombie Panic: Source"
};
new Handle:g_hChatFormats;
new Handle:g_fwdOnChatMessage;
new bool:g_bAutoUpdate;
new g_CurrentChatType;
public Plugin:myinfo =
{
	name = "Simple Chat Processor (Redux)",
	description = "Process chat and allows other plugins to manipulate chat.",
	author = "Simple Plugins, Mini",
	version = "1.1.5",
	url = "http://forums.alliedmods.net"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

bool:CanTestFeatures()
{
	return LibraryExists("__CanTestFeatures__");
}

ReloadPlugin(Handle:plugin)
{
	decl String:filename[64];
	GetPluginFilename(plugin, filename, 64);
	ServerCommand("sm plugins reload %s", filename);
	return 0;
}

public __pl_updater_SetNTVOptional()
{
	MarkNativeAsOptional("Updater_AddPlugin");
	MarkNativeAsOptional("Updater_RemovePlugin");
	MarkNativeAsOptional("Updater_ForceUpdate");
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	MarkNativeAsOptional("GetUserMessageType");
	CreateNative("GetMessageFlags", Native_GetMessageFlags);
	RegPluginLibrary("scp");
	return APLRes:0;
}

public OnPluginStart()
{
	new Handle:conVar = CreateConVar("sm_scp_autoupdate", "1", "Is auto-update enabled?", 0, false, 0.0, false, 0.0);
	g_bAutoUpdate = GetConVarBool(conVar);
	HookConVarChange(conVar, OnAutoUpdateChange);
	g_CurrentMod = GetCurrentMod();
	g_hChatFormats = CreateTrie();
	LogMessage("[SCP] Recognized mod [%s].", g_sGameName[g_CurrentMod]);
	new UserMsg:umSayText2 = GetUserMessageId("SayText2");
	if (umSayText2 != UserMsg:-1)
	{
		HookUserMessage(umSayText2, OnSayText2, true, MsgPostHook:-1);
	}
	else
	{
		LogError("[SCP] This mod appears not to support SayText2.  Plugin disabled.");
		SetFailState("Error hooking usermessage saytext2");
	}
	decl String:sGameDir[32];
	decl String:sTranslationFile[256];
	decl String:sTranslationLocation[256];
	GetGameFolderName(sGameDir, 32);
	Format(sTranslationFile, 256, "scp.%s.phrases", sGameDir);
	BuildPath(PathType:0, sTranslationLocation, 256, "translations/%s.txt", sTranslationFile);
	if (FileExists(sTranslationLocation, false))
	{
		LogMessage("[SCP] Loading translation file [%s].", sTranslationFile);
		LoadTranslations(sTranslationFile);
		if (!GetChatFormats(sTranslationLocation))
		{
			LogError("[SCP] Could not parse the translation file");
			SetFailState("Could not parse the translation file");
		}
	}
	else
	{
		LogError("[SCP] Translation file is not present");
		SetFailState("Translation file is not present");
	}
	g_fwdOnChatMessage = CreateGlobalForward("OnChatMessage", ExecType:3, 3, 2, 7, 7);
	g_hDPArray = CreateArray(1, 0);
	return 0;
}

public OnAutoUpdateChange(Handle:conVar, String:oldVal[], String:newVal[])
{
	g_bAutoUpdate = StringToInt(newVal, 10);
	return 0;
}

public OnAllPluginsLoaded()
{
	new Handle:convar;
	if (LibraryExists("updater"))
	{
		Updater_AddPlugin("http://dev.xadgaming.com/simple-chat-processor/raw/master/updater.txt");
		decl String:newVersion[12];
		FormatEx(newVersion, 10, "%sA", "1.1.5");
		convar = CreateConVar("scp_version", newVersion, "Plugin Version", 147712, false, 0.0, false, 0.0);
	}
	else
	{
		convar = CreateConVar("scp_version", "1.1.5", "Plugin Version", 147712, false, 0.0, false, 0.0);
	}
	HookConVarChange(convar, Callback_VersionConVarChanged);
	return 0;
}

public Callback_VersionConVarChanged(Handle:convar, String:oldValue[], String:newValue[])
{
	ResetConVar(convar, false, false);
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (!strcmp(name, "updater", true))
	{
		Updater_AddPlugin("http://dev.xadgaming.com/simple-chat-processor/raw/master/updater.txt");
	}
	return 0;
}

public Action:Updater_OnPluginDownloading()
{
	if (!g_bAutoUpdate)
	{
		return Action:3;
	}
	return Action:0;
}

public Updater_OnPluginUpdated()
{
	ReloadPlugin(Handle:0);
	return 0;
}

public Action:OnSayText2(UserMsg:msg_id, Handle:bf, clients[], numClients, bool:reliable, bool:init)
{
	decl bool:bProtobuf;
	new var1;
	bProtobuf = CanTestFeatures() && GetFeatureStatus(FeatureType:0, "GetUserMessageType") && GetUserMessageType() == 1;
	new cpSender;
	if (bProtobuf)
	{
		cpSender = PbReadInt(bf, "ent_idx", -1);
	}
	else
	{
		cpSender = BfReadByte(bf);
	}
	if (cpSender)
	{
		new bool:bChat;
		if (bProtobuf)
		{
			bChat = PbReadBool(bf, "chat", -1);
		}
		else
		{
			new var2;
			if (BfReadByte(bf))
			{
				var2 = 1;
			}
			else
			{
				var2 = 0;
			}
			bChat = var2;
		}
		decl String:cpTranslationName[32];
		new buffer;
		if (bProtobuf)
		{
			PbReadString(bf, "msg_name", cpTranslationName, 32, -1);
		}
		else
		{
			BfReadString(bf, cpTranslationName, 32, false);
		}
		if (!GetTrieValue(g_hChatFormats, cpTranslationName, buffer))
		{
			return Action:0;
		}
		if (StrContains(cpTranslationName, "all", false) != -1)
		{
			g_CurrentChatType = g_CurrentChatType | 1;
		}
		new var3;
		if (StrContains(cpTranslationName, "team", false) == -1 && StrContains(cpTranslationName, "survivor", false) == -1 && StrContains(cpTranslationName, "infected", false) == -1 && StrContains(cpTranslationName, "Cstrike_Chat_CT", false) == -1 && StrContains(cpTranslationName, "Cstrike_Chat_T", false) == -1)
		{
			g_CurrentChatType = g_CurrentChatType | 2;
		}
		if (StrContains(cpTranslationName, "spec", false) != -1)
		{
			g_CurrentChatType = g_CurrentChatType | 4;
		}
		if (StrContains(cpTranslationName, "dead", false) != -1)
		{
			g_CurrentChatType = g_CurrentChatType | 8;
		}
		decl String:cpSender_Name[64];
		if (bProtobuf)
		{
			PbReadString(bf, "params", cpSender_Name, 64, 0);
		}
		else
		{
			if (BfGetNumBytesLeft(bf))
			{
				BfReadString(bf, cpSender_Name, 64, false);
			}
		}
		decl String:cpMessage[128];
		if (bProtobuf)
		{
			PbReadString(bf, "params", cpMessage, 128, 1);
		}
		else
		{
			if (BfGetNumBytesLeft(bf))
			{
				BfReadString(bf, cpMessage, 128, false);
			}
		}
		new Handle:cpRecipients = CreateArray(1, 0);
		new i;
		while (i < numClients)
		{
			PushArrayCell(cpRecipients, clients[i]);
			i++;
		}
		decl String:sOriginalName[64];
		strcopy(sOriginalName, 64, cpSender_Name);
		new Action:fResult;
		Call_StartForward(g_fwdOnChatMessage);
		Call_PushCellRef(cpSender);
		Call_PushCell(cpRecipients);
		Call_PushStringEx(cpSender_Name, 64, 3, 1);
		Call_PushStringEx(cpMessage, 128, 3, 1);
		new fError = Call_Finish(fResult);
		g_CurrentChatType = 0;
		if (fError)
		{
			ThrowNativeError(fError, "Forward failed");
			CloseHandle(cpRecipients);
			return Action:0;
		}
		if (fResult)
		{
			if (fResult == Action:4)
			{
				CloseHandle(cpRecipients);
				return Action:3;
			}
			if (StrEqual(sOriginalName, cpSender_Name, true))
			{
				Format(cpSender_Name, 64, "\x03%s", cpSender_Name);
			}
			new Handle:cpPack = CreateDataPack();
			new numRecipients = GetArraySize(cpRecipients);
			WritePackCell(cpPack, cpSender);
			new i;
			while (i < numRecipients)
			{
				new x = GetArrayCell(cpRecipients, i, 0, false);
				if (!IsValidClient(x, true))
				{
					numRecipients--;
					RemoveFromArray(cpRecipients, i);
				}
				i++;
			}
			WritePackCell(cpPack, numRecipients);
			new i;
			while (i < numRecipients)
			{
				new x = GetArrayCell(cpRecipients, i, 0, false);
				WritePackCell(cpPack, x);
				i++;
			}
			WritePackCell(cpPack, bChat);
			WritePackString(cpPack, cpTranslationName);
			WritePackString(cpPack, cpSender_Name);
			WritePackString(cpPack, cpMessage);
			PushArrayCell(g_hDPArray, cpPack);
			WritePackCell(cpPack, bProtobuf);
			CloseHandle(cpRecipients);
			return Action:3;
		}
		CloseHandle(cpRecipients);
		return Action:0;
	}
	return Action:0;
}

public OnGameFrame()
{
	new i;
	while (GetArraySize(g_hDPArray) > i)
	{
		new Handle:pack = GetArrayCell(g_hDPArray, i, 0, false);
		ResetPack(pack, false);
		new client = ReadPackCell(pack);
		new numClientsStart = ReadPackCell(pack);
		new numClientsFinish;
		new clients[numClientsStart];
		new x;
		while (x < numClientsStart)
		{
			new buffer = ReadPackCell(pack);
			if (IsValidClient(buffer, true))
			{
				numClientsFinish++;
				clients[numClientsFinish] = buffer;
			}
			x++;
		}
		new bool:bChat = ReadPackCell(pack);
		decl String:sChatType[32];
		decl String:sSenderName[64];
		decl String:sMessage[128];
		ReadPackString(pack, sChatType, 32);
		ReadPackString(pack, sSenderName, 64);
		ReadPackString(pack, sMessage, 128);
		decl String:sTranslation[256];
		Format(sTranslation, 256, "%t", sChatType, sSenderName, sMessage);
		new Handle:bf = StartMessage("SayText2", clients, numClientsFinish, 132);
		if (ReadPackCell(pack))
		{
			PbSetInt(bf, "ent_idx", client, -1);
			PbSetBool(bf, "chat", bChat, -1);
			PbSetString(bf, "msg_name", sTranslation, -1);
			PbAddString(bf, "params", "");
			PbAddString(bf, "params", "");
			PbAddString(bf, "params", "");
			PbAddString(bf, "params", "");
		}
		else
		{
			BfWriteByte(bf, client);
			BfWriteByte(bf, bChat);
			BfWriteString(bf, sTranslation);
		}
		EndMessage();
		CloseHandle(pack);
		RemoveFromArray(g_hDPArray, i);
		i++;
	}
	return 0;
}

public Native_GetMessageFlags(Handle:plugin, numParams)
{
	return g_CurrentChatType;
}

bool:IsValidClient(client, bool:nobots)
{
	new var2;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client) || (nobots && IsFakeClient(client)))
	{
		return false;
	}
	return IsClientInGame(client);
}

bool:GetChatFormats(String:file[])
{
	new Handle:hParser = SMC_CreateParser();
	new String:error[128];
	new line;
	new col;
	SMC_SetReaders(hParser, Config_NewSection, Config_KeyValue, Config_EndSection);
	SMC_SetParseEnd(hParser, Config_End);
	new SMCError:result = SMC_ParseFile(hParser, file, line, col);
	CloseHandle(hParser);
	if (result)
	{
		SMC_GetErrorString(result, error, 128);
		LogError("%s on line %d, col %d of %s", error, line, col, file);
	}
	return result == 0;
}

public SMCResult:Config_NewSection(Handle:parser, String:section[], bool:quotes)
{
	if (StrEqual(section, "Phrases", true))
	{
		return SMCResult:0;
	}
	SetTrieValue(g_hChatFormats, section, any:1, true);
	return SMCResult:0;
}

public SMCResult:Config_KeyValue(Handle:parser, String:key[], String:value[], bool:key_quotes, bool:value_quotes)
{
	return SMCResult:0;
}

public SMCResult:Config_EndSection(Handle:parser)
{
	return SMCResult:0;
}

public Config_End(Handle:parser, bool:halted, bool:failed)
{
	return 0;
}

eMods:GetCurrentMod()
{
	decl String:sGameType[64];
	GetGameFolderName(sGameType, 64);
	if (StrEqual(sGameType, "aoc", false))
	{
		return eMods:1;
	}
	if (StrEqual(sGameType, "csgo", false))
	{
		return eMods:2;
	}
	if (StrEqual(sGameType, "cstrike", false))
	{
		return eMods:3;
	}
	if (StrEqual(sGameType, "dod", false))
	{
		return eMods:4;
	}
	if (StrEqual(sGameType, "ff", false))
	{
		return eMods:5;
	}
	if (StrEqual(sGameType, "hidden", false))
	{
		return eMods:6;
	}
	if (StrEqual(sGameType, "hl2mp", false))
	{
		return eMods:5;
	}
	new var1;
	if (StrEqual(sGameType, "insurgency", false) || StrEqual(sGameType, "ins", false))
	{
		return eMods:8;
	}
	new var2;
	if (StrEqual(sGameType, "left4dead", false) || StrEqual(sGameType, "l4d", false))
	{
		return eMods:9;
	}
	new var3;
	if (StrEqual(sGameType, "left4dead2", false) || StrEqual(sGameType, "l4d2", false))
	{
		return eMods:10;
	}
	if (StrEqual(sGameType, "nts", false))
	{
		return eMods:11;
	}
	if (StrEqual(sGameType, "sgtls", false))
	{
		return eMods:12;
	}
	if (StrEqual(sGameType, "tf", false))
	{
		return eMods:13;
	}
	if (StrEqual(sGameType, "zps", false))
	{
		return eMods:15;
	}
	if (StrEqual(sGameType, "mmdarkmessiah", false))
	{
		return eMods:14;
	}
	LogMessage("Unknown Game Folder: %s", sGameType);
	return eMods:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/20/2016",
	time = "00:53:40"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 0,
};
new bool:g_bReadyUpAvailable;
new String:g_csSIClassName[9][] =
{
	"",
	"Smoker",
	"Boomer",
	"Hunter",
	"Spitter",
	"Jockey",
	"Charger",
	"Witch",
	"Tank"
};
public Plugin:myinfo =
{
	name = "Special Infected Class Announce",
	description = "Report what SI classes are up when the round starts.",
	author = "Tabun",
	version = "0.9.2",
	url = "none"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public OnAllPluginsLoaded()
{
	g_bReadyUpAvailable = LibraryExists("readyup");
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		g_bReadyUpAvailable = false;
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		g_bReadyUpAvailable = true;
	}
	return 0;
}

public OnRoundIsLive()
{
	AnnounceSIClasses();
	return 0;
}

public Action:L4D_OnFirstSurvivorLeftSafeArea(client)
{
	if (!g_bReadyUpAvailable)
	{
		AnnounceSIClasses();
	}
	return Action:0;
}

AnnounceSIClasses()
{
	new iSpawns;
	new iSpawnClass[9];
	new i = 1;
	while (i <= MaxClients && iSpawns < 8)
	{
		new var2;
		if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && (GetClientTeam(i) == 3 && IsPlayerAlive(i)))
		{
		}
	}
	switch (iSpawns)
	{
		case 1:
		{
			PrintToSurvivors("{default}Special Infected: {red}%s{default}.", g_csSIClassName[iSpawnClass[0]]);
		}
		case 2:
		{
			PrintToSurvivors("{default}Special Infected: {red}%s{default}, {red}%s{default}.", g_csSIClassName[iSpawnClass[0]], g_csSIClassName[iSpawnClass[1]]);
		}
		case 3:
		{
			PrintToSurvivors("{default}Special Infected: {red}%s{default}, {red}%s{default}, {red}%s{default}.", g_csSIClassName[iSpawnClass[0]], g_csSIClassName[iSpawnClass[1]], g_csSIClassName[iSpawnClass[2]]);
		}
		case 4:
		{
			PrintToSurvivors("{default}Special Infected: {red}%s{default}, {red}%s{default}, {red}%s{default}, {red}%s{default}.", g_csSIClassName[iSpawnClass[0]], g_csSIClassName[iSpawnClass[1]], g_csSIClassName[iSpawnClass[2]], g_csSIClassName[iSpawnClass[3]]);
		}
		default:
		{
		}
	}
	return 0;
}

PrintToSurvivors(String:Message[])
{
	decl String:sPrint[256];
	VFormat(sPrint, 256, Message, 2);
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if ((i > 0 && i <= MaxClients) && IsClientInGame(i) && GetClientTeam(i) == 2)
		{
		}
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2",
	date = "10/15/2015",
	time = "10:59:34"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new Handle:infected_fire_immunity;
new Handle:tank_fire_immunity;
new bool:inWait[66];
public Plugin:myinfo =
{
	name = "SI Fire Immunity",
	description = "Special Infected fire damage management.",
	author = "Jacob, darkid",
	version = "2.3",
	url = "github.com/jacob404/myplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

SetEntityHealth(entity, amount)
{
	static bool:gotconfig;
	static String:prop[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_iHealth", prop, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(prop, 32, "m_iHealth");
		}
		gotconfig = true;
	}
	decl String:cls[64];
	new PropFieldType:type;
	new offset;
	if (!GetEntityNetClass(entity, cls, 64))
	{
		ThrowError("SetEntityHealth not supported by this mod: Could not get serverclass name");
		return 0;
	}
	offset = FindSendPropInfo(cls, prop, type, 0, 0);
	if (0 >= offset)
	{
		ThrowError("SetEntityHealth not supported by this mod");
		return 0;
	}
	if (type == PropFieldType:2)
	{
		SetEntDataFloat(entity, offset, float(amount), false);
	}
	else
	{
		SetEntProp(entity, PropType:0, prop, amount, 4, 0);
	}
	return 0;
}

public OnPluginStart()
{
	infected_fire_immunity = CreateConVar("infected_fire_immunity", "3", "What type of fire immunity should infected have? 0 = None, 3 = Extinguish burns, 2 = Prevent burns, 1 = Complete immunity", 262144, true, 0.0, true, 3.0);
	tank_fire_immunity = CreateConVar("tank_fire_immunity", "2", "What type of fire immunity should the tank have? 0 = None, 3 = Extinguish burns, 2 = Prevent burns, 1 = Complete immunity", 262144, true, 0.0, true, 3.0);
	HookEvent("player_hurt", SIOnFire, EventHookMode:1);
	return 0;
}

public SIOnFire(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (!IsValidClient(client, true) || !GetClientTeam(client) == 3)
	{
		return 0;
	}
	decl String:weapon[64];
	GetEventString(event, "weapon", weapon, 64);
	new attacker = GetEventInt(event, "attacker");
	new var2;
	if (strcmp(weapon, "inferno", true) && attacker && strcmp(weapon, "entityflame", true))
	{
		if (GetEntProp(client, PropType:0, "m_zombieClass", 4, 0) == 8)
		{
			if (GetConVarInt(tank_fire_immunity) == 3)
			{
				CreateTimer(1.0, Extinguish, client, 0);
			}
			if (GetConVarInt(tank_fire_immunity) <= 2)
			{
				ExtinguishEntity(client);
			}
			if (GetConVarInt(tank_fire_immunity) == 1)
			{
				new CurHealth = GetClientHealth(client);
				new DmgDone = GetEventInt(event, "dmg_health");
				SetEntityHealth(client, DmgDone + CurHealth);
			}
		}
		if (GetConVarInt(infected_fire_immunity) == 3)
		{
			CreateTimer(1.0, Extinguish, client, 0);
		}
		if (GetConVarInt(infected_fire_immunity) <= 2)
		{
			ExtinguishEntity(client);
		}
		if (GetConVarInt(infected_fire_immunity) == 1)
		{
			new CurHealth = GetClientHealth(client);
			new DmgDone = GetEventInt(event, "dmg_health");
			SetEntityHealth(client, DmgDone + CurHealth);
		}
	}
	return 0;
}

public Action:Extinguish(Handle:timer, any:client)
{
	new var1;
	if (IsValidClient(client, true) && !inWait[client])
	{
		ExtinguishEntity(client);
		inWait[client] = 1;
		CreateTimer(1.2, ExtinguishWait, client, 0);
	}
	return Action:0;
}

public Action:ExtinguishWait(Handle:timer, any:client)
{
	if (IsValidClient(client, true))
	{
		inWait[client] = 0;
	}
	return Action:0;
}

bool:IsValidClient(client, bool:nobots)
{
	new var2;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client) || (nobots && IsFakeClient(client)))
	{
		return false;
	}
	return IsClientInGame(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/26/2017",
	time = "17:43:48"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_builtinvotes =
{
	name = "BuiltinVotes",
	file = "builtinvotes.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new Handle:g_hVote;
new String:g_sSlots[32];
new Handle:hMaxSlots;
new MaxSlots;
public Plugin:myinfo =
{
	name = "Slots?! Voter",
	description = "Slots Voter",
	author = "Sir",
	version = "",
	url = ""
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

bool:IsNewBuiltinVoteAllowed()
{
	new var1;
	if (IsBuiltinVoteInProgress() || CheckBuiltinVoteDelay())
	{
		return false;
	}
	return true;
}

public __ext_builtinvotes_SetNTVOptional()
{
	MarkNativeAsOptional("CreateBuiltinVote");
	MarkNativeAsOptional("DisplayBuiltinVote");
	MarkNativeAsOptional("AddBuiltinVoteItem");
	MarkNativeAsOptional("InsertBuiltinVoteItem");
	MarkNativeAsOptional("RemoveBuiltinVoteItem");
	MarkNativeAsOptional("RemoveAllBuiltinVoteItems");
	MarkNativeAsOptional("GetBuiltinVoteItem");
	MarkNativeAsOptional("GetBuiltinVoteItemCount");
	MarkNativeAsOptional("SetBuiltinVoteArgument");
	MarkNativeAsOptional("GetBuiltinVoteArgument");
	MarkNativeAsOptional("IsBuiltinVoteInProgress");
	MarkNativeAsOptional("GetBuiltinVoteMaxItems");
	MarkNativeAsOptional("SetBuiltinVoteOptionFlags");
	MarkNativeAsOptional("GetBuiltinVoteOptionFlags");
	MarkNativeAsOptional("SetBuiltinVoteResultCallback");
	MarkNativeAsOptional("CheckBuiltinVoteDelay");
	MarkNativeAsOptional("IsClientInBuiltinVotePool");
	MarkNativeAsOptional("RedrawClientBuiltinVote");
	MarkNativeAsOptional("GetBuiltinVoteType");
	MarkNativeAsOptional("SetBuiltinVoteTeam");
	MarkNativeAsOptional("GetBuiltinVoteTeam");
	MarkNativeAsOptional("SetBuiltinVoteInitiator");
	MarkNativeAsOptional("GetBuiltinVoteInitiator");
	MarkNativeAsOptional("DisplayBuiltinVotePass");
	MarkNativeAsOptional("DisplayBuiltinVotePass2");
	MarkNativeAsOptional("DisplayBuiltinVoteFail");
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	RegConsoleCmd("sm_slots", SlotsRequest, "", 0);
	hMaxSlots = CreateConVar("slots_max_slots", "30", "Maximum amount of slots you wish players to be able to vote for? (DON'T GO HIGHER THAN 30)", 0, false, 0.0, false, 0.0);
	MaxSlots = GetConVarInt(hMaxSlots);
	HookConVarChange(hMaxSlots, CVarChanged);
	return 0;
}

public Action:SlotsRequest(client, args)
{
	if (!client)
	{
		return Action:3;
	}
	if (args == 1)
	{
		new String:sSlots[64];
		GetCmdArg(1, sSlots, 64);
		new Int = StringToInt(sSlots, 10);
		if (Int > MaxSlots)
		{
			CPrintToChat(client, "{blue}[{default}Slots{blue}] {default}You can't limit slots above {olive}%i {default}on this Server", MaxSlots);
		}
		else
		{
			if (GetUserAdmin(client) != -1)
			{
				CPrintToChatAll("{blue}[{default}Slots{blue}] {olive}Admin {default}has limited Slots to {blue}%i", Int);
				SetConVarInt(FindConVar("sv_maxplayers"), Int, false, false);
			}
			if (GetConVarInt(FindConVar("z_max_player_zombies")) + GetConVarInt(FindConVar("survivor_limit")) > Int)
			{
				CPrintToChat(client, "{blue}[{default}Slots{blue}] {default}You can't limit Slots lower than required Players.");
			}
			if (StartSlotVote(client, sSlots))
			{
				strcopy(g_sSlots, 32, sSlots);
				FakeClientCommand(client, "Vote Yes");
			}
		}
	}
	else
	{
		CPrintToChat(client, "{blue}[{default}Slots{blue}] {default}Usage: {olive}!slots {default}<{olive}number{default}> {blue}| {default}Example: {olive}!slots 8");
	}
	return Action:3;
}

bool:StartSlotVote(client, String:Slots[])
{
	if (GetClientTeam(client) == 1)
	{
		PrintToChat(client, "Voting isn't allowed for spectators.");
		return false;
	}
	if (IsNewBuiltinVoteAllowed())
	{
		new iNumPlayers;
		decl iPlayers[MaxClients];
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (!IsClientInGame(i) || IsFakeClient(i) || GetClientTeam(i) == 1)
			{
			}
			else
			{
				iNumPlayers++;
				iPlayers[iNumPlayers] = i;
			}
			i++;
		}
		new String:sBuffer[64];
		g_hVote = CreateBuiltinVote(BuiltinVoteActionHandler:11, BuiltinVoteType:3, BuiltinVoteAction:26);
		Format(sBuffer, 64, "Limit Slots to '%s'?", Slots);
		SetBuiltinVoteArgument(g_hVote, sBuffer);
		SetBuiltinVoteInitiator(g_hVote, client);
		SetBuiltinVoteResultCallback(g_hVote, BuiltinVoteHandler:7);
		DisplayBuiltinVote(g_hVote, iPlayers, iNumPlayers, 20);
		return true;
	}
	PrintToChat(client, "Vote cannot be started now.");
	return false;
}

public SlotVoteResultHandler(Handle:vote, num_votes, num_clients, client_info[][2], num_items, item_info[][2])
{
	new i;
	while (i < num_items)
	{
		if (item_info[i][0] == 1)
		{
			if (num_votes / 2 < item_info[i][1])
			{
				new Slots = StringToInt(g_sSlots, 10);
				DisplayBuiltinVotePass(vote, "Limiting Slots...");
				SetConVarInt(FindConVar("sv_maxplayers"), Slots, false, false);
				return 0;
			}
		}
		i++;
	}
	DisplayBuiltinVoteFail(vote, BuiltinVoteFailReason:3);
	return 0;
}

public VoteActionHandler(Handle:vote, BuiltinVoteAction:action, param1, param2)
{
	switch (action)
	{
		case 2:
		{
			g_hVote = MissingTAG:0;
			CloseHandle(vote);
		}
		case 8:
		{
			DisplayBuiltinVoteFail(vote, param1);
		}
		default:
		{
		}
	}
	return 0;
}

public CVarChanged(Handle:cvar, String:oldValue[], String:newValue[])
{
	MaxSlots = GetConVarInt(hMaxSlots);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "01/25/2014",
	time = "23:42:10"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Smart AI Rock",
	description = "Prevents AI tanks from throwing underhand rocks since he can't aim them correctly",
	author = "CanadaRox",
	version = "1",
	url = "https://github.com/CanadaRox/sourcemod-plugins/tree/master/smart_ai_rock"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

public Action:L4D2_OnSelectTankAttack(client, &sequence)
{
	new var1;
	if (IsFakeClient(client) && sequence == 50)
	{
		new var2;
		if (GetRandomInt(0, 1))
		{
			var2 = 49;
		}
		else
		{
			var2 = 51;
		}
		sequence = var2;
		return Action:3;
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2-dev+4559",
	date = "10/04/2014",
	time = "13:30:28"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new g_SawSurvivorsOutsideBattlefieldOffset;
new bool:g_bHooked;
public Plugin:myinfo =
{
	name = "Finale Can't Spawn Glitch Fix",
	description = "Fixing Waiting For Survivors To Start The Finale or w/e",
	author = "ProdigySim",
	version = "1.0",
	url = "https://github.com/ConfoglTeam/ProMod"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public OnPluginStart()
{
	RegAdminCmd("sm_fix_wff", AdminFixWaitingForFinale, 2, "Manually fix the 'Waiting for finale to start' issue for all infected.", "", 0);
	g_SawSurvivorsOutsideBattlefieldOffset = FindSendPropOffs("CTerrorPlayer", "m_ghostSpawnState") + 38;
	return 0;
}

public OnMapStart()
{
	decl String:mapname[200];
	if (0 < GetCurrentMap(mapname, 200))
	{
		if (StrEqual("uf4_airfield", mapname, true))
		{
			HookEvent("round_start", OnRoundStart, EventHookMode:1);
			g_bHooked = true;
		}
	}
	return 0;
}

public OnMapEnd()
{
	if (g_bHooked)
	{
		UnhookEvent("round_start", OnRoundStart, EventHookMode:1);
		g_bHooked = false;
	}
	return 0;
}

public OnRoundStart(Handle:event, String:name[], bool:dontBroadcast)
{
	FixAllInfected();
	return 0;
}

FixAllInfected()
{
	new i = 1;
	while (i < MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && GetClientTeam(i) == 3)
		{
			SetSeenSurvivorsState(i, true);
			SetSpawnFlags(i, GetSpawnFlags(i) & -5);
		}
		i++;
	}
	return 0;
}

public Action:AdminFixWaitingForFinale(client, args)
{
	FixAllInfected();
	PrintToChatAll("Fixing Waiting For Finale to Start issue for all infected");
	return Action:0;
}

SetSpawnFlags(entity, flags)
{
	SetEntProp(entity, PropType:0, "m_ghostSpawnState", flags, 4, 0);
	return 0;
}

GetSpawnFlags(entity)
{
	return GetEntProp(entity, PropType:0, "m_ghostSpawnState", 4, 0);
}

SetSeenSurvivorsState(entity, bool:seen)
{
	new var1;
	if (seen)
	{
		var1 = MissingTAG:1;
	}
	else
	{
		var1 = MissingTAG:0;
	}
	SetEntData(entity, g_SawSurvivorsOutsideBattlefieldOffset, var1, 1, false);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4177",
	date = "08/16/2016",
	time = "13:40:55"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:WeaponNames[56][] =
{
	"weapon_none",
	"weapon_pistol",
	"weapon_smg",
	"weapon_pumpshotgun",
	"weapon_autoshotgun",
	"weapon_rifle",
	"weapon_hunting_rifle",
	"weapon_smg_silenced",
	"weapon_shotgun_chrome",
	"weapon_rifle_desert",
	"weapon_sniper_military",
	"weapon_shotgun_spas",
	"weapon_first_aid_kit",
	"weapon_molotov",
	"weapon_pipe_bomb",
	"weapon_pain_pills",
	"weapon_gascan",
	"weapon_propanetank",
	"weapon_oxygentank",
	"weapon_melee",
	"weapon_chainsaw",
	"weapon_grenade_launcher",
	"weapon_ammo_pack",
	"weapon_adrenaline",
	"weapon_defibrillator",
	"weapon_vomitjar",
	"weapon_rifle_ak47",
	"weapon_gnome",
	"weapon_cola_bottles",
	"weapon_fireworkcrate",
	"weapon_upgradepack_incendiary",
	"weapon_upgradepack_explosive",
	"weapon_pistol_magnum",
	"weapon_smg_mp5",
	"weapon_rifle_sg552",
	"weapon_sniper_awp",
	"weapon_sniper_scout",
	"weapon_rifle_m60",
	"weapon_tank_claw",
	"weapon_hunter_claw",
	"weapon_charger_claw",
	"weapon_boomer_claw",
	"weapon_smoker_claw",
	"weapon_spitter_claw",
	"weapon_jockey_claw",
	"weapon_machinegun",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:LongWeaponNames[56][] =
{
	"None",
	"Pistol",
	"Uzi",
	"Pump",
	"Autoshotgun",
	"M-16",
	"Hunting Rifle",
	"Mac",
	"Chrome",
	"Desert Rifle",
	"Military Sniper",
	"SPAS Shotgun",
	"First Aid Kit",
	"Molotov",
	"Pipe Bomb",
	"Pills",
	"Gascan",
	"Propane Tank",
	"Oxygen Tank",
	"Melee",
	"Chainsaw",
	"Grenade Launcher",
	"Ammo Pack",
	"Adrenaline",
	"Defibrillator",
	"Bile Bomb",
	"AK-47",
	"Gnome",
	"Cola Bottles",
	"Fireworks",
	"Incendiary Ammo Pack",
	"Explosive Ammo Pack",
	"Deagle",
	"MP5",
	"SG552",
	"AWP",
	"Scout",
	"M60",
	"Tank Claw",
	"Hunter Claw",
	"Charger Claw",
	"Boomer Claw",
	"Smoker Claw",
	"Spitter Claw",
	"Jockey Claw",
	"Turret",
	"vomit",
	"splat",
	"pounce",
	"lounge",
	"pull",
	"choke",
	"rock",
	"physics",
	"ammo",
	"upgrade_item"
};
new String:MeleeWeaponNames[15][] =
{
	"",
	"knife",
	"baseball_bat",
	"chainsaw",
	"cricket_bat",
	"crowbar",
	"didgeridoo",
	"electric_guitar",
	"fireaxe",
	"frying_pan",
	"golfclub",
	"katana",
	"machete",
	"riotshield",
	"tonfa"
};
new String:LongMeleeWeaponNames[15][] =
{
	"None",
	"Knife",
	"Baseball Bat",
	"Chainsaw",
	"Cricket Bat",
	"Crowbar",
	"didgeridoo",
	"Guitar",
	"Axe",
	"Frying Pan",
	"Golf Club",
	"Katana",
	"Machete",
	"Riot Shield",
	"Tonfa"
};
new String:MeleeWeaponModels[15][] =
{
	"",
	"/w_models/weapons/w_knife_t.mdl",
	"/weapons/melee/w_bat.mdl",
	"/weapons/melee/w_chainsaw.mdl",
	"/weapons/melee/w_cricket_bat.mdl",
	"/weapons/melee/w_crowbar.mdl",
	"/weapons/melee/w_didgeridoo.mdl",
	"/weapons/melee/w_electric_guitar.mdl",
	"/weapons/melee/w_fireaxe.mdl",
	"/weapons/melee/w_frying_pan.mdl",
	"/weapons/melee/w_golfclub.mdl",
	"/weapons/melee/w_katana.mdl",
	"/weapons/melee/w_machete.mdl",
	"/weapons/melee/w_riotshield.mdl",
	"/weapons/melee/w_tonfa.mdl"
};
new String:WeaponModels[56][];
new WeaponSlots[56] =
{
	0, 0, 0, 0, 0, 1885431159, 1935634031, 1853317488, 0, 1702322029, 1852797025, 17481, 1634759519, 28279, 1684104562, 7370105, 1684104562, 779122041, 7892339, 4680, 4688, 1, 1399088193, 1852404340, 1383027815, 2036621669, 1953460038, 29285, 1850307401, 1684104530, 121, 1816359753, 1953391977, 1953718595, 29285, 1145664329, 1953718595, 29285, 1937072496, 101, 1937072496, 1836265061, 120, 4776, 4784, 1, 1850307401, 1937072464, 101, 24, 32, 36, 48, 52, 56, 1717920891
};
new Handle:hWeaponNamesTrie;
new Handle:hMeleeWeaponNamesTrie;
new Handle:hMeleeWeaponModelsTrie;
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 1,
};
public SharedPlugin:__pl_pause =
{
	name = "pause",
	file = "pause.smx",
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public SharedPlugin:__pl_l4d2_scoremod =
{
	name = "l4d2_hybrid_scoremod",
	file = "l4d2_hybrid_scoremod.smx",
	required = 0,
};
new String:L4D2SI_Names[9][32] =
{
	"None",
	"Smoker",
	"Boomer",
	"Hunter",
	"Spitter",
	"Jockey",
	"Charger",
	"Witch",
	"Tank"
};
new Handle:survivor_limit;
new Handle:z_max_player_zombies;
new bool:bSpecHudActive[66];
new bool:bSpecHudHintShown[66];
new bool:bTankHudActive[66];
new bool:bTankHudHintShown[66];
new bool:hybridScoringAvailable;
public Plugin:myinfo =
{
	name = "Hyper-V HUD Manager [Public Version]",
	description = "Provides different HUDs for spectators",
	author = "Visor",
	version = "3.0",
	url = "https://github.com/Attano/smplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

RoundFloat(Float:value)
{
	return RoundToNearest(value);
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

Float:operator/(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) / oper2;
}

Float:operator-(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) - oper2;
}

bool:operator>(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) > 0;
}

bool:operator<(Float:,Float:)(Float:oper1, Float:oper2)
{
	return FloatCompare(oper1, oper2) < 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetCDirector()
{
	static Address:TheDirector;
	if (!TheDirector)
	{
		TheDirector = GameConfGetAddress(L4D2Direct_GetGameConf(), "CDirector");
	}
	return TheDirector;
}

Address:L4D2Direct_GetCDirectorVersusMode()
{
	static Address:pVersusModeDirector;
	if (!pVersusModeDirector)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode");
		if (offs == -1)
		{
			return Address:0;
		}
		pVersusModeDirector = L4D2Direct_GetCDirector() + offs;
		pVersusModeDirector = LoadFromAddress(pVersusModeDirector, NumberType:2);
	}
	return pVersusModeDirector;
}

Address:L4D2Direct_GetTerrorNavMesh()
{
	static Address:TheNavMesh;
	if (!TheNavMesh)
	{
		TheNavMesh = GameConfGetAddress(L4D2Direct_GetGameConf(), "TerrorNavMesh");
	}
	return TheNavMesh;
}

Address:L4D2Direct_GetTankPassedCountAddr()
{
	static Address:pTankPassedCount;
	if (!pTankPassedCount)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirector::m_iTankPassedCount");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankPassedCount = L4D2Direct_GetCDirector() + offs;
	}
	return pTankPassedCount;
}

Address:L4D2Direct_GetVSTankFlowAddr()
{
	static Address:pTankFlowPercent;
	if (!pTankFlowPercent)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_fTankSpawnFlowPercent");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankFlowPercent = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pTankFlowPercent;
}

Address:L4D2Direct_GeVSTankToSpawnAddr()
{
	static Address:pTankSpawnThisRound;
	if (!pTankSpawnThisRound)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_bTankThisRound");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankSpawnThisRound = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pTankSpawnThisRound;
}

Address:L4D2Direct_GetVSWitchFlowAddr()
{
	static Address:pWitchFlowPercent;
	if (!pWitchFlowPercent)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_fWitchSpawnFlowPercent");
		if (offs == -1)
		{
			return Address:0;
		}
		pWitchFlowPercent = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pWitchFlowPercent;
}

Address:L4D2Direct_GetVSWitchToSpawnAddr()
{
	static Address:pWitchSpawnThisRound;
	if (!pWitchSpawnThisRound)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_bWitchThisRound");
		if (offs == -1)
		{
			return Address:0;
		}
		pWitchSpawnThisRound = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pWitchSpawnThisRound;
}

Address:L4D2Direct_GetMapMaxFlowDistanceAddr()
{
	static Address:pMapMaxFlowDistance;
	if (!pMapMaxFlowDistance)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "TerrorNavMesh::m_fMapMaxFlowDistance");
		if (offs == -1)
		{
			return Address:0;
		}
		pMapMaxFlowDistance = L4D2Direct_GetTerrorNavMesh() + offs;
	}
	return pMapMaxFlowDistance;
}

Float:CTimer_GetRemainingTime(CountdownTimer:timer)
{
	return CTimer_GetTimestamp(timer) - GetGameTime();
}

Float:CTimer_GetTimestamp(CountdownTimer:timer)
{
	return LoadFromAddress(timer + 8, NumberType:2);
}

L4D2Direct_GetTankPassedCount()
{
	return LoadFromAddress(L4D2Direct_GetTankPassedCountAddr(), NumberType:2);
}

Float:L4D2Direct_GetVSTankFlowPercent(roundNumber)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return -1.0;
	}
	return LoadFromAddress(roundNumber * 4 + L4D2Direct_GetVSTankFlowAddr(), NumberType:2);
}

bool:L4D2Direct_GetVSTankToSpawnThisRound(roundNumber)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return false;
	}
	return LoadFromAddress(L4D2Direct_GeVSTankToSpawnAddr() + roundNumber, NumberType:0);
}

Float:L4D2Direct_GetVSWitchFlowPercent(roundNumber)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return -1.0;
	}
	return LoadFromAddress(roundNumber * 4 + L4D2Direct_GetVSWitchFlowAddr(), NumberType:2);
}

bool:L4D2Direct_GetVSWitchToSpawnThisRound(roundNumber)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return false;
	}
	return LoadFromAddress(L4D2Direct_GetVSWitchToSpawnAddr() + roundNumber, NumberType:0);
}

Float:L4D2Direct_GetMapMaxFlowDistance()
{
	return LoadFromAddress(L4D2Direct_GetMapMaxFlowDistanceAddr(), NumberType:2);
}

CountdownTimer:L4D2Direct_GetSpawnTimer(client)
{
	new var1;
	if (client < 1 || client > MaxClients)
	{
		return CountdownTimer:0;
	}
	new Address:pEntity = GetEntityAddress(client);
	if (pEntity)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CTerrorPlayer::SpawnTimer");
		if (offs == -1)
		{
			return CountdownTimer:0;
		}
		return offs + pEntity;
	}
	return CountdownTimer:0;
}

Float:L4D2Direct_GetFlowDistance(client)
{
	static Handle:GetFlowDistanceSDKCall;
	if (!GetFlowDistanceSDKCall)
	{
		StartPrepSDKCall(SDKCallType:2);
		if (!PrepSDKCall_SetFromConf(L4D2Direct_GetGameConf(), SDKFuncConfSource:1, "CTerrorPlayer::GetFlowDistance"))
		{
			return 0.0;
		}
		PrepSDKCall_AddParameter(SDKType:4, SDKPassMethod:1, 0, 0);
		PrepSDKCall_SetReturnInfo(SDKType:5, SDKPassMethod:1, 0, 0);
		GetFlowDistanceSDKCall = EndPrepSDKCall();
		if (!GetFlowDistanceSDKCall)
		{
			return 0.0;
		}
	}
	return SDKCall(GetFlowDistanceSDKCall, client, 0);
}

InitWeaponNamesTrie()
{
	WeaponSlots[0] = CreateTrie();
	new i;
	while (i < 56)
	{
		SetTrieValue(WeaponSlots[0], WeaponNames[i], i, true);
		i++;
	}
	hMeleeWeaponNamesTrie = CreateTrie();
	hMeleeWeaponModelsTrie = CreateTrie();
	new i;
	while (i < 15)
	{
		SetTrieValue(hMeleeWeaponNamesTrie, MeleeWeaponNames[i], i, true);
		SetTrieString(hMeleeWeaponModelsTrie, MeleeWeaponModels[i], MeleeWeaponNames[i], true);
		i++;
	}
	return 0;
}

bool:IsValidWeaponId(WeaponId:wepid, tagType)
{
	if (tagType == -1073741725)
	{
		new var1;
		return wepid >= WeaponId:0 && wepid < WeaponId:15;
	}
	new var2;
	return wepid >= WeaponId:0 && wepid < WeaponId:56;
}

WeaponId:WeaponNameToId(String:weaponName[])
{
	new WeaponID:id;
	if (!WeaponSlots[0])
	{
		InitWeaponNamesTrie();
	}
	if (GetTrieValue(WeaponSlots[0], weaponName, id))
	{
		return id;
	}
	return WeaponId:0;
}

GetLongWeaponName(WeaponId:wepid, String:nameBuffer[], length, tagType)
{
	if (tagType == -1073741725)
	{
		new var1;
		if (IsValidWeaponId(wepid, -1073741725))
		{
			var1[0] = LongMeleeWeaponNames[wepid];
		}
		else
		{
			var1[0] = 4636;
		}
		strcopy(nameBuffer, length, var1);
	}
	else
	{
		new var2;
		if (IsValidWeaponId(wepid, -1073741726))
		{
			var2[0] = LongWeaponNames[wepid];
		}
		else
		{
			var2[0] = 4640;
		}
		strcopy(nameBuffer, length, var2);
	}
	return 0;
}

WeaponId:IdentifyWeapon(entity)
{
	new var1;
	if (!entity || !IsValidEntity(entity) || !IsValidEdict(entity))
	{
		return WeaponId:0;
	}
	decl String:class[64];
	if (!GetEdictClassname(entity, class, 64))
	{
		return WeaponId:0;
	}
	if (StrEqual(class, "weapon_spawn", true))
	{
		return GetEntProp(entity, PropType:0, "m_weaponID", 4, 0);
	}
	new len = strlen(class);
	new var2;
	if (len + -6 > 0 && StrEqual(class[len + -6], "_spawn", true))
	{
		class[len + -6] = MissingTAG:0;
		return WeaponNameToId(class);
	}
	return WeaponNameToId(class);
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public __pl_pause_SetNTVOptional()
{
	MarkNativeAsOptional("IsInPause");
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	BfWriteByte(hBuffer, author);
	BfWriteByte(hBuffer, 1);
	BfWriteString(hBuffer, szMessage);
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public __pl_l4d2_hybrid_scoremod_SetNTVOptional()
{
	MarkNativeAsOptional("SMPlus_GetHealthBonus");
	MarkNativeAsOptional("SMPlus_GetDamageBonus");
	MarkNativeAsOptional("SMPlus_GetPillsBonus");
	MarkNativeAsOptional("SMPlus_GetMaxHealthBonus");
	MarkNativeAsOptional("SMPlus_GetMaxDamageBonus");
	MarkNativeAsOptional("SMPlus_GetMaxPillsBonus");
	return 0;
}

public APLRes:AskPluginLoad2(Handle:plugin, bool:late, String:error[], errMax)
{
	MarkNativeAsOptional("SMPlus_GetHealthBonus");
	MarkNativeAsOptional("SMPlus_GetDamageBonus");
	MarkNativeAsOptional("SMPlus_GetPillsBonus");
	MarkNativeAsOptional("SMPlus_GetMaxHealthBonus");
	MarkNativeAsOptional("SMPlus_GetMaxDamageBonus");
	MarkNativeAsOptional("SMPlus_GetMaxPillsBonus");
	return APLRes:0;
}

public OnPluginStart()
{
	survivor_limit = FindConVar("survivor_limit");
	z_max_player_zombies = FindConVar("z_max_player_zombies");
	RegConsoleCmd("sm_spechud", ToggleSpecHudCmd, "", 0);
	RegConsoleCmd("sm_tankhud", ToggleTankHudCmd, "", 0);
	CreateTimer(0.5, HudDrawTimer, any:0, 1);
	return 0;
}

public OnAllPluginsLoaded()
{
	hybridScoringAvailable = LibraryExists("l4d2_hybrid_scoremod");
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "l4d2_hybrid_scoremod", true))
	{
		hybridScoringAvailable = false;
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "l4d2_hybrid_scoremod", true))
	{
		hybridScoringAvailable = true;
	}
	return 0;
}

public OnClientAuthorized(client, String:auth[])
{
	bSpecHudActive[client] = 0;
	bSpecHudHintShown[client] = 0;
	bTankHudActive[client] = 1;
	bTankHudHintShown[client] = 0;
	return 0;
}

public Action:ToggleSpecHudCmd(client, args)
{
	bSpecHudActive[client] = !bSpecHudActive[client];
	new var1;
	if (bSpecHudActive[client])
	{
		var1 = 7428;
	}
	else
	{
		var1 = 7448;
	}
	CPrintToChat(client, "<{olive}HUD{default}> Spectator HUD is now %s.", var1);
	return Action:0;
}

public Action:ToggleTankHudCmd(client, args)
{
	bTankHudActive[client] = !bTankHudActive[client];
	new var1;
	if (bTankHudActive[client])
	{
		var1 = 7512;
	}
	else
	{
		var1 = 7532;
	}
	CPrintToChat(client, "<{olive}HUD{default}> Tank HUD is now %s.", var1);
	return Action:0;
}

public Action:HudDrawTimer(Handle:hTimer)
{
	new var1;
	if (IsInReady() || IsInPause())
	{
		return Action:3;
	}
	new bool:bSpecsOnServer;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsSpectator(i))
		{
			bSpecsOnServer = true;
			if (bSpecsOnServer)
			{
				new Handle:specHud = CreatePanel(Handle:0);
				FillHeaderInfo(specHud);
				FillSurvivorInfo(specHud);
				FillInfectedInfo(specHud);
				FillTankInfo(specHud, false);
				FillGameInfo(specHud);
				new i = 1;
				while (i <= MaxClients)
				{
					new var2;
					if (!bSpecHudActive[i] || !IsSpectator(i) || IsFakeClient(i))
					{
					}
					else
					{
						SendPanelToClient(specHud, i, DummySpecHudHandler, 3);
						if (!bSpecHudHintShown[i])
						{
							bSpecHudHintShown[i] = 1;
							CPrintToChat(i, "<{olive}HUD{default}> Type {green}!spechud{default} into chat to toggle the {blue}Spectator HUD{default}.");
						}
					}
					i++;
				}
				CloseHandle(specHud);
			}
			new Handle:tankHud = CreatePanel(Handle:0);
			if (!FillTankInfo(tankHud, true))
			{
				CloseHandle(tankHud);
				return Action:3;
			}
			new i = 1;
			while (i <= MaxClients)
			{
				new var4;
				if (!bTankHudActive[i] || !IsClientInGame(i) || IsFakeClient(i) || IsSurvivor(i) || (bSpecHudActive[i] && IsSpectator(i)))
				{
				}
				else
				{
					SendPanelToClient(tankHud, i, DummyTankHudHandler, 3);
					if (!bTankHudHintShown[i])
					{
						bTankHudHintShown[i] = 1;
						CPrintToChat(i, "<{olive}HUD{default}> Type {green}!tankhud{default} into chat to toggle the {red}Tank HUD{default}.");
					}
				}
				i++;
			}
			CloseHandle(tankHud);
			return Action:0;
		}
		i++;
	}
	if (bSpecsOnServer)
	{
		new Handle:specHud = CreatePanel(Handle:0);
		FillHeaderInfo(specHud);
		FillSurvivorInfo(specHud);
		FillInfectedInfo(specHud);
		FillTankInfo(specHud, false);
		FillGameInfo(specHud);
		new i = 1;
		while (i <= MaxClients)
		{
			new var2;
			if (!bSpecHudActive[i] || !IsSpectator(i) || IsFakeClient(i))
			{
			}
			else
			{
				SendPanelToClient(specHud, i, DummySpecHudHandler, 3);
				if (!bSpecHudHintShown[i])
				{
					bSpecHudHintShown[i] = 1;
					CPrintToChat(i, "<{olive}HUD{default}> Type {green}!spechud{default} into chat to toggle the {blue}Spectator HUD{default}.");
				}
			}
			i++;
		}
		CloseHandle(specHud);
	}
	new Handle:tankHud = CreatePanel(Handle:0);
	if (!FillTankInfo(tankHud, true))
	{
		CloseHandle(tankHud);
		return Action:3;
	}
	new i = 1;
	while (i <= MaxClients)
	{
		new var4;
		if (!bTankHudActive[i] || !IsClientInGame(i) || IsFakeClient(i) || IsSurvivor(i) || (bSpecHudActive[i] && IsSpectator(i)))
		{
		}
		else
		{
			SendPanelToClient(tankHud, i, DummyTankHudHandler, 3);
			if (!bTankHudHintShown[i])
			{
				bTankHudHintShown[i] = 1;
				CPrintToChat(i, "<{olive}HUD{default}> Type {green}!tankhud{default} into chat to toggle the {red}Tank HUD{default}.");
			}
		}
		i++;
	}
	CloseHandle(tankHud);
	return Action:0;
}

public DummySpecHudHandler(Handle:hMenu, MenuAction:action, param1, param2)
{
	return 0;
}

public DummyTankHudHandler(Handle:hMenu, MenuAction:action, param1, param2)
{
	return 0;
}

FillHeaderInfo(Handle:hSpecHud)
{
	DrawPanelText(hSpecHud, "Spectator HUD");
	decl String:buffer[512];
	Format(buffer, 512, "Slots %i/%i | Tickrate %i", GetRealClientCount(), GetConVarInt(FindConVar("sv_maxplayers")), RoundToNearest(1.0 / GetTickInterval()));
	DrawPanelText(hSpecHud, buffer);
	return 0;
}

GetMeleePrefix(client, String:prefix[], length)
{
	new secondary = GetPlayerWeaponSlot(client, 1);
	new WeaponId:secondaryWep = IdentifyWeapon(secondary);
	new String:buf[4] = "?";
	switch (secondaryWep)
	{
		case 0:
		{
		}
		case 1:
		{
			new var1;
			if (GetEntProp(secondary, PropType:0, "m_isDualWielding", 4, 0))
			{
				var1 = 7844;
			}
			else
			{
				var1 = 7848;
			}
		}
		case 19:
		{
		}
		case 32:
		{
		}
		default:
		{
		}
	}
	strcopy(prefix, length, buf);
	return 0;
}

FillSurvivorInfo(Handle:hSpecHud)
{
	decl String:info[512];
	decl String:buffer[64];
	decl String:name[32];
	DrawPanelText(hSpecHud, " ");
	DrawPanelText(hSpecHud, "->1. Survivors");
	new survivorCount;
	new client = 1;
	while (client <= MaxClients && survivorCount < GetConVarInt(survivor_limit))
	{
		if (IsSurvivor(client))
		{
			GetClientFixedName(client, name, 32);
			if (!IsPlayerAlive(client))
			{
				Format(info, 512, "%s: Dead", name);
			}
			else
			{
				new WeaponId:primaryWep = IdentifyWeapon(GetPlayerWeaponSlot(client, 0));
				GetLongWeaponName(primaryWep, info, 512, -1073741726);
				GetMeleePrefix(client, buffer, 64);
				Format(info, 512, "%s/%s", info, buffer);
				if (IsSurvivorHanging(client))
				{
					Format(info, 512, "%s: %iHP <Hanging> [%s]", name, GetSurvivorHealth(client), info);
				}
				else
				{
					if (IsIncapacitated(client))
					{
						Format(info, 512, "%s: %iHP <Incapped(#%i)> [%s]", name, GetSurvivorHealth(client), GetSurvivorIncapCount(client) + 1, info);
					}
					new health = GetSurvivorTemporaryHealth(client) + GetSurvivorHealth(client);
					new incapCount = GetSurvivorIncapCount(client);
					if (incapCount)
					{
						new var2;
						if (incapCount > 1)
						{
							var2[0] = 7988;
						}
						else
						{
							var2[0] = 7992;
						}
						Format(buffer, 64, "%i incap%s", incapCount, var2);
						Format(info, 512, "%s: %iHP (%s) [%s]", name, health, buffer, info);
					}
					else
					{
						Format(info, 512, "%s: %iHP [%s]", name, health, info);
					}
				}
			}
			survivorCount++;
			DrawPanelText(hSpecHud, info);
		}
		client++;
	}
	if (hybridScoringAvailable)
	{
		new healthBonus = SMPlus_GetHealthBonus();
		new damageBonus = SMPlus_GetDamageBonus();
		new pillsBonus = SMPlus_GetPillsBonus();
		DrawPanelText(hSpecHud, " ");
		Format(info, 512, "HB: %i <%.1f%%>", healthBonus, ToPercent(healthBonus, SMPlus_GetMaxHealthBonus()));
		DrawPanelText(hSpecHud, info);
		Format(info, 512, "DB: %i <%.1f%%>", damageBonus, ToPercent(damageBonus, SMPlus_GetMaxDamageBonus()));
		DrawPanelText(hSpecHud, info);
		Format(info, 512, "Pills: %i <%.1f%%>", pillsBonus, ToPercent(pillsBonus, SMPlus_GetMaxPillsBonus()));
		DrawPanelText(hSpecHud, info);
	}
	return 0;
}

FillInfectedInfo(Handle:hSpecHud)
{
	DrawPanelText(hSpecHud, " ");
	DrawPanelText(hSpecHud, "->2. Infected");
	decl String:info[512];
	decl String:buffer[32];
	decl String:name[32];
	new infectedCount;
	new client = 1;
	while (client <= MaxClients && infectedCount < GetConVarInt(z_max_player_zombies))
	{
		if (IsInfected(client))
		{
			GetClientFixedName(client, name, 32);
			if (!IsPlayerAlive(client))
			{
				new CountdownTimer:spawnTimer = L4D2Direct_GetSpawnTimer(client);
				new Float:timeLeft = -1.0;
				if (spawnTimer)
				{
					timeLeft = CTimer_GetRemainingTime(spawnTimer);
				}
				if (timeLeft < 0.0)
				{
					Format(info, 512, "%s: Dead", name);
				}
				else
				{
					Format(buffer, 32, "%is", RoundToNearest(timeLeft));
					new var2;
					if (RoundToNearest(timeLeft))
					{
						var2[0] = buffer;
					}
					else
					{
						var2[0] = 8124;
					}
					Format(info, 512, "%s: Dead (%s)", name, var2);
				}
			}
			else
			{
				new L4D2SI:zClass = GetInfectedClass(client);
				if (!(zClass == L4D2SI:8))
				{
					if (IsInfectedGhost(client))
					{
						Format(info, 512, "%s: %s (Ghost)", name, L4D2SI_Names[zClass]);
					}
					else
					{
						if (GetEntityFlags(client) & 134217728)
						{
							Format(info, 512, "%s: %s (%iHP) [On Fire]", name, L4D2SI_Names[zClass], GetClientHealth(client));
						}
						Format(info, 512, "%s: %s (%iHP)", name, L4D2SI_Names[zClass], GetClientHealth(client));
					}
				}
			}
			infectedCount++;
			DrawPanelText(hSpecHud, info);
		}
		client++;
	}
	if (!infectedCount)
	{
		DrawPanelText(hSpecHud, "There are no SI at this moment.");
	}
	return 0;
}

bool:FillTankInfo(Handle:hSpecHud, bool:bTankHUD)
{
	new tank = FindTank();
	if (tank == -1)
	{
		return false;
	}
	new String:info[512] = "Frustr.  : AI";
	decl String:name[32];
	if (bTankHUD)
	{
		GetConVarString(FindConVar("l4d_ready_cfg_name"), info, 512);
		Format(info, 512, "%s :: Tank HUD", info);
		DrawPanelText(hSpecHud, info);
		DrawPanelText(hSpecHud, "___________________");
	}
	else
	{
		DrawPanelText(hSpecHud, " ");
		DrawPanelText(hSpecHud, "->3. Tank");
	}
	new passCount = L4D2Direct_GetTankPassedCount();
	switch (passCount)
	{
		case 0:
		{
			Format(info, 512, "native");
		}
		case 1:
		{
			Format(info, 512, "%ist", passCount);
		}
		case 2:
		{
			Format(info, 512, "%ind", passCount);
		}
		case 3:
		{
			Format(info, 512, "%ird", passCount);
		}
		default:
		{
			Format(info, 512, "%ith", passCount);
		}
	}
	if (!IsFakeClient(tank))
	{
		GetClientFixedName(tank, name, 32);
		Format(info, 512, "Control : %s (%s)", name, info);
	}
	else
	{
		Format(info, 512, "Control : AI (%s)", info);
	}
	DrawPanelText(hSpecHud, info);
	new health = GetClientHealth(tank);
	new var1;
	if (health <= 0 || IsIncapacitated(tank) || !IsPlayerAlive(tank))
	{
	}
	else
	{
		new healthPercent = RoundFloat(100.0 / GetConVarFloat(FindConVar("z_tank_health")) * 1.5 * health);
		new var2;
		if (healthPercent < 1)
		{
			var2 = 1;
		}
		else
		{
			var2 = healthPercent;
		}
		Format(info, 512, "Health  : %i / %i%%", health, var2);
	}
	DrawPanelText(hSpecHud, info);
	if (!IsFakeClient(tank))
	{
		Format(info, 512, "Frustr.  : %d%%", GetTankFrustration(tank));
	}
	DrawPanelText(hSpecHud, info);
	if (GetEntityFlags(tank) & 134217728)
	{
		new timeleft = RoundToCeil(health / 1117782016);
		Format(info, 512, "On Fire : %is", timeleft);
		DrawPanelText(hSpecHud, info);
	}
	return true;
}

FillGameInfo(Handle:hSpecHud)
{
	new tank = FindTank();
	if (tank != -1)
	{
		return 0;
	}
	DrawPanelText(hSpecHud, " ");
	DrawPanelText(hSpecHud, "->3. Game");
	decl String:info[512];
	decl String:buffer[512];
	GetConVarString(FindConVar("l4d_ready_cfg_name"), info, 512);
	if (GetCurrentGameMode() == 1)
	{
		new var1;
		if (InSecondHalfOfRound())
		{
			var1[0] = 8528;
		}
		else
		{
			var1[0] = 8532;
		}
		Format(info, 512, "%s (%s round)", info, var1);
		DrawPanelText(hSpecHud, info);
		Format(info, 512, "Survivor progress: %i%%", RoundToNearest(GetHighestSurvivorFlow() * 100.0));
		DrawPanelText(hSpecHud, info);
		if (RoundHasFlowTank())
		{
			Format(info, 512, "Tank: %i%%", RoundToNearest(GetTankFlow() * 100.0));
			DrawPanelText(hSpecHud, info);
		}
		if (RoundHasFlowWitch())
		{
			Format(info, 512, "Witch: %i%%", RoundToNearest(GetWitchFlow() * 100.0));
			DrawPanelText(hSpecHud, info);
		}
	}
	else
	{
		if (GetCurrentGameMode() == 2)
		{
			DrawPanelText(hSpecHud, info);
			new round = GetScavengeRoundNumber();
			switch (round)
			{
				case 0:
				{
					Format(buffer, 512, "N/A");
				}
				case 1:
				{
					Format(buffer, 512, "%ist", round);
				}
				case 2:
				{
					Format(buffer, 512, "%ind", round);
				}
				case 3:
				{
					Format(buffer, 512, "%ird", round);
				}
				default:
				{
					Format(buffer, 512, "%ith", round);
				}
			}
			new var2;
			if (InSecondHalfOfRound())
			{
				var2[0] = 8632;
			}
			else
			{
				var2[0] = 8636;
			}
			Format(info, 512, "Half: %s", var2);
			DrawPanelText(hSpecHud, info);
			Format(info, 512, "Round: %s", buffer);
			DrawPanelText(hSpecHud, info);
		}
	}
	return 0;
}

Float:ToPercent(score, maxbonus)
{
	new var1;
	if (score < 1)
	{
		var1 = 0.0;
	}
	else
	{
		var1 = float(score) / float(maxbonus) * 100.0;
	}
	return var1;
}

GetClientFixedName(client, String:name[], length)
{
	GetClientName(client, name, length);
	if (name[0] == '[')
	{
		decl String:temp[32];
		strcopy(temp, 32, name);
		temp[7] = MissingTAG:0;
		strcopy(name[0], length + -1, temp);
		name[0] = MissingTAG:32;
	}
	if (strlen(name) > 25)
	{
		name[6] = MissingTAG:46;
		name[5] = MissingTAG:46;
		name[5] = MissingTAG:46;
		name[6] = MissingTAG:0;
	}
	return 0;
}

GetRealClientCount()
{
	new clients;
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientConnected(i) && IsClientInGame(i) && !IsFakeClient(i))
		{
			clients++;
		}
		i++;
	}
	return clients;
}

InSecondHalfOfRound()
{
	return GameRules_GetProp("m_bInSecondHalfOfRound", 4, 0);
}

GetScavengeRoundNumber()
{
	return GameRules_GetProp("m_nRoundNumber", 4, 0);
}

Float:GetClientFlow(client)
{
	return L4D2Direct_GetFlowDistance(client) / L4D2Direct_GetMapMaxFlowDistance();
}

Float:GetHighestSurvivorFlow()
{
	new Float:flow = 0.0;
	new Float:maxflow = 0.0;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsSurvivor(i))
		{
			flow = GetClientFlow(i);
			if (flow > maxflow)
			{
				maxflow = flow;
			}
		}
		i++;
	}
	return maxflow;
}

bool:RoundHasFlowTank()
{
	return L4D2Direct_GetVSTankToSpawnThisRound(InSecondHalfOfRound());
}

bool:RoundHasFlowWitch()
{
	return L4D2Direct_GetVSWitchToSpawnThisRound(InSecondHalfOfRound());
}

Float:GetTankFlow()
{
	return L4D2Direct_GetVSTankFlowPercent(InSecondHalfOfRound()) - GetConVarInt(FindConVar("versus_boss_buffer")) / L4D2Direct_GetMapMaxFlowDistance();
}

Float:GetWitchFlow()
{
	return L4D2Direct_GetVSWitchFlowPercent(InSecondHalfOfRound()) - GetConVarInt(FindConVar("versus_boss_buffer")) / L4D2Direct_GetMapMaxFlowDistance();
}

bool:IsSpectator(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 1;
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

bool:IsInfected(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 3;
}

bool:IsInfectedGhost(client)
{
	return GetEntProp(client, PropType:0, "m_isGhost", 4, 0);
}

L4D2SI:GetInfectedClass(client)
{
	new var1;
	if (IsInfected(client))
	{
		var1 = GetEntProp(client, PropType:0, "m_zombieClass", 4, 0);
	}
	else
	{
		var1 = MissingTAG:0;
	}
	return var1;
}

FindTank()
{
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsInfected(i) && GetInfectedClass(i) == 8 && IsPlayerAlive(i))
		{
			return i;
		}
		i++;
	}
	return -1;
}

GetTankFrustration(tank)
{
	return 100 - GetEntProp(tank, PropType:0, "m_frustration", 4, 0);
}

bool:IsIncapacitated(client)
{
	return GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0);
}

bool:IsSurvivorHanging(client)
{
	return GetEntProp(client, PropType:0, "m_isFallingFromLedge", 4, 0) | GetEntProp(client, PropType:0, "m_isHangingFromLedge", 4, 0);
}

GetSurvivorIncapCount(client)
{
	return GetEntProp(client, PropType:0, "m_currentReviveCount", 4, 0);
}

GetSurvivorTemporaryHealth(client)
{
	new temphp = RoundToCeil(GetEntPropFloat(client, PropType:0, "m_healthBuffer", 0) - GetGameTime() - GetEntPropFloat(client, PropType:0, "m_healthBufferTime", 0) * GetConVarFloat(FindConVar("pain_pills_decay_rate"))) + -1;
	new var1;
	if (temphp > 0)
	{
		var1 = temphp;
	}
	else
	{
		var1 = 0;
	}
	return var1;
}

GetSurvivorHealth(client)
{
	return GetEntProp(client, PropType:0, "m_iHealth", 4, 0);
}

L4D2Gamemode:GetCurrentGameMode()
{
	static String:sGameMode[32];
	if (!sGameMode[0])
	{
		GetConVarString(FindConVar("mp_gamemode"), sGameMode, 32);
	}
	if (StrContains(sGameMode, "scavenge", true) > -1)
	{
		return L4D2Gamemode:2;
	}
	new var1;
	if (StrContains(sGameMode, "versus", true) > -1 || StrEqual(sGameMode, "mutation12", true))
	{
		return L4D2Gamemode:1;
	}
	return L4D2Gamemode:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "05/28/2017",
	time = "10:41:53"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 0,
};
new bool:readyUpIsAvailable;
new Handle:sv_mincmdrate;
new Handle:sv_maxcmdrate;
new Handle:sv_minupdaterate;
new Handle:sv_maxupdaterate;
new Handle:sv_minrate;
new Handle:sv_maxrate;
new Handle:sv_client_min_interp_ratio;
new Handle:sv_client_max_interp_ratio;
new String:netvars[8][8];
new Float:fLastAdjusted[66];
public Plugin:myinfo =
{
	name = "Lightweight Spectating",
	description = "Forces low rates on spectators",
	author = "Visor",
	version = "1.2",
	url = "https://github.com/Attano/smplugins"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public OnPluginStart()
{
	sv_mincmdrate = FindConVar("sv_mincmdrate");
	sv_maxcmdrate = FindConVar("sv_maxcmdrate");
	sv_minupdaterate = FindConVar("sv_minupdaterate");
	sv_maxupdaterate = FindConVar("sv_maxupdaterate");
	sv_minrate = FindConVar("sv_minrate");
	sv_maxrate = FindConVar("sv_maxrate");
	sv_client_min_interp_ratio = FindConVar("sv_client_min_interp_ratio");
	sv_client_max_interp_ratio = FindConVar("sv_client_max_interp_ratio");
	HookEvent("player_team", OnTeamChange, EventHookMode:1);
	return 0;
}

public OnPluginEnd()
{
	SetConVarString(sv_minupdaterate, netvars[2], false, false);
	new var1 = netvars;
	SetConVarString(sv_mincmdrate, var1[0][var1], false, false);
	return 0;
}

public OnAllPluginsLoaded()
{
	readyUpIsAvailable = LibraryExists("readyup");
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		readyUpIsAvailable = false;
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		readyUpIsAvailable = true;
	}
	return 0;
}

public OnConfigsExecuted()
{
	new var1 = netvars;
	GetConVarString(sv_mincmdrate, var1[0][var1], 8);
	GetConVarString(sv_maxcmdrate, netvars[1], 8);
	GetConVarString(sv_minupdaterate, netvars[2], 8);
	GetConVarString(sv_maxupdaterate, netvars[3], 8);
	GetConVarString(sv_minrate, netvars[4], 8);
	GetConVarString(sv_maxrate, netvars[5], 8);
	GetConVarString(sv_client_min_interp_ratio, netvars[6], 8);
	GetConVarString(sv_client_max_interp_ratio, netvars[7], 8);
	SetConVarInt(sv_minupdaterate, 30, false, false);
	SetConVarInt(sv_mincmdrate, 30, false, false);
	return 0;
}

public OnClientPutInServer(client)
{
	fLastAdjusted[client] = 0;
	return 0;
}

public OnTeamChange(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	CreateTimer(10.0, TimerAdjustRates, client, 2);
	return 0;
}

public Action:TimerAdjustRates(Handle:timer, any:client)
{
	AdjustRates(client);
	return Action:3;
}

public OnClientSettingsChanged(client)
{
	AdjustRates(client);
	return 0;
}

AdjustRates(client)
{
	if (!IsValidClient(client))
	{
		return 0;
	}
	if (fLastAdjusted[client] < GetEngineTime() - 1.0)
	{
		fLastAdjusted[client] = GetEngineTime();
		new L4D2Team:team = GetClientTeam(client);
		new var2;
		if (team == L4D2Team:2 || team == L4D2Team:3 || (readyUpIsAvailable && IsClientCaster(client)))
		{
			ResetRates(client);
		}
		else
		{
			if (team == L4D2Team:1)
			{
				SetSpectatorRates(client);
			}
		}
	}
	return 0;
}

SetSpectatorRates(client)
{
	SendConVarValue(client, sv_mincmdrate, "30");
	SendConVarValue(client, sv_maxcmdrate, "30");
	SendConVarValue(client, sv_minupdaterate, "30");
	SendConVarValue(client, sv_maxupdaterate, "30");
	SendConVarValue(client, sv_minrate, "10000");
	SendConVarValue(client, sv_maxrate, "10000");
	SetClientInfo(client, "cl_updaterate", "30");
	SetClientInfo(client, "cl_cmdrate", "30");
	return 0;
}

ResetRates(client)
{
	new var1 = netvars;
	SendConVarValue(client, sv_mincmdrate, var1[0][var1]);
	SendConVarValue(client, sv_maxcmdrate, netvars[1]);
	SendConVarValue(client, sv_minupdaterate, netvars[2]);
	SendConVarValue(client, sv_maxupdaterate, netvars[3]);
	SendConVarValue(client, sv_minrate, netvars[4]);
	SendConVarValue(client, sv_maxrate, netvars[5]);
	SetClientInfo(client, "cl_updaterate", netvars[3]);
	SetClientInfo(client, "cl_cmdrate", netvars[1]);
	return 0;
}

bool:IsValidClient(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && !IsFakeClient(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "12/10/2015",
	time = "12:51:33"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedNames[8][32] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:MeleeWeaponModels[15][];
new String:MeleeWeaponNames[15][];
new String:SurvivorModels[8][] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:SurvivorNames[8][] =
{
	"models/survivors/survivor_coach.mdl",
	"models/survivors/survivor_gambler.mdl",
	"models/survivors/survivor_producer.mdl",
	"models/survivors/survivor_mechanic.mdl",
	"models/survivors/survivor_manager.mdl",
	"models/survivors/survivor_teenangst.mdl",
	"models/survivors/survivor_namvet.mdl",
	"models/survivors/survivor_biker.mdl"
};
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	32, 64, 100, 136, 172, 208, 244, 280, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1868783474, 778593121, 7103597, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1634164594, 1701601901, 1684876914, 108, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1919967090, 1668637807, 1831760485, 27748, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1701666674, 1851877475, 1831756649, 27748, 1701080941, 1932489580, 1769370229, 1936879478, 1920299823, 1870031222, 1634557810, 1701273966, 1684876914
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new Handle:hSurvivorModelsTrie;
new Handle:hMeleeWeaponModelsTrie = 845427820;
new Handle:hMeleeWeaponNamesTrie = 845427820;
new Handle:hWeaponNamesTrie = 845427820;
public SharedPlugin:__pl_l4d2util =
{
	name = "l4d2util",
	file = "l4d2util.smx",
	required = 1,
};
new bool:isSurvivorStaggerBlocked[8];
new getUpAnimations[8][5] =
{
	{
		621, 656, 660, 661, 629
	},
	{
		620, 667, 671, 672, 629
	},
	{
		629, 674, 678, 679, 637
	},
	{
		625, 671, 675, 676, 634
	},
	{
		528, 759, 763, 764, 537
	},
	{
		537, 819, 823, 824, 546
	},
	{
		528, 759, 763, 764, 537
	},
	{
		531, 762, 766, 767, 540
	}
};
public Plugin:myinfo =
{
	name = "Stagger Blocker",
	description = "Block players from being staggered for a time while getting up from a Hunter pounce or a Charger pummel",
	author = "Standalone (aka Manu)",
	version = "",
	url = "https://github.com/jacob404/Pro-Mod-4.0/releases/latest"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:IsInfected(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 3)
	{
		return false;
	}
	return true;
}

L4D2_Infected:GetInfectedClass(client)
{
	return GetEntProp(client, PropType:0, L4D2_InfectedTimerEntities, 4, 0);
}

bool:IsSurvivor(client)
{
	new var1;
	if (!IsClientInGame(client) || GetClientTeam(client) == 2)
	{
		return false;
	}
	return true;
}

InitSurvivorModelTrie()
{
	hSurvivorModelsTrie = CreateTrie();
	new i;
	while (i < 8)
	{
		SetTrieValue(hSurvivorModelsTrie, L4D2_InfectedNames[i], i, true);
		i++;
	}
	return 0;
}

SurvivorCharacter:IdentifySurvivor(client)
{
	new var1;
	if (!client || !IsClientInGame(client) || !IsSurvivor(client))
	{
		return SurvivorCharacter:-1;
	}
	decl String:clientModel[44];
	GetClientModel(client, clientModel, 42);
	return ClientModelToSC(clientModel);
}

SurvivorCharacter:ClientModelToSC(String:model[])
{
	if (!hSurvivorModelsTrie)
	{
		InitSurvivorModelTrie();
	}
	new SurvivorCharacter:sc;
	if (GetTrieValue(hSurvivorModelsTrie, model, sc))
	{
		return sc;
	}
	return SurvivorCharacter:-1;
}

public __pl_l4d2util_SetNTVOptional()
{
	return 0;
}

public OnPluginStart()
{
	HookEvent("pounce_stopped", Event_PounceChargeEnd, EventHookMode:1);
	HookEvent("charger_pummel_end", Event_PounceChargeEnd, EventHookMode:1);
	HookEvent("charger_carry_end", Event_PounceChargeEnd, EventHookMode:1);
	HookEvent("player_bot_replace", Event_PlayerBotReplace, EventHookMode:1);
	HookEvent("bot_player_replace", Event_BotPlayerReplace, EventHookMode:1);
	HookEvent("round_end", Event_RoundEnd, EventHookMode:2);
	return 0;
}

public Action:Event_RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	ResetStaggerBlocked();
	return Action:0;
}

public OnMapEnd()
{
	ResetStaggerBlocked();
	return 0;
}

public Action:Event_BotPlayerReplace(Handle:event, String:name[], bool:dontBroadcast)
{
	new player = GetClientOfUserId(GetEventInt(event, "player"));
	new SurvivorCharacter:charIndex = IdentifySurvivor(player);
	if (charIndex == SurvivorCharacter:-1)
	{
		return Action:0;
	}
	if (isSurvivorStaggerBlocked[charIndex])
	{
		SDKHook(player, SDKHookType:5, OnThink);
	}
	return Action:0;
}

public Action:Event_PlayerBotReplace(Handle:event, String:name[], bool:dontBroadcast)
{
	new bot = GetClientOfUserId(GetEventInt(event, "bot"));
	new SurvivorCharacter:charIndex = IdentifySurvivor(bot);
	if (charIndex == SurvivorCharacter:-1)
	{
		return Action:0;
	}
	if (isSurvivorStaggerBlocked[charIndex])
	{
		SDKHook(bot, SDKHookType:5, OnThink);
	}
	return Action:0;
}

public Action:Event_PounceChargeEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new SurvivorCharacter:charIndex = IdentifySurvivor(client);
	if (charIndex == SurvivorCharacter:-1)
	{
		return Action:0;
	}
	CreateTimer(0.2, HookOnThink, client, 0);
	isSurvivorStaggerBlocked[charIndex] = 1;
	return Action:0;
}

public Action:HookOnThink(Handle:timer, any:client)
{
	new var1;
	if (client && IsClientInGame(client) && IsSurvivor(client))
	{
		SDKHook(client, SDKHookType:5, OnThink);
	}
	return Action:0;
}

public OnThink(client)
{
	new SurvivorCharacter:charIndex = IdentifySurvivor(client);
	if (charIndex == SurvivorCharacter:-1)
	{
		return 0;
	}
	new sequence = GetEntProp(client, PropType:0, "m_nSequence", 4, 0);
	new var1;
	if (getUpAnimations[charIndex][0] != sequence && getUpAnimations[charIndex][1] != sequence && getUpAnimations[charIndex][2] != sequence && getUpAnimations[charIndex][3] != sequence && getUpAnimations[charIndex][4] != sequence)
	{
		isSurvivorStaggerBlocked[charIndex] = 0;
		SDKUnhook(client, SDKHookType:5, OnThink);
	}
	return 0;
}

public Action:L4D2_OnStagger(target, source)
{
	new var1;
	if (source && IsInfected(source))
	{
		new L4D2_Infected:sourceClass = GetInfectedClass(source);
		new var2;
		if (sourceClass == L4D2_Infected:3 || sourceClass == L4D2_Infected:5)
		{
			new SurvivorCharacter:charIndex = IdentifySurvivor(target);
			if (charIndex == SurvivorCharacter:-1)
			{
				return Action:0;
			}
			if (isSurvivorStaggerBlocked[charIndex])
			{
				return Action:3;
			}
		}
	}
	return Action:0;
}

public ResetStaggerBlocked()
{
	new i;
	while (i < 8)
	{
		isSurvivorStaggerBlocked[i] = 0;
		i++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+3944",
	date = "09/02/2013",
	time = "10:45:43"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Super Stagger Solver",
	description = "Blocks all button presses during stumbles",
	author = "CanadaRox",
	version = "(^.^)",
	url = ""
};
new Handle:g_hGameConf;
new Handle:g_hIsStaggering;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbReadRepeatedInt");
	MarkNativeAsOptional("PbReadRepeatedFloat");
	MarkNativeAsOptional("PbReadRepeatedBool");
	MarkNativeAsOptional("PbReadRepeatedString");
	MarkNativeAsOptional("PbReadRepeatedColor");
	MarkNativeAsOptional("PbReadRepeatedAngle");
	MarkNativeAsOptional("PbReadRepeatedVector");
	MarkNativeAsOptional("PbReadRepeatedVector2D");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	g_hGameConf = LoadGameConfigFile("staggersolver");
	if (!g_hGameConf)
	{
		SetFailState("[Stagger Solver] Could not load game config file.");
	}
	StartPrepSDKCall(SDKCallType:2);
	if (!PrepSDKCall_SetFromConf(g_hGameConf, SDKFuncConfSource:1, "IsStaggering"))
	{
		SetFailState("[Stagger Solver] Could not find signature IsStaggering.");
	}
	PrepSDKCall_SetReturnInfo(SDKType:4, SDKPassMethod:1, 0, 0);
	g_hIsStaggering = EndPrepSDKCall();
	if (!g_hIsStaggering)
	{
		SetFailState("[Stagger Solver] Failed to load signature IsStaggering");
	}
	CloseHandle(g_hGameConf);
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons)
{
	new var1;
	if (IsClientInGame(client) && IsPlayerAlive(client) && SDKCall(g_hIsStaggering, client))
	{
		buttons = 0;
	}
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2-dev+4559",
	date = "10/22/2014",
	time = "20:01:24"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_readyup =
{
	name = "readyup",
	file = "readyup.smx",
	required = 0,
};
public Plugin:myinfo =
{
	name = "Starting Items",
	description = "Gives health items and throwables to survivors at the start of each round",
	author = "CircleSquared + Jacob",
	version = "1.1",
	url = "none"
};
new Handle:hCvarItemType;
new iItemFlags;
new bool:g_bReadyUpAvailable;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public __pl_readyup_SetNTVOptional()
{
	MarkNativeAsOptional("AddStringToReadyFooter");
	MarkNativeAsOptional("IsInReady");
	MarkNativeAsOptional("IsClientCaster");
	MarkNativeAsOptional("IsIDCaster");
	return 0;
}

public OnPluginStart()
{
	hCvarItemType = CreateConVar("starting_item_flags", "0", "Item flags to give on leaving the saferoom (1: Kit, 2: Defib, 4: Pills, 8: Adren, 16: Pipebomb, 32: Molotov, 64: Bile)", 262144, false, 0.0, false, 0.0);
	HookEvent("player_left_start_area", PlayerLeftStartArea, EventHookMode:1);
	return 0;
}

public OnAllPluginsLoaded()
{
	g_bReadyUpAvailable = LibraryExists("readyup");
	return 0;
}

public OnLibraryRemoved(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		g_bReadyUpAvailable = false;
	}
	return 0;
}

public OnLibraryAdded(String:name[])
{
	if (StrEqual(name, "readyup", true))
	{
		g_bReadyUpAvailable = true;
	}
	return 0;
}

public OnRoundIsLive()
{
	DetermineItems();
	return 0;
}

public Action:PlayerLeftStartArea(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_bReadyUpAvailable)
	{
		DetermineItems();
	}
	return Action:0;
}

public DetermineItems()
{
	new String:strItemName[32] = "weapon_vomitjar";
	iItemFlags = GetConVarInt(hCvarItemType);
	if (iItemFlags)
	{
		if (iItemFlags & 1)
		{
			giveStartingItem(strItemName);
		}
		else
		{
			if (iItemFlags & 2)
			{
				giveStartingItem(strItemName);
			}
		}
		if (iItemFlags & 4)
		{
			giveStartingItem(strItemName);
		}
		else
		{
			if (iItemFlags & 8)
			{
				giveStartingItem(strItemName);
			}
		}
		if (iItemFlags & 16)
		{
			giveStartingItem(strItemName);
		}
		if (iItemFlags & 32)
		{
			giveStartingItem(strItemName);
		}
		if (iItemFlags & 64)
		{
			giveStartingItem(strItemName);
		}
	}
	return 0;
}

giveStartingItem(String:strItemName[32])
{
	new startingItem;
	new Float:clientOrigin[3] = 0.0;
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && GetClientTeam(i) == 2)
		{
			startingItem = CreateEntityByName(strItemName, -1);
			GetClientAbsOrigin(i, clientOrigin);
			TeleportEntity(startingItem, clientOrigin, NULL_VECTOR, NULL_VECTOR);
			DispatchSpawn(startingItem);
			EquipPlayerWeapon(i, startingItem);
		}
		i++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "05/09/2017",
	time = "18:14:29"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public Plugin:myinfo =
{
	name = "Survivor MVP notification",
	description = "Shows MVP for survivor team at end of round",
	author = "Tabun, Artifacial",
	version = "0.3",
	url = "https://github.com/alexberriman/l4d2_survivor_mvp"
};
new Handle:hPluginEnabled;
new Handle:hCountTankDamage;
new Handle:hCountWitchDamage;
new Handle:hTrackFF;
new Handle:hBrevityFlags;
new Handle:hRUPActive;
new Handle:hTeamSize;
new bool:bCountTankDamage;
new bool:bCountWitchDamage;
new bool:bTrackFF;
new iBrevityFlags;
new bool:bRUPActive;
new Handle:hGameMode;
new String:sGameMode[24];
new String:sClientName[66][64];
new iGotKills[66];
new iGotCommon[66];
new iDidDamage[66];
new iDidDamageAll[66];
new iDidDamageTank[66];
new iDidDamageWitch[66];
new iDidFF[66];
new iDidDamageClass[66][9];
new timesPinned[66][9];
new totalPinned[66];
new pillsUsed[66];
new boomerPops[66];
new damageReceived[66];
new tankSpawned;
new commonKilledDuringTank[66];
new ttlCommonKilledDuringTank;
new siDmgDuringTank[66];
new ttlSiDmgDuringTank;
new tankThrow;
new rocksEaten[66];
new rockIndex;
new ttlPinnedDuringTank[66];
new iTotalKills;
new iTotalCommon;
new iTotalDamage;
new iTotalDamageTank;
new iTotalDamageWitch;
new iTotalDamageAll;
new iTotalFF;
new iRoundNumber;
new bInRound;
new bPlayerLeftStartArea;
new String:sTmpString[32];
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator*(Float:,_:)(Float:oper1, oper2)
{
	return oper1 * float(oper2);
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

StrCat(String:buffer[], maxlength, String:source[])
{
	new len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	return Format(buffer[len], maxlength - len, "%s", source);
}

ExplodeString(String:text[], String:split[], String:buffers[][], maxStrings, maxStringLength, bool:copyRemainder)
{
	new reloc_idx;
	new idx;
	new total;
	new var1;
	if (maxStrings < 1 || !split[0])
	{
		return 0;
	}
	while ((idx = SplitString(text[reloc_idx], split, buffers[total], maxStringLength)) != -1)
	{
		reloc_idx = idx + reloc_idx;
		total++;
		if (maxStrings == total)
		{
			if (copyRemainder)
			{
				strcopy(buffers[total + -1], maxStringLength, text[reloc_idx - idx]);
			}
			return total;
		}
	}
	total++;
	strcopy(buffers[total], maxStringLength, text[reloc_idx]);
	return total;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

MoveType:GetEntityMoveType(entity)
{
	static bool:gotconfig;
	static String:datamap[32];
	if (!gotconfig)
	{
		new Handle:gc = LoadGameConfigFile("core.games");
		new bool:exists = GameConfGetKeyValue(gc, "m_MoveType", datamap, 32);
		CloseHandle(gc);
		if (!exists)
		{
			strcopy(datamap, 32, "m_MoveType");
		}
		gotconfig = true;
	}
	return GetEntProp(entity, PropType:1, datamap, 4, 0);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	CreateNative("SURVMVP_GetMVP", Native_GetMVP);
	CreateNative("SURVMVP_GetMVPDmgCount", Native_GetMVPDmgCount);
	CreateNative("SURVMVP_GetMVPKills", Native_GetMVPKills);
	CreateNative("SURVMVP_GetMVPDmgPercent", Native_GetMVPDmgPercent);
	CreateNative("SURVMVP_GetMVPCI", Native_GetMVPCI);
	CreateNative("SURVMVP_GetMVPCIKills", Native_GetMVPCIKills);
	CreateNative("SURVMVP_GetMVPCIPercent", Native_GetMVPCIPercent);
	return APLRes:0;
}

public Native_GetMVP(Handle:plugin, numParams)
{
	new client = findMVPSI(0, 0, 0);
	return client;
}

public Native_GetMVPDmgPercent(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	decl Float:dmgprc;
	new var1;
	if (client && iTotalDamageAll > 0)
	{
		var2 = float(iDidDamageAll[client]) / float(iTotalDamageAll) * 100;
	}
	else
	{
		var2 = 0;
	}
	dmgprc = var2;
	return dmgprc;
}

public Native_GetMVPDmgCount(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	decl dmg;
	new var1;
	if (client && iTotalDamageAll > 0)
	{
		var2 = iDidDamageAll[client];
	}
	else
	{
		var2 = 0;
	}
	dmg = var2;
	return dmg;
}

public Native_GetMVPKills(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	decl dmg;
	new var1;
	if (client && iTotalKills > 0)
	{
		var2 = iGotKills[client];
	}
	else
	{
		var2 = 0;
	}
	dmg = var2;
	return dmg;
}

public Native_GetMVPCI(Handle:plugin, numParams)
{
	new client = findMVPCommon(0, 0, 0);
	return client;
}

public Native_GetMVPCIKills(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	decl dmg;
	new var1;
	if (client && iTotalCommon > 0)
	{
		var2 = iGotCommon[client];
	}
	else
	{
		var2 = 0;
	}
	dmg = var2;
	return dmg;
}

public Native_GetMVPCIPercent(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	decl Float:dmgprc;
	new var1;
	if (client && iTotalCommon > 0)
	{
		var2 = float(iGotCommon[client]) / float(iTotalCommon) * 100;
	}
	else
	{
		var2 = 0;
	}
	dmgprc = var2;
	return dmgprc;
}

public OnPluginStart()
{
	HookEvent("round_start", RoundStart_Event, EventHookMode:2);
	HookEvent("round_end", RoundEnd_Event, EventHookMode:2);
	HookEvent("scavenge_round_start", ScavRoundStart, EventHookMode:1);
	HookEvent("player_left_start_area", PlayerLeftStartArea, EventHookMode:1);
	HookEvent("pills_used", pillsUsedEvent, EventHookMode:1);
	HookEvent("boomer_exploded", boomerExploded, EventHookMode:1);
	HookEvent("charger_carry_end", chargerCarryEnd, EventHookMode:1);
	HookEvent("jockey_ride", jockeyRide, EventHookMode:1);
	HookEvent("lunge_pounce", hunterLunged, EventHookMode:1);
	HookEvent("choke_start", smokerChoke, EventHookMode:1);
	HookEvent("tank_killed", tankKilled, EventHookMode:1);
	HookEvent("tank_spawn", tankSpawn, EventHookMode:1);
	HookEvent("ability_use", abilityUseEvent, EventHookMode:1);
	HookEvent("player_hurt", PlayerHurt_Event, EventHookMode:1);
	HookEvent("player_death", PlayerDeath_Event, EventHookMode:1);
	HookEvent("infected_hurt", InfectedHurt_Event, EventHookMode:1);
	HookEvent("infected_death", InfectedDeath_Event, EventHookMode:1);
	hGameMode = FindConVar("mp_gamemode");
	hPluginEnabled = CreateConVar("sm_survivor_mvp_enabled", "1", "Enable display of MVP at end of round", 262144, true, 0.0, true, 1.0);
	hCountTankDamage = CreateConVar("sm_survivor_mvp_counttank", "0", "Damage on tank counts towards MVP-selection if enabled.", 262144, true, 0.0, true, 1.0);
	hCountWitchDamage = CreateConVar("sm_survivor_mvp_countwitch", "0", "Damage on witch counts towards MVP-selection if enabled.", 262144, true, 0.0, true, 1.0);
	hTrackFF = CreateConVar("sm_survivor_mvp_showff", "1", "Track Friendly-fire stat.", 262144, true, 0.0, true, 1.0);
	hBrevityFlags = CreateConVar("sm_survivor_mvp_brevity", "0", "Flags for setting brevity of MVP report (hide 1:SI, 2:CI, 4:FF, 8:rank, 32:perc, 64:abs).", 262144, true, 0.0, false, 0.0);
	hTeamSize = FindConVar("survivor_limit");
	bCountTankDamage = GetConVarBool(hCountTankDamage);
	bCountWitchDamage = GetConVarBool(hCountWitchDamage);
	bTrackFF = GetConVarBool(hTrackFF);
	iBrevityFlags = GetConVarInt(hBrevityFlags);
	bTrackFF = true;
	HookConVarChange(hCountTankDamage, ConVarChange_CountTankDamage);
	HookConVarChange(hCountWitchDamage, ConVarChange_CountWitchDamage);
	HookConVarChange(hTrackFF, ConVarChange_TrackFF);
	HookConVarChange(hBrevityFlags, ConVarChange_BrevityFlags);
	if (!iBrevityFlags & 4)
	{
		bTrackFF = true;
	}
	hRUPActive = FindConVar("l4d_ready_enabled");
	if (hRUPActive)
	{
		bRUPActive = GetConVarBool(hRUPActive);
		HookConVarChange(hRUPActive, ConVarChange_RUPActive);
	}
	else
	{
		bRUPActive = false;
	}
	bPlayerLeftStartArea = 0;
	RegConsoleCmd("sm_mvp", SurvivorMVP_Cmd, "Prints the current MVP for the survivor team", 0);
	RegConsoleCmd("sm_mvpme", ShowMVPStats_Cmd, "Prints the client's own MVP-related stats", 0);
	RegConsoleCmd("say", Say_Cmd, "", 0);
	RegConsoleCmd("say_team", Say_Cmd, "", 0);
	return 0;
}

public OnClientPutInServer(client)
{
	decl String:tmpBuffer[64];
	GetClientName(client, tmpBuffer, 64);
	if (strcmp(tmpBuffer, sClientName[client], true))
	{
		iGotKills[client] = 0;
		iGotCommon[client] = 0;
		iDidDamage[client] = 0;
		iDidDamageAll[client] = 0;
		iDidDamageWitch[client] = 0;
		iDidDamageTank[client] = 0;
		iDidFF[client] = 0;
		new siClass = 1;
		while (siClass <= 8)
		{
			iDidDamageClass[client][siClass] = 0;
			timesPinned[client][siClass] = 0;
			siClass++;
		}
		pillsUsed[client] = 0;
		boomerPops[client] = 0;
		damageReceived[client] = 0;
		totalPinned[client] = 0;
		commonKilledDuringTank[client] = 0;
		siDmgDuringTank[client] = 0;
		rocksEaten[client] = 0;
		ttlPinnedDuringTank[client] = 0;
		strcopy(sClientName[client], 64, tmpBuffer);
	}
	return 0;
}

public ConVarChange_CountTankDamage(Handle:cvar, String:oldValue[], String:newValue[])
{
	bCountTankDamage = StringToInt(newValue, 10) != 0;
	return 0;
}

public ConVarChange_CountWitchDamage(Handle:cvar, String:oldValue[], String:newValue[])
{
	bCountWitchDamage = StringToInt(newValue, 10) != 0;
	return 0;
}

public ConVarChange_TrackFF(Handle:cvar, String:oldValue[], String:newValue[])
{
	return 0;
}

public ConVarChange_BrevityFlags(Handle:cvar, String:oldValue[], String:newValue[])
{
	iBrevityFlags = StringToInt(newValue, 10);
	if (!iBrevityFlags & 4)
	{
		bTrackFF = true;
	}
	return 0;
}

public ConVarChange_RUPActive(Handle:cvar, String:oldValue[], String:newValue[])
{
	bRUPActive = StringToInt(newValue, 10) != 0;
	return 0;
}

public Action:PlayerLeftStartArea(Handle:event, String:name[], bool:dontBroadcast)
{
	bPlayerLeftStartArea = 1;
	return Action:0;
}

public OnMapStart()
{
	bPlayerLeftStartArea = 0;
	GetConVarString(hGameMode, sGameMode, 24);
	return 0;
}

public OnMapEnd()
{
	iRoundNumber = 0;
	bInRound = 0;
	return 0;
}

public ScavRoundStart(Handle:event)
{
	new i;
	new maxplayers = MaxClients;
	i = 1;
	while (i <= maxplayers)
	{
		iGotKills[i] = 0;
		iGotCommon[i] = 0;
		iDidDamage[i] = 0;
		iDidDamageAll[i] = 0;
		iDidDamageWitch[i] = 0;
		iDidDamageTank[i] = 0;
		iDidFF[i] = 0;
		new siClass = 1;
		while (siClass <= 8)
		{
			iDidDamageClass[i][siClass] = 0;
			timesPinned[i][siClass] = 0;
			siClass++;
		}
		pillsUsed[i] = 0;
		boomerPops[i] = 0;
		damageReceived[i] = 0;
		totalPinned[i] = 0;
		commonKilledDuringTank[i] = 0;
		siDmgDuringTank[i] = 0;
		rocksEaten[i] = 0;
		ttlPinnedDuringTank[i] = 0;
		i++;
	}
	iTotalKills = 0;
	iTotalCommon = 0;
	iTotalDamage = 0;
	iTotalDamageTank = 0;
	iTotalDamageWitch = 0;
	iTotalDamageAll = 0;
	iTotalFF = 0;
	ttlSiDmgDuringTank = 0;
	ttlCommonKilledDuringTank = 0;
	tankThrow = 0;
	bInRound = 1;
	tankSpawned = 0;
	return 0;
}

public RoundStart_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	bPlayerLeftStartArea = 0;
	if (!bInRound)
	{
		bInRound = 1;
		iRoundNumber += 1;
	}
	new i;
	new maxplayers = MaxClients;
	i = 1;
	while (i <= maxplayers)
	{
		iGotKills[i] = 0;
		iGotCommon[i] = 0;
		iDidDamage[i] = 0;
		iDidDamageAll[i] = 0;
		iDidDamageWitch[i] = 0;
		iDidDamageTank[i] = 0;
		iDidFF[i] = 0;
		new siClass = 1;
		while (siClass <= 8)
		{
			iDidDamageClass[i][siClass] = 0;
			timesPinned[i][siClass] = 0;
			siClass++;
		}
		pillsUsed[i] = 0;
		boomerPops[i] = 0;
		damageReceived[i] = 0;
		totalPinned[i] = 0;
		commonKilledDuringTank[i] = 0;
		siDmgDuringTank[i] = 0;
		rocksEaten[i] = 0;
		ttlPinnedDuringTank[i] = 0;
		i++;
	}
	iTotalKills = 0;
	iTotalCommon = 0;
	iTotalDamage = 0;
	iTotalDamageAll = 0;
	iTotalFF = 0;
	ttlSiDmgDuringTank = 0;
	ttlCommonKilledDuringTank = 0;
	iTotalDamageTank = 0;
	tankThrow = 0;
	tankSpawned = 0;
	return 0;
}

public RoundEnd_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	if (StrEqual(sGameMode, "scavenge", false))
	{
		if (bInRound)
		{
			if (GetConVarBool(hPluginEnabled))
			{
				CreateTimer(2.0, delayedMVPPrint, any:0, 0);
			}
			bInRound = 0;
		}
	}
	else
	{
		if (bInRound)
		{
			if (GetConVarBool(hPluginEnabled))
			{
				CreateTimer(2.0, delayedMVPPrint, any:0, 0);
			}
			bInRound = 0;
		}
	}
	tankSpawned = 0;
	return 0;
}

public Action:Say_Cmd(client, args)
{
	if (!client)
	{
		return Action:0;
	}
	decl String:sMessage[32];
	GetCmdArg(1, sMessage, 32);
	new var1;
	if (StrEqual(sMessage, "!mvp", true) || StrEqual(sMessage, "!mvpme", true))
	{
		return Action:3;
	}
	return Action:0;
}

public Action:SurvivorMVP_Cmd(client, args)
{
	new var2;
	new var3 = 0;
	GetMVPString();
	new intPieces = ExplodeString(var2, "\n", var3, 8, 192, false);
	new var1;
	if (client && IsClientConnected(client))
	{
		new i;
		while (i < intPieces)
		{
			CPrintToChat(client, "%s", var3[i]);
			i++;
		}
	}
	else
	{
		PrintToServer("\x01%s", var2);
	}
	PrintLoserz(true, client);
	return Action:0;
}

public Action:ShowMVPStats_Cmd(client, args)
{
	PrintLoserz(true, client);
	return Action:0;
}

public Action:delayedMVPPrint(Handle:timer)
{
	new var1;
	new var2 = 0;
	GetMVPString();
	PrintToServer("\x01%s", var1);
	new intPieces = ExplodeString(var1, "\n", var2, 8, 192, false);
	new i;
	while (i < intPieces)
	{
		new client = 1;
		while (client <= MaxClients)
		{
			if (IsClientInGame(client))
			{
				CPrintToChat(client, "{default}%s", var2[i]);
			}
			client++;
		}
		i++;
	}
	CreateTimer(0.1, PrintLosers, any:0, 0);
	return Action:0;
}

public Action:PrintLosers(Handle:timer)
{
	PrintLoserz(false, -1);
	return Action:0;
}

PrintLoserz(bool:bSolo, client)
{
	decl String:tmpBuffer[512];
	if (0 < iTotalDamageAll)
	{
		new mvp_SI = findMVPSI(0, 0, 0);
		new mvp_SI_losers[3];
		mvp_SI_losers[0] = findMVPSI(mvp_SI, 0, 0);
		mvp_SI_losers[1] = findMVPSI(mvp_SI, mvp_SI_losers[0], 0);
		mvp_SI_losers[2] = findMVPSI(mvp_SI, mvp_SI_losers[0], mvp_SI_losers[1]);
		new i;
		while (i <= 2)
		{
			new var1;
			if (IsClientAndInGame(mvp_SI_losers[i]) && !IsFakeClient(mvp_SI_losers[i]))
			{
				if (bSolo)
				{
					if (client == mvp_SI_losers[i])
					{
						Format(tmpBuffer, 512, "{blue}Your Rank {green}SI: {olive}#%d - {blue}({default}%d {green}dmg {blue}[{default}%.0f%%{blue}]{olive}, {default}%d {green}kills {blue}[{default}%.0f%%{blue}])", i + 2, iDidDamageAll[mvp_SI_losers[i]], float(iDidDamageAll[mvp_SI_losers[i]]) / float(iTotalDamageAll) * 100, iGotKills[mvp_SI_losers[i]], float(iGotKills[mvp_SI_losers[i]]) / float(iTotalKills) * 100);
						CPrintToChat(mvp_SI_losers[i], "%s", tmpBuffer);
					}
				}
				Format(tmpBuffer, 512, "{blue}Your Rank {green}SI: {olive}#%d - {blue}({default}%d {green}dmg {blue}[{default}%.0f%%{blue}]{olive}, {default}%d {green}kills {blue}[{default}%.0f%%{blue}])", i + 2, iDidDamageAll[mvp_SI_losers[i]], float(iDidDamageAll[mvp_SI_losers[i]]) / float(iTotalDamageAll) * 100, iGotKills[mvp_SI_losers[i]], float(iGotKills[mvp_SI_losers[i]]) / float(iTotalKills) * 100);
				CPrintToChat(mvp_SI_losers[i], "%s", tmpBuffer);
			}
			i++;
		}
	}
	if (0 < iTotalCommon)
	{
		new mvp_CI = findMVPCommon(0, 0, 0);
		new mvp_CI_losers[3];
		mvp_CI_losers[0] = findMVPCommon(mvp_CI, 0, 0);
		mvp_CI_losers[1] = findMVPCommon(mvp_CI, mvp_CI_losers[0], 0);
		mvp_CI_losers[2] = findMVPCommon(mvp_CI, mvp_CI_losers[0], mvp_CI_losers[1]);
		new i;
		while (i <= 2)
		{
			new var2;
			if (IsClientAndInGame(mvp_CI_losers[i]) && !IsFakeClient(mvp_CI_losers[i]))
			{
				if (bSolo)
				{
					if (client == mvp_CI_losers[i])
					{
						Format(tmpBuffer, 512, "{blue}Your Rank {green}CI{default}: {olive}#%d {blue}({default}%d {green}common {blue}[{default}%.0f%%{blue}])", i + 2, iGotCommon[mvp_CI_losers[i]], float(iGotCommon[mvp_CI_losers[i]]) / float(iTotalCommon) * 100);
						CPrintToChat(mvp_CI_losers[i], "%s", tmpBuffer);
					}
				}
				Format(tmpBuffer, 512, "{blue}Your Rank {green}CI{default}: {olive}#%d {blue}({default}%d {green}common {blue}[{default}%.0f%%{blue}])", i + 2, iGotCommon[mvp_CI_losers[i]], float(iGotCommon[mvp_CI_losers[i]]) / float(iTotalCommon) * 100);
				CPrintToChat(mvp_CI_losers[i], "%s", tmpBuffer);
			}
			i++;
		}
	}
	if (0 < iTotalFF)
	{
		new mvp_FF = findLVPFF(0, 0, 0);
		new mvp_FF_losers[3];
		mvp_FF_losers[0] = findLVPFF(mvp_FF, 0, 0);
		mvp_FF_losers[1] = findLVPFF(mvp_FF, mvp_FF_losers[0], 0);
		mvp_FF_losers[2] = findLVPFF(mvp_FF, mvp_FF_losers[0], mvp_FF_losers[1]);
		new i;
		while (i <= 2)
		{
			new var3;
			if (IsClientAndInGame(mvp_FF_losers[i]) && !IsFakeClient(mvp_FF_losers[i]))
			{
				if (bSolo)
				{
					if (client == mvp_FF_losers[i])
					{
						Format(tmpBuffer, 512, "{blue}Your Rank {green}FF{default}: {olive}#%d {blue}({default}%d {green}friendly fire {blue}[{default}%.0f%%{blue}])", i + 2, iDidFF[mvp_FF_losers[i]], float(iDidFF[mvp_FF_losers[i]]) / float(iTotalFF) * 100);
						CPrintToChat(mvp_FF_losers[i], "%s", tmpBuffer);
					}
				}
				Format(tmpBuffer, 512, "{blue}Your Rank {green}FF{default}: {olive}#%d {blue}({default}%d {green}friendly fire {blue}[{default}%.0f%%{blue}])", i + 2, iDidFF[mvp_FF_losers[i]], float(iDidFF[mvp_FF_losers[i]]) / float(iTotalFF) * 100);
				CPrintToChat(mvp_FF_losers[i], "%s", tmpBuffer);
			}
			i++;
		}
	}
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	if (!tankThrow)
	{
		return 0;
	}
	if (StrEqual(classname, "tank_rock", true))
	{
		rockIndex = entity;
		tankThrow = 1;
	}
	return 0;
}

public OnEntityDestroyed(entity)
{
	if (entity == rockIndex)
	{
		tankThrow = 0;
	}
	return 0;
}

public Action:abilityUseEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	decl String:ability[32];
	GetEventString(event, "ability", ability, 32);
	if (StrEqual(ability, "ability_throw", true))
	{
		tankThrow = 1;
	}
	return Action:0;
}

public pillsUsedEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (client && !IsClientInGame(client))
	{
		return 0;
	}
	pillsUsed[client]++;
	return 0;
}

public boomerExploded(Handle:event, String:name[], bool:dontBroadcast)
{
	new bool:biled = GetEventBool(event, "splashedbile");
	if (!biled)
	{
		new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
		new var1;
		if (attacker && !IsClientInGame(attacker))
		{
			return 0;
		}
		boomerPops[attacker]++;
	}
	return 0;
}

public chargerCarryEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new var1;
	if (client && !IsClientInGame(client))
	{
		return 0;
	}
	timesPinned[client][6]++;
	totalPinned[client]++;
	if (tankSpawned)
	{
		ttlPinnedDuringTank[client]++;
	}
	return 0;
}

public jockeyRide(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new var1;
	if (client && !IsClientInGame(client))
	{
		return 0;
	}
	timesPinned[client][5]++;
	totalPinned[client]++;
	if (tankSpawned)
	{
		ttlPinnedDuringTank[client]++;
	}
	return 0;
}

public hunterLunged(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new var1;
	if (client && !IsClientInGame(client))
	{
		return 0;
	}
	timesPinned[client][3]++;
	totalPinned[client]++;
	if (tankSpawned)
	{
		ttlPinnedDuringTank[client]++;
	}
	return 0;
}

public smokerChoke(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "victim"));
	new var1;
	if (client && !IsClientInGame(client))
	{
		return 0;
	}
	timesPinned[client][1]++;
	totalPinned[client]++;
	if (tankSpawned)
	{
		ttlPinnedDuringTank[client]++;
	}
	return 0;
}

public tankSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	tankSpawned = 1;
	return 0;
}

public tankKilled(Handle:event, String:name[], bool:dontBroadcast)
{
	tankSpawned = 0;
	return 0;
}

public PlayerHurt_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new zombieClass;
	new victimId = GetEventInt(event, "userid");
	new victim = GetClientOfUserId(victimId);
	new attackerId = GetEventInt(event, "attacker");
	new attacker = GetClientOfUserId(attackerId);
	new damageDone = GetEventInt(event, "dmg_health");
	new var1;
	if (victimId && attackerId && IsClientAndInGame(victim) && IsClientAndInGame(attacker))
	{
		new var2;
		if (GetClientTeam(attacker) == 2 && GetClientTeam(victim) == 3)
		{
			zombieClass = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
			new var9 = iDidDamageClass[attacker][zombieClass];
			var9 = var9[damageDone];
			new var3;
			if (zombieClass >= 1 && zombieClass < 7)
			{
				if (tankSpawned)
				{
					new var10 = siDmgDuringTank[attacker];
					var10 = var10[damageDone];
					ttlSiDmgDuringTank = damageDone + ttlSiDmgDuringTank;
				}
				new var11 = iDidDamage[attacker];
				var11 = var11[damageDone];
				new var12 = iDidDamageAll[attacker];
				var12 = var12[damageDone];
				iTotalDamage = damageDone + iTotalDamage;
				iTotalDamageAll = damageDone + iTotalDamageAll;
			}
			else
			{
				new var4;
				if (zombieClass == 8 && damageDone != 5000)
				{
					new var13 = iDidDamageTank[attacker];
					var13 = var13[damageDone];
					iTotalDamageTank = damageDone + iTotalDamageTank;
					if (bCountTankDamage)
					{
						new var14 = iDidDamageAll[attacker];
						var14 = var14[damageDone];
						iTotalDamageAll = damageDone + iTotalDamageAll;
					}
				}
			}
		}
		new var5;
		if (GetClientTeam(attacker) == 2 && GetClientTeam(victim) == 2 && bTrackFF)
		{
			new var6;
			if (!bRUPActive || GetEntityMoveType(victim) || bPlayerLeftStartArea)
			{
				new var15 = iDidFF[attacker];
				var15 = var15[damageDone];
				iTotalFF = damageDone + iTotalFF;
			}
		}
		new var7;
		if (GetClientTeam(attacker) == 3 && GetClientTeam(victim) == 2)
		{
			zombieClass = GetEntProp(attacker, PropType:0, "m_zombieClass", 4, 0);
			new var8;
			if (tankThrow && zombieClass == 8 && damageDone == 24)
			{
				rocksEaten[victim]++;
			}
			new var16 = damageReceived[victim];
			var16 = var16[damageDone];
		}
	}
	return 0;
}

public InfectedHurt_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new victimEntId = GetEventInt(event, "entityid");
	if (IsWitch(victimEntId))
	{
		new attackerId = GetEventInt(event, "attacker");
		new attacker = GetClientOfUserId(attackerId);
		new damageDone = GetEventInt(event, "amount");
		new var1;
		if (attackerId && IsClientAndInGame(attacker) && GetClientTeam(attacker) == 2)
		{
			new var2 = iDidDamageWitch[attacker];
			var2 = var2[damageDone];
			iTotalDamageWitch = damageDone + iTotalDamageWitch;
			if (bCountWitchDamage)
			{
				new var3 = iDidDamageAll[attacker];
				var3 = var3[damageDone];
				iTotalDamageAll = damageDone + iTotalDamageAll;
			}
		}
	}
	return 0;
}

public PlayerDeath_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new zombieClass;
	new victimId = GetEventInt(event, "userid");
	new victim = GetClientOfUserId(victimId);
	new attackerId = GetEventInt(event, "attacker");
	new attacker = GetClientOfUserId(attackerId);
	new var1;
	if (victimId && attackerId && IsClientAndInGame(victim) && IsClientAndInGame(attacker) && GetClientTeam(attacker) == 2)
	{
		zombieClass = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
		new var2;
		if (zombieClass >= 1 && zombieClass < 7)
		{
			iGotKills[attacker]++;
			iTotalKills += 1;
		}
	}
	new var3;
	if (victimId && IsClientAndInGame(victim))
	{
		zombieClass = GetEntProp(victim, PropType:0, "m_zombieClass", 4, 0);
		if (zombieClass == 8)
		{
			tankSpawned = 0;
		}
	}
	return 0;
}

public bool:isHunter(zombieClass)
{
	return zombieClass == 3;
}

public InfectedDeath_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new attackerId = GetEventInt(event, "attacker");
	new attacker = GetClientOfUserId(attackerId);
	new var1;
	if (attackerId && IsClientAndInGame(attacker) && GetClientTeam(attacker) == 2)
	{
		if (tankSpawned)
		{
			commonKilledDuringTank[attacker]++;
			ttlCommonKilledDuringTank += 1;
		}
		iGotCommon[attacker]++;
		iTotalCommon += 1;
	}
	return 0;
}

String:GetMVPString(_arg0)
{
	new String:printBuffer[4096] = "";
	decl String:tmpBuffer[1024];
	decl String:tmpName[64];
	new String:mvp_SI_name[64] = "(nobody)";
	new String:mvp_Common_name[64] = "(nobody)";
	new String:mvp_FF_name[64] = "(nobody)";
	new mvp_SI;
	new mvp_Common;
	new mvp_FF;
	if (!iBrevityFlags & 1)
	{
		mvp_SI = findMVPSI(0, 0, 0);
		if (0 < mvp_SI)
		{
			if (IsClientConnected(mvp_SI))
			{
				GetClientName(mvp_SI, tmpName, 64);
				if (IsFakeClient(mvp_SI))
				{
					StrCat(tmpName, 64, " \x01[BOT]");
				}
			}
			else
			{
				strcopy(tmpName, 64, sClientName[mvp_SI]);
			}
		}
	}
	if (!iBrevityFlags & 2)
	{
		mvp_Common = findMVPCommon(0, 0, 0);
		if (0 < mvp_Common)
		{
			if (IsClientConnected(mvp_Common))
			{
				GetClientName(mvp_Common, tmpName, 64);
				if (IsFakeClient(mvp_Common))
				{
					StrCat(tmpName, 64, " \x01[BOT]");
				}
			}
			else
			{
				strcopy(tmpName, 64, sClientName[mvp_Common]);
			}
		}
	}
	new var1;
	if (!iBrevityFlags & 4 && bTrackFF)
	{
		mvp_FF = findLVPFF(0, 0, 0);
		if (0 < mvp_FF)
		{
			if (IsClientConnected(mvp_FF))
			{
				GetClientName(mvp_FF, tmpName, 64);
				if (IsFakeClient(mvp_FF))
				{
					StrCat(tmpName, 64, " \x01[BOT]");
				}
			}
			else
			{
				strcopy(tmpName, 64, sClientName[mvp_FF]);
			}
		}
	}
	new var3;
	if (mvp_SI && mvp_Common && (iBrevityFlags & 1 && iBrevityFlags & 2))
	{
		Format(tmpBuffer, 1024, "{blue}[{default}MVP{blue}]{default} {blue}({default}not enough action yet{blue}){default}\n");
		StrCat(printBuffer, 4096, tmpBuffer);
	}
	else
	{
		if (!iBrevityFlags & 1)
		{
			if (0 < mvp_SI)
			{
				if (iBrevityFlags & 32)
				{
					Format(tmpBuffer, 1024, "[MVP] SI:\x03 %s \x01(\x05%d \x01dmg,\x05 %d \x01kills)\n", mvp_SI_name, iDidDamageAll[mvp_SI], iGotKills[mvp_SI]);
				}
				else
				{
					if (iBrevityFlags & 64)
					{
						Format(tmpBuffer, 1024, "[MVP] SI:\x03 %s \x01(dmg \x04%2.0f%%\x01, kills \x04%.0f%%\x01)\n", mvp_SI_name, float(iDidDamageAll[mvp_SI]) / float(iTotalDamageAll) * 100, float(iGotKills[mvp_SI]) / float(iTotalKills) * 100);
					}
					Format(tmpBuffer, 1024, "{blue}[{default}MVP{blue}] SI: {olive}%s {blue}({default}%d {green}dmg {blue}[{default}%.0f%%{blue}]{olive}, {default}%d {green}kills {blue}[{default}%.0f%%{blue}])\n", mvp_SI_name, iDidDamageAll[mvp_SI], float(iDidDamageAll[mvp_SI]) / float(iTotalDamageAll) * 100, iGotKills[mvp_SI], float(iGotKills[mvp_SI]) / float(iTotalKills) * 100);
				}
				StrCat(printBuffer, 4096, tmpBuffer);
			}
			StrCat(printBuffer, 4096, "{blue}[{default}MVP{blue}] SI: {blue}({default}nobody{blue}){default}\n");
		}
		if (!iBrevityFlags & 2)
		{
			if (0 < mvp_Common)
			{
				if (iBrevityFlags & 32)
				{
					Format(tmpBuffer, 1024, "[MVP] CI:\x03 %s \x01(\x05%d \x01common)\n", mvp_Common_name, iGotCommon[mvp_Common]);
				}
				else
				{
					if (iBrevityFlags & 64)
					{
						Format(tmpBuffer, 1024, "[MVP] CI:\x03 %s \x01(\x04%.0f%%\x01)\n", mvp_Common_name, float(iGotCommon[mvp_Common]) / float(iTotalCommon) * 100);
					}
					Format(tmpBuffer, 1024, "{blue}[{default}MVP{blue}] CI: {olive}%s {blue}({default}%d {green}common {blue}[{default}%.0f%%{blue}])\n", mvp_Common_name, iGotCommon[mvp_Common], float(iGotCommon[mvp_Common]) / float(iTotalCommon) * 100);
				}
				StrCat(printBuffer, 4096, tmpBuffer);
			}
		}
	}
	new var4;
	if (!iBrevityFlags & 4 && bTrackFF)
	{
		if (mvp_FF)
		{
			if (iBrevityFlags & 32)
			{
				Format(tmpBuffer, 1024, "[LVP] FF:\x03 %s \x01(\x05%d \x01dmg)\n", mvp_FF_name, iDidFF[mvp_FF]);
			}
			else
			{
				if (iBrevityFlags & 64)
				{
					Format(tmpBuffer, 1024, "[LVP] FF:\x03 %s \x01(\x04%.0f%%\x01)\n", mvp_FF_name, float(iDidFF[mvp_FF]) / float(iTotalFF) * 100);
				}
				Format(tmpBuffer, 1024, "{blue}[{default}LVP{blue}] FF{default}: {olive}%s {blue}({default}%d {green}friendly fire {blue}[{default}%.0f%%{blue}]){default}\n", mvp_FF_name, iDidFF[mvp_FF], float(iDidFF[mvp_FF]) / float(iTotalFF) * 100);
			}
			StrCat(printBuffer, 4096, tmpBuffer);
		}
		Format(tmpBuffer, 1024, "{blue}[{default}LVP{blue}] FF{default}: {green}no friendly fire at all!{default}\n");
		StrCat(printBuffer, 4096, tmpBuffer);
	}
	return printBuffer;
}

findMVPSI(excludeMeA, excludeMeB, excludeMeC)
{
	new i;
	new maxIndex;
	i = 1;
	while (i < 66)
	{
		new var1;
		if (iDidDamageAll[i] > iDidDamageAll[maxIndex] && excludeMeA != i && excludeMeB != i && excludeMeC != i)
		{
			maxIndex = i;
		}
		i++;
	}
	return maxIndex;
}

findMVPCommon(excludeMeA, excludeMeB, excludeMeC)
{
	new i;
	new maxIndex;
	i = 1;
	while (i < 66)
	{
		new var1;
		if (iGotCommon[i] > iGotCommon[maxIndex] && excludeMeA != i && excludeMeB != i && excludeMeC != i)
		{
			maxIndex = i;
		}
		i++;
	}
	return maxIndex;
}

findLVPFF(excludeMeA, excludeMeB, excludeMeC)
{
	new i;
	new maxIndex;
	i = 1;
	while (i < 66)
	{
		new var1;
		if (iDidFF[i] > iDidFF[maxIndex] && excludeMeA != i && excludeMeB != i && excludeMeC != i)
		{
			maxIndex = i;
		}
		i++;
	}
	return maxIndex;
}

bool:IsClientAndInGame(index)
{
	new var1;
	return index > 0 && index <= MaxClients && IsClientInGame(index);
}

bool:IsWitch(iEntity)
{
	new var1;
	if (iEntity > 0 && IsValidEntity(iEntity) && IsValidEdict(iEntity))
	{
		decl String:strClassName[64];
		GetEdictClassname(iEntity, strClassName, 64);
		return StrEqual(strClassName, "witch", true);
	}
	return false;
}

public stripUnicode(String:testString[32])
{
	new maxlength = 32;
	new uni;
	new currentChar;
	new tmpCharLength;
	new i;
	while (i < maxlength + -3 && sTmpString[i])
	{
		if (sTmpString[i] & 128)
		{
			new var2;
			if (sTmpString[i] & 224 == 192 && sTmpString[i + 1] & 192 == 128)
			{
				i++;
				currentChar = sTmpString[i] & 31;
				currentChar <<= 6;
				currentChar = sTmpString[i] & 63 + currentChar;
				tmpCharLength = 1;
			}
			new var3;
			if (sTmpString[i] & 240 == 224 && sTmpString[i + 1] & 192 == 128 && sTmpString[i + 2] & 192 == 128)
			{
				i++;
				currentChar = sTmpString[i] & 15;
				currentChar <<= 6;
				i++;
				currentChar = sTmpString[i] & 63 + currentChar;
				currentChar <<= 6;
				currentChar = sTmpString[i] & 63 + currentChar;
				tmpCharLength = 2;
			}
			new var4;
			if (sTmpString[i] & 248 == 240 && sTmpString[i + 1] & 192 == 128 && sTmpString[i + 2] & 192 == 128 && sTmpString[i + 3] & 192 == 128)
			{
				i++;
				currentChar = sTmpString[i] & 7;
				currentChar <<= 6;
				i++;
				currentChar = sTmpString[i] & 63 + currentChar;
				currentChar <<= 6;
				i++;
				currentChar = sTmpString[i] & 63 + currentChar;
				currentChar <<= 6;
				currentChar = sTmpString[i] & 63 + currentChar;
				tmpCharLength = 3;
			}
			currentChar = 161;
			tmpCharLength = 0;
		}
		else
		{
			currentChar = sTmpString[i];
			tmpCharLength = 0;
		}
		if (currentChar > 160)
		{
			uni++;
			new j = tmpCharLength;
			while (0 <= j)
			{
				sTmpString[i - j] = 95;
				j--;
			}
		}
		i++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.7.3-dev+5320",
	date = "12/30/2018",
	time = "14:18:00"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new bool:bTimerCheater[66];
new Handle:hCvarServerMessage;
public Plugin:myinfo =
{
	name = "sv_consistency fixes",
	description = "Fixes multiple sv_consistency issues.",
	author = "step, Sir",
	version = "1.3",
	url = "http://step.l4dnation.com/"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("BfWrite.WriteBool");
	MarkNativeAsOptional("BfWrite.WriteByte");
	MarkNativeAsOptional("BfWrite.WriteChar");
	MarkNativeAsOptional("BfWrite.WriteShort");
	MarkNativeAsOptional("BfWrite.WriteWord");
	MarkNativeAsOptional("BfWrite.WriteNum");
	MarkNativeAsOptional("BfWrite.WriteFloat");
	MarkNativeAsOptional("BfWrite.WriteString");
	MarkNativeAsOptional("BfWrite.WriteEntity");
	MarkNativeAsOptional("BfWrite.WriteAngle");
	MarkNativeAsOptional("BfWrite.WriteCoord");
	MarkNativeAsOptional("BfWrite.WriteVecCoord");
	MarkNativeAsOptional("BfWrite.WriteVecNormal");
	MarkNativeAsOptional("BfWrite.WriteAngles");
	MarkNativeAsOptional("BfRead.ReadBool");
	MarkNativeAsOptional("BfRead.ReadByte");
	MarkNativeAsOptional("BfRead.ReadChar");
	MarkNativeAsOptional("BfRead.ReadShort");
	MarkNativeAsOptional("BfRead.ReadWord");
	MarkNativeAsOptional("BfRead.ReadNum");
	MarkNativeAsOptional("BfRead.ReadFloat");
	MarkNativeAsOptional("BfRead.ReadString");
	MarkNativeAsOptional("BfRead.ReadEntity");
	MarkNativeAsOptional("BfRead.ReadAngle");
	MarkNativeAsOptional("BfRead.ReadCoord");
	MarkNativeAsOptional("BfRead.ReadVecCoord");
	MarkNativeAsOptional("BfRead.ReadVecNormal");
	MarkNativeAsOptional("BfRead.ReadAngles");
	MarkNativeAsOptional("BfRead.GetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	MarkNativeAsOptional("Protobuf.ReadInt");
	MarkNativeAsOptional("Protobuf.ReadFloat");
	MarkNativeAsOptional("Protobuf.ReadBool");
	MarkNativeAsOptional("Protobuf.ReadString");
	MarkNativeAsOptional("Protobuf.ReadColor");
	MarkNativeAsOptional("Protobuf.ReadAngle");
	MarkNativeAsOptional("Protobuf.ReadVector");
	MarkNativeAsOptional("Protobuf.ReadVector2D");
	MarkNativeAsOptional("Protobuf.GetRepeatedFieldCount");
	MarkNativeAsOptional("Protobuf.SetInt");
	MarkNativeAsOptional("Protobuf.SetFloat");
	MarkNativeAsOptional("Protobuf.SetBool");
	MarkNativeAsOptional("Protobuf.SetString");
	MarkNativeAsOptional("Protobuf.SetColor");
	MarkNativeAsOptional("Protobuf.SetAngle");
	MarkNativeAsOptional("Protobuf.SetVector");
	MarkNativeAsOptional("Protobuf.SetVector2D");
	MarkNativeAsOptional("Protobuf.AddInt");
	MarkNativeAsOptional("Protobuf.AddFloat");
	MarkNativeAsOptional("Protobuf.AddBool");
	MarkNativeAsOptional("Protobuf.AddString");
	MarkNativeAsOptional("Protobuf.AddColor");
	MarkNativeAsOptional("Protobuf.AddAngle");
	MarkNativeAsOptional("Protobuf.AddVector");
	MarkNativeAsOptional("Protobuf.AddVector2D");
	MarkNativeAsOptional("Protobuf.RemoveRepeatedFieldValue");
	MarkNativeAsOptional("Protobuf.ReadMessage");
	MarkNativeAsOptional("Protobuf.ReadRepeatedMessage");
	MarkNativeAsOptional("Protobuf.AddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public void:OnPluginStart()
{
	if (!FileExists("whitelist.cfg", false, "GAME"))
	{
		SetFailState("Couldn't find whitelist.cfg");
	}
	hCvarServerMessage = CreateConVar("soundm_server_message", "a SoundM Protected Server", "Message to show to Players in console", 0, false, 0.0, false, 0.0);
	HookEvent("player_connect_full", Event_PlayerConnectFull, EventHookMode:1);
	RegAdminCmd("sm_consistencycheck", Command_ConsistencyCheck, 4096, "Performs a consistency check on all players.", "", 262144);
	SetConVarInt(CreateConVar("cl_consistencycheck_interval", "180.0", "Perform a consistency check after this amount of time (seconds) has passed since the last.", 8194, false, 0.0, false, 0.0), 999999, false, false);
	return void:0;
}

public Action:Event_PlayerConnectFull(Handle:event, String:name[], bool:dontBroadcast)
{
	CreateTimer(0.1, PrintWhitelist, GetClientOfUserId(GetEventInt(event, "userid", 0)), 0);
	return Action:0;
}

public Action:PrintWhitelist(Handle:timer, any:client)
{
	new String:sMessage[128];
	GetConVarString(hCvarServerMessage, sMessage, 128);
	PrintToConsole(client, " ");
	PrintToConsole(client, " ");
	PrintToConsole(client, "// -------------------------------- \");
	PrintToConsole(client, "/| --> Welcome to %s <--", sMessage);
	PrintToConsole(client, "|");
	PrintToConsole(client, "| Your Sound Files have been checked.");
	PrintToConsole(client, "| Don't be a filthy Cheater.");
	PrintToConsole(client, "| Enjoy your Stay, or don't.");
	PrintToConsole(client, "|");
	PrintToConsole(client, "/| --> Welcome to %s <--", sMessage);
	PrintToConsole(client, "// -------------------------------- \");
	PrintToConsole(client, " ");
	PrintToConsole(client, " ");
	return Action:0;
}

public Action:Command_ConsistencyCheck(client, args)
{
	if (args < 1)
	{
		ConsistencyCheck(0);
		return Action:3;
	}
	new String:sPlayer[32];
	GetCmdArg(1, sPlayer, 32);
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientConnected(i))
		{
			new String:sOther[32];
			GetClientName(i, sOther, 32);
			if (StrEqual(sPlayer, sOther, false))
			{
				ConsistencyCheck(i);
			}
		}
		i++;
	}
	return Action:3;
}

public ConsistencyCheck(client)
{
	if (!client)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && !IsFakeClient(i))
			{
				ClientCommand(i, "cl_consistencycheck");
				bTimerCheater[client] = 1;
				CreateTimer(1.0, CheaterBoi, client, 0);
			}
			i++;
		}
		return 0;
	}
	ClientCommand(client, "cl_consistencycheck");
	bTimerCheater[client] = 1;
	CreateTimer(1.0, CheaterBoi, client, 0);
	return 0;
}

public Action:CheaterBoi(Handle:timer, any:client)
{
	bTimerCheater[client] = 0;
	return Action:0;
}

public void:OnClientConnected(client)
{
	ClientCommand(client, "cl_consistencycheck");
	return void:0;
}

public void:OnClientDisconnect(client)
{
	if (bTimerCheater[client])
	{
		PrintToChatAll("{blue}[{default}SoundM{blue}]{default}: Modified Sound Files detected on {olive}%N", client);
		bTimerCheater[client] = 0;
	}
	return void:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "12/10/2015",
	time = "12:51:34"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new bool:IsPlantation;
public Plugin:myinfo =
{
	name = "Swamp Finale Fix",
	description = "Fix swamp finale breaking for 2nd team",
	author = "Jacob",
	version = "0.1",
	url = "https://github.com/jacob404/Pro-Mod-4.0/releases/latest"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

public OnPluginStart()
{
	HookEvent("round_end", Event_RoundEnd, EventHookMode:1);
	return 0;
}

public OnMapStart()
{
	decl String:mapname[64];
	GetCurrentMap(mapname, 64);
	if (StrEqual(mapname, "c3m4_plantation", true))
	{
		IsPlantation = true;
	}
	else
	{
		IsPlantation = false;
	}
	return 0;
}

public Event_RoundEnd(Handle:event, String:name[], bool:dontBroadcast)
{
	new FinaleEntity;
	while ((FinaleEntity = FindEntityByClassname(FinaleEntity, "trigger_finale")) != -1)
	{
		new var1;
		if (!(!IsValidEdict(FinaleEntity) || !IsValidEntity(FinaleEntity) || !IsPlantation))
		{
			AcceptEntityInput(FinaleEntity, "ForceFinaleStart", -1, -1, 0);
		}
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "12/24/2016",
	time = "10:52:57"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
new tankCount;
new Float:nextTankPunchAllowed[19];
new tankClassIndex;
public Plugin:myinfo =
{
	name = "TankDoorFix",
	description = "This should at some point fix the case in which the tank misses the door he's supposed to destroy by using his punch",
	author = "PP(R)TH: Dr. Gregory House",
	version = "1.4",
	url = "http://forums.alliedmods.net/showthread.php?t=225087"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

SubtractVectors(Float:vec1[3], Float:vec2[3], Float:result[3])
{
	result[0] = vec1[0] - vec2[0];
	result[1] = vec1[1] - vec2[1];
	result[2] = vec1[2] - vec2[2];
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

bool:GetEntityClassname(entity, String:clsname[], maxlength)
{
	return !!GetEntPropString(entity, PropType:1, "m_iClassname", clsname, maxlength, 0);
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	decl String:gameName[32];
	GetGameFolderName(gameName, 32);
	if (StrEqual(gameName, "left4dead", true))
	{
		tankClassIndex = 5;
	}
	else
	{
		if (StrContains(gameName, "left4dead2", true) > -1)
		{
			tankClassIndex = 8;
		}
		strcopy(error, err_max, "This plugin only supports L4D(2).");
		return APLRes:2;
	}
	return APLRes:0;
}

public OnPluginStart()
{
	HookEvent("tank_spawn", Event_TankSpawn, EventHookMode:1);
	HookEvent("tank_killed", Event_TankKilled, EventHookMode:1);
	CreateConVar("tankdoorfix_version", "1.4", "TankDoorFix Version", 270656, false, 0.0, false, 0.0);
	return 0;
}

public OnMapStart()
{
	tankCount = 0;
	return 0;
}

public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	if (0 < tankCount)
	{
		new var1;
		if (IsValidClient(client) && GetClientTeam(client) == 3 && tankClassIndex == GetEntProp(client, PropType:0, "m_zombieClass", 4, 0))
		{
			if (buttons & 1)
			{
				new tankweapon = GetEntPropEnt(client, PropType:0, "m_hActiveWeapon", 0);
				if (0 < tankweapon)
				{
					new Float:gameTime = GetGameTime();
					new var2;
					if (GetEntPropFloat(tankweapon, PropType:0, "m_flTimeWeaponIdle", 0) <= gameTime && nextTankPunchAllowed[client] <= gameTime)
					{
						nextTankPunchAllowed[client] = gameTime + 2.0;
						CreateTimer(1.0, Timer_DoorCheck, GetClientUserId(client), 0);
					}
				}
			}
		}
	}
	return Action:0;
}

public Action:Timer_DoorCheck(Handle:timer, any:clientUserID)
{
	new client = GetClientOfUserId(clientUserID);
	new var1;
	if (client > 0 && IsClientInGame(client))
	{
		decl Float:direction[3];
		new result = IsLookingAtBreakableDoor(client, direction);
		if (0 < result)
		{
			SDKHooks_TakeDamage(result, client, client, 1200.0, 128, -1, direction, NULL_VECTOR);
		}
	}
	return Action:0;
}

public Event_TankSpawn(Handle:event, String:name[], bool:dontBroadcast)
{
	tankCount += 1;
	nextTankPunchAllowed[GetClientOfUserId(GetEventInt(event, "userid"))] = GetGameTime() + 0.8;
	return 0;
}

public Event_TankKilled(Handle:event, String:name[], bool:dontBroadcast)
{
	tankCount -= 1;
	return 0;
}

IsLookingAtBreakableDoor(client, Float:direction[3])
{
	new target = GetClientAimTarget(client, false);
	if (0 < target)
	{
		decl String:entName[32];
		GetEntityClassname(target, entName, 32);
		if (StrEqual(entName, "prop_door_rotating", true))
		{
			decl Float:clientPos[3];
			decl Float:doorPos[3];
			GetClientAbsOrigin(client, clientPos);
			GetEntPropVector(target, PropType:0, "m_vecOrigin", doorPos, 0);
			if (GetVectorDistance(clientPos, doorPos, false) <= 90.0)
			{
				SubtractVectors(doorPos, clientPos, direction);
				return target;
			}
			return -2;
		}
		return 0;
	}
	return -1;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client))
	{
		return false;
	}
	return IsClientInGame(client);
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "04/18/2017",
	time = "04:21:40"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
public SharedPlugin:__pl_l4d2lib =
{
	name = "l4d2lib",
	file = "l4d2lib.smx",
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1231183725, 1667584878, 1214541423, 1332112481, 1970229862, 25710, 1952867660, 1142961184, 1953396591, 7239535, 1952867692, 2003788852, 2003793006, 2019896942, 116, 1708, 1724, 1, 1, 1802395988, 1684955424, 544173600, 1668573527, 1718165608, 561145193, 0, 1634623811, 1867669860, 1394617464, 29289, 49, 1937007955, 1948279072, 543911521, 2002874483, 1851859054, 1701978212, 1702260589, 1769414771, 543712116, 2002874483, 1869619310, 544501353, 1696624239, 2037540214, 1885433120, 0, 0, 1760, 1808, 1788, 1804, 1872, 0, 0, 0
};
new Handle:hSurvivorModelsTrie = 1952867660;
new Handle:hWeaponNamesTrie = 1952867660;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Tank and no Witch ifier!",
	description = "Sets a tank spawn and removes witch spawn point on every map",
	author = "CanadaRox, Sir",
	version = "1",
	url = ""
};
new Handle:g_hVsBossBuffer;
new Handle:g_hVsBossFlowMax;
new Handle:g_hVsBossFlowMin;
new Handle:hStaticTankMaps;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

Float:operator/(_:,Float:)(oper1, Float:oper2)
{
	return float(oper1) / oper2;
}

bool:operator>(Float:,_:)(Float:oper1, oper2)
{
	return oper1 > float(oper2);
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetCDirector()
{
	static Address:TheDirector;
	if (!TheDirector)
	{
		TheDirector = GameConfGetAddress(L4D2Direct_GetGameConf(), "CDirector");
	}
	return TheDirector;
}

Address:L4D2Direct_GetCDirectorVersusMode()
{
	static Address:pVersusModeDirector;
	if (!pVersusModeDirector)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode");
		if (offs == -1)
		{
			return Address:0;
		}
		pVersusModeDirector = L4D2Direct_GetCDirector() + offs;
		pVersusModeDirector = LoadFromAddress(pVersusModeDirector, NumberType:2);
	}
	return pVersusModeDirector;
}

Address:L4D2Direct_GetVSTankFlowAddr()
{
	static Address:pTankFlowPercent;
	if (!pTankFlowPercent)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_fTankSpawnFlowPercent");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankFlowPercent = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pTankFlowPercent;
}

Address:L4D2Direct_GeVSTankToSpawnAddr()
{
	static Address:pTankSpawnThisRound;
	if (!pTankSpawnThisRound)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_bTankThisRound");
		if (offs == -1)
		{
			return Address:0;
		}
		pTankSpawnThisRound = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pTankSpawnThisRound;
}

Address:L4D2Direct_GetVSWitchToSpawnAddr()
{
	static Address:pWitchSpawnThisRound;
	if (!pWitchSpawnThisRound)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "CDirectorVersusMode::m_bWitchThisRound");
		if (offs == -1)
		{
			return Address:0;
		}
		pWitchSpawnThisRound = L4D2Direct_GetCDirectorVersusMode() + offs;
	}
	return pWitchSpawnThisRound;
}

L4D2Direct_SetVSTankFlowPercent(roundNumber, Float:flow)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(roundNumber * 4 + L4D2Direct_GetVSTankFlowAddr(), flow, NumberType:2);
	return 0;
}

L4D2Direct_SetVSTankToSpawnThisRound(roundNumber, bool:spawn)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(L4D2Direct_GeVSTankToSpawnAddr() + roundNumber, spawn, NumberType:0);
	return 0;
}

L4D2Direct_SetVSWitchToSpawnThisRound(roundNumber, bool:spawn)
{
	new var1;
	if (roundNumber < 0 || roundNumber > 1)
	{
		return 0;
	}
	StoreToAddress(L4D2Direct_GetVSWitchToSpawnAddr() + roundNumber, spawn, NumberType:0);
	return 0;
}

public __pl_l4d2lib_SetNTVOptional()
{
	MarkNativeAsOptional("L4D2_GetCurrentRound");
	MarkNativeAsOptional("L4D2_CurrentlyInRound");
	MarkNativeAsOptional("L4D2_GetSurvivorCount");
	MarkNativeAsOptional("L4D2_GetSurvivorOfIndex");
	MarkNativeAsOptional("L4D2_IsMapDataAvailable");
	MarkNativeAsOptional("L4D2_IsEntityInSaferoom");
	MarkNativeAsOptional("L4D2_GetMapStartOrigin");
	MarkNativeAsOptional("L4D2_GetMapEndOrigin");
	MarkNativeAsOptional("L4D2_GetMapStartDistance");
	MarkNativeAsOptional("L4D2_GetMapStartExtraDistance");
	MarkNativeAsOptional("L4D2_GetMapEndDistance");
	MarkNativeAsOptional("L4D2_GetMapValueInt");
	MarkNativeAsOptional("L4D2_GetMapValueFloat");
	MarkNativeAsOptional("L4D2_GetMapValueVector");
	MarkNativeAsOptional("L4D2_GetMapValueString");
	MarkNativeAsOptional("L4D2_CopyMapSubsection");
	return 0;
}

bool:InSecondHalfOfRound()
{
	return GameRules_GetProp(L4D2_InfectedNames, 4, 0);
}

public OnPluginStart()
{
	g_hVsBossBuffer = FindConVar("versus_boss_buffer");
	g_hVsBossFlowMax = FindConVar("versus_boss_flow_max");
	g_hVsBossFlowMin = FindConVar("versus_boss_flow_min");
	hStaticTankMaps = CreateTrie();
	HookEvent("round_start", RoundStartEvent, EventHookMode:2);
	RegServerCmd("static_tank_map", StaticTank_Command, "", 0);
	RegServerCmd("reset_static_maps", Reset_Command, "", 0);
	return 0;
}

public Action:L4D_OnSpawnWitch(Float:vector[3], Float:qangle[3])
{
	return Action:3;
}

public Action:L4D_OnSpawnWitchBride(Float:vector[3], Float:qangle[3])
{
	return Action:3;
}

public Action:StaticTank_Command(args)
{
	decl String:mapname[64];
	GetCmdArg(1, mapname, 64);
	SetTrieValue(hStaticTankMaps, mapname, any:1, true);
	return Action:0;
}

public Action:Reset_Command(args)
{
	ClearTrie(hStaticTankMaps);
	return Action:0;
}

public RoundStartEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	CreateTimer(0.5, AdjustBossFlow, any:0, 0);
	return 0;
}

public Action:AdjustBossFlow(Handle:timer)
{
	if (InSecondHalfOfRound())
	{
		return Action:0;
	}
	decl String:sCurMap[64];
	decl dummy;
	GetCurrentMap(sCurMap, 64);
	new Float:fCvarMinFlow = GetConVarFloat(g_hVsBossFlowMin);
	new Float:fCvarMaxFlow = GetConVarFloat(g_hVsBossFlowMax);
	new Float:fTankFlow = -1.0;
	if (!GetTrieValue(hStaticTankMaps, sCurMap, dummy))
	{
		new Float:fMinBanFlow = L4D2_GetMapValueInt("tank_ban_flow_min", -1) / 100.0;
		new Float:fMaxBanFlow = L4D2_GetMapValueInt("tank_ban_flow_max", -1) / 100.0;
		new Float:fBanRange = fMaxBanFlow - fMinBanFlow;
		new var1;
		if (fMinBanFlow > 0.0 && fMinBanFlow < fCvarMinFlow)
		{
			fBanRange -= fCvarMinFlow - fMinBanFlow;
		}
		fTankFlow = GetRandomFloat(fCvarMinFlow, fCvarMaxFlow - fBanRange);
		if (fTankFlow > fMinBanFlow)
		{
			fTankFlow += fBanRange;
		}
		L4D2Direct_SetVSTankToSpawnThisRound(0, true);
		L4D2Direct_SetVSTankToSpawnThisRound(1, true);
		L4D2Direct_SetVSTankFlowPercent(0, fTankFlow);
		L4D2Direct_SetVSTankFlowPercent(1, fTankFlow);
	}
	else
	{
		L4D2Direct_SetVSTankToSpawnThisRound(0, false);
		L4D2Direct_SetVSTankToSpawnThisRound(1, false);
	}
	L4D2Direct_SetVSWitchToSpawnThisRound(0, false);
	L4D2Direct_SetVSWitchToSpawnThisRound(1, false);
	return Action:0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.0-dev+4284",
	date = "03/24/2014",
	time = "01:49:26"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new result_int;
new String:client_name[32];
new previous_timeC;
new current_timeC;
new Handle:delay_time;
public Plugin:myinfo =
{
	name = "Teamflip",
	description = "coinflip, but for teams!",
	author = "purpletreefactory, epilimic",
	version = "1.0.1.0.1.0",
	url = "http://www.sourcemod.net/"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public OnPluginStart()
{
	delay_time = CreateConVar("teamflip_delay", "-1", "Time delay in seconds between allowed teamflips. Set at -1 if no delay at all is desired.", 0, false, 0.0, false, 0.0);
	RegConsoleCmd("sm_teamflip", Command_teamflip, "", 0);
	RegConsoleCmd("sm_tf", Command_teamflip, "", 0);
	return 0;
}

public Action:Command_teamflip(client, args)
{
	current_timeC = GetTime({0,0});
	if (GetConVarInt(delay_time) < current_timeC - previous_timeC)
	{
		result_int = GetURandomInt() % 2;
		GetClientName(client, client_name, 32);
		if (result_int)
		{
			PrintToChatAll("\x01[\x05Teamflip\x01] \x03%s\x01 flipped a team and is on the \x03Infected \x01team!", client_name);
		}
		else
		{
			PrintToChatAll("\x01[\x05Teamflip\x01] \x03%s\x01 flipped a team and is on the \x03Survivor \x01team!", client_name);
		}
		previous_timeC = current_timeC;
	}
	else
	{
		PrintToConsole(client, "[Teamflip] Whoa there buddy, slow down. Wait at least %d seconds.", GetConVarInt(delay_time));
	}
	return Action:3;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "01/31/2012",
	time = "17:30:23"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Plugin:myinfo =
{
	name = "Hittable Temp Health Fixer",
	description = "Ensures that survivors that have been incapacitated with a hittable object get their temp health set correctly",
	author = "CanadaRox",
	version = "13.3.7",
	url = "https://bitbucket.org/CanadaRox/random-sourcemod-stuff/"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	HookEvent("player_incapacitated_start", Incap_Event, EventHookMode:1);
	return 0;
}

public Incap_Event(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	SetEntPropFloat(client, PropType:0, "m_healthBufferTime", GetGameTime(), 0);
	SetEntPropFloat(client, PropType:0, "m_healthBuffer", 0.0, 0);
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "08/30/2016",
	time = "14:19:48"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new Handle:g_hPistolDelayDualies;
new Handle:g_hPistolDelaySingle;
new Handle:g_hPistolDelayIncapped;
new Handle:hCvarDoorSpeed;
new Float:g_fNextAttack[66];
new Float:g_fPistolDelayDualies = 1036831949;
new Float:g_fPistolDelaySingle = 1045220557;
new Float:g_fPistolDelayIncapped = 1050253722;
new Float:fDoorSpeed;
new Handle:g_hCvarGravity;
new String:g_szDoors_Type_Tracked[2][32] =
{
	"prop_door_rotating",
	"prop_door_rotating_checkpoint"
};
new Float:g_ddDoors[2048][3];
public Extension:__ext_sdkhooks =
{
	name = "SDKHooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new localIPRanges[4] =
{
	1819044171, 1919248712, 1751347809, 121
};
new String:chatColorNames[12][] =
{
	"normal",
	"orange",
	"red",
	"redblue",
	"blue",
	"bluered",
	"team",
	"lightgreen",
	"gray",
	"green",
	"olivegreen",
	"black"
};
new String:chatColorTags[12][16] =
{
	"normal",
	"orange",
	"red",
	"redblue",
	"blue",
	"bluered",
	"team",
	"lightgreen",
	"gray",
	"green",
	"olivegreen",
	"black"
};
new chatColorInfo[12][4] =
{
	{
		1, -1, 1, -3
	},
	{
		1, 0, 1, -3
	},
	{
		3, 9, 1, 2
	},
	{
		3, 4, 1, 2
	},
	{
		3, 9, 1, 3
	},
	{
		3, 2, 1, 3
	},
	{
		3, 9, 1, -2
	},
	{
		3, 9, 1, 0
	},
	{
		3, 9, 1, -1
	},
	{
		4, 0, 1, -3
	},
	{
		5, 9, 1, -3
	},
	{
		6, 9, 1, -3
	}
};
new bool:checkTeamPlay;
new Handle:mp_teamplay;
new bool:isSayText2_supported = 1;
new chatSubject = -2;
new Float:getPlayersInRadius_distances[66];
new printToChat_excludeclient;
new String:_smlib_empty_twodimstring_array[1][16];
new base64_cFillChar = 3308130;
new base64_decodeTable[256] =
{
	3308130, 1886221434, 0, 12079, 47, 46, 11822, 623866661, 115, 42, 46, 46, 11822, 623866661, 115, 25202, 25207, 11822, 46, 623866661, 115, 623866661, 115, 1801677140, 1702125938, 2020165152, 29541, 745695571, 1769096992, 1852401254, 0, 1702390086, 543236211, 1684955496, 543978854, 1931503215, 2037148777, 1667847200, 1952543339, 1969365093, 29543, 3157553, 1819763022, 46, 35484, 35516, 35500, 35556, 35560, 1600402540, 1953720688, 1683975279, 2036427877, 1635083359, 1936025964, 0, 3223088, 1768843597, 544044397, 1701669236, 1852385312, 1667592992, 1935961711, 1700929577, 1701148532, 1969496174, 1881173089, 1869902697, 1752375404, 7566447, 1600402540, 1953720688, 1683975279, 2036427877, 1852404575, 6646887, 3288624, 1768843597, 544044397, 1701669236, 1852385312, 1667592992, 1935961711, 1700929577, 1701148532, 1769152622, 1701603182, 1936289824, 543977332, 1953458291, 115, 1600402540, 1953720688, 1683975279, 2036427877, 1668180319, 1701867617, 100, 3354160, 1768843597, 544044397, 1701669236, 1852385312, 1667592992, 1935961711, 1700929577, 1701148532, 1768956014, 1819243635, 1869116192, 1998615412, 1701603688, 1668180256, 1701867617, 100, 1885431159, 1717530223, 6648425, 1801677172, 1869571167, 1886609266, 6579557, 3485234, 1937007955, 1701344288, 1701868320, 1864393829, 1818304614, 1919950956, 1683976303, 544370543, 1769238117, 1936025972, 544108320, 1634541665, 824192624, 540356654, 1851876717, 540876915, 624242737, 1701868320, 25701, 1734309491, 1769365874, 31092, 1097359213, 1986622563, 1634031461, 7237488, 1885431159, 1885302383, 1869902697, 108, 1818648429, 1954047310, 1835627088, 1098478177, 1667331188, 107, 1818648429, 1954047310, 1835627088, 1098478177, 1667331188, 107, 1919251317, 25705, 1097359213, 1986622563, 1634031461, 7237488, 1885431159, 1885302383, 1869902697, 108, 1936285549, 1633906249, 1768120688, 1702125940, 100, 1936285549, 1818326340, 1818585431, 1735289188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
new String:base64_mime_chars[4] = "bz2";
new String:base64_sTable[68] = "bz2";
new String:base64_url_chars[4] = "bz2";
new printToTop_excludeclient = 3308130;
public Plugin:myinfo =
{
	name = "Tickrate Fixes",
	description = "Fixes a handful of silly Tickrate bugs",
	author = "Sir, Griffin",
	version = "1.0",
	url = "Nawl."
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

FindCharInString(String:str[], c, bool:reverse)
{
	new i;
	new len = strlen(str);
	if (!reverse)
	{
		i = 0;
		while (i < len)
		{
			if (c == str[i])
			{
				return i;
			}
			i++;
		}
	}
	else
	{
		i = len + -1;
		while (0 <= i)
		{
			if (c == str[i])
			{
				return i;
			}
			i--;
		}
	}
	return -1;
}

StrCat(String:buffer[], maxlength, String:source[])
{
	new len = strlen(buffer);
	if (len >= maxlength)
	{
		return 0;
	}
	return Format(buffer[len], maxlength - len, "%s", source);
}

bool:GetEntityClassname(entity, String:clsname[], maxlength)
{
	return !!GetEntPropString(entity, PropType:1, "m_iClassname", clsname, maxlength, 0);
}

AddFileToDownloadsTable(String:filename[])
{
	static table = -1;
	if (table == -1)
	{
		table = FindStringTable("downloadables");
	}
	new bool:save = LockStringTables(false);
	AddToStringTable(table, filename, "", -1);
	LockStringTables(save);
	return 0;
}

Array_FindString(String:array[][], size, String:str[], bool:caseSensitive, start)
{
	if (0 > start)
	{
		start = 0;
	}
	new i = start;
	while (i < size)
	{
		if (StrEqual(array[i], str, caseSensitive))
		{
			return i;
		}
		i++;
	}
	return -1;
}

Entity_IsValid(entity)
{
	return IsValidEntity(entity);
}

bool:Entity_IsPlayer(entity)
{
	new var1;
	if (entity < 1 || entity > MaxClients)
	{
		return false;
	}
	return true;
}

bool:Entity_Kill(kenny, killChildren)
{
	if (Entity_IsPlayer(kenny))
	{
		ForcePlayerSuicide(kenny);
		return true;
	}
	if (killChildren)
	{
		return AcceptEntityInput(kenny, localIPRanges, -1, -1, 0);
	}
	return AcceptEntityInput(kenny, "Kill", -1, -1, 0);
}

public Action:__smlib_Timer_ChangeOverTime(Handle:Timer, Handle:dataPack)
{
	new entity = EntRefToEntIndex(ReadPackCell(dataPack));
	if (!Entity_IsValid(entity))
	{
		return Action:4;
	}
	new Float:interval = ReadPackFloat(dataPack);
	new currentCall = ReadPackCell(dataPack);
	new Function:callback = ReadPackCell(dataPack);
	new any:result;
	Call_StartFunction(Handle:0, callback);
	Call_PushCellRef(entity);
	Call_PushFloatRef(interval);
	Call_PushCellRef(currentCall);
	Call_Finish(result);
	if (result)
	{
		ResetPack(dataPack, true);
		WritePackCell(dataPack, EntIndexToEntRef(entity));
		WritePackFloat(dataPack, interval);
		WritePackCell(dataPack, currentCall + 1);
		WritePackCell(dataPack, callback);
		ResetPack(dataPack, false);
		CreateTimer(interval, __smlib_Timer_ChangeOverTime, dataPack, 0);
		return Action:4;
	}
	return Action:4;
}

bool:Entity_GetForceClose(entity)
{
	return GetEntProp(entity, PropType:1, "m_bForceClosed", 4, 0);
}

Entity_SetForceClose(entity, bool:forceClose)
{
	SetEntProp(entity, PropType:1, "m_bForceClosed", forceClose, 4, 0);
	return 0;
}

Float:Entity_GetSpeed(entity)
{
	return GetEntPropFloat(entity, PropType:1, "m_flSpeed", 0);
}

Entity_SetSpeed(entity, Float:speed)
{
	SetEntPropFloat(entity, PropType:1, "m_flSpeed", speed, 0);
	return 0;
}

Team_GetAnyClient(index)
{
	static client_cache[32] =
	{
		-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	};
	new client;
	if (0 < index)
	{
		client = client_cache[index];
		new var1;
		if (client > 0 && client <= MaxClients)
		{
			new var2;
			if (IsClientInGame(client) && index == GetClientTeam(client))
			{
				return client;
			}
		}
		client = -1;
	}
	client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			if (!(index != GetClientTeam(client)))
			{
				client_cache[index] = client;
				return client;
			}
		}
		client++;
	}
	return -1;
}

Color_ChatInitialize()
{
	static initialized;
	if (initialized)
	{
		return 0;
	}
	initialized = 1;
	decl String:gameFolderName[32];
	GetGameFolderName(gameFolderName, 32);
	chatColorInfo[11][2] = 0;
	new var1;
	if (strncmp(gameFolderName, "left4dead", 9, false) && !StrEqual(gameFolderName, "cstrike", false) && !StrEqual(gameFolderName, "tf", false))
	{
		chatColorInfo[7][2] = 0;
		chatColorInfo[8][2] = 0;
	}
	if (StrEqual(gameFolderName, "tf", false))
	{
		chatColorInfo[11][2] = 1;
		chatColorInfo[8] = 1;
		chatColorInfo[8][3] = -3;
	}
	else
	{
		if (strncmp(gameFolderName, "left4dead", 9, false))
		{
			if (StrEqual(gameFolderName, "hl2mp", false))
			{
				chatColorInfo[2][3] = 3;
				chatColorInfo[3][3] = 3;
				chatColorInfo[4][3] = 2;
				chatColorInfo[5][3] = 2;
				chatColorInfo[11][2] = 1;
				checkTeamPlay = true;
			}
			if (StrEqual(gameFolderName, "dod", false))
			{
				chatColorInfo[8] = 1;
				chatColorInfo[8][3] = -3;
				chatColorInfo[11][2] = 1;
				chatColorInfo[1][2] = 0;
			}
		}
		chatColorInfo[2][3] = 3;
		chatColorInfo[3][3] = 3;
		chatColorInfo[4][3] = 2;
		chatColorInfo[5][3] = 2;
		chatColorInfo[1] = 4;
		chatColorInfo[9] = 5;
	}
	if (GetUserMessageId("SayText2") == -1)
	{
		isSayText2_supported = false;
	}
	decl String:path_gamedata[256];
	BuildPath(PathType:0, path_gamedata, 256, "gamedata/%s.txt", "smlib_colors.games");
	if (FileExists(path_gamedata, false))
	{
		new Handle:gamedata;
		if ((gamedata = LoadGameConfigFile("smlib_colors.games")))
		{
			decl String:keyName[32];
			decl String:buffer[8];
			new i;
			while (i < 12)
			{
				Format(keyName, 32, "%s_code", chatColorNames[i]);
				if (GameConfGetKeyValue(gamedata, keyName, buffer, 6))
				{
					chatColorInfo[i][0] = StringToInt(buffer, 10);
				}
				Format(keyName, 32, "%s_alternative", chatColorNames[i]);
				if (GameConfGetKeyValue(gamedata, keyName, buffer, 6))
				{
					chatColorInfo[i][1] = buffer[0];
				}
				Format(keyName, 32, "%s_supported", chatColorNames[i]);
				if (GameConfGetKeyValue(gamedata, keyName, buffer, 6))
				{
					chatColorInfo[i][2] = StrEqual(buffer, "true", true);
				}
				Format(keyName, 32, "%s_subjecttype", chatColorNames[i]);
				if (GameConfGetKeyValue(gamedata, keyName, buffer, 6))
				{
					chatColorInfo[i][3] = StringToInt(buffer, 10);
				}
				i++;
			}
			if (GameConfGetKeyValue(gamedata, "checkteamplay", buffer, 6))
			{
				checkTeamPlay = StrEqual(buffer, "true", true);
			}
			CloseHandle(gamedata);
		}
	}
	mp_teamplay = FindConVar("mp_teamplay");
	return 0;
}

Color_GetChatColorInfo(&index, &subject)
{
	Color_ChatInitialize();
	if (index == -1)
	{
		index = 0;
	}
	while (!chatColorInfo[index][2])
	{
		new alternative = chatColorInfo[index][1];
		if (alternative == -1)
		{
			index = 0;
			if (index == -1)
			{
				index = 0;
			}
			new newSubject = -2;
			new ChatColorSubjectType:type = chatColorInfo[index][3];
			switch (type)
			{
				case -3:
				{
				}
				case -2:
				{
					newSubject = chatSubject;
				}
				case -1:
				{
					newSubject = -1;
				}
				case 0:
				{
					newSubject = 0;
				}
				default:
				{
					new var1;
					if (!checkTeamPlay || GetConVarBool(mp_teamplay))
					{
						new var2;
						if (subject > 0 && subject <= MaxClients)
						{
							if (type == GetClientTeam(subject))
							{
								newSubject = subject;
							}
						}
						if (subject == -2)
						{
							new client = Team_GetAnyClient(type);
							if (client != -1)
							{
								newSubject = client;
							}
						}
					}
				}
			}
			new var5;
			if (type > ChatColorSubjectType:-3 && ((subject != -2 && newSubject != subject) || (newSubject == -2 || !isSayText2_supported)))
			{
				index = chatColorInfo[index][1];
				newSubject = Color_GetChatColorInfo(index, subject);
			}
			if (subject == -2)
			{
				subject = newSubject;
			}
			return newSubject;
		}
		index = alternative;
	}
	if (index == -1)
	{
		index = 0;
	}
	new newSubject = -2;
	new ChatColorSubjectType:type = chatColorInfo[index][3];
	switch (type)
	{
		case -3:
		{
		}
		case -2:
		{
			newSubject = chatSubject;
		}
		case -1:
		{
			newSubject = -1;
		}
		case 0:
		{
			newSubject = 0;
		}
		default:
		{
			new var1;
			if (!checkTeamPlay || GetConVarBool(mp_teamplay))
			{
				new var2;
				if (subject > 0 && subject <= MaxClients)
				{
					if (type == GetClientTeam(subject))
					{
						newSubject = subject;
					}
				}
				if (subject == -2)
				{
					new client = Team_GetAnyClient(type);
					if (client != -1)
					{
						newSubject = client;
					}
				}
			}
		}
	}
	new var5;
	if (type > ChatColorSubjectType:-3 && ((subject != -2 && newSubject != subject) || (newSubject == -2 || !isSayText2_supported)))
	{
		index = chatColorInfo[index][1];
		newSubject = Color_GetChatColorInfo(index, subject);
	}
	if (subject == -2)
	{
		subject = newSubject;
	}
	return newSubject;
}

public bool:_smlib_TraceEntityFilter(entity, contentsMask)
{
	return entity == 0;
}

public __smlib_GetPlayersInRadius_Sort(player1, player2, clients[], Handle:hndl)
{
	return FloatCompare(getPlayersInRadius_distances[player1], getPlayersInRadius_distances[player2]);
}

public Action:_smlib_Timer_Effect_Fade(Handle:Timer, Handle:dataPack)
{
	new entity = ReadPackCell(dataPack);
	new kill = ReadPackCell(dataPack);
	new Function:callback = ReadPackCell(dataPack);
	new any:data = ReadPackCell(dataPack);
	if (callback != -1)
	{
		Call_StartFunction(Handle:0, callback);
		Call_PushCell(entity);
		Call_PushCell(data);
		Call_Finish(0);
	}
	new var1;
	if (kill && IsValidEntity(entity))
	{
		Entity_Kill(entity, 0);
	}
	return Action:4;
}

bool:File_GetBaseName(String:path[], String:buffer[], size)
{
	if (path[0])
	{
		new pos_start = FindCharInString(path, 47, true);
		if (pos_start == -1)
		{
			pos_start = FindCharInString(path, 92, true);
		}
		pos_start++;
		strcopy(buffer, size, path[pos_start]);
		return false;
	}
	buffer[0] = MissingTAG:0;
	return false;
}

bool:File_GetDirName(String:path[], String:buffer[], size)
{
	if (path[0])
	{
		new pos_start = FindCharInString(path, 47, true);
		if (pos_start == -1)
		{
			pos_start = FindCharInString(path, 92, true);
			if (pos_start == -1)
			{
				buffer[0] = MissingTAG:0;
				return false;
			}
		}
		strcopy(buffer, size, path);
		buffer[pos_start] = MissingTAG:0;
		return false;
	}
	buffer[0] = MissingTAG:0;
	return false;
}

bool:File_GetFileName(String:path[], String:buffer[], size)
{
	if (path[0])
	{
		File_GetBaseName(path, buffer, size);
		new pos_ext = FindCharInString(buffer, 46, true);
		if (pos_ext != -1)
		{
			buffer[pos_ext] = MissingTAG:0;
		}
		return false;
	}
	buffer[0] = MissingTAG:0;
	return false;
}

File_GetExtension(String:path[], String:buffer[], size)
{
	new extpos = FindCharInString(path, 46, true);
	if (extpos == -1)
	{
		buffer[0] = MissingTAG:0;
		return 0;
	}
	extpos++;
	strcopy(buffer, size, path[extpos]);
	return 0;
}

File_AddToDownloadsTable(String:path[], bool:recursive, String:ignoreExts[][], size)
{
	if (path[0])
	{
		if (FileExists(path, false))
		{
			new String:fileExtension[8];
			File_GetExtension(path, fileExtension, 5);
			new var1;
			if (StrEqual(fileExtension, _smlib_empty_twodimstring_array, false) || StrEqual(fileExtension, "ztmp", false))
			{
				return 0;
			}
			if (Array_FindString(ignoreExts, size, fileExtension, true, 0) != -1)
			{
				return 0;
			}
			decl String:path_new[256];
			strcopy(path_new, 256, path);
			ReplaceString(path_new, 256, "//", "/", true);
			AddFileToDownloadsTable(path_new);
		}
		else
		{
			new var2;
			if (recursive && DirExists(path))
			{
				decl String:dirEntry[256];
				new Handle:__dir = OpenDirectory(path);
				while (ReadDirEntry(__dir, dirEntry, 256, 0))
				{
					new var3;
					if (!(StrEqual(dirEntry, ".", true) || StrEqual(dirEntry, "..", true)))
					{
						Format(dirEntry, 256, "%s/%s", path, dirEntry);
						File_AddToDownloadsTable(dirEntry, recursive, ignoreExts, size);
					}
				}
				CloseHandle(__dir);
			}
			if (FindCharInString(path, 42, true))
			{
				new String:fileExtension[4];
				File_GetExtension(path, fileExtension, 4);
				if (StrEqual(fileExtension, "*", true))
				{
					decl String:dirName[256];
					decl String:fileName[256];
					decl String:dirEntry[256];
					File_GetDirName(path, dirName, 256);
					File_GetFileName(path, fileName, 256);
					StrCat(fileName, 256, ".");
					new Handle:__dir = OpenDirectory(dirName);
					while (ReadDirEntry(__dir, dirEntry, 256, 0))
					{
						new var4;
						if (!(StrEqual(dirEntry, ".", true) || StrEqual(dirEntry, "..", true)))
						{
							if (strncmp(dirEntry, fileName, strlen(fileName), true))
							{
							}
							else
							{
								Format(dirEntry, 256, "%s/%s", dirName, dirEntry);
								File_AddToDownloadsTable(dirEntry, recursive, ignoreExts, size);
							}
						}
					}
					CloseHandle(__dir);
				}
			}
		}
		return 0;
	}
	return 0;
}

bool:File_Copy(String:source[], String:destination[])
{
	new Handle:file_source = OpenFile(source, "rb");
	if (file_source)
	{
		new Handle:file_destination = OpenFile(destination, "wb");
		if (file_destination)
		{
			new buffer[32];
			new cache;
			while (!IsEndOfFile(file_source))
			{
				cache = ReadFile(file_source, buffer, 32, 1);
				WriteFile(file_destination, buffer, cache, 1);
			}
			CloseHandle(file_source);
			CloseHandle(file_destination);
			return true;
		}
		CloseHandle(file_source);
		return false;
	}
	return false;
}

bool:File_CopyRecursive(String:path[], String:destination[], bool:stop_on_error, dirMode)
{
	if (FileExists(path, false))
	{
		return File_Copy(path, destination);
	}
	if (DirExists(path))
	{
		return Sub_File_CopyRecursive(path, destination, stop_on_error, FileType:1, dirMode);
	}
	return false;
}

bool:Sub_File_CopyRecursive(String:path[], String:destination[], bool:stop_on_error, FileType:fileType, dirMode)
{
	if (fileType == FileType:2)
	{
		return File_Copy(path, destination);
	}
	if (fileType == FileType:1)
	{
		new var1;
		if (!CreateDirectory(destination, dirMode) && stop_on_error)
		{
			return false;
		}
		new Handle:directory = OpenDirectory(path);
		if (directory)
		{
			decl String:source_buffer[256];
			decl String:destination_buffer[256];
			new FileType:type;
			while (ReadDirEntry(directory, source_buffer, 256, type))
			{
				new var2;
				if (!(StrEqual(source_buffer, "..", true) || StrEqual(source_buffer, ".", true)))
				{
					Format(destination_buffer, 256, "%s/%s", destination, source_buffer);
					Format(source_buffer, 256, "%s/%s", path, source_buffer);
					if (type == FileType:2)
					{
						File_Copy(source_buffer, destination_buffer);
					}
					else
					{
						if (type == FileType:1)
						{
							new var3;
							if (!File_CopyRecursive(source_buffer, destination_buffer, stop_on_error, dirMode) && stop_on_error)
							{
								CloseHandle(directory);
								return false;
							}
						}
					}
				}
			}
			CloseHandle(directory);
		}
		return false;
	}
	else
	{
		if (!fileType)
		{
			return false;
		}
	}
	return true;
}

public OnPluginStart()
{
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsClientInGame(client))
		{
			SDKHook(client, SDKHookType:20, Hook_OnPostThinkPost);
		}
		client++;
	}
	g_hPistolDelayDualies = CreateConVar("l4d_pistol_delay_dualies", "0.1", "Minimum time (in seconds) between dual pistol shots", 262464, true, 0.0, true, 5.0);
	g_hPistolDelaySingle = CreateConVar("l4d_pistol_delay_single", "0.2", "Minimum time (in seconds) between single pistol shots", 262464, true, 0.0, true, 5.0);
	g_hPistolDelayIncapped = CreateConVar("l4d_pistol_delay_incapped", "0.3", "Minimum time (in seconds) between pistol shots while incapped", 262464, true, 0.0, true, 5.0);
	UpdatePistolDelays();
	HookConVarChange(g_hPistolDelayDualies, Cvar_PistolDelay);
	HookConVarChange(g_hPistolDelaySingle, Cvar_PistolDelay);
	HookConVarChange(g_hPistolDelayIncapped, Cvar_PistolDelay);
	HookEvent("weapon_fire", Event_WeaponFire, EventHookMode:1);
	hCvarDoorSpeed = CreateConVar("tick_door_speed", "2.5", "Sets the speed of all prop_door entities on a map. 1.05 means = 105% speed", 262144, false, 0.0, false, 0.0);
	fDoorSpeed = GetConVarFloat(hCvarDoorSpeed);
	HookConVarChange(hCvarDoorSpeed, cvarChanged);
	Door_ClearSettingsAll();
	Door_GetSettingsAll();
	Door_SetSettingsAll();
	g_hCvarGravity = FindConVar("sv_gravity");
	if (GetConVarInt(g_hCvarGravity) != 750)
	{
		SetConVarInt(g_hCvarGravity, 750, false, false);
	}
	return 0;
}

public OnPluginEnd()
{
	Door_ResetSettingsAll();
	return 0;
}

public OnEntityCreated(entity, String:classname[])
{
	new i;
	while (i < 2)
	{
		if (StrEqual(classname, g_szDoors_Type_Tracked[i], false))
		{
			CreateTimer(0.2, EntityTimer, entity, 0);
		}
		i++;
	}
	return 0;
}

public Action:EntityTimer(Handle:timer, any:entity)
{
	if (!IsValidEntity(entity))
	{
		return Action:0;
	}
	new String:classname[128];
	GetEntityClassname(entity, classname, 128);
	new i;
	while (i < 2)
	{
		if (StrEqual(classname, g_szDoors_Type_Tracked[i], false))
		{
			Door_GetSettings(entity, i);
		}
		i++;
	}
	Door_SetSettings(entity);
	return Action:0;
}

public OnClientPutInServer(client)
{
	SDKHook(client, SDKHookType:4, Hook_OnPostThinkPost);
	g_fNextAttack[client] = 0;
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:4, Hook_OnPostThinkPost);
	return 0;
}

public Cvar_PistolDelay(Handle:convar, String:oldValue[], String:newValue[])
{
	UpdatePistolDelays();
	return 0;
}

UpdatePistolDelays()
{
	g_fPistolDelayDualies = GetConVarFloat(g_hPistolDelayDualies);
	if (g_fPistolDelayDualies < 0.0)
	{
		g_fPistolDelayDualies = 0.0;
	}
	else
	{
		if (g_fPistolDelayDualies > 5.0)
		{
			g_fPistolDelayDualies = 5.0;
		}
	}
	g_fPistolDelaySingle = GetConVarFloat(g_hPistolDelaySingle);
	if (g_fPistolDelaySingle < 0.0)
	{
		g_fPistolDelaySingle = 0.0;
	}
	else
	{
		if (g_fPistolDelaySingle > 5.0)
		{
			g_fPistolDelaySingle = 5.0;
		}
	}
	g_fPistolDelayIncapped = GetConVarFloat(g_hPistolDelayIncapped);
	if (g_fPistolDelayIncapped < 0.0)
	{
		g_fPistolDelayIncapped = 0.0;
	}
	else
	{
		if (g_fPistolDelayIncapped > 5.0)
		{
			g_fPistolDelayIncapped = 5.0;
		}
	}
	return 0;
}

public Hook_OnPostThinkPost(client)
{
	new var1;
	if (!IsClientInGame(client) || IsFakeClient(client) || GetClientTeam(client) == 2)
	{
		return 0;
	}
	new activeweapon = GetEntPropEnt(client, PropType:0, "m_hActiveWeapon", 0);
	if (!IsValidEdict(activeweapon))
	{
		return 0;
	}
	decl String:weaponname[64];
	GetEdictClassname(activeweapon, weaponname, 64);
	if (strcmp(weaponname, "weapon_pistol", true))
	{
		return 0;
	}
	new Float:old_value = GetEntPropFloat(activeweapon, PropType:0, "m_flNextPrimaryAttack", 0);
	new Float:new_value = g_fNextAttack[client];
	if (new_value > old_value)
	{
		SetEntPropFloat(activeweapon, PropType:0, "m_flNextPrimaryAttack", new_value, 0);
	}
	return 0;
}

public Action:Event_WeaponFire(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new var1;
	if (!IsClientInGame(client) || IsFakeClient(client) || GetClientTeam(client) == 2)
	{
		return Action:0;
	}
	new activeweapon = GetEntPropEnt(client, PropType:0, "m_hActiveWeapon", 0);
	if (!IsValidEdict(activeweapon))
	{
		return Action:0;
	}
	decl String:weaponname[64];
	GetEdictClassname(activeweapon, weaponname, 64);
	if (strcmp(weaponname, "weapon_pistol", true))
	{
		return Action:0;
	}
	if (GetEntProp(client, PropType:0, "m_isIncapacitated", 4, 0))
	{
		g_fNextAttack[client] = GetGameTime() + g_fPistolDelayIncapped;
	}
	else
	{
		if (GetEntProp(activeweapon, PropType:0, "m_isDualWielding", 4, 0))
		{
			g_fNextAttack[client] = GetGameTime() + g_fPistolDelayDualies;
		}
		g_fNextAttack[client] = GetGameTime() + g_fPistolDelaySingle;
	}
	return Action:0;
}

public cvarChanged(Handle:cvar, String:oldValue[], String:newValue[])
{
	fDoorSpeed = GetConVarFloat(hCvarDoorSpeed);
	Door_SetSettingsAll();
	return 0;
}

Door_SetSettingsAll()
{
	new countEnts;
	new entity = -1;
	new i;
	while (i < 2)
	{
		while ((entity = FindEntityByClassname(entity, g_szDoors_Type_Tracked[i])) != -1)
		{
			Door_SetSettings(entity);
			Entity_SetForceClose(entity, false);
			countEnts++;
		}
		entity = -1;
		i++;
	}
	return 0;
}

Door_SetSettings(entity)
{
	Entity_SetSpeed(entity, g_ddDoors[entity][1] * fDoorSpeed);
	return 0;
}

Door_ResetSettingsAll()
{
	new countEnts;
	new entity = -1;
	new i;
	while (i < 2)
	{
		while ((entity = FindEntityByClassname(entity, g_szDoors_Type_Tracked[i])) != -1)
		{
			Door_ResetSettings(entity);
			countEnts++;
		}
		entity = -1;
		i++;
	}
	return 0;
}

Door_ResetSettings(entity)
{
	Entity_SetSpeed(entity, g_ddDoors[entity][1]);
	return 0;
}

Door_GetSettingsAll()
{
	new countEnts;
	new entity = -1;
	new i;
	while (i < 2)
	{
		while ((entity = FindEntityByClassname(entity, g_szDoors_Type_Tracked[i])) != -1)
		{
			Door_GetSettings(entity, i);
			countEnts++;
		}
		entity = -1;
		i++;
	}
	return 0;
}

Door_GetSettings(entity, DoorsTypeTracked:type)
{
	g_ddDoors[entity][0] = type;
	g_ddDoors[entity][1] = Entity_GetSpeed(entity);
	g_ddDoors[entity][2] = Entity_GetForceClose(entity);
	return 0;
}

Door_ClearSettingsAll()
{
	new i;
	while (i < 2048)
	{
		g_ddDoors[i][0] = NaN;
		g_ddDoors[i][1] = 0.0;
		g_ddDoors[i][2] = 0.0;
		i++;
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.1",
	date = "03/06/2014",
	time = "17:14:55"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_left4downtown =
{
	name = "Left 4 Downtown",
	file = "left4downtown.ext",
	autoload = 1,
	required = 1,
};
public Plugin:myinfo =
{
	name = "Map Distance Unifier",
	description = "Sets every map to the same max distance",
	author = "CanadaRox",
	version = "1",
	url = "https://github.com/CanadaRox/sourcemod-plugins/unified_dist/"
};
new Handle:hMapDist;
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

public OnPluginStart()
{
	hMapDist = CreateConVar("map_dist", "100", "Set custom map distance for every map", 0, false, 0.0, false, 0.0);
	return 0;
}

public OnMapStart()
{
	L4D_SetVersusMaxCompletionScore(GetConVarInt(hMapDist));
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.4.4",
	date = "10/06/2013",
	time = "19:43:41"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public Extension:__ext_sdkhooks =
{
	name = "sdkhooks",
	file = "sdkhooks.ext",
	autoload = 1,
	required = 1,
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new bool:bPluginActive;
public Plugin:myinfo =
{
	name = "Warcelona Fix aka Lazy Workaround",
	description = "Prevents Survivors from dying during/after ready-up on Warcelona maps.",
	author = "raecher, alexip, Visor",
	version = "0.3",
	url = "https://github.com/Attano/Equilibrium"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	VerifyCoreVersion();
	return 0;
}

bool:operator<=(_:,Float:)(oper1, Float:oper2)
{
	return FloatCompare(float(oper1), oper2) <= 0;
}

Handle:L4D2Direct_GetGameConf()
{
	static Handle:g_hGameConf_l4d2dir;
	if (!g_hGameConf_l4d2dir)
	{
		g_hGameConf_l4d2dir = LoadGameConfigFile("l4d2_direct");
	}
	return g_hGameConf_l4d2dir;
}

Address:L4D2Direct_GetTerrorNavMesh()
{
	static Address:TheNavMesh;
	if (!TheNavMesh)
	{
		TheNavMesh = GameConfGetAddress(L4D2Direct_GetGameConf(), "TerrorNavMesh");
	}
	return TheNavMesh;
}

Address:L4D2Direct_GetMapMaxFlowDistanceAddr()
{
	static Address:pMapMaxFlowDistance;
	if (!pMapMaxFlowDistance)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "TerrorNavMesh::m_fMapMaxFlowDistance");
		if (offs == -1)
		{
			return Address:0;
		}
		pMapMaxFlowDistance = L4D2Direct_GetTerrorNavMesh() + offs;
	}
	return pMapMaxFlowDistance;
}

Float:L4D2Direct_GetMapMaxFlowDistance()
{
	return LoadFromAddress(L4D2Direct_GetMapMaxFlowDistanceAddr(), NumberType:2);
}

Address:L4D2Direct_GetTerrorNavArea(Float:pos[3], Float:beneathLimit)
{
	static Handle:GetNavAreaSDKCall;
	if (!GetNavAreaSDKCall)
	{
		StartPrepSDKCall(SDKCallType:5);
		if (!PrepSDKCall_SetFromConf(L4D2Direct_GetGameConf(), SDKFuncConfSource:1, "CNavMesh::GetNavArea"))
		{
			return Address:0;
		}
		PrepSDKCall_AddParameter(SDKType:2, SDKPassMethod:3, 0, 0);
		PrepSDKCall_AddParameter(SDKType:5, SDKPassMethod:1, 0, 0);
		PrepSDKCall_SetReturnInfo(SDKType:4, SDKPassMethod:1, 0, 0);
		GetNavAreaSDKCall = EndPrepSDKCall();
		if (!GetNavAreaSDKCall)
		{
			return Address:0;
		}
	}
	return SDKCall(GetNavAreaSDKCall, L4D2Direct_GetTerrorNavMesh(), pos, beneathLimit);
}

Float:L4D2Direct_GetTerrorNavAreaFlow(Address:pTerrorNavArea)
{
	if (pTerrorNavArea)
	{
		new offs = GameConfGetOffset(L4D2Direct_GetGameConf(), "TerrorNavArea::m_flow");
		if (offs == -1)
		{
			return 0.0;
		}
		return LoadFromAddress(offs + pTerrorNavArea, NumberType:2);
	}
	return 0.0;
}

public OnMapStart()
{
	decl String:mapname[64];
	GetCurrentMap(mapname, 64);
	new var1;
	if (!strcmp(mapname, "srocchurch", true) || !strcmp(mapname, "mnac", true))
	{
		var2 = 1;
	}
	else
	{
		var2 = 0;
	}
	bPluginActive = var2;
	return 0;
}

public OnClientPutInServer(client)
{
	if (bPluginActive)
	{
		SDKHook(client, SDKHookType:2, OnTakeDamage);
	}
	return 0;
}

public OnClientDisconnect(client)
{
	SDKUnhook(client, SDKHookType:2, OnTakeDamage);
	return 0;
}

public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	if (!IsSurvivor(victim))
	{
		return Action:0;
	}
	new var1;
	if (GetDistance(victim) <= 1045220557 && damagetype & 32)
	{
		return Action:3;
	}
	return Action:0;
}

GetDistance(client)
{
	new Float:pos[3] = 0.0;
	GetEntPropVector(client, PropType:0, "m_vecOrigin", pos, 0);
	new Float:flow = L4D2Direct_GetTerrorNavAreaFlow(L4D2Direct_GetTerrorNavArea(pos, 120.0));
	return RoundToNearest(flow / L4D2Direct_GetMapMaxFlowDistance());
}

bool:IsSurvivor(client)
{
	new var1;
	return client > 0 && client <= MaxClients && IsClientInGame(client) && GetClientTeam(client) == 2;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.2",
	date = "11/13/2014",
	time = "16:18:13"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new bool:g_bIsTankAlive;
new Handle:SlowdownFactor;
new Handle:WSDT_Print;
new Handle:WSDT_Sound;
public Plugin:myinfo =
{
	name = "Water Slowdown During Tank",
	description = "Modifies water slowdown while tank is in play.",
	author = "Don, Jacob, epilimic",
	version = "1.8",
	url = "https://github.com/Stabbath/ProMod"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CPrintToChatAll(String:szMessage[])
{
	decl String:szBuffer[252];
	new i = 1;
	while (i <= MaxClients)
	{
		new var1;
		if (IsClientInGame(i) && !IsFakeClient(i) && !CSkipList[i])
		{
			SetGlobalTransTarget(i);
			VFormat(szBuffer, 250, szMessage, 2);
			CPrintToChat(i, szBuffer);
		}
		CSkipList[i] = 0;
		i++;
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	BfWriteByte(hBuffer, author);
	BfWriteByte(hBuffer, 1);
	BfWriteString(hBuffer, szMessage);
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

EmitSoundToAll(String:sample[], entity, channel, level, flags, Float:volume, pitch, speakerentity, Float:origin[3], Float:dir[3], bool:updatePos, Float:soundtime)
{
	new clients[MaxClients];
	new total;
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			total++;
			clients[total] = i;
		}
		i++;
	}
	if (!total)
	{
		return 0;
	}
	EmitSound(clients, total, sample, entity, channel, level, flags, volume, pitch, speakerentity, origin, dir, updatePos, soundtime);
	return 0;
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	decl String:sGame[12];
	GetGameFolderName(sGame, 12);
	if (StrEqual(sGame, "left4dead2", true))
	{
		return APLRes:0;
	}
	strcopy(error, err_max, "Plugin only supports L4D2");
	return APLRes:1;
}

public OnMapStart()
{
	PrecacheSound("ui/pickup_secret01.wav", false);
	return 0;
}

public OnPluginStart()
{
	HookEvent("tank_spawn", Event_tank_spawn_Callback, EventHookMode:1);
	HookEvent("player_death", Event_player_death_Callback, EventHookMode:1);
	HookEvent("round_end", Event_round_end_Callback, EventHookMode:1);
	WSDT_Print = CreateConVar("tank_print_type", "1", "Whether or not to tell people slowdown has changed.", 262144, true, 0.0, true, 1.0);
	WSDT_Sound = CreateConVar("tank_spawn_sound", "1", "Whether or not to play a sound when tank spawns.", 262144, true, 0.0, true, 1.0);
	SlowdownFactor = FindConVar("confogl_slowdown_factor");
	return 0;
}

public Event_tank_spawn_Callback(Handle:event, String:name[], bool:dontBroadcast)
{
	if (!g_bIsTankAlive)
	{
		SetConVarFloat(SlowdownFactor, 0.95, false, false);
		g_bIsTankAlive = true;
		if (GetConVarBool(WSDT_Print))
		{
			CPrintToChatAll("{olive}Water Slowdown{default} has been reduced while Tank is in play.");
		}
		if (GetConVarBool(WSDT_Sound))
		{
			EmitSoundToAll("ui/pickup_secret01.wav", -2, 0, 75, 0, 0.8, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
		}
		if (!GetConVarBool(WSDT_Print))
		{
			CPrintToChatAll("{olive}Tank{default} is now in play.");
		}
	}
	return 0;
}

public Event_player_death_Callback(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bIsTankAlive)
	{
		new String:sVictimName[8];
		GetEventString(event, "victimname", sVictimName, 8);
		if (StrEqual(sVictimName, "Tank", true))
		{
			SetConVarFloat(SlowdownFactor, 0.9, false, false);
			g_bIsTankAlive = false;
			if (GetConVarBool(WSDT_Print))
			{
				CPrintToChatAll("{olive}Water Slowdown{default} has been restored to normal.");
			}
		}
	}
	return 0;
}

public Event_round_end_Callback(Handle:event, String:name[], bool:dontBroadcast)
{
	if (g_bIsTankAlive)
	{
		SetConVarFloat(SlowdownFactor, 0.9, false, false);
		g_bIsTankAlive = false;
	}
	return 0;
}

public OnPluginEnd()
{
	if (g_bIsTankAlive)
	{
		SetConVarFloat(SlowdownFactor, 0.9, false, false);
	}
	return 0;
}

public PlVers:__version =
{
	version = 5,
	filevers = "1.6.4-dev+4625",
	date = "08/28/2016",
	time = "14:35:38"
};
new Float:NULL_VECTOR[3];
new String:NULL_STRING[4];
public Extension:__ext_core =
{
	name = "Core",
	file = "core",
	autoload = 0,
	required = 0,
};
new MaxClients;
public SharedPlugin:__pl_l4d2lib =
{
	name = "l4d2lib",
	file = "l4d2lib.smx",
	required = 1,
};
new String:L4D2_InfectedNames[8][32];
new String:SurvivorModels[8][];
new String:SurvivorNames[8][];
new String:WeaponModels[56][];
new String:WeaponNames[56][];
new WeaponSlots[56] =
{
	1414218835, 1936486255, 0, 1953195123, 1936486255, 1954047278, 0, 1448, 1460, 1, 1, 1919311725, 1920234357, 1869182049, 110, 1919311725, 1920234357, 1869182049, 110, 845427820, 1818850421, 0, 845427820, 1818850421, 2020438830, 0, 1524, 1536, 1, 24, 32, 36, 48, 52, 56, 1717920891, 1953264993, 125, 1701996411, 8220261, 1734962299, 1919382632, 2104386917, 0, 1684370043, 125, 1970037371, 32101, 1768714107, 8217974, 24, 24, 24, 24, 24, 24
};
public Extension:__ext_sdktools =
{
	name = "SDKTools",
	file = "sdktools.ext",
	autoload = 1,
	required = 1,
};
new String:L4D2_InfectedTimerEntities[8][];
new String:L4D2_InfectedVictimNetprops[8][];
new Handle:hSurvivorModelsTrie = 1919311725;
new Handle:hWeaponNamesTrie = 845427820;
public SharedPlugin:__pl_l4d2util =
{
	name = "l4d2util",
	file = "l4d2util.smx",
	required = 1,
};
new String:CTag[6][] =
{
	"{default}",
	"{green}",
	"{lightgreen}",
	"{red}",
	"{blue}",
	"{olive}"
};
new String:CTagCode[6][16] =
{
	"\x01",
	"\x04",
	"\x03",
	"\x03",
	"\x03",
	"\x05"
};
new bool:CTagReqSayText2[6] =
{
	0, 0, 1, 1, 1, 0
};
new bool:CEventIsHooked;
new bool:CSkipList[66];
new bool:CProfile_Colors[6] =
{
	1, 1, 0, 0, 0, 0
};
new CProfile_TeamIndex[6] =
{
	-1, ...
};
new bool:CProfile_SayText2;
new Handle:hCvarVisionSeconds;
new Handle:hCvarFrustrationGain;
new Float:fVisionSeconds;
new iFrustrationGain;
new iStoredFrustration[66];
new Float:fSecondsVisionHeld[66];
new Handle:hTimer[66];
public Plugin:myinfo =
{
	name = "Tank Vision Frustration",
	description = "Gives Tanks frustration if they keep vision long enough",
	author = "Sir",
	version = "1.0",
	url = "https://github.com/SirPlease/SirCoding"
};
public __ext_core_SetNTVOptional()
{
	MarkNativeAsOptional("GetFeatureStatus");
	MarkNativeAsOptional("RequireFeature");
	MarkNativeAsOptional("AddCommandListener");
	MarkNativeAsOptional("RemoveCommandListener");
	MarkNativeAsOptional("BfWriteBool");
	MarkNativeAsOptional("BfWriteByte");
	MarkNativeAsOptional("BfWriteChar");
	MarkNativeAsOptional("BfWriteShort");
	MarkNativeAsOptional("BfWriteWord");
	MarkNativeAsOptional("BfWriteNum");
	MarkNativeAsOptional("BfWriteFloat");
	MarkNativeAsOptional("BfWriteString");
	MarkNativeAsOptional("BfWriteEntity");
	MarkNativeAsOptional("BfWriteAngle");
	MarkNativeAsOptional("BfWriteCoord");
	MarkNativeAsOptional("BfWriteVecCoord");
	MarkNativeAsOptional("BfWriteVecNormal");
	MarkNativeAsOptional("BfWriteAngles");
	MarkNativeAsOptional("BfReadBool");
	MarkNativeAsOptional("BfReadByte");
	MarkNativeAsOptional("BfReadChar");
	MarkNativeAsOptional("BfReadShort");
	MarkNativeAsOptional("BfReadWord");
	MarkNativeAsOptional("BfReadNum");
	MarkNativeAsOptional("BfReadFloat");
	MarkNativeAsOptional("BfReadString");
	MarkNativeAsOptional("BfReadEntity");
	MarkNativeAsOptional("BfReadAngle");
	MarkNativeAsOptional("BfReadCoord");
	MarkNativeAsOptional("BfReadVecCoord");
	MarkNativeAsOptional("BfReadVecNormal");
	MarkNativeAsOptional("BfReadAngles");
	MarkNativeAsOptional("BfGetNumBytesLeft");
	MarkNativeAsOptional("PbReadInt");
	MarkNativeAsOptional("PbReadFloat");
	MarkNativeAsOptional("PbReadBool");
	MarkNativeAsOptional("PbReadString");
	MarkNativeAsOptional("PbReadColor");
	MarkNativeAsOptional("PbReadAngle");
	MarkNativeAsOptional("PbReadVector");
	MarkNativeAsOptional("PbReadVector2D");
	MarkNativeAsOptional("PbGetRepeatedFieldCount");
	MarkNativeAsOptional("PbSetInt");
	MarkNativeAsOptional("PbSetFloat");
	MarkNativeAsOptional("PbSetBool");
	MarkNativeAsOptional("PbSetString");
	MarkNativeAsOptional("PbSetColor");
	MarkNativeAsOptional("PbSetAngle");
	MarkNativeAsOptional("PbSetVector");
	MarkNativeAsOptional("PbSetVector2D");
	MarkNativeAsOptional("PbAddInt");
	MarkNativeAsOptional("PbAddFloat");
	MarkNativeAsOptional("PbAddBool");
	MarkNativeAsOptional("PbAddString");
	MarkNativeAsOptional("PbAddColor");
	MarkNativeAsOptional("PbAddAngle");
	MarkNativeAsOptional("PbAddVector");
	MarkNativeAsOptional("PbAddVector2D");
	MarkNativeAsOptional("PbRemoveRepeatedFieldValue");
	MarkNativeAsOptional("PbReadMessage");
	MarkNativeAsOptional("PbReadRepeatedMessage");
	MarkNativeAsOptional("PbAddMessage");
	VerifyCoreVersion();
	return 0;
}

bool:StrEqual(String:str1[], String:str2[], bool:caseSensitive)
{
	return strcmp(str1, str2, caseSensitive) == 0;
}

Handle:StartMessageOne(String:msgname[], client, flags)
{
	new players[1];
	players[0] = client;
	return StartMessage(msgname, players, 1, flags);
}

PrintToChatAll(String:format[])
{
	decl String:buffer[192];
	new i = 1;
	while (i <= MaxClients)
	{
		if (IsClientInGame(i))
		{
			SetGlobalTransTarget(i);
			VFormat(buffer, 192, format, 2);
			PrintToChat(i, "%s", buffer);
		}
		i++;
	}
	return 0;
}

public __pl_l4d2lib_SetNTVOptional()
{
	MarkNativeAsOptional("L4D2_GetCurrentRound");
	MarkNativeAsOptional("L4D2_CurrentlyInRound");
	MarkNativeAsOptional("L4D2_GetSurvivorCount");
	MarkNativeAsOptional("L4D2_GetSurvivorOfIndex");
	MarkNativeAsOptional("L4D2_IsMapDataAvailable");
	MarkNativeAsOptional("L4D2_IsEntityInSaferoom");
	MarkNativeAsOptional("L4D2_GetMapStartOrigin");
	MarkNativeAsOptional("L4D2_GetMapEndOrigin");
	MarkNativeAsOptional("L4D2_GetMapStartDistance");
	MarkNativeAsOptional("L4D2_GetMapStartExtraDistance");
	MarkNativeAsOptional("L4D2_GetMapEndDistance");
	MarkNativeAsOptional("L4D2_GetMapValueInt");
	MarkNativeAsOptional("L4D2_GetMapValueFloat");
	MarkNativeAsOptional("L4D2_GetMapValueVector");
	MarkNativeAsOptional("L4D2_GetMapValueString");
	MarkNativeAsOptional("L4D2_CopyMapSubsection");
	return 0;
}

GetTankFrustration(iTankClient)
{
	return 100 - GetEntProp(iTankClient, PropType:0, L4D2_InfectedTimerEntities, 4, 0);
}

SetTankFrustration(iTankClient, iFrustration)
{
	new var1;
	if (iFrustration < 0 || iFrustration > 100)
	{
		return 0;
	}
	SetEntProp(iTankClient, PropType:0, "m_frustration", 100 - iFrustration, 4, 0);
	return 0;
}

public __pl_l4d2util_SetNTVOptional()
{
	return 0;
}

CPrintToChat(client, String:szMessage[])
{
	new var1;
	if (client <= 0 || client > MaxClients)
	{
		ThrowError("Invalid client index %d", client);
	}
	if (!IsClientInGame(client))
	{
		ThrowError("Client %d is not in game", client);
	}
	decl String:szBuffer[252];
	decl String:szCMessage[252];
	SetGlobalTransTarget(client);
	Format(szBuffer, 250, "\x01%s", szMessage);
	VFormat(szCMessage, 250, szBuffer, 3);
	new index = CFormat(szCMessage, 250, -1);
	if (index == -1)
	{
		PrintToChat(client, szCMessage);
	}
	else
	{
		CSayText2(client, index, szCMessage);
	}
	return 0;
}

CFormat(String:szMessage[], maxlength, author)
{
	if (!CEventIsHooked)
	{
		CSetupProfile();
		HookEvent("server_spawn", CEvent_MapStart, EventHookMode:2);
		CEventIsHooked = true;
	}
	new iRandomPlayer = -1;
	if (author != -1)
	{
		if (CProfile_SayText2)
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", "\x03", true);
			iRandomPlayer = author;
		}
		else
		{
			ReplaceString(szMessage, maxlength, "{teamcolor}", CTagCode[1], true);
		}
	}
	else
	{
		ReplaceString(szMessage, maxlength, "{teamcolor}", "", true);
	}
	new i;
	while (i < 6)
	{
		if (!(StrContains(szMessage, CTag[i], true) == -1))
		{
			if (!CProfile_Colors[i])
			{
				ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
			}
			else
			{
				if (!CTagReqSayText2[i])
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
				}
				if (!CProfile_SayText2)
				{
					ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
				}
				if (iRandomPlayer == -1)
				{
					iRandomPlayer = CFindRandomPlayerByTeam(CProfile_TeamIndex[i]);
					if (iRandomPlayer == -2)
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[1], true);
					}
					else
					{
						ReplaceString(szMessage, maxlength, CTag[i], CTagCode[i], true);
					}
				}
				ThrowError("Using two team colors in one message is not allowed");
			}
		}
		i++;
	}
	return iRandomPlayer;
}

CFindRandomPlayerByTeam(color_team)
{
	if (color_team)
	{
		new i = 1;
		while (i <= MaxClients)
		{
			new var1;
			if (IsClientInGame(i) && color_team == GetClientTeam(i))
			{
				return i;
			}
			i++;
		}
		return -2;
	}
	return 0;
}

CSayText2(client, author, String:szMessage[])
{
	new Handle:hBuffer = StartMessageOne("SayText2", client, 0);
	if (GetUserMessageType() == 1)
	{
		PbSetInt(hBuffer, "ent_idx", author, -1);
		PbSetBool(hBuffer, "chat", true, -1);
		PbSetString(hBuffer, "msg_name", szMessage, -1);
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
		PbAddString(hBuffer, "params", "");
	}
	else
	{
		BfWriteByte(hBuffer, author);
		BfWriteByte(hBuffer, 1);
		BfWriteString(hBuffer, szMessage);
	}
	EndMessage();
	return 0;
}

CSetupProfile()
{
	decl String:szGameName[32];
	GetGameFolderName(szGameName, 30);
	if (StrEqual(szGameName, "cstrike", false))
	{
		CProfile_Colors[2] = 1;
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_Colors[5] = 1;
		CProfile_TeamIndex[2] = 0;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	else
	{
		if (StrEqual(szGameName, "tf", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 2;
			CProfile_TeamIndex[4] = 3;
			CProfile_SayText2 = true;
		}
		new var1;
		if (StrEqual(szGameName, "left4dead", false) || StrEqual(szGameName, "left4dead2", false))
		{
			CProfile_Colors[2] = 1;
			CProfile_Colors[3] = 1;
			CProfile_Colors[4] = 1;
			CProfile_Colors[5] = 1;
			CProfile_TeamIndex[2] = 0;
			CProfile_TeamIndex[3] = 3;
			CProfile_TeamIndex[4] = 2;
			CProfile_SayText2 = true;
		}
		if (StrEqual(szGameName, "hl2mp", false))
		{
			if (GetConVarBool(FindConVar("mp_teamplay")))
			{
				CProfile_Colors[3] = 1;
				CProfile_Colors[4] = 1;
				CProfile_Colors[5] = 1;
				CProfile_TeamIndex[3] = 3;
				CProfile_TeamIndex[4] = 2;
				CProfile_SayText2 = true;
			}
			else
			{
				CProfile_SayText2 = false;
				CProfile_Colors[5] = 1;
			}
		}
		if (StrEqual(szGameName, "dod", false))
		{
			CProfile_Colors[5] = 1;
			CProfile_SayText2 = false;
		}
		if (GetUserMessageId("SayText2") == -1)
		{
			CProfile_SayText2 = false;
		}
		CProfile_Colors[3] = 1;
		CProfile_Colors[4] = 1;
		CProfile_TeamIndex[3] = 2;
		CProfile_TeamIndex[4] = 3;
		CProfile_SayText2 = true;
	}
	return 0;
}

public Action:CEvent_MapStart(Handle:event, String:name[], bool:dontBroadcast)
{
	CSetupProfile();
	new i = 1;
	while (i <= MaxClients)
	{
		CSkipList[i] = 0;
		i++;
	}
	return Action:0;
}

public OnPluginStart()
{
	hCvarVisionSeconds = CreateConVar("tank_vision_seconds", "6.0", "How long to keep Vision before you gain Frustration, (z_frustration_los_delay has a big impact on this)", 0, false, 0.0, false, 0.0);
	hCvarFrustrationGain = CreateConVar("tank_vision_frustration_gain", "4", "Frustration Gain, between 1-100, Steps should be in: (100 / z_frustration_lifetime)", 0, false, 0.0, false, 0.0);
	fVisionSeconds = GetConVarFloat(hCvarVisionSeconds);
	iFrustrationGain = GetConVarInt(hCvarFrustrationGain);
	HookConVarChange(hCvarVisionSeconds, cvarChanged);
	HookConVarChange(hCvarFrustrationGain, cvarChanged);
	RegConsoleCmd("sm_stats", Stats_Cmd, "", 0);
	HookEvent("round_start", RoundStartEvent, EventHookMode:2);
	return 0;
}

public RoundStartEvent(Handle:event, String:name[], bool:dontBroadcast)
{
	new client = 1;
	while (client <= MaxClients)
	{
		if (IsValidClient(client))
		{
			if (hTimer[client])
			{
				KillTimer(hTimer[client], false);
				hTimer[client] = 0;
			}
			iStoredFrustration[client] = 0;
			fSecondsVisionHeld[client] = 0;
		}
		client++;
	}
	return 0;
}

public Action:Stats_Cmd(client, args)
{
	CPrintToChat(client, "{olive}fSecondsVisionHeld: {default}%f", fSecondsVisionHeld[client]);
	CPrintToChat(client, "{olive}iStoredFrustration: {default}%i", iStoredFrustration[client]);
	return Action:0;
}

public cvarChanged(Handle:cvar, String:oldValue[], String:newValue[])
{
	fVisionSeconds = GetConVarFloat(hCvarVisionSeconds);
	iFrustrationGain = GetConVarInt(hCvarFrustrationGain);
	return 0;
}

public L4D2_OnTankPassControl(oldTank, newTank, passCount)
{
	if (IsValidClient(oldTank))
	{
		if (hTimer[oldTank])
		{
			KillTimer(hTimer[oldTank], false);
			hTimer[oldTank] = 0;
		}
		iStoredFrustration[oldTank] = 0;
		fSecondsVisionHeld[oldTank] = 0;
	}
	if (IsValidClient(newTank))
	{
		if (hTimer[newTank])
		{
			KillTimer(hTimer[newTank], false);
			hTimer[newTank] = 0;
		}
		iStoredFrustration[newTank] = GetTankFrustration(newTank);
		fSecondsVisionHeld[newTank] = 0;
		hTimer[newTank] = CreateTimer(0.1, VisionTimer, newTank, 1);
		PrintToChatAll("Timer Live Pass");
	}
	return 0;
}

public OnTankSpawn(iTank)
{
	if (IsValidClient(iTank))
	{
		if (hTimer[iTank])
		{
			KillTimer(hTimer[iTank], false);
			hTimer[iTank] = 0;
		}
		iStoredFrustration[iTank] = 0;
		fSecondsVisionHeld[iTank] = 0;
		hTimer[iTank] = CreateTimer(0.1, VisionTimer, iTank, 1);
		PrintToChatAll("Timer Live Spawn");
	}
	return 0;
}

public OnTankDeath(iOldTank)
{
	if (IsValidClient(iOldTank))
	{
		if (hTimer[iOldTank])
		{
			KillTimer(hTimer[iOldTank], false);
			hTimer[iOldTank] = 0;
		}
		iStoredFrustration[iOldTank] = 0;
		fSecondsVisionHeld[iOldTank] = 0;
	}
	return 0;
}

public Action:VisionTimer(Handle:timer, any:client)
{
	new iFrust = GetTankFrustration(client);
	new var1;
	if (iFrust == 100 || iFrust)
	{
		return Action:0;
	}
	if (iStoredFrustration[client] == iFrust)
	{
		new var3 = fSecondsVisionHeld[client];
		var3 = var3[0.1];
	}
	else
	{
		fSecondsVisionHeld[client] = 0;
	}
	new var2;
	if (iStoredFrustration[client] == iFrust && fSecondsVisionHeld[client] >= fVisionSeconds)
	{
		SetTankFrustration(client, iFrustrationGain + iFrust);
		fSecondsVisionHeld[client] = 0;
	}
	iStoredFrustration[client] = iFrust;
	return Action:0;
}

bool:IsValidClient(client)
{
	new var1;
	if (client <= 0 || client > MaxClients || !IsClientConnected(client) || !IsClientInGame(client) || IsFakeClient(client))
	{
		return false;
	}
	return true;
}

